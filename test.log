2025-12-28 12:12:55 [INFO] === EPUB Reader starting ===
2025-12-28 12:12:55 [INFO] Log file: test.log
2025-12-28 12:12:55 [INFO] Loading file: books/writing_an_interpreter_in_go_1.7.epub
2025-12-28 12:12:55 [DEBUG] Terminal size: 210x62
2025-12-28 12:12:55 [DEBUG] Terminal setup completed
2025-12-28 12:12:55 [DEBUG] Initializing application state
2025-12-28 12:12:55 [DEBUG] Config loaded: max_width=Some(80), toc_panel_width=30, bookmarks_panel_width=35
2025-12-28 12:12:55 [DEBUG] Viewport initialized: 210x60
2025-12-28 12:12:55 [INFO] Starting initial book load: books/writing_an_interpreter_in_go_1.7.epub
2025-12-28 12:12:55 [DEBUG] Resize debouncer started (debounce: 200ms)
2025-12-28 12:12:55 [INFO] Starting EPUB load task: books/writing_an_interpreter_in_go_1.7.epub
2025-12-28 12:12:55 [DEBUG] Spawning blocking task for EPUB parsing
2025-12-28 12:12:55 [INFO] Parsing EPUB file: books/writing_an_interpreter_in_go_1.7.epub
2025-12-28 12:12:55 [DEBUG] Opening EPUB document
2025-12-28 12:12:55 [DEBUG] Received task message: BookLoadingStarted { file_path: "books/writing_an_interpreter_in_go_1.7.epub" }
2025-12-28 12:12:55 [INFO] Book loading started: books/writing_an_interpreter_in_go_1.7.epub
2025-12-28 12:12:55 [DEBUG] Parsed metadata: title='Writing An Interpreter In Go', author=Some("Thorsten Ball")
2025-12-28 12:12:55 [DEBUG] Parsed TOC: 11 entries found
2025-12-28 12:12:55 [DEBUG] Processing 13 spine entries (chapters)
2025-12-28 12:12:55 [DEBUG] Processing chapter 1/13: 'Chapter 1' (spine_id: cover_xhtml, path: cover_xhtml)
2025-12-28 12:12:55 [DEBUG]   No TOC sections found for chapter
2025-12-28 12:12:55 [DEBUG]   Found 0 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG] Processing chapter 2/13: 'Writing An Interpreter In Go' (spine_id: title_page_xhtml, path: EPUB\text/title_page.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 0 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG] Processing chapter 3/13: 'Chapter 3' (spine_id: nav, path: nav)
2025-12-28 12:12:55 [DEBUG]   No TOC sections found for chapter
2025-12-28 12:12:55 [DEBUG]   Found 0 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG] Processing chapter 4/13: 'Acknowledgments' (spine_id: ch001_xhtml, path: EPUB\text/ch001.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 1 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG]     Section 1: 'Acknowledgments' (fragment_id: Some("acknowledgments"))
2025-12-28 12:12:55 [DEBUG] Processing chapter 5/13: 'Introduction' (spine_id: ch002_xhtml, path: EPUB\text/ch002.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 4 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG]     Section 1: 'Introduction' (fragment_id: Some("introduction"))
2025-12-28 12:12:55 [DEBUG]     Section 2: 'The Monkey Programming Language & Interpreter' (fragment_id: Some("the-monkey-programming-language-interpreter"))
2025-12-28 12:12:55 [DEBUG]     Section 3: 'Why Go?' (fragment_id: Some("why-go"))
2025-12-28 12:12:55 [DEBUG]     Section 4: 'How to Use this Book' (fragment_id: Some("how-to-use-this-book"))
2025-12-28 12:12:55 [DEBUG] Processing chapter 6/13: 'Lexing' (spine_id: ch003_xhtml, path: EPUB\text/ch003.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 6 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG]     Section 1: 'Lexing' (fragment_id: Some("lexing"))
2025-12-28 12:12:55 [DEBUG]     Section 2: '1.1 - Lexical Analysis' (fragment_id: Some("lexical-analysis"))
2025-12-28 12:12:55 [DEBUG]     Section 3: '1.2 - Defining Our Tokens' (fragment_id: Some("defining-our-tokens"))
2025-12-28 12:12:55 [DEBUG]     Section 4: '1.3 - The Lexer' (fragment_id: Some("the-lexer"))
2025-12-28 12:12:55 [DEBUG]     Section 5: '1.4 - Extending our Token Set and Lexer' (fragment_id: Some("extending-our-token-set-and-lexer"))
2025-12-28 12:12:55 [DEBUG]     Section 6: '1.5 - Start of a REPL' (fragment_id: Some("start-of-a-repl"))
2025-12-28 12:12:55 [DEBUG] Processing chapter 7/13: 'Parsing' (spine_id: ch004_xhtml, path: EPUB\text/ch004.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 10 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG]     Section 1: 'Parsing' (fragment_id: Some("parsing"))
2025-12-28 12:12:55 [DEBUG]     Section 2: '2.1 - Parsers' (fragment_id: Some("parsers"))
2025-12-28 12:12:55 [DEBUG]     Section 3: '2.2 - Why not a parser generator?' (fragment_id: Some("why-not-a-parser-generator"))
2025-12-28 12:12:55 [DEBUG]     Section 4: '2.3 - Writing a Parser for the Monkey Programming Language' (fragment_id: Some("writing-a-parser-for-the-monkey-programming-language"))
2025-12-28 12:12:55 [DEBUG]     Section 5: '2.4 - Parser’s first steps: parsing let statements' (fragment_id: Some("parsers-first-steps-parsing-let-statements"))
2025-12-28 12:12:55 [DEBUG]     Section 6: '2.5 - Parsing Return Statements' (fragment_id: Some("parsing-return-statements"))
2025-12-28 12:12:55 [DEBUG]     Section 7: '2.6 - Parsing Expressions' (fragment_id: Some("parsing-expressions"))
2025-12-28 12:12:55 [DEBUG]     Section 8: '2.7 - How Pratt Parsing Works' (fragment_id: Some("how-pratt-parsing-works"))
2025-12-28 12:12:55 [DEBUG]     Section 9: '2.8 - Extending the Parser' (fragment_id: Some("extending-the-parser"))
2025-12-28 12:12:55 [DEBUG]     Section 10: '2.9 - Read-Parse-Print-Loop' (fragment_id: Some("read-parse-print-loop"))
2025-12-28 12:12:55 [DEBUG] Processing chapter 8/13: 'Evaluation' (spine_id: ch005_xhtml, path: EPUB\text/ch005.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 12 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG]     Section 1: 'Evaluation' (fragment_id: Some("evaluation"))
2025-12-28 12:12:55 [DEBUG]     Section 2: '3.1 - Giving Meaning to Symbols' (fragment_id: Some("giving-meaning-to-symbols"))
2025-12-28 12:12:55 [DEBUG]     Section 3: '3.2 - Strategies of Evaluation' (fragment_id: Some("strategies-of-evaluation"))
2025-12-28 12:12:55 [DEBUG]     Section 4: '3.3 - A Tree-Walking Interpreter' (fragment_id: Some("a-tree-walking-interpreter"))
2025-12-28 12:12:55 [DEBUG]     Section 5: '3.4 - Representing Objects' (fragment_id: Some("representing-objects"))
2025-12-28 12:12:55 [DEBUG]     Section 6: '3.5 - Evaluating Expressions' (fragment_id: Some("evaluating-expressions"))
2025-12-28 12:12:55 [DEBUG]     Section 7: '3.6 - Conditionals' (fragment_id: Some("conditionals"))
2025-12-28 12:12:55 [DEBUG]     Section 8: '3.7 - Return Statements' (fragment_id: Some("return-statements"))
2025-12-28 12:12:55 [DEBUG]     Section 9: '3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling' (fragment_id: Some("abort-abort-theres-been-a-mistake-or-error-handling"))
2025-12-28 12:12:55 [DEBUG]     Section 10: '3.9 - Bindings & The Environment' (fragment_id: Some("bindings-the-environment"))
2025-12-28 12:12:55 [DEBUG]     Section 11: '3.10 - Functions & Function Calls' (fragment_id: Some("functions-function-calls"))
2025-12-28 12:12:55 [DEBUG]     Section 12: '3.11 - Who’s taking the trash out?' (fragment_id: Some("whos-taking-the-trash-out"))
2025-12-28 12:12:55 [DEBUG] Processing chapter 9/13: 'Extending the Interpreter' (spine_id: ch006_xhtml, path: EPUB\text/ch006.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 7 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG]     Section 1: 'Extending the Interpreter' (fragment_id: Some("extending-the-interpreter"))
2025-12-28 12:12:55 [DEBUG]     Section 2: '4.1 - Data Types & Functions' (fragment_id: Some("data-types-functions"))
2025-12-28 12:12:55 [DEBUG]     Section 3: '4.2 - Strings' (fragment_id: Some("strings"))
2025-12-28 12:12:55 [DEBUG]     Section 4: '4.3 - Built-in Functions' (fragment_id: Some("built-in-functions"))
2025-12-28 12:12:55 [DEBUG]     Section 5: '4.4 - Array' (fragment_id: Some("array"))
2025-12-28 12:12:55 [DEBUG]     Section 6: '4.5 - Hashes' (fragment_id: Some("hashes"))
2025-12-28 12:12:55 [DEBUG]     Section 7: '4.6 - The Grand Finale' (fragment_id: Some("the-grand-finale"))
2025-12-28 12:12:55 [DEBUG] Processing chapter 10/13: 'Going Further' (spine_id: ch007_xhtml, path: EPUB\text/ch007.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 3 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG]     Section 1: 'Going Further' (fragment_id: Some("going-further"))
2025-12-28 12:12:55 [DEBUG]     Section 2: 'The Lost Chapter' (fragment_id: Some("the-lost-chapter"))
2025-12-28 12:12:55 [DEBUG]     Section 3: 'Writing A Compiler In Go' (fragment_id: Some("writing-a-compiler-in-go"))
2025-12-28 12:12:55 [DEBUG] Processing chapter 11/13: 'Resources' (spine_id: ch008_xhtml, path: EPUB\text/ch008.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 1 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG]     Section 1: 'Resources' (fragment_id: Some("resources"))
2025-12-28 12:12:55 [DEBUG] Processing chapter 12/13: 'Feedback' (spine_id: ch009_xhtml, path: EPUB\text/ch009.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 1 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG]     Section 1: 'Feedback' (fragment_id: Some("feedback"))
2025-12-28 12:12:55 [DEBUG] Processing chapter 13/13: 'Changelog' (spine_id: ch010_xhtml, path: EPUB\text/ch010.xhtml)
2025-12-28 12:12:55 [DEBUG]   Found 1 TOC sections for chapter
2025-12-28 12:12:55 [DEBUG]     Section 1: 'Changelog' (fragment_id: Some("changelog"))
2025-12-28 12:12:55 [INFO] Successfully parsed EPUB: 13 chapters extracted
2025-12-28 12:12:55 [DEBUG] EPUB parsing completed successfully
2025-12-28 12:12:55 [DEBUG] Rendering 13 chapters
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Chapter 1': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG]   Rendered 0 lines, found 0 headings from 689 bytes of HTML
2025-12-28 12:12:55 [DEBUG]   No TOC sections, extracting from HTML headings
2025-12-28 12:12:55 [DEBUG]   Extracted 0 sections from headings
2025-12-28 12:12:55 [DEBUG] First chapter rendered: 'Chapter 1' (0 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Writing An Interpreter In Go': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG]   Rendered 4 lines, found 1 headings from 650 bytes of HTML
2025-12-28 12:12:55 [DEBUG]   No TOC sections, extracting from HTML headings
2025-12-28 12:12:55 [DEBUG]   Extracted 0 sections from headings
2025-12-28 12:12:55 [DEBUG] Rendered chapter 2/13: 'Writing An Interpreter In Go' (4 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Chapter 3': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG]   Rendered 52 lines, found 0 headings from 5444 bytes of HTML
2025-12-28 12:12:55 [DEBUG]   No TOC sections, extracting from HTML headings
2025-12-28 12:12:55 [DEBUG]   Extracted 0 sections from headings
2025-12-28 12:12:55 [DEBUG] Rendered chapter 3/13: 'Chapter 3' (52 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Acknowledgments': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG]   Rendered 11 lines, found 1 headings from 1033 bytes of HTML
2025-12-28 12:12:55 [DEBUG] Matching 1 TOC sections to 1 headings
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Acknowledgments' with fragment_id 'acknowledgments'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Acknowledgments' by title (normalized: 'Acknowledgments')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Acknowledgments' at line 0
2025-12-28 12:12:55 [DEBUG] Rendered chapter 4/13: 'Acknowledgments' (11 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Introduction': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 1, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 1/13
2025-12-28 12:12:55 [DEBUG]   Rendered 288 lines, found 4 headings from 22508 bytes of HTML
2025-12-28 12:12:55 [DEBUG] Matching 4 TOC sections to 4 headings
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Introduction' with fragment_id 'introduction'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Introduction' by title (normalized: 'Introduction')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Introduction' at line 0
2025-12-28 12:12:55 [DEBUG] Trying to match section 'The Monkey Programming Language & Interpreter' with fragment_id 'the-monkey-programming-language-interpreter'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'The Monkey Programming Language & Interpreter' by title (normalized: 'The Monkey Programming Language & Interpreter')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'The Monkey Programming Language & Interpreter' at line 83
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Why Go?' with fragment_id 'why-go'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Why Go?' by title (normalized: 'Why Go?')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Why Go?' at line 207
2025-12-28 12:12:55 [DEBUG] Trying to match section 'How to Use this Book' with fragment_id 'how-to-use-this-book'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'How to Use this Book' by title (normalized: 'How to Use this Book')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'How to Use this Book' at line 248
2025-12-28 12:12:55 [DEBUG] Rendered chapter 5/13: 'Introduction' (288 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Lexing': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 2, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 2/13
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 3, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 3/13
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 4, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 4/13
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 5, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 5/13
2025-12-28 12:12:55 [DEBUG]   Rendered 1111 lines, found 6 headings from 89524 bytes of HTML
2025-12-28 12:12:55 [DEBUG] Matching 6 TOC sections to 6 headings
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Lexing' with fragment_id 'lexing'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Lexing' by title (normalized: 'Lexing')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Lexing' at line 0
2025-12-28 12:12:55 [DEBUG] Trying to match section '1.1 - Lexical Analysis' with fragment_id 'lexical-analysis'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '1.1 - Lexical Analysis' by title (normalized: '1.1 - Lexical Analysis')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '1.1 - Lexical Analysis' at line 2
2025-12-28 12:12:55 [DEBUG] Trying to match section '1.2 - Defining Our Tokens' with fragment_id 'defining-our-tokens'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '1.2 - Defining Our Tokens' by title (normalized: '1.2 - Defining Our Tokens')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '1.2 - Defining Our Tokens' at line 78
2025-12-28 12:12:55 [DEBUG] Trying to match section '1.3 - The Lexer' with fragment_id 'the-lexer'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '1.3 - The Lexer' by title (normalized: '1.3 - The Lexer')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '1.3 - The Lexer' at line 181
2025-12-28 12:12:55 [DEBUG] Trying to match section '1.4 - Extending our Token Set and Lexer' with fragment_id 'extending-our-token-set-and-lexer'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '1.4 - Extending our Token Set and Lexer' by title (normalized: '1.4 - Extending our Token Set and Lexer')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '1.4 - Extending our Token Set and Lexer' at line 681
2025-12-28 12:12:55 [DEBUG] Trying to match section '1.5 - Start of a REPL' with fragment_id 'start-of-a-repl'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '1.5 - Start of a REPL' by title (normalized: '1.5 - Start of a REPL')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '1.5 - Start of a REPL' at line 1004
2025-12-28 12:12:55 [DEBUG] Rendered chapter 6/13: 'Lexing' (1111 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Parsing': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 6, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 6/13
2025-12-28 12:12:55 [DEBUG]   Rendered 4474 lines, found 25 headings from 365101 bytes of HTML
2025-12-28 12:12:55 [DEBUG] Matching 10 TOC sections to 25 headings
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Parsing' with fragment_id 'parsing'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Parsing' by title (normalized: 'Parsing')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Parsing' at line 0
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.1 - Parsers' with fragment_id 'parsers'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.1 - Parsers' by title (normalized: '2.1 - Parsers')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '2.1 - Parsers' at line 2
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.2 - Why not a parser generator?' with fragment_id 'why-not-a-parser-generator'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.2 - Why not a parser generator?' by title (normalized: '2.2 - Why not a parser generator?')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '2.2 - Why not a parser generator?' at line 146
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.3 - Writing a Parser for the Monkey Programming Language' with fragment_id 'writing-a-parser-for-the-monkey-programming-language'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.3 - Writing a Parser for the Monkey Programming Language' by title (normalized: '2.3 - Writing a Parser for the Monkey Programming Language')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '2.3 - Writing a Parser for the Monkey Programming Language' at line 222
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.4 - Parser’s first steps: parsing let statements' with fragment_id 'parsers-first-steps-parsing-let-statements'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.4 - Parser’s first steps: parsing let statements' by title (normalized: '2.4 - Parser’s first steps: parsing let statements')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '2.4 - Parser’s first steps: parsing let statements' at line 261
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.5 - Parsing Return Statements' with fragment_id 'parsing-return-statements'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.5 - Parsing Return Statements' by title (normalized: '2.5 - Parsing Return Statements')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '2.5 - Parsing Return Statements' at line 961
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.6 - Parsing Expressions' with fragment_id 'parsing-expressions'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.6 - Parsing Expressions' by title (normalized: '2.6 - Parsing Expressions')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '2.6 - Parsing Expressions' at line 1096
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.7 - How Pratt Parsing Works' with fragment_id 'how-pratt-parsing-works'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.7 - How Pratt Parsing Works' by title (normalized: '2.7 - How Pratt Parsing Works')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '2.7 - How Pratt Parsing Works' at line 2542
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.8 - Extending the Parser' with fragment_id 'extending-the-parser'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.8 - Extending the Parser' by title (normalized: '2.8 - Extending the Parser')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '2.8 - Extending the Parser' at line 2979
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.9 - Read-Parse-Print-Loop' with fragment_id 'read-parse-print-loop'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '2.9 - Read-Parse-Print-Loop' by title (normalized: '2.9 - Read-Parse-Print-Loop')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '2.9 - Read-Parse-Print-Loop' at line 4339
2025-12-28 12:12:55 [DEBUG] Rendered chapter 7/13: 'Parsing' (4474 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Evaluation': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 7, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 7/13
2025-12-28 12:12:55 [DEBUG]   Rendered 3034 lines, found 22 headings from 235665 bytes of HTML
2025-12-28 12:12:55 [DEBUG] Matching 12 TOC sections to 22 headings
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Evaluation' with fragment_id 'evaluation'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Evaluation' by title (normalized: 'Evaluation')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Evaluation' at line 0
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.1 - Giving Meaning to Symbols' with fragment_id 'giving-meaning-to-symbols'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.1 - Giving Meaning to Symbols' by title (normalized: '3.1 - Giving Meaning to Symbols')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.1 - Giving Meaning to Symbols' at line 2
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.2 - Strategies of Evaluation' with fragment_id 'strategies-of-evaluation'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.2 - Strategies of Evaluation' by title (normalized: '3.2 - Strategies of Evaluation')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.2 - Strategies of Evaluation' at line 54
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.3 - A Tree-Walking Interpreter' with fragment_id 'a-tree-walking-interpreter'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.3 - A Tree-Walking Interpreter' by title (normalized: '3.3 - A Tree-Walking Interpreter')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.3 - A Tree-Walking Interpreter' at line 165
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.4 - Representing Objects' with fragment_id 'representing-objects'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.4 - Representing Objects' by title (normalized: '3.4 - Representing Objects')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.4 - Representing Objects' at line 231
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.5 - Evaluating Expressions' with fragment_id 'evaluating-expressions'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.5 - Evaluating Expressions' by title (normalized: '3.5 - Evaluating Expressions')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.5 - Evaluating Expressions' at line 456
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.6 - Conditionals' with fragment_id 'conditionals'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.6 - Conditionals' by title (normalized: '3.6 - Conditionals')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.6 - Conditionals' at line 1346
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.7 - Return Statements' with fragment_id 'return-statements'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.7 - Return Statements' by title (normalized: '3.7 - Return Statements')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.7 - Return Statements' at line 1516
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling' with fragment_id 'abort-abort-theres-been-a-mistake-or-error-handling'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling' by title (normalized: '3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling' at line 1751
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.9 - Bindings & The Environment' with fragment_id 'bindings-the-environment'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.9 - Bindings & The Environment' by title (normalized: '3.9 - Bindings & The Environment')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.9 - Bindings & The Environment' at line 2071
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.10 - Functions & Function Calls' with fragment_id 'functions-function-calls'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.10 - Functions & Function Calls' by title (normalized: '3.10 - Functions & Function Calls')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.10 - Functions & Function Calls' at line 2328
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.11 - Who’s taking the trash out?' with fragment_id 'whos-taking-the-trash-out'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '3.11 - Who’s taking the trash out?' by title (normalized: '3.11 - Who’s taking the trash out?')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '3.11 - Who’s taking the trash out?' at line 2915
2025-12-28 12:12:55 [DEBUG] Rendered chapter 8/13: 'Evaluation' (3034 lines)
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 8, total: 13 }
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Extending the Interpreter': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG] Render progress: 8/13
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG]   Rendered 2931 lines, found 24 headings from 242946 bytes of HTML
2025-12-28 12:12:55 [DEBUG] Matching 7 TOC sections to 24 headings
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Extending the Interpreter' with fragment_id 'extending-the-interpreter'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Extending the Interpreter' by title (normalized: 'Extending the Interpreter')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Extending the Interpreter' at line 0
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.1 - Data Types & Functions' with fragment_id 'data-types-functions'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.1 - Data Types & Functions' by title (normalized: '4.1 - Data Types & Functions')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '4.1 - Data Types & Functions' at line 2
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.2 - Strings' with fragment_id 'strings'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.2 - Strings' by title (normalized: '4.2 - Strings')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '4.2 - Strings' at line 33
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.3 - Built-in Functions' with fragment_id 'built-in-functions'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.3 - Built-in Functions' by title (normalized: '4.3 - Built-in Functions')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '4.3 - Built-in Functions' at line 482
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.4 - Array' with fragment_id 'array'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.4 - Array' by title (normalized: '4.4 - Array')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '4.4 - Array' at line 759
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.5 - Hashes' with fragment_id 'hashes'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.5 - Hashes' by title (normalized: '4.5 - Hashes')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '4.5 - Hashes' at line 1820
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.6 - The Grand Finale' with fragment_id 'the-grand-finale'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section '4.6 - The Grand Finale' by title (normalized: '4.6 - The Grand Finale')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading '4.6 - The Grand Finale' at line 2834
2025-12-28 12:12:55 [DEBUG] Rendered chapter 9/13: 'Extending the Interpreter' (2931 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Going Further': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 9, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 9/13
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG]   Rendered 24 lines, found 3 headings from 1770 bytes of HTML
2025-12-28 12:12:55 [DEBUG] Matching 3 TOC sections to 3 headings
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Going Further' with fragment_id 'going-further'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Going Further' by title (normalized: 'Going Further')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Going Further' at line 0
2025-12-28 12:12:55 [DEBUG] Trying to match section 'The Lost Chapter' with fragment_id 'the-lost-chapter'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'The Lost Chapter' by title (normalized: 'The Lost Chapter')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'The Lost Chapter' at line 2
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Writing A Compiler In Go' with fragment_id 'writing-a-compiler-in-go'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Writing A Compiler In Go' by title (normalized: 'Writing A Compiler In Go')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Writing A Compiler In Go' at line 12
2025-12-28 12:12:55 [DEBUG] Rendered chapter 10/13: 'Going Further' (24 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Resources': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 10, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 10/13
2025-12-28 12:12:55 [DEBUG]   Rendered 93 lines, found 5 headings from 7441 bytes of HTML
2025-12-28 12:12:55 [DEBUG] Matching 1 TOC sections to 5 headings
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Resources' with fragment_id 'resources'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Resources' by title (normalized: 'Resources')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Resources' at line 0
2025-12-28 12:12:55 [DEBUG] Rendered chapter 11/13: 'Resources' (93 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Feedback': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 11, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 11/13
2025-12-28 12:12:55 [DEBUG]   Rendered 7 lines, found 1 headings from 709 bytes of HTML
2025-12-28 12:12:55 [DEBUG] Matching 1 TOC sections to 1 headings
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Feedback' with fragment_id 'feedback'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Feedback' by title (normalized: 'Feedback')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Feedback' at line 0
2025-12-28 12:12:55 [DEBUG] Rendered chapter 12/13: 'Feedback' (7 lines)
2025-12-28 12:12:55 [DEBUG] Rendering chapter 'Changelog': max_width=Some(80), terminal_width=210
2025-12-28 12:12:55 [DEBUG]   Effective rendering width: 76 columns
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 12, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 12/13
2025-12-28 12:12:55 [DEBUG]   Rendered 363 lines, found 9 headings from 10293 bytes of HTML
2025-12-28 12:12:55 [DEBUG] Matching 1 TOC sections to 9 headings
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Changelog' with fragment_id 'changelog'
2025-12-28 12:12:55 [DEBUG]   ✗ No fragment ID match found
2025-12-28 12:12:55 [DEBUG] Trying to match section 'Changelog' by title (normalized: 'Changelog')
2025-12-28 12:12:55 [DEBUG]   ✓ Matched by title to heading 'Changelog' at line 0
2025-12-28 12:12:55 [DEBUG] Rendered chapter 13/13: 'Changelog' (363 lines)
2025-12-28 12:12:55 [INFO] All chapters rendered successfully, sending book
2025-12-28 12:12:55 [DEBUG] Received task message: RenderProgress { rendered: 13, total: 13 }
2025-12-28 12:12:55 [DEBUG] Render progress: 13/13
2025-12-28 12:12:55 [DEBUG] Received task message: BookLoadingComplete { book: Book { metadata: BookMetadata { title: "Writing An Interpreter In Go", author: Some("Thorsten Ball"), publisher: None, publication_date: Some("2016"), language: Some("en-US") }, chapters: [Chapter { title: "Chapter 1", sections: [], content_lines: [], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>Writing An Interpreter In Go</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body id=\"cover\">\n<div id=\"cover-image\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"100%\" height=\"100%\" viewBox=\"0 0 1142 1440\" preserveAspectRatio=\"none\">\n<image width=\"1142\" height=\"1440\" xlink:href=\"../media/epub_cover.png\" />\n</svg>\n</div>\n</body>\n</html>\n" }, Chapter { title: "Writing An Interpreter In Go", sections: [], content_lines: [RenderedLine { text: "Writing An Interpreter In Go", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Thorsten Ball", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>Writing An Interpreter In Go</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"frontmatter\">\n<section epub:type=\"titlepage\" class=\"titlepage\">\n  <h1 class=\"title\">Writing An Interpreter In Go</h1>\n  <p class=\"author\">Thorsten Ball</p>\n<!-- REMOVED THE DATE -->\n<!--  -->\n<!--   <p class=\"date\">2016</p> -->\n<!--  -->\n</section>\n</body>\n</html>\n" }, Chapter { title: "Chapter 3", sections: [], content_lines: [RenderedLine { text: "─── Navigation ───", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Acknowledgments", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Introduction", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ The Monkey Programming Language & Interpreter", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Why Go?", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ How to Use this Book", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Lexing", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 1.1 - Lexical Analysis", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 1.2 - Defining Our Tokens", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 1.3 - The Lexer", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 1.4 - Extending our Token Set and Lexer", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 1.5 - Start of a REPL", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Parsing", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 2.1 - Parsers", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 2.2 - Why not a parser generator?", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 2.3 - Writing a Parser for the Monkey Programming Language", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 2.4 - Parser’s first steps: parsing let statements", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 2.5 - Parsing Return Statements", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 2.6 - Parsing Expressions", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 2.7 - How Pratt Parsing Works", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 2.8 - Extending the Parser", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 2.9 - Read-Parse-Print-Loop", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Evaluation", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.1 - Giving Meaning to Symbols", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.2 - Strategies of Evaluation", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.3 - A Tree-Walking Interpreter", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.4 - Representing Objects", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.5 - Evaluating Expressions", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.6 - Conditionals", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.7 - Return Statements", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.9 - Bindings & The Environment", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.10 - Functions & Function Calls", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 3.11 - Who’s taking the trash out?", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Extending the Interpreter", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 4.1 - Data Types & Functions", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 4.2 - Strings", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 4.3 - Built-in Functions", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 4.4 - Array", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 4.5 - Hashes", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ 4.6 - The Grand Finale", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Going Further", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ The Lost Chapter", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Writing A Compiler In Go", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Resources", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Feedback", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Changelog", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "─── Navigation ───", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Cover", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "→ Table of contents", style: Link, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>Writing An Interpreter In Go</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"styles/stylesheet1.css\" />\n</head>\n<body>\n<nav epub:type=\"toc\" id=\"toc\"><h1 id=\"toc-title\">Writing An Interpreter In Go</h1><ol class=\"toc\"><li id=\"toc-li-1\"><a href=\"text/ch001.xhtml#acknowledgments\">Acknowledgments</a></li><li id=\"toc-li-2\"><a href=\"text/ch002.xhtml#introduction\">Introduction</a><ol class=\"toc\"><li id=\"toc-li-3\"><a href=\"text/ch002.xhtml#the-monkey-programming-language-interpreter\">The Monkey Programming Language &amp; Interpreter</a></li><li id=\"toc-li-4\"><a href=\"text/ch002.xhtml#why-go\">Why Go?</a></li><li id=\"toc-li-5\"><a href=\"text/ch002.xhtml#how-to-use-this-book\">How to Use this Book</a></li></ol></li><li id=\"toc-li-6\"><a href=\"text/ch003.xhtml#lexing\">Lexing</a><ol class=\"toc\"><li id=\"toc-li-7\"><a href=\"text/ch003.xhtml#lexical-analysis\">1.1 - Lexical Analysis</a></li><li id=\"toc-li-8\"><a href=\"text/ch003.xhtml#defining-our-tokens\">1.2 - Defining Our Tokens</a></li><li id=\"toc-li-9\"><a href=\"text/ch003.xhtml#the-lexer\">1.3 - The Lexer</a></li><li id=\"toc-li-10\"><a href=\"text/ch003.xhtml#extending-our-token-set-and-lexer\">1.4 - Extending our Token Set and Lexer</a></li><li id=\"toc-li-11\"><a href=\"text/ch003.xhtml#start-of-a-repl\">1.5 - Start of a REPL</a></li></ol></li><li id=\"toc-li-12\"><a href=\"text/ch004.xhtml#parsing\">Parsing</a><ol class=\"toc\"><li id=\"toc-li-13\"><a href=\"text/ch004.xhtml#parsers\">2.1 - Parsers</a></li><li id=\"toc-li-14\"><a href=\"text/ch004.xhtml#why-not-a-parser-generator\">2.2 - Why not a parser generator?</a></li><li id=\"toc-li-15\"><a href=\"text/ch004.xhtml#writing-a-parser-for-the-monkey-programming-language\">2.3 - Writing a Parser for the Monkey Programming Language</a></li><li id=\"toc-li-16\"><a href=\"text/ch004.xhtml#parsers-first-steps-parsing-let-statements\">2.4 - Parser’s first steps: parsing let statements</a></li><li id=\"toc-li-17\"><a href=\"text/ch004.xhtml#parsing-return-statements\">2.5 - Parsing Return Statements</a></li><li id=\"toc-li-18\"><a href=\"text/ch004.xhtml#parsing-expressions\">2.6 - Parsing Expressions</a></li><li id=\"toc-li-19\"><a href=\"text/ch004.xhtml#how-pratt-parsing-works\">2.7 - How Pratt Parsing Works</a></li><li id=\"toc-li-20\"><a href=\"text/ch004.xhtml#extending-the-parser\">2.8 - Extending the Parser</a></li><li id=\"toc-li-21\"><a href=\"text/ch004.xhtml#read-parse-print-loop\">2.9 - Read-Parse-Print-Loop</a></li></ol></li><li id=\"toc-li-22\"><a href=\"text/ch005.xhtml#evaluation\">Evaluation</a><ol class=\"toc\"><li id=\"toc-li-23\"><a href=\"text/ch005.xhtml#giving-meaning-to-symbols\">3.1 - Giving Meaning to Symbols</a></li><li id=\"toc-li-24\"><a href=\"text/ch005.xhtml#strategies-of-evaluation\">3.2 - Strategies of Evaluation</a></li><li id=\"toc-li-25\"><a href=\"text/ch005.xhtml#a-tree-walking-interpreter\">3.3 - A Tree-Walking Interpreter</a></li><li id=\"toc-li-26\"><a href=\"text/ch005.xhtml#representing-objects\">3.4 - Representing Objects</a></li><li id=\"toc-li-27\"><a href=\"text/ch005.xhtml#evaluating-expressions\">3.5 - Evaluating Expressions</a></li><li id=\"toc-li-28\"><a href=\"text/ch005.xhtml#conditionals\">3.6 - Conditionals</a></li><li id=\"toc-li-29\"><a href=\"text/ch005.xhtml#return-statements\">3.7 - Return Statements</a></li><li id=\"toc-li-30\"><a href=\"text/ch005.xhtml#abort-abort-theres-been-a-mistake-or-error-handling\">3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling</a></li><li id=\"toc-li-31\"><a href=\"text/ch005.xhtml#bindings-the-environment\">3.9 - Bindings &amp; The Environment</a></li><li id=\"toc-li-32\"><a href=\"text/ch005.xhtml#functions-function-calls\">3.10 - Functions &amp; Function Calls</a></li><li id=\"toc-li-33\"><a href=\"text/ch005.xhtml#whos-taking-the-trash-out\">3.11 - Who’s taking the trash out?</a></li></ol></li><li id=\"toc-li-34\"><a href=\"text/ch006.xhtml#extending-the-interpreter\">Extending the Interpreter</a><ol class=\"toc\"><li id=\"toc-li-35\"><a href=\"text/ch006.xhtml#data-types-functions\">4.1 - Data Types &amp; Functions</a></li><li id=\"toc-li-36\"><a href=\"text/ch006.xhtml#strings\">4.2 - Strings</a></li><li id=\"toc-li-37\"><a href=\"text/ch006.xhtml#built-in-functions\">4.3 - Built-in Functions</a></li><li id=\"toc-li-38\"><a href=\"text/ch006.xhtml#array\">4.4 - Array</a></li><li id=\"toc-li-39\"><a href=\"text/ch006.xhtml#hashes\">4.5 - Hashes</a></li><li id=\"toc-li-40\"><a href=\"text/ch006.xhtml#the-grand-finale\">4.6 - The Grand Finale</a></li></ol></li><li id=\"toc-li-41\"><a href=\"text/ch007.xhtml#going-further\">Going Further</a><ol class=\"toc\"><li id=\"toc-li-42\"><a href=\"text/ch007.xhtml#the-lost-chapter\">The Lost Chapter</a></li><li id=\"toc-li-43\"><a href=\"text/ch007.xhtml#writing-a-compiler-in-go\">Writing A Compiler In Go</a></li></ol></li><li id=\"toc-li-44\"><a href=\"text/ch008.xhtml#resources\">Resources</a></li><li id=\"toc-li-45\"><a href=\"text/ch009.xhtml#feedback\">Feedback</a></li><li id=\"toc-li-46\"><a href=\"text/ch010.xhtml#changelog\">Changelog</a></li></ol></nav>\n<nav epub:type=\"landmarks\" id=\"landmarks\" hidden=\"hidden\">\n  <ol>\n    <li>\n      <a href=\"text/cover.xhtml\" epub:type=\"cover\">Cover</a>\n    </li>\n    <li>\n      <a href=\"#toc\" epub:type=\"toc\">Table of contents</a>\n    </li>\n  </ol>\n</nav>\n</body>\n</html>\n" }, Chapter { title: "Acknowledgments", sections: [Section { title: "Acknowledgments", start_line: 0, fragment_id: Some("acknowledgments") }], content_lines: [RenderedLine { text: "Acknowledgments", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I want to use these lines to express my gratitude to my wife for supporting", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "me. She’s the reason you’re reading this. This book wouldn’t exist without", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "her encouragement, faith in me, assistance and her willingness to listen to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "my mechanical keyboard clacking away at 6am.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Thanks to my friends Christian, Felix and Robin for reviewing early versions", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of this book and providing me with invaluable feedback, advice and cheers.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "You improved this book more than you can imagine.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>ch001.xhtml</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"bodymatter\">\n<section id=\"acknowledgments\" class=\"level1 unnumbered\" data-number=\"\">\n<h1 class=\"unnumbered\" data-number=\"\">Acknowledgments</h1>\n<p>I want to use these lines to express my gratitude to my wife for supporting me. She’s the reason you’re reading this. This book wouldn’t exist without her encouragement, faith in me, assistance and her willingness to listen to my mechanical keyboard clacking away at 6am.</p>\n<p>Thanks to my friends Christian, Felix and Robin for reviewing early versions of this book and providing me with invaluable feedback, advice and cheers. You improved this book more than you can imagine.</p>\n</section>\n</body>\n</html>\n" }, Chapter { title: "Introduction", sections: [Section { title: "Introduction", start_line: 0, fragment_id: Some("introduction") }, Section { title: "The Monkey Programming Language & Interpreter", start_line: 83, fragment_id: Some("the-monkey-programming-language-interpreter") }, Section { title: "Why Go?", start_line: 207, fragment_id: Some("why-go") }, Section { title: "How to Use this Book", start_line: 248, fragment_id: Some("how-to-use-this-book") }], content_lines: [RenderedLine { text: "Introduction", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first sentence of this introduction was supposed to be this one:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“Interpreters are magical”. But one of the earliest reviewers, who wishes to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "remain anonymous, said that “sounds super stupid”. Well, Christian, I don’t", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "think so! I still think that interpreters are magical! Let me tell you why.", style: Normal, search_matches: [], inline_styles: [(44, 47, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "On the surface they look deceptively simple: text goes in and something", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "comes out. They are programs that take other programs as their input and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "produce something. Simple, right? But the more you think about it, the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "more fascinating it becomes. Seemingly random characters - letters, numbers", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and special characters - are fed into the interpreter and suddenly become", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "meaningful. The interpreter gives them meaning! It makes sense out of", style: Normal, search_matches: [], inline_styles: [(0, 10, Bold)], syntax_colors: [] }, RenderedLine { text: "nonsense. And the computer, a machine that’s built on understanding ones and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "zeroes, now understands and acts upon this weird language we feed into it -", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "thanks to an interpreter that translates this language while reading it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I kept asking myself: how does this work? And the first time this question", style: Normal, search_matches: [], inline_styles: [(22, 41, Italic)], syntax_colors: [] }, RenderedLine { text: "began forming in my mind, I already knew that I’ll only be satisfied with an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "answer if I get to it by writing my own interpreter. So I set out to do so.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A lot of books, articles, blog posts and tutorials on interpreters exist.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Most of the time, though, they fall into one of two categories. Either they", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "are huge, incredibly heavy on theory and more targeted towards people who", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "already have a vast understanding of the topic, or they are really short,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "provide just a small introduction to the topic, use external tools as black", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "boxes and only concern themselves with “toy interpreters”.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "One of the main sources of frustration was this latter category of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "resources, because the interpreters they explain only interpret languages", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "with a really simple syntax. I didn’t want to take a shortcut! I truly", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "wanted to understand how interpreters work and that included understanding", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "how lexers and parsers work. Especially with a C-like language and its curly", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "braces and semicolons, where I didn’t even know how to start parsing them.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The academic textbooks had the answers I was looking for, of course. But", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "rather inaccessible to me, behind their lengthy, theoretical explanations", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and mathematical notation.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What I wanted was something between the 900 page book on compilers and the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "blog post that explains how to write a Lisp interpreter in 50 lines of Ruby", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "code.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So I wrote this book, for you and me. This is the book I wish I had. This is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a book for people who love to look under the hood. For people that love to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "learn by understanding how something really works.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In this book we’re going to write our own interpreter for our own", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programming language - from scratch. We won’t be using any 3rd party tools", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and libraries. The result won’t be production-ready, it won’t have the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "performance of a fully-fledged interpreter and, of course, the language it’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "built to interpret will be missing features. But we’re going to learn a lot.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s difficult to make generic statements about interpreters since the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "variety is so high and none are alike. What can be said is that the one", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fundamental attribute they all share is that they take source code and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluate it without producing some visible, intermediate result that can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "later be executed. That’s in contrast to compilers, which take source", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "code and produce output in another language that the underlying system can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "understand.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Some interpreters are really small, tiny, and do not even bother with a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parsing step. They just interpret the input right away. Look at one of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "many Brainfuck interpreters out there to see what I mean.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "On the other end of the spectrum are much more elaborate types of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreters. Highly optimized and using advanced parsing and evaluation", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "techniques. Some of them don’t just evaluate their input, but compile it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "into an internal representation called bytecode and then evaluate this. Even", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "more advanced are JIT interpreters that compile the input just-in-time into", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "native machine code that gets then executed.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But then, in between those two categories, there are interpreters that parse", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the source code, build an abstract syntax tree (AST) out of it and then", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluate this tree. This type of interpreter is sometimes called “tree-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "walking” interpreter, because it “walks” the AST and interprets it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What we will be building in this book is such a tree-walking interpreter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to build our own lexer, our own parser, our own tree", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "representation and our own evaluator. We’ll see what “tokens” are, what an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "abstract syntax tree is, how to build such a tree, how to evaluate it and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "how to extend our language with new data structures and built-in functions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The Monkey Programming Language & Interpreter", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Every interpreter is built to interpret a specific programming language.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s how you “implement” a programming language. Without a compiler", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "or an interpreter a programming language is nothing more than an idea or", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a specification.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to parse and evaluate our own language called Monkey. It’s a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language specifically designed for this book. Its only implementation is the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "one we’re going to build in this book - our interpreter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Expressed as a list of features, Monkey has the following:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• C-like syntax", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• variable bindings", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• integers and booleans", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• arithmetic expressions", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• built-in functions", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• first-class and higher-order functions", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• closures", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• a string data structure", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• an array data structure", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• a hash data structure", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to take a detailed look at and implement each of these features", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in the rest of this book. But for now, let’s see what Monkey looks like.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is how we bind values to names in Monkey:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let age = 1;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "let name = \"Monkey\";", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "let result = 10 * (20 / 2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides integers, booleans and strings, the Monkey interpreter we’re going", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to build will also support arrays and hashes. Here’s what binding an array", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of integers to a name looks like:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let myArray = [1, 2, 3, 4, 5];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And here is a hash, where values are associated with keys:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let thorsten = {\"name\": \"Thorsten\", \"age\": 28};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Accessing the elements in arrays and hashes is done with index expressions:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "myArray[0]       // => 1", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "thorsten[\"name\"] // => \"Thorsten\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The let statements can also be used to bind functions to names. Here’s a", style: Normal, search_matches: [], inline_styles: [(4, 7, Code)], syntax_colors: [] }, RenderedLine { text: "small function that adds two numbers:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(a, b) { return a + b; };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But Monkey not only supports return statements. Implicit return values are", style: Normal, search_matches: [], inline_styles: [(29, 35, Code)], syntax_colors: [] }, RenderedLine { text: "also possible, which means we can leave out the return if we want to:", style: Normal, search_matches: [], inline_styles: [(48, 54, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(a, b) { a + b; };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And calling a function is as easy as you’d expect:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "add(1, 2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A more complex function, such as a fibonacci function that returns the Nth", style: Normal, search_matches: [], inline_styles: [(35, 44, Code)], syntax_colors: [] }, RenderedLine { text: "Fibonacci number, might look like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let fibonacci = fn(x) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "  if (x == 0) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    0", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "  } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    if (x == 1) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "      1", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "      fibonacci(x - 1) + fibonacci(x - 2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Note the recursive calls to fibonacci itself!", style: Normal, search_matches: [], inline_styles: [(28, 37, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Monkey also supports a special type of functions, called higher order", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "functions. These are functions that take other functions as arguments. Here", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is an example:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let twice = fn(f, x) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "  return f(f(x));", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let addTwo = fn(x) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  return x + 2;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "twice(addTwo, 2); // => 6", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here twice takes two arguments: another function called addTwo and the", style: Normal, search_matches: [], inline_styles: [(5, 10, Code), (56, 62, Code)], syntax_colors: [] }, RenderedLine { text: "integer 2. It calls addTwo two times with first 2 as argument and then with", style: Normal, search_matches: [], inline_styles: [(8, 9, Code), (20, 26, Code), (48, 49, Code)], syntax_colors: [] }, RenderedLine { text: "the return value of the first call. The last line produces 6.", style: Normal, search_matches: [], inline_styles: [(59, 60, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, we can use functions as arguments in function calls. Functions in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Monkey are just values, like integers or strings. That feature is called", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“first class functions”.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The interpreter we’re going to build in this book will implement all these", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "features. It will tokenize and parse Monkey source code in a REPL, building", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "up an internal representation of the code called abstract syntax tree and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "then evaluate this tree. It will have a few major parts:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• the lexer", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• the parser", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• the Abstract Syntax Tree (AST)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• the internal object system", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• the evaluator", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to build these parts in exactly this order, from the bottom up.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Or better put: starting with the source code and ending with the output. The", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "drawback of this approach is that it won’t produce a simple “Hello World”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "after the first chapter. The advantage is that it’s easier to understand how", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "all the pieces fit together and how the data flows through the program.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But why the name? Why is it called “Monkey”? Well, because monkeys are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "magnificent, elegant, fascinating and funny creatures. Exactly like our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And why the name of the book?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Why Go?", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If you read this far without noticing the title and the words “in Go” in it,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "first of all: congratulations, that’s pretty remarkable. And second: we will", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "write our interpreter in Go. Why Go?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I like writing code in Go. I enjoy using the language, its standard library", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and the tools it provides. But other than that I think that Go is in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "possession of a few attributes that make it a great fit for this particular", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "book.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Go is really easy to read and subsequently understand. You won’t need to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "decipher the Go code I present to you in this book. Even if you are not an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "experienced Go programmer. I’d bet that you can follow this book along even", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if you’ve never written a single line of Go in your life.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Another reason is the great tooling Go provides. The focus of this book is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the interpreter we are writing - the ideas and concepts behind it and its", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implementation. With Go’s universal formatting style thanks to gofmt and", style: Normal, search_matches: [], inline_styles: [(65, 70, Code)], syntax_colors: [] }, RenderedLine { text: "a testing framework built-in, we can concentrate on our interpreter and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "not worry about 3rd party libraries, tools and dependencies. We won’t be", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "using any other tools in this book other than the ones provided by the Go", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programming language.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But I think much more important is that the Go code presented in this book", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "maps closely to other and possibly more low-level languages, like C, C++ and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Rust. Maybe the reason for this is Go itself, with its focus on simplicity,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "its stripped-down charm and lack of programming language constructs that are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "absent in other languages and hard to translate. Or maybe it’s because of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the way I chose to write Go for this book. Either way, there won’t be any", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "meta-programming tricks to take a shortcut that nobody understands anymore", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "after two weeks and no grandiose object-oriented designs and patterns that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "need pen, paper and the sentence “actually, it’s pretty easy” to explain.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "All of these reasons make the code presented here easy to understand (on a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "conceptual as well as a technical level) and reusable for you. And if you,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "after reading this book, choose to write your own interpreter in another", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language this should come in handy. With this book I want to provide a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "starting point in your understanding and construction of interpreters and I", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "think the code reflects that.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "How to Use this Book", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This book is neither a reference, nor is it a theory-laden paper describing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "concepts of interpreter implementation with code in the appendix. This book", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is meant to be read from start to finish and I recommend that you follow", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "along by reading, typing out and modifying the presented code.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Each chapter builds upon its predecessor - in code and in prose. And in each", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "chapter we build another part of our interpreter, piece by piece. To make", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it easier to follow along, the book comes with a folder called code, that", style: Normal, search_matches: [], inline_styles: [(63, 67, Code)], syntax_colors: [] }, RenderedLine { text: "contains, well, code. If your copy of the book came without the folder, you", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "can download it here:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "https://interpreterbook.com/waiig_code_1.7.zip", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The code folder is divided into several subfolders, with one for each", style: Normal, search_matches: [], inline_styles: [(4, 8, Code)], syntax_colors: [] }, RenderedLine { text: "chapter, containing the final result of the corresponding chapter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Sometimes I’ll only allude to something being in the code, without showing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the code itself (because either it would take up too much space, as is the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "case with the test files, or it is just some detail) - you can find this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "code in the folder accompanying the chapter, too.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Which tools do you need to follow along? Not much: a text editor and the Go", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programming language. Any Go version above 1.0 should work, but just as a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "disclaimer and for future generations: when I wrote this book I was using Go", style: Normal, search_matches: [], inline_styles: [(74, 76, Bold)], syntax_colors: [] }, RenderedLine { text: "1.7. Now, with the latest update of the book, I’m using Go 1.14.", style: Normal, search_matches: [], inline_styles: [(0, 3, Bold), (58, 65, Bold)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If you’re using Go >= 1.13 the code in the code folder should be runnable", style: Normal, search_matches: [], inline_styles: [(18, 28, Bold), (45, 49, Code)], syntax_colors: [] }, RenderedLine { text: "out of the box.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If you’re on an older version of Go, one that doesn’t support Go modules,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I recommend using direnv, which can change the environment of your shell", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "according to an .envrc file. Each sub-folder in the code folder accompanying", style: Normal, search_matches: [], inline_styles: [(18, 24, Code)], syntax_colors: [] }, RenderedLine { text: "this book contains such an .envrc file that sets the GOPATH correctly for", style: Normal, search_matches: [], inline_styles: [(30, 36, Code), (56, 62, Code)], syntax_colors: [] }, RenderedLine { text: "this sub-folder. That allows us to easily work with the code of different", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "chapters.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And with that out of the way, let’s get started!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>ch002.xhtml</title>\n  <style>\npre > code.sourceCode { white-space: pre; position: relative; }\npre > code.sourceCode > span { display: inline-block; line-height: 1.25; }\npre > code.sourceCode > span:empty { height: 1.2em; }\ncode.sourceCode > span { color: inherit; text-decoration: inherit; }\ndiv.sourceCode { margin: 1em 0; }\npre.sourceCode { margin: 0; }\n@media screen {\ndiv.sourceCode { overflow: auto; }\n}\n@media print {\npre > code.sourceCode { white-space: pre-wrap; }\npre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }\n}\npre.numberSource code\n  { counter-reset: source-line 0; }\npre.numberSource code > span\n  { position: relative; left: -4em; counter-increment: source-line; }\npre.numberSource code > span > a:first-child::before\n  { content: counter(source-line);\n    position: relative; left: -1em; text-align: right; vertical-align: baseline;\n    border: none; display: inline-block;\n    -webkit-touch-callout: none; -webkit-user-select: none;\n    -khtml-user-select: none; -moz-user-select: none;\n    -ms-user-select: none; user-select: none;\n    padding: 0 4px; width: 4em;\n    color: #aaaaaa;\n  }\npre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\ndiv.sourceCode\n  {   }\n@media screen {\npre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }\n}\ncode span.al { color: #ff0000; font-weight: bold; } /* Alert */\ncode span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */\ncode span.at { color: #7d9029; } /* Attribute */\ncode span.bn { color: #40a070; } /* BaseN */\ncode span.bu { } /* BuiltIn */\ncode span.cf { color: #007020; font-weight: bold; } /* ControlFlow */\ncode span.ch { color: #4070a0; } /* Char */\ncode span.cn { color: #880000; } /* Constant */\ncode span.co { color: #60a0b0; font-style: italic; } /* Comment */\ncode span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */\ncode span.do { color: #ba2121; font-style: italic; } /* Documentation */\ncode span.dt { color: #902000; } /* DataType */\ncode span.dv { color: #40a070; } /* DecVal */\ncode span.er { color: #ff0000; font-weight: bold; } /* Error */\ncode span.ex { } /* Extension */\ncode span.fl { color: #40a070; } /* Float */\ncode span.fu { color: #06287e; } /* Function */\ncode span.im { } /* Import */\ncode span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */\ncode span.kw { color: #007020; font-weight: bold; } /* Keyword */\ncode span.op { color: #666666; } /* Operator */\ncode span.ot { color: #007020; } /* Other */\ncode span.pp { color: #bc7a00; } /* Preprocessor */\ncode span.sc { color: #4070a0; } /* SpecialChar */\ncode span.ss { color: #bb6688; } /* SpecialString */\ncode span.st { color: #4070a0; } /* String */\ncode span.va { color: #19177c; } /* Variable */\ncode span.vs { color: #4070a0; } /* VerbatimString */\ncode span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */\n/* Apple Books 2.4+ doesn't like overflow:auto on syntax highlighting generated by skylighting */\n@media screen {\n  div.sourceCode { overflow: visible !important; }\n  p, span, pre, code, blockquote { overflow: visible !important; }\n}\n  </style>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"bodymatter\">\n<section id=\"introduction\" class=\"level1 unnumbered\" data-number=\"\">\n<h1 class=\"unnumbered\" data-number=\"\">Introduction</h1>\n<p>The first sentence of this introduction was supposed to be this one: “Interpreters are magical”. But one of the earliest reviewers, who wishes to remain anonymous, said that “sounds super stupid”. Well, Christian, I don’t think so! I still think that interpreters <em>are</em> magical! Let me tell you why.</p>\n<p>On the surface they look deceptively simple: text goes in and something comes out. They are programs that take other programs as their input and produce something. Simple, right? But the more you think about it, the more fascinating it becomes. Seemingly random characters - letters, numbers and special characters - are fed into the interpreter and suddenly become <strong>meaningful</strong>. The interpreter gives them meaning! It makes sense out of nonsense. And the computer, a machine that’s built on understanding ones and zeroes, now understands and acts upon this weird language we feed into it - thanks to an interpreter that translates this language while reading it.</p>\n<p>I kept asking myself: <em>how does this work?</em> And the first time this question began forming in my mind, I already knew that I’ll only be satisfied with an answer if I get to it by writing my own interpreter. So I set out to do so.</p>\n<p>A lot of books, articles, blog posts and tutorials on interpreters exist. Most of the time, though, they fall into one of two categories. Either they are huge, incredibly heavy on theory and more targeted towards people who already have a vast understanding of the topic, or they are really short, provide just a small introduction to the topic, use external tools as black boxes and only concern themselves with “toy interpreters”.</p>\n<p>One of the main sources of frustration was this latter category of resources, because the interpreters they explain only interpret languages with a really simple syntax. I didn’t want to take a shortcut! I truly wanted to understand how interpreters work and that included understanding how lexers and parsers work. Especially with a C-like language and its curly braces and semicolons, where I didn’t even know how to start parsing them. The academic textbooks had the answers I was looking for, of course. But rather inaccessible to me, behind their lengthy, theoretical explanations and mathematical notation.</p>\n<p>What I wanted was something between the 900 page book on compilers and the blog post that explains how to write a Lisp interpreter in 50 lines of Ruby code.</p>\n<p>So I wrote this book, for you and me. This is the book I wish I had. This is a book for people who love to look under the hood. For people that love to learn by understanding how something really works.</p>\n<p>In this book we’re going to write our own interpreter for our own programming language - from scratch. We won’t be using any 3rd party tools and libraries. The result won’t be production-ready, it won’t have the performance of a fully-fledged interpreter and, of course, the language it’s built to interpret will be missing features. But we’re going to learn a lot.</p>\n<p>It’s difficult to make generic statements about interpreters since the variety is so high and none are alike. What can be said is that the one fundamental attribute they all share is that they take source code and evaluate it without producing some visible, intermediate result that can later be executed. That’s in contrast to compilers, which take source code and produce output in another language that the underlying system can understand.</p>\n<p>Some interpreters are really small, tiny, and do not even bother with a parsing step. They just interpret the input right away. Look at one of the many Brainfuck interpreters out there to see what I mean.</p>\n<p>On the other end of the spectrum are much more elaborate types of interpreters. Highly optimized and using advanced parsing and evaluation techniques. Some of them don’t just evaluate their input, but compile it into an internal representation called bytecode and then evaluate this. Even more advanced are JIT interpreters that compile the input just-in-time into native machine code that gets then executed.</p>\n<p>But then, in between those two categories, there are interpreters that parse the source code, build an abstract syntax tree (AST) out of it and then evaluate this tree. This type of interpreter is sometimes called “tree-walking” interpreter, because it “walks” the AST and interprets it.</p>\n<p>What we will be building in this book is such a tree-walking interpreter.</p>\n<p>We’re going to build our own lexer, our own parser, our own tree representation and our own evaluator. We’ll see what “tokens” are, what an abstract syntax tree is, how to build such a tree, how to evaluate it and how to extend our language with new data structures and built-in functions.</p>\n<section id=\"the-monkey-programming-language-interpreter\" class=\"level2\" data-number=\"0.1\">\n<h2 data-number=\"0.1\">The Monkey Programming Language &amp; Interpreter</h2>\n<p>Every interpreter is built to interpret a specific programming language. That’s how you “implement” a programming language. Without a compiler or an interpreter a programming language is nothing more than an idea or a specification.</p>\n<p>We’re going to parse and evaluate our own language called Monkey. It’s a language specifically designed for this book. Its only implementation is the one we’re going to build in this book - our interpreter.</p>\n<p>Expressed as a list of features, Monkey has the following:</p>\n<ul>\n<li>C-like syntax</li>\n<li>variable bindings</li>\n<li>integers and booleans</li>\n<li>arithmetic expressions</li>\n<li>built-in functions</li>\n<li>first-class and higher-order functions</li>\n<li>closures</li>\n<li>a string data structure</li>\n<li>an array data structure</li>\n<li>a hash data structure</li>\n</ul>\n<p>We’re going to take a detailed look at and implement each of these features in the rest of this book. But for now, let’s see what Monkey looks like.</p>\n<p>Here is how we bind values to names in Monkey:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb1-1\"><a href=\"#cb1-1\"></a><span class=\"kw\">let</span> age <span class=\"op\">=</span> <span class=\"dv\">1</span><span class=\"op\">;</span></span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\"></a><span class=\"kw\">let</span> name <span class=\"op\">=</span> <span class=\"st\">&quot;Monkey&quot;</span><span class=\"op\">;</span></span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\"></a><span class=\"kw\">let</span> result <span class=\"op\">=</span> <span class=\"dv\">10</span> <span class=\"op\">*</span> (<span class=\"dv\">20</span> <span class=\"op\">/</span> <span class=\"dv\">2</span>)<span class=\"op\">;</span></span></code></pre></div>\n<p>Besides integers, booleans and strings, the Monkey interpreter we’re going to build will also support arrays and hashes. Here’s what binding an array of integers to a name looks like:</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb2-1\"><a href=\"#cb2-1\"></a><span class=\"kw\">let</span> myArray <span class=\"op\">=</span> [<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span><span class=\"op\">,</span> <span class=\"dv\">5</span>]<span class=\"op\">;</span></span></code></pre></div>\n<p>And here is a hash, where values are associated with keys:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb3-1\"><a href=\"#cb3-1\"></a><span class=\"kw\">let</span> thorsten <span class=\"op\">=</span> {<span class=\"st\">&quot;name&quot;</span><span class=\"op\">:</span> <span class=\"st\">&quot;Thorsten&quot;</span><span class=\"op\">,</span> <span class=\"st\">&quot;age&quot;</span><span class=\"op\">:</span> <span class=\"dv\">28</span>}<span class=\"op\">;</span></span></code></pre></div>\n<p>Accessing the elements in arrays and hashes is done with index expressions:</p>\n<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb4-1\"><a href=\"#cb4-1\"></a>myArray[<span class=\"dv\">0</span>]       <span class=\"co\">// =&gt; 1</span></span>\n<span id=\"cb4-2\"><a href=\"#cb4-2\"></a>thorsten[<span class=\"st\">&quot;name&quot;</span>] <span class=\"co\">// =&gt; &quot;Thorsten&quot;</span></span></code></pre></div>\n<p>The <code>let</code> statements can also be used to bind functions to names. Here’s a small function that adds two numbers:</p>\n<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb5-1\"><a href=\"#cb5-1\"></a><span class=\"kw\">let</span> add <span class=\"op\">=</span> fn(a<span class=\"op\">,</span> b) { <span class=\"cf\">return</span> a <span class=\"op\">+</span> b<span class=\"op\">;</span> }<span class=\"op\">;</span></span></code></pre></div>\n<p>But Monkey not only supports <code>return</code> statements. Implicit return values are also possible, which means we can leave out the <code>return</code> if we want to:</p>\n<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb6-1\"><a href=\"#cb6-1\"></a><span class=\"kw\">let</span> add <span class=\"op\">=</span> fn(a<span class=\"op\">,</span> b) { a <span class=\"op\">+</span> b<span class=\"op\">;</span> }<span class=\"op\">;</span></span></code></pre></div>\n<p>And calling a function is as easy as you’d expect:</p>\n<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb7-1\"><a href=\"#cb7-1\"></a>add(<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span>)<span class=\"op\">;</span></span></code></pre></div>\n<p>A more complex function, such as a <code>fibonacci</code> function that returns the Nth Fibonacci number, might look like this:</p>\n<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb8-1\"><a href=\"#cb8-1\"></a><span class=\"kw\">let</span> fibonacci <span class=\"op\">=</span> fn(x) {</span>\n<span id=\"cb8-2\"><a href=\"#cb8-2\"></a>  <span class=\"cf\">if</span> (x <span class=\"op\">==</span> <span class=\"dv\">0</span>) {</span>\n<span id=\"cb8-3\"><a href=\"#cb8-3\"></a>    <span class=\"dv\">0</span></span>\n<span id=\"cb8-4\"><a href=\"#cb8-4\"></a>  } <span class=\"cf\">else</span> {</span>\n<span id=\"cb8-5\"><a href=\"#cb8-5\"></a>    <span class=\"cf\">if</span> (x <span class=\"op\">==</span> <span class=\"dv\">1</span>) {</span>\n<span id=\"cb8-6\"><a href=\"#cb8-6\"></a>      <span class=\"dv\">1</span></span>\n<span id=\"cb8-7\"><a href=\"#cb8-7\"></a>    } <span class=\"cf\">else</span> {</span>\n<span id=\"cb8-8\"><a href=\"#cb8-8\"></a>      fibonacci(x <span class=\"op\">-</span> <span class=\"dv\">1</span>) <span class=\"op\">+</span> fibonacci(x <span class=\"op\">-</span> <span class=\"dv\">2</span>)<span class=\"op\">;</span></span>\n<span id=\"cb8-9\"><a href=\"#cb8-9\"></a>    }</span>\n<span id=\"cb8-10\"><a href=\"#cb8-10\"></a>  }</span>\n<span id=\"cb8-11\"><a href=\"#cb8-11\"></a>}<span class=\"op\">;</span></span></code></pre></div>\n<p>Note the recursive calls to <code>fibonacci</code> itself!</p>\n<p>Monkey also supports a special type of functions, called higher order functions. These are functions that take other functions as arguments. Here is an example:</p>\n<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb9-1\"><a href=\"#cb9-1\"></a><span class=\"kw\">let</span> twice <span class=\"op\">=</span> fn(f<span class=\"op\">,</span> x) {</span>\n<span id=\"cb9-2\"><a href=\"#cb9-2\"></a>  <span class=\"cf\">return</span> f(f(x))<span class=\"op\">;</span></span>\n<span id=\"cb9-3\"><a href=\"#cb9-3\"></a>}<span class=\"op\">;</span></span>\n<span id=\"cb9-4\"><a href=\"#cb9-4\"></a></span>\n<span id=\"cb9-5\"><a href=\"#cb9-5\"></a><span class=\"kw\">let</span> addTwo <span class=\"op\">=</span> fn(x) {</span>\n<span id=\"cb9-6\"><a href=\"#cb9-6\"></a>  <span class=\"cf\">return</span> x <span class=\"op\">+</span> <span class=\"dv\">2</span><span class=\"op\">;</span></span>\n<span id=\"cb9-7\"><a href=\"#cb9-7\"></a>}<span class=\"op\">;</span></span>\n<span id=\"cb9-8\"><a href=\"#cb9-8\"></a></span>\n<span id=\"cb9-9\"><a href=\"#cb9-9\"></a>twice(addTwo<span class=\"op\">,</span> <span class=\"dv\">2</span>)<span class=\"op\">;</span> <span class=\"co\">// =&gt; 6</span></span></code></pre></div>\n<p>Here <code>twice</code> takes two arguments: another function called <code>addTwo</code> and the integer <code>2</code>. It calls <code>addTwo</code> two times with first <code>2</code> as argument and then with the return value of the first call. The last line produces <code>6</code>.</p>\n<p>Yes, we can use functions as arguments in function calls. Functions in Monkey are just values, like integers or strings. That feature is called “first class functions”.</p>\n<p>The interpreter we’re going to build in this book will implement all these features. It will tokenize and parse Monkey source code in a REPL, building up an internal representation of the code called abstract syntax tree and then evaluate this tree. It will have a few major parts:</p>\n<ul>\n<li>the lexer</li>\n<li>the parser</li>\n<li>the Abstract Syntax Tree (AST)</li>\n<li>the internal object system</li>\n<li>the evaluator</li>\n</ul>\n<p>We’re going to build these parts in exactly this order, from the bottom up. Or better put: starting with the source code and ending with the output. The drawback of this approach is that it won’t produce a simple “Hello World” after the first chapter. The advantage is that it’s easier to understand how all the pieces fit together and how the data flows through the program.</p>\n<p>But why the name? Why is it called “Monkey”? Well, because monkeys are magnificent, elegant, fascinating and funny creatures. Exactly like our interpreter.</p>\n<p>And why the name of the book?</p>\n</section>\n<section id=\"why-go\" class=\"level2\" data-number=\"0.2\">\n<h2 data-number=\"0.2\">Why Go?</h2>\n<p>If you read this far without noticing the title and the words “in Go” in it, first of all: congratulations, that’s pretty remarkable. And second: we will write our interpreter in Go. Why Go?</p>\n<p>I like writing code in Go. I enjoy using the language, its standard library and the tools it provides. But other than that I think that Go is in possession of a few attributes that make it a great fit for this particular book.</p>\n<p>Go is really easy to read and subsequently understand. You won’t need to decipher the Go code I present to you in this book. Even if you are not an experienced Go programmer. I’d bet that you can follow this book along even if you’ve never written a single line of Go in your life.</p>\n<p>Another reason is the great tooling Go provides. The focus of this book is the interpreter we are writing - the ideas and concepts behind it and its implementation. With Go’s universal formatting style thanks to <code>gofmt</code> and a testing framework built-in, we can concentrate on our interpreter and not worry about 3rd party libraries, tools and dependencies. We won’t be using any other tools in this book other than the ones provided by the Go programming language.</p>\n<p>But I think much more important is that the Go code presented in this book maps closely to other and possibly more low-level languages, like C, C++ and Rust. Maybe the reason for this is Go itself, with its focus on simplicity, its stripped-down charm and lack of programming language constructs that are absent in other languages and hard to translate. Or maybe it’s because of the way I chose to write Go for this book. Either way, there won’t be any meta-programming tricks to take a shortcut that nobody understands anymore after two weeks and no grandiose object-oriented designs and patterns that need pen, paper and the sentence “actually, it’s pretty easy” to explain.</p>\n<p>All of these reasons make the code presented here easy to understand (on a conceptual as well as a technical level) and reusable for you. And if you, after reading this book, choose to write your own interpreter in another language this should come in handy. With this book I want to provide a starting point in your understanding and construction of interpreters and I think the code reflects that.</p>\n</section>\n<section id=\"how-to-use-this-book\" class=\"level2\" data-number=\"0.3\">\n<h2 data-number=\"0.3\">How to Use this Book</h2>\n<p>This book is neither a reference, nor is it a theory-laden paper describing concepts of interpreter implementation with code in the appendix. This book is meant to be read from start to finish and I recommend that you follow along by reading, typing out and modifying the presented code.</p>\n<p>Each chapter builds upon its predecessor - in code and in prose. And in each chapter we build another part of our interpreter, piece by piece. To make it easier to follow along, the book comes with a folder called <code>code</code>, that contains, well, code. If your copy of the book came without the folder, you can download it here:</p>\n<p><a href=\"https://interpreterbook.com/waiig_code_1.7.zip\">https://interpreterbook.com/waiig_code_1.7.zip</a></p>\n<p>The <code>code</code> folder is divided into several subfolders, with one for each chapter, containing the final result of the corresponding chapter.</p>\n<p>Sometimes I’ll only allude to something being in the code, without showing the code itself (because either it would take up too much space, as is the case with the test files, or it is just some detail) - you can find this code in the folder accompanying the chapter, too.</p>\n<p>Which tools do you need to follow along? Not much: a text editor and the Go programming language. Any Go version above 1.0 should work, but just as a disclaimer and for future generations: when I wrote this book I was using <strong>Go 1.7</strong>. Now, with the latest update of the book, I’m using <strong>Go 1.14</strong>.</p>\n<p>If you’re using <strong>Go &gt;= 1.13</strong> the code in the <code>code</code> folder should be runnable out of the box.</p>\n<p>If you’re on an older version of Go, one that doesn’t support Go modules, I recommend using <a href=\"http://direnv.net/\">direnv</a>, which can change the environment of your shell according to an <code>.envrc</code> file. Each sub-folder in the code folder accompanying this book contains such an <code>.envrc</code> file that sets the <code>GOPATH</code> correctly for this sub-folder. That allows us to easily work with the code of different chapters.</p>\n<p>And with that out of the way, let’s get started!</p>\n</section>\n</section>\n</body>\n</html>\n" }, Chapter { title: "Lexing", sections: [Section { title: "Lexing", start_line: 0, fragment_id: Some("lexing") }, Section { title: "1.1 - Lexical Analysis", start_line: 2, fragment_id: Some("lexical-analysis") }, Section { title: "1.2 - Defining Our Tokens", start_line: 78, fragment_id: Some("defining-our-tokens") }, Section { title: "1.3 - The Lexer", start_line: 181, fragment_id: Some("the-lexer") }, Section { title: "1.4 - Extending our Token Set and Lexer", start_line: 681, fragment_id: Some("extending-our-token-set-and-lexer") }, Section { title: "1.5 - Start of a REPL", start_line: 1004, fragment_id: Some("start-of-a-repl") }], content_lines: [RenderedLine { text: "Lexing", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "1.1 - Lexical Analysis", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order for us to work with source code we need to turn it into a more", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "accessible form. As easy as plain text is to work with in our editor, it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "becomes cumbersome pretty fast when trying to interpret it in a programming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language as another programming language.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So, what we need to do is represent our source code in other forms that are", style: Normal, search_matches: [], inline_styles: [(72, 75, Bold)], syntax_colors: [] }, RenderedLine { text: "easier to work with. We’re going to change the representation of our source", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "code two times before we evaluate it:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first transformation, from source code to tokens, is called “lexical", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "analysis”, or “lexing” for short. It’s done by a lexer (also called", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tokenizer or scanner – some use one word or the other to denote subtle", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "differences in behaviour, which we can ignore in this book).", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Tokens themselves are small, easily categorizable data structures that are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "then fed to the parser, which does the second transformation and turns the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tokens into an “Abstract Syntax Tree”.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here’s an example. This is the input one gives to a lexer:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "\"let x = 5 + 5;\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And what comes out of the lexer looks kinda like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "  LET,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "  IDENTIFIER(\"x\"),", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "  EQUAL_SIGN,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "  INTEGER(5),", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "  PLUS_SIGN,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "  INTEGER(5),", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "  SEMICOLON", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "All of these tokens have the original source code representation attached.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "\"let\" in the case of LET, \"+\" in the case of PLUS_SIGN, and so on. Some,", style: Normal, search_matches: [], inline_styles: [(0, 5, Code), (21, 24, Code), (26, 29, Code), (45, 54, Code)], syntax_colors: [] }, RenderedLine { text: "like IDENTIFIER and INTEGER in our example, also have the concrete values", style: Normal, search_matches: [], inline_styles: [(5, 15, Code), (20, 27, Code)], syntax_colors: [] }, RenderedLine { text: "they represent attached: 5 (not \"5\"!) in the case of INTEGER and \"x\" in the", style: Normal, search_matches: [], inline_styles: [(25, 26, Code), (32, 35, Code), (53, 60, Code), (65, 68, Code)], syntax_colors: [] }, RenderedLine { text: "case of IDENTIFIER. But what exactly constitutes a “token” varies between", style: Normal, search_matches: [], inline_styles: [(8, 18, Code)], syntax_colors: [] }, RenderedLine { text: "different lexer implementations. As an example, some lexers only convert", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the \"5\" to an integer in the parsing stage, or even later, and not when", style: Normal, search_matches: [], inline_styles: [(6, 9, Code)], syntax_colors: [] }, RenderedLine { text: "constructing tokens.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A thing to note about this example: whitespace characters don’t show", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "up as tokens. In our case that’s okay, because whitespace length is not", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "significant in the Monkey language. Whitespace merely acts as a separator", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "for other tokens. It doesn’t matter if we type this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let x = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Or if we type this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let   x   =   5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In other languages, like Python, the length of whitespace is significant.", style: Normal, search_matches: [], inline_styles: [(58, 60, Italic)], syntax_colors: [] }, RenderedLine { text: "That means the lexer can’t just “eat up” the whitespace and newline", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "characters. It has to output the whitespace characters as tokens so the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser can later on make sense of them (or output an error, of course, if", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "there are not enough or too many).", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A production-ready lexer might also attach the line number, column number", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and filename to a token. Why? For example, to later output more useful error", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "messages in the parsing stage. Instead of \"error: expected semicolon token\"", style: Normal, search_matches: [], inline_styles: [(42, 75, Code)], syntax_colors: [] }, RenderedLine { text: "it can output:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "\"error: expected semicolon token. line 42, column 23, program.monkey\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re not going to bother with that. Not because it’s too complex, but", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "because it would take away from the essential simpleness of the tokens and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the lexer, making it harder to understand.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "1.2 - Defining Our Tokens", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we have to do is to define the tokens our lexer is going to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "output. We’re going to start with just a few token definitions and then add", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "more when extending the lexer.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The subset of the Monkey language we’re going to lex in our first step looks", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let five = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "let ten = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(x, y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  x + y;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let result = add(five, ten);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s break this down: which types of tokens does this example contain?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "First of all, there are the numbers like 5 and 10. These are pretty obvious.", style: Normal, search_matches: [], inline_styles: [(42, 43, Code), (48, 50, Code)], syntax_colors: [] }, RenderedLine { text: "Then we have the variable names x, y, add and result. And then there are", style: Normal, search_matches: [], inline_styles: [(34, 35, Code), (37, 38, Code), (40, 43, Code), (48, 54, Code)], syntax_colors: [] }, RenderedLine { text: "also these parts of the language that are not numbers, just words, but no", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "variable names either, like let and fn. Of course, there are also a lot of", style: Normal, search_matches: [], inline_styles: [(30, 33, Code), (38, 40, Code)], syntax_colors: [] }, RenderedLine { text: "special characters: (, ), {, }, =, ,, ;.", style: Normal, search_matches: [], inline_styles: [(22, 23, Code), (25, 26, Code), (28, 29, Code), (31, 32, Code), (34, 35, Code), (37, 38, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The numbers are just integers and we’re going to treat them as such and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "give them a separate type. In the lexer or parser we don’t care if the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "number is 5 or 10, we just want to know if it’s a number. The same goes for", style: Normal, search_matches: [], inline_styles: [(12, 13, Code), (17, 19, Code)], syntax_colors: [] }, RenderedLine { text: "“variable names”: we’ll call them “identifiers” and treat them the same.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now, the other words, the ones that look like identifiers, but aren’t really", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "identifiers, since they’re part of the language, are called “keywords”.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We won’t group these together since it should make a difference in the", style: Normal, search_matches: [], inline_styles: [(47, 53, Bold)], syntax_colors: [] }, RenderedLine { text: "parsing stage whether we encounter a let or a fn. The same goes for the last", style: Normal, search_matches: [], inline_styles: [(44, 47, Code), (53, 55, Code)], syntax_colors: [] }, RenderedLine { text: "category we identified: the special characters. We’ll treat each of them", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "separately, since it is a big difference whether or not we have a ( or a )", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in the source code.", style: Normal, search_matches: [], inline_styles: [(1, 2, Code), (8, 9, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s define our Token data structure. Which fields does it need? As we just", style: Normal, search_matches: [], inline_styles: [(19, 24, Code)], syntax_colors: [] }, RenderedLine { text: "saw, we definitely need a “type” attribute, so we can distinguish between", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“integers” and “right bracket” for example. And it also needs a field that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "holds the literal value of the token, so we can reuse it later and the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "information whether a “number” token is a 5 or a 10 doesn’t get lost.", style: Normal, search_matches: [], inline_styles: [(50, 51, Code), (57, 59, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In a new token package we define our Token struct and our TokenType type:", style: Normal, search_matches: [], inline_styles: [(9, 14, Code), (37, 42, Code), (58, 67, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// token/token.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type TokenType string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Token struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    Type    TokenType", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Literal string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We defined the TokenType type to be a string. That allows us to use many", style: Normal, search_matches: [], inline_styles: [(15, 24, Code), (38, 44, Code)], syntax_colors: [] }, RenderedLine { text: "different values as TokenTypes, which in turn allows us to distinguish", style: Normal, search_matches: [], inline_styles: [(20, 29, Code)], syntax_colors: [] }, RenderedLine { text: "between different types of tokens. Using string also has the advantage of", style: Normal, search_matches: [], inline_styles: [(41, 47, Code)], syntax_colors: [] }, RenderedLine { text: "being easy to debug without a lot of boilerplate and helper functions: we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "can just print a string. Of course, using a string might not lead to the", style: Normal, search_matches: [], inline_styles: [(17, 23, Code), (44, 50, Code)], syntax_colors: [] }, RenderedLine { text: "same performance as using an int or a byte would, but for this book a string", style: Normal, search_matches: [], inline_styles: [(29, 32, Code), (38, 42, Code), (70, 76, Code)], syntax_colors: [] }, RenderedLine { text: "is perfect.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As we just saw, there is a limited number of different token types in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the Monkey language. That means we can define the possible TokenTypes as", style: Normal, search_matches: [], inline_styles: [(59, 68, Code)], syntax_colors: [] }, RenderedLine { text: "constants. In the same file we add this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// token/token.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "    ILLEGAL = \"ILLEGAL\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    EOF     = \"EOF\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // Identifiers + literals", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    IDENT = \"IDENT\" // add, foobar, x, y, ...", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    INT   = \"INT\"   // 1343456", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // Operators", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    ASSIGN   = \"=\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    PLUS     = \"+\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // Delimiters", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    COMMA     = \",\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    SEMICOLON = \";\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    LPAREN = \"(\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    RPAREN = \")\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    LBRACE = \"{\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    RBRACE = \"}\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // Keywords", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    FUNCTION = \"FUNCTION\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    LET      = \"LET\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As you can see there are two special types: ILLEGAL and EOF. We didn’t see", style: Normal, search_matches: [], inline_styles: [(44, 51, Code), (56, 59, Code)], syntax_colors: [] }, RenderedLine { text: "them in the example above, but we’ll need them. ILLEGAL signifies a token/", style: Normal, search_matches: [], inline_styles: [(51, 58, Code)], syntax_colors: [] }, RenderedLine { text: "character we don’t know about and EOF stands for “end of file”, which tells", style: Normal, search_matches: [], inline_styles: [(37, 40, Code)], syntax_colors: [] }, RenderedLine { text: "our parser later on that it can stop.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So far so good! We are ready to start writing our lexer.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "1.3 - The Lexer", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Before we start to write code, let’s be clear about the goal of this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "section. We’re going to write our own lexer. It will take source code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "as input and output the tokens that represent the source code. It will", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "go through its input and output the next token it recognizes. It doesn’t", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "need to buffer or save tokens, since there will only be one method called", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "NextToken(), which will output the next token.", style: Normal, search_matches: [], inline_styles: [(2, 13, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That means, we’ll initialize the lexer with our source code and then", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "repeatedly call NextToken() on it to go through the source code, token by", style: Normal, search_matches: [], inline_styles: [(17, 28, Code)], syntax_colors: [] }, RenderedLine { text: "token, character by character. We’ll also make life simpler here by using", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "string as the type for our source code. Again: in a production environment", style: Normal, search_matches: [], inline_styles: [(3, 9, Code)], syntax_colors: [] }, RenderedLine { text: "it makes sense to attach filenames and line numbers to tokens, to better", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "track down lexing and parsing errors. So it would be better to initialize", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the lexer with an io.Reader and the filename. But since that would add more", style: Normal, search_matches: [], inline_styles: [(22, 31, Code)], syntax_colors: [] }, RenderedLine { text: "complexity we’re not here to handle, we’ll start small and just use a string", style: Normal, search_matches: [], inline_styles: [(78, 80, Code)], syntax_colors: [] }, RenderedLine { text: "and ignore filenames and line numbers.", style: Normal, search_matches: [], inline_styles: [(0, 3, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Having thought this through, we now realize that what our lexer needs to do", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is pretty clear. So let’s create a new package and add a first test that we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "can continuously run to get feedback about the working state of the lexer.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re starting small here and will extend the test case as we add more", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "capabilities to the lexer:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"testing\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    \"monkey/token\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestNextToken(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `=+(){},;`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedType    token.TokenType", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedLiteral string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.ASSIGN, \"=\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.PLUS, \"+\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LPAREN, \"(\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.RPAREN, \")\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LBRACE, \"{\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.RBRACE, \"}\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.COMMA, \",\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.SEMICOLON, \";\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.EOF, \"\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for i, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok := l.NextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if tok.Type != tt.expectedType {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"tests[%d] - tokentype wrong. expected=%q, got=%q\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "                i, tt.expectedType, tok.Type)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if tok.Literal != tt.expectedLiteral {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"tests[%d] - literal wrong. expected=%q, got=%q\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "                i, tt.expectedLiteral, tok.Literal)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of course, the tests fail – we haven’t written any code yet:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "# monkey/lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "lexer/lexer_test.go:27: undefined: New", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/lexer [build failed]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So let’s start by defining the New() function that returns *Lexer.", style: Normal, search_matches: [], inline_styles: [(33, 38, Code), (61, 67, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "package lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Lexer struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    input        string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    position     int  // current position in input (points to current char)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "    readPosition int  // current reading position in input (after current char)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "    ch           byte // current char under examination", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(input string) *Lexer {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    l := &Lexer{input: input}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    return l", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Most of the fields in Lexer are pretty self-explanatory. The ones that", style: Normal, search_matches: [], inline_styles: [(22, 27, Code)], syntax_colors: [] }, RenderedLine { text: "might cause some confusion right now are position and readPosition. Both", style: Normal, search_matches: [], inline_styles: [(41, 49, Code), (54, 66, Code)], syntax_colors: [] }, RenderedLine { text: "will be used to access characters in input by using them as an index, e.g.:", style: Normal, search_matches: [], inline_styles: [(37, 42, Code)], syntax_colors: [] }, RenderedLine { text: "l.input[l.readPosition]. The reason for these two “pointers” pointing into", style: Normal, search_matches: [], inline_styles: [(0, 23, Code)], syntax_colors: [] }, RenderedLine { text: "our input string is the fact that we will need to be able to “peek” further", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "into the input and look after the current character to see what comes up", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "next. readPosition always points to the “next” character in the input.", style: Normal, search_matches: [], inline_styles: [(8, 20, Code)], syntax_colors: [] }, RenderedLine { text: "position points to the character in the input that corresponds to the ch", style: Normal, search_matches: [], inline_styles: [(3, 11, Code)], syntax_colors: [] }, RenderedLine { text: "byte.", style: Normal, search_matches: [], inline_styles: [(1, 3, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A first helper method called readChar() should make the usage of these", style: Normal, search_matches: [], inline_styles: [(29, 39, Code)], syntax_colors: [] }, RenderedLine { text: "fields easier to understand:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) readChar() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    if l.readPosition >= len(l.input) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        l.ch = 0", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        l.ch = l.input[l.readPosition]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    l.position = l.readPosition", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    l.readPosition += 1", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The purpose of readChar is to give us the next character and advance our", style: Normal, search_matches: [], inline_styles: [(15, 23, Code)], syntax_colors: [] }, RenderedLine { text: "position in the input string. The first thing it does is to check whether", style: Normal, search_matches: [], inline_styles: [(16, 21, Code)], syntax_colors: [] }, RenderedLine { text: "we have reached the end of input. If that’s the case it sets l.ch to 0,", style: Normal, search_matches: [], inline_styles: [(27, 32, Code), (63, 67, Code), (71, 72, Code)], syntax_colors: [] }, RenderedLine { text: "which is the ASCII code for the \"NUL\" character and signifies either “we", style: Normal, search_matches: [], inline_styles: [(33, 38, Code)], syntax_colors: [] }, RenderedLine { text: "haven’t read anything yet” or “end of file” for us. But if we haven’t", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "reached the end of input yet it sets l.ch to the next character by accessing", style: Normal, search_matches: [], inline_styles: [(21, 26, Code), (39, 43, Code)], syntax_colors: [] }, RenderedLine { text: "l.input[l.readPosition].", style: Normal, search_matches: [], inline_styles: [(3, 24, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "After that l.position is updated to the just used l.readPosition and", style: Normal, search_matches: [], inline_styles: [(11, 21, Code), (50, 64, Code)], syntax_colors: [] }, RenderedLine { text: "l.readPosition is incremented by one. That way, l.readPosition always points", style: Normal, search_matches: [], inline_styles: [(0, 14, Code), (48, 62, Code)], syntax_colors: [] }, RenderedLine { text: "to the next position where we’re going to read from next and l.position", style: Normal, search_matches: [], inline_styles: [(63, 73, Code)], syntax_colors: [] }, RenderedLine { text: "always points to the position where we last read. This will come in handy", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "soon enough.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "While talking about readChar it’s worth pointing out that the lexer", style: Normal, search_matches: [], inline_styles: [(20, 28, Code)], syntax_colors: [] }, RenderedLine { text: "only supports ASCII characters instead of the full Unicode range. Why?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Because this lets us keep things simple and concentrate on the essential", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parts of our interpreter. In order to fully support Unicode and UTF-8 we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "would need to change l.ch from a byte to rune and change the way we read", style: Normal, search_matches: [], inline_styles: [(23, 27, Code), (35, 39, Code), (43, 47, Code)], syntax_colors: [] }, RenderedLine { text: "the next characters, since they could be multiple bytes wide now. Using", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "l.input[l.readPosition] wouldn’t work anymore. And then we’d also need to", style: Normal, search_matches: [], inline_styles: [(2, 25, Code)], syntax_colors: [] }, RenderedLine { text: "change a few other methods and functions we’ll see later on. So it’s left as", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an exercise to the reader to fully support Unicode (and emojis!) in Monkey.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s use readChar in our New() function so our *Lexer is in a fully", style: Normal, search_matches: [], inline_styles: [(12, 20, Code), (28, 33, Code), (50, 56, Code)], syntax_colors: [] }, RenderedLine { text: "working state before anyone calls NextToken(), with l.ch, l.position and", style: Normal, search_matches: [], inline_styles: [(35, 46, Code), (53, 57, Code), (59, 69, Code)], syntax_colors: [] }, RenderedLine { text: "l.readPosition already initialized:", style: Normal, search_matches: [], inline_styles: [(2, 16, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(input string) *Lexer {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    l := &Lexer{input: input}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    l.readChar()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    return l", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Our tests now tell us that calling New(input) doesn’t result in problems", style: Normal, search_matches: [], inline_styles: [(35, 45, Code)], syntax_colors: [] }, RenderedLine { text: "anymore, but the NextToken() method is still missing. Let’s fix that by", style: Normal, search_matches: [], inline_styles: [(18, 29, Code)], syntax_colors: [] }, RenderedLine { text: "adding a first version:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import \"monkey/token\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) NextToken() token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    var tok token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    switch l.ch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '=':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.ASSIGN, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    case ';':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.SEMICOLON, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '(':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.LPAREN, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    case ')':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.RPAREN, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    case ',':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.COMMA, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '+':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.PLUS, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '{':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.LBRACE, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '}':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.RBRACE, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    case 0:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok.Literal = \"\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok.Type = token.EOF", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l.readChar()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    return tok", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func newToken(tokenType token.TokenType, ch byte) token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "    return token.Token{Type: tokenType, Literal: string(ch)}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s the basic structure of the NextToken() method. We look at the current", style: Normal, search_matches: [], inline_styles: [(36, 47, Code)], syntax_colors: [] }, RenderedLine { text: "character under examination (l.ch) and return a token depending on which", style: Normal, search_matches: [], inline_styles: [(30, 34, Code)], syntax_colors: [] }, RenderedLine { text: "character it is. Before returning the token we advance our pointers into the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "input so when we call NextToken() again the l.ch field is already updated. A", style: Normal, search_matches: [], inline_styles: [(24, 35, Code), (46, 50, Code)], syntax_colors: [] }, RenderedLine { text: "small function called newToken helps us with initializing these tokens.", style: Normal, search_matches: [], inline_styles: [(24, 32, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Running the tests we can see that they pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: None }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/lexer 0.007s", style: CodeBlock { language: None }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Great! Let’s now extend the test case so it starts to resemble Monkey source", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "code.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestNextToken(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `let five = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "let ten = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(x, y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  x + y;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let result = add(five, ten);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedType    token.TokenType", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedLiteral string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LET, \"let\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"five\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.ASSIGN, \"=\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.INT, \"5\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.SEMICOLON, \";\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LET, \"let\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"ten\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.ASSIGN, \"=\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.INT, \"10\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.SEMICOLON, \";\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LET, \"let\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"add\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.ASSIGN, \"=\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.FUNCTION, \"fn\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LPAREN, \"(\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"x\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.COMMA, \",\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"y\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.RPAREN, \")\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LBRACE, \"{\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"x\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.PLUS, \"+\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"y\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.SEMICOLON, \";\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.RBRACE, \"}\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.SEMICOLON, \";\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LET, \"let\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"result\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.ASSIGN, \"=\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"add\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LPAREN, \"(\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"five\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.COMMA, \",\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.IDENT, \"ten\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.RPAREN, \")\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.SEMICOLON, \";\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.EOF, \"\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Most notably the input in this test case has changed. It looks like a subset", style: Normal, search_matches: [], inline_styles: [(17, 22, Code)], syntax_colors: [] }, RenderedLine { text: "of the Monkey language. It contains all the symbols we already successfully", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "turned into tokens, but also new things that are now causing our tests to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fail: identifiers, keywords and numbers.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s start with the identifiers and keywords. What our lexer needs to do", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is recognize whether the current character is a letter and if so, it needs", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to read the rest of the identifier/keyword until it encounters a non-letter-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "character. Having read that identifier/keyword, we then need to find out if", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it is a identifier or a keyword, so we can use the correct token.TokenType.", style: Normal, search_matches: [], inline_styles: [(61, 75, Code)], syntax_colors: [] }, RenderedLine { text: "The first step is extending our switch statement:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import \"monkey/token\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) NextToken() token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    var tok token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    switch l.ch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isLetter(l.ch) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok.Literal = l.readIdentifier()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "            return tok", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok = newToken(token.ILLEGAL, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) readIdentifier() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    position := l.position", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    for isLetter(l.ch) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        l.readChar()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    return l.input[position:l.position]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func isLetter(ch byte) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_'", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We added a default branch to our switch statement, so we can check for", style: Normal, search_matches: [], inline_styles: [(11, 18, Code)], syntax_colors: [] }, RenderedLine { text: "identifiers whenever the l.ch is not one of the recognized characters.", style: Normal, search_matches: [], inline_styles: [(25, 29, Code)], syntax_colors: [] }, RenderedLine { text: "We also added the generation of token.ILLEGAL tokens. If we end up there,", style: Normal, search_matches: [], inline_styles: [(32, 45, Code)], syntax_colors: [] }, RenderedLine { text: "we truly don’t know how to handle the current character and declare it as", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "token.ILLEGAL.", style: Normal, search_matches: [], inline_styles: [(1, 14, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The isLetter helper function just checks whether the given argument is", style: Normal, search_matches: [], inline_styles: [(4, 12, Code)], syntax_colors: [] }, RenderedLine { text: "a letter. That sounds easy enough, but what’s noteworthy about isLetter", style: Normal, search_matches: [], inline_styles: [(65, 73, Code)], syntax_colors: [] }, RenderedLine { text: "is that changing this function has a larger impact on the language our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter will be able to parse than one would expect from such a small", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function. As you can see, in our case it contains the check ch == '_',", style: Normal, search_matches: [], inline_styles: [(62, 70, Code)], syntax_colors: [] }, RenderedLine { text: "which means that we’ll treat _ as a letter and allow it in identifiers", style: Normal, search_matches: [], inline_styles: [(33, 34, Code)], syntax_colors: [] }, RenderedLine { text: "and keywords. That means we can use variable names like foo_bar. Other", style: Normal, search_matches: [], inline_styles: [(59, 66, Code)], syntax_colors: [] }, RenderedLine { text: "programming languages even allow ! and ? in identifiers. If you want to", style: Normal, search_matches: [], inline_styles: [(37, 38, Code), (43, 44, Code)], syntax_colors: [] }, RenderedLine { text: "allow that too, this is the place to sneak it in.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "readIdentifier() does exactly what its name suggests: it reads in an", style: Normal, search_matches: [], inline_styles: [(0, 16, Code)], syntax_colors: [] }, RenderedLine { text: "identifier and advances our lexer’s positions until it encounters a non-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "letter-character.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In the default: branch of the switch statement we use readIdentifier() to", style: Normal, search_matches: [], inline_styles: [(7, 15, Code), (54, 70, Code)], syntax_colors: [] }, RenderedLine { text: "set the Literal field of our current token. But what about its Type? Now", style: Normal, search_matches: [], inline_styles: [(8, 15, Code), (63, 67, Code)], syntax_colors: [] }, RenderedLine { text: "that we have read identifiers like let, fn or foobar, we need to be able", style: Normal, search_matches: [], inline_styles: [(35, 38, Code), (40, 42, Code), (46, 52, Code)], syntax_colors: [] }, RenderedLine { text: "to tell user-defined identifiers apart from language keywords. We need a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function that returns the correct TokenType for the token literal we have.", style: Normal, search_matches: [], inline_styles: [(34, 43, Code)], syntax_colors: [] }, RenderedLine { text: "What better place than the token package to add such a function?", style: Normal, search_matches: [], inline_styles: [(27, 32, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// token/token.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var keywords = map[string]TokenType{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"fn\":  FUNCTION,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"let\": LET,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func LookupIdent(ident string) TokenType {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    if tok, ok := keywords[ident]; ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        return tok", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    return IDENT", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "LookupIdent checks the keywords table to see whether the given identifier is", style: Normal, search_matches: [], inline_styles: [(0, 11, Code), (23, 31, Code)], syntax_colors: [] }, RenderedLine { text: "in fact a keyword. If it is, it returns the keyword’s TokenType constant. If", style: Normal, search_matches: [], inline_styles: [(56, 65, Code)], syntax_colors: [] }, RenderedLine { text: "it isn’t, we just get back token.IDENT, which is the TokenType for all user-", style: Normal, search_matches: [], inline_styles: [(30, 41, Code), (56, 65, Code)], syntax_colors: [] }, RenderedLine { text: "defined identifiers.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With this in hand we can now complete the lexing of identifiers and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "keywords:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) NextToken() token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    var tok token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    switch l.ch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isLetter(l.ch) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok.Literal = l.readIdentifier()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok.Type = token.LookupIdent(tok.Literal)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "            return tok", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok = newToken(token.ILLEGAL, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The early exit here, our return tok statement, is necessary because when", style: Normal, search_matches: [], inline_styles: [(25, 35, Code)], syntax_colors: [] }, RenderedLine { text: "calling readIdentifier(), we call readChar() repeatedly and advance our", style: Normal, search_matches: [], inline_styles: [(8, 24, Code), (34, 44, Code)], syntax_colors: [] }, RenderedLine { text: "readPosition and position fields past the last character of the current", style: Normal, search_matches: [], inline_styles: [(0, 12, Code), (17, 25, Code)], syntax_colors: [] }, RenderedLine { text: "identifier. So we don’t need the call to readChar() after the switch", style: Normal, search_matches: [], inline_styles: [(43, 53, Code)], syntax_colors: [] }, RenderedLine { text: "statement again.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Running our tests now, we can see that let is identified correctly but the", style: Normal, search_matches: [], inline_styles: [(39, 42, Code)], syntax_colors: [] }, RenderedLine { text: "tests still fail:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestNextToken (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "  lexer_test.go:70: tests[1] - tokentype wrong. expected=\"IDENT\", got=\"ILLEGAL\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/lexer 0.008s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The problem is the next token we want: a IDENT token with \"five\" in its", style: Normal, search_matches: [], inline_styles: [(41, 46, Code), (58, 64, Code)], syntax_colors: [] }, RenderedLine { text: "Literal field. Instead we get an ILLEGAL token. Why is that? Because of the", style: Normal, search_matches: [], inline_styles: [(0, 7, Code), (33, 40, Code)], syntax_colors: [] }, RenderedLine { text: "whitespace character between “let” and “five”. But in Monkey whitespace only", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "acts as a separator of tokens and doesn’t have meaning, so we need to skip", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "over it entirely:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) NextToken() token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    var tok token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l.skipWhitespace()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    switch l.ch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) skipWhitespace() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    for l.ch == ' ' || l.ch == '\\t' || l.ch == '\\n' || l.ch == '\\r' {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "        l.readChar()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This little helper function is found in a lot of parsers. Sometimes it’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "called eatWhitespace and sometimes consumeWhitespace and sometimes something", style: Normal, search_matches: [], inline_styles: [(8, 21, Code), (36, 53, Code)], syntax_colors: [] }, RenderedLine { text: "entirely different. Which characters these functions actually skip depends", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "on the language being lexed. Some language implementations do create tokens", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "for newline characters for example and throw parsing errors if they are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "not at the correct place in the stream of tokens. We skip over newline", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "characters to make the parsing step later on a little easier.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With skipWhitespace() in place, the lexer trips over the 5 in the let five =", style: Normal, search_matches: [], inline_styles: [(5, 21, Code), (57, 58, Code), (66, 76, Code)], syntax_colors: [] }, RenderedLine { text: "5; part of our test input. And that’s right, it doesn’t know yet how to turn", style: Normal, search_matches: [], inline_styles: [(0, 2, Code)], syntax_colors: [] }, RenderedLine { text: "numbers into tokens. It’s time to add this.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As we did previously for identifiers, we now need to add more functionality", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to the default branch of our switch statement.", style: Normal, search_matches: [], inline_styles: [(7, 14, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) NextToken() token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    var tok token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l.skipWhitespace()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    switch l.ch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isLetter(l.ch) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok.Literal = l.readIdentifier()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok.Type = token.LookupIdent(tok.Literal)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "            return tok", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        } else if isDigit(l.ch) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok.Type = token.INT", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok.Literal = l.readNumber()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "            return tok", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok = newToken(token.ILLEGAL, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) readNumber() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    position := l.position", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    for isDigit(l.ch) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        l.readChar()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    return l.input[position:l.position]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func isDigit(ch byte) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    return '0' <= ch && ch <= '9'", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As you can see, the added code closely mirrors the part concerned with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "reading identifiers and keywords. The readNumber method is exactly the", style: Normal, search_matches: [], inline_styles: [(38, 48, Code)], syntax_colors: [] }, RenderedLine { text: "same as readIdentifier except for its usage of isDigit instead of isLetter.", style: Normal, search_matches: [], inline_styles: [(8, 22, Code), (47, 54, Code), (66, 74, Code)], syntax_colors: [] }, RenderedLine { text: "We could probably generalize this by passing in the character-identifying", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "functions as arguments, but won’t, for simplicity’s sake and ease of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "understanding.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The isDigit function is as simple as isLetter. It just returns whether the", style: Normal, search_matches: [], inline_styles: [(4, 11, Code), (37, 45, Code)], syntax_colors: [] }, RenderedLine { text: "passed in byte is a Latin digit between 0 and 9.", style: Normal, search_matches: [], inline_styles: [(40, 41, Code), (46, 47, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With this added, our tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/lexer 0.008s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I don’t know if you noticed, but we simplified things a lot in readNumber.", style: Normal, search_matches: [], inline_styles: [(65, 75, Code)], syntax_colors: [] }, RenderedLine { text: "We only read in integers. What about floats? Or numbers in hex notation?", style: Normal, search_matches: [], inline_styles: [(17, 25, Italic)], syntax_colors: [] }, RenderedLine { text: "Octal notation? We ignore them and just say that Monkey doesn’t support", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this. Of course, the reason for this is again the educational aim and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "limited scope of this book.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s time to pop the champagne and celebrate: we successfully turned the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "small subset of the Monkey language we used in the our test case into", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tokens!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With this victory under our belt, it’s easy to extend the lexer so it can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tokenize a lot more of Monkey source code.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "1.4 - Extending our Token Set and Lexer", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order to eliminate the need to jump between packages when later writing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "our parser, we need to extend our lexer so it can recognize more of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Monkey language and output more tokens. So in this section we will add", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "support for ==, !, !=, -, /, *, <, > and the keywords true, false, if, else", style: Normal, search_matches: [], inline_styles: [(12, 14, Code), (16, 17, Code), (19, 21, Code), (23, 24, Code), (26, 27, Code), (29, 30, Code), (32, 33, Code), (35, 36, Code), (54, 58, Code), (60, 65, Code), (67, 69, Code), (71, 75, Code)], syntax_colors: [] }, RenderedLine { text: "and return.", style: Normal, search_matches: [], inline_styles: [(4, 10, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The new tokens we will need to add, build and output can be classified", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "as one of these three: one-character token (e.g.\u{a0}-), two-character token", style: Normal, search_matches: [], inline_styles: [(50, 51, Code)], syntax_colors: [] }, RenderedLine { text: "(e.g.\u{a0}==) and keyword token (e.g.\u{a0}return). We already know how to handle", style: Normal, search_matches: [], inline_styles: [(8, 10, Code), (37, 43, Code)], syntax_colors: [] }, RenderedLine { text: "one-character and keyword tokens, so we add support for these first, before", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "extending the lexer for two-character tokens.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Adding support for -, /, *, < and > is trivial. The first thing we need to", style: Normal, search_matches: [], inline_styles: [(19, 20, Code), (22, 23, Code), (25, 26, Code), (28, 29, Code), (34, 35, Code)], syntax_colors: [] }, RenderedLine { text: "do, of course, is modify the input of our test case in lexer/lexer_test.go", style: Normal, search_matches: [], inline_styles: [(55, 74, Code)], syntax_colors: [] }, RenderedLine { text: "to include these characters. Just like we did before. In the code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "accompanying this chapter you can also find the extended tests table, which", style: Normal, search_matches: [], inline_styles: [(57, 62, Code)], syntax_colors: [] }, RenderedLine { text: "I won’t show in the remainder of this chapter, in order to save space and to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "keep you from getting bored.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestNextToken(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `let five = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "let ten = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(x, y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  x + y;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let result = add(five, ten);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "!-/*5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 < 10 > 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Note that although the input looks like an actual piece of Monkey source", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "code, some lines don’t really make sense, with gibberish like !-/*5. That’s", style: Normal, search_matches: [], inline_styles: [(64, 69, Code)], syntax_colors: [] }, RenderedLine { text: "okay. The lexer’s job is not to tell us whether code makes sense, works or", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "contains errors. That comes in a later stage. The lexer should only turn", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this input into tokens. For that reason the test cases I write for lexers", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "cover all tokens and also try to provoke off-by-one errors, edge cases at", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "end-of-file, newline handling, multi-digit number parsing and so on. That’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "why the “code” looks like gibberish.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Running the test we get undefined: errors, because the tests contain", style: Normal, search_matches: [], inline_styles: [(24, 34, Code)], syntax_colors: [] }, RenderedLine { text: "references to undefined TokenTypes. To fix them we add the following", style: Normal, search_matches: [], inline_styles: [(24, 33, Code)], syntax_colors: [] }, RenderedLine { text: "constants to token/token.go:", style: Normal, search_matches: [], inline_styles: [(13, 27, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// token/token.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // Operators", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    ASSIGN   = \"=\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    PLUS     = \"+\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    MINUS    = \"-\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    BANG     = \"!\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    ASTERISK = \"*\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    SLASH    = \"/\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    LT = \"<\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "    GT = \">\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With the new constants added, the tests still fail, because we don’t return", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the tokens with the expected TokenTypes.", style: Normal, search_matches: [], inline_styles: [(30, 39, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestNextToken (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "  lexer_test.go:84: tests[36] - tokentype wrong. expected=\"!\", got=\"ILLEGAL\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/lexer 0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Turning these tests from failing to passing requires us to extend our switch", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statement in the NextToken() method of Lexer:", style: Normal, search_matches: [], inline_styles: [(17, 28, Code), (39, 44, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) NextToken() token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch l.ch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '=':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.ASSIGN, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '+':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.PLUS, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '-':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.MINUS, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '!':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.BANG, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '/':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.SLASH, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '*':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.ASTERISK, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '<':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.LT, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '>':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.GT, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    case ';':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.SEMICOLON, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    case ',':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.COMMA, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The tokens are now added and the cases of the switch statement have been", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "reordered to reflect the structure of the constants in token/token.go. This", style: Normal, search_matches: [], inline_styles: [(55, 69, Code)], syntax_colors: [] }, RenderedLine { text: "small change makes our tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/lexer 0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The new one-character tokens have been successfully added. Next step: add", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the new keywords true, false, if, else and return.", style: Normal, search_matches: [], inline_styles: [(17, 21, Code), (23, 28, Code), (30, 32, Code), (34, 38, Code), (43, 49, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Again, the first step is to extend the input in our test to include these", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "new keywords. Here is what the input in TestNextToken looks like now:", style: Normal, search_matches: [], inline_styles: [(31, 36, Code), (40, 53, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestNextToken(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `let five = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "let ten = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(x, y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  x + y;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let result = add(five, ten);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "!-/*5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 < 10 > 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (5 < 10) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "    return true;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "} else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    return false;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The tests do not even compile since the references in the test expectations", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to the new keywords are undefined. Fixing that, again, means just adding", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "new constants and in this case, adding the keywords to the lookup table", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "for LookupIdent().", style: Normal, search_matches: [], inline_styles: [(4, 17, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// token/token.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // Keywords", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    FUNCTION = \"FUNCTION\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    LET      = \"LET\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    TRUE     = \"TRUE\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    FALSE    = \"FALSE\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    IF       = \"IF\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    ELSE     = \"ELSE\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    RETURN   = \"RETURN\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var keywords = map[string]TokenType{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"fn\":     FUNCTION,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"let\":    LET,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"true\":   TRUE,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"false\":  FALSE,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"if\":     IF,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"else\":   ELSE,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"return\": RETURN,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And it turns out that we not only fixed the compilation error by fixing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "references to undefined variables, we even made the tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/lexer 0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The lexer now recognizes the new keywords and the necessary changes were", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "trivial, easy to predict and easy to make. I’d say a pat on the back is in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "order. We did a great job!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But before we can move onto the next chapter and start with our parser, we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "still need to extend the lexer so it recognizes tokens that are composed of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "two characters. The tokens we want to support look like this in the source", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "code: == and !=.", style: Normal, search_matches: [], inline_styles: [(6, 8, Code), (13, 15, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "At first glance you may be thinking: “why not add a new case to our switch", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statement and be done with it?” Since our switch statement takes the current", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "character l.ch as the expression to compare against the cases, we can’t just", style: Normal, search_matches: [], inline_styles: [(12, 16, Code)], syntax_colors: [] }, RenderedLine { text: "add new cases like case \"==\" - the compiler won’t let us. We can’t compare", style: Normal, search_matches: [], inline_styles: [(21, 30, Code)], syntax_colors: [] }, RenderedLine { text: "our l.ch byte with strings like \"==\".", style: Normal, search_matches: [], inline_styles: [(7, 11, Code), (35, 37, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What we can do instead is to reuse the existing branches for '=' and '!'", style: Normal, search_matches: [], inline_styles: [(61, 64, Code), (69, 72, Code)], syntax_colors: [] }, RenderedLine { text: "and extend them. So what we’re going to do is to look ahead in the input and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "then determine whether to return a token for = or ==. After extending input", style: Normal, search_matches: [], inline_styles: [(46, 47, Code), (51, 53, Code), (71, 75, Code)], syntax_colors: [] }, RenderedLine { text: "in lexer/lexer_test.go again, it now looks like this:", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (5, 24, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestNextToken(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `let five = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "let ten = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(x, y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  x + y;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let result = add(five, ten);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "!-/*5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 < 10 > 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (5 < 10) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "    return true;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "} else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    return false;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "10 == 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "10 != 9;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Before we start working on the switch statement in NextToken(), we need to", style: Normal, search_matches: [], inline_styles: [(51, 62, Code)], syntax_colors: [] }, RenderedLine { text: "add a new helper method defined on *Lexer called peekChar():", style: Normal, search_matches: [], inline_styles: [(35, 41, Code), (49, 59, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) peekChar() byte {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "    if l.readPosition >= len(l.input) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        return 0", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return l.input[l.readPosition]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "peekChar() is really similar to readChar(), except that it doesn’t increment", style: Normal, search_matches: [], inline_styles: [(0, 10, Code), (32, 42, Code)], syntax_colors: [] }, RenderedLine { text: "l.position and l.readPosition. We only want to “peek” ahead in the input and", style: Normal, search_matches: [], inline_styles: [(1, 11, Code), (16, 30, Code)], syntax_colors: [] }, RenderedLine { text: "not move around in it, so we know what a call to readChar() would return.", style: Normal, search_matches: [], inline_styles: [(51, 61, Code)], syntax_colors: [] }, RenderedLine { text: "Most lexers and parser have such a “peek” function that looks ahead and most", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of the time it only returns the immediately next character. The difficulty", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of parsing different languages often comes down to how far you have to peek", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "ahead (or look backwards!) in the source code to make sense of it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With peekChar() added, the code with the updated test input doesn’t compile.", style: Normal, search_matches: [], inline_styles: [(5, 15, Code)], syntax_colors: [] }, RenderedLine { text: "Of course, since we’re referencing undefined token constants in the tests.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fixing that, again, is easy:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// token/token.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    EQ     = \"==\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    NOT_EQ = \"!=\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With the references to token.EQ and token.NOT_EQ in the tests for the lexer", style: Normal, search_matches: [], inline_styles: [(23, 31, Code), (36, 48, Code)], syntax_colors: [] }, RenderedLine { text: "fixed, running go test now returns the correct failure message:", style: Normal, search_matches: [], inline_styles: [(15, 22, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestNextToken (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "  lexer_test.go:118: tests[66] - tokentype wrong. expected=\"==\", got=\"=\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/lexer 0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When the lexer comes upon a == in the input it creates two token.ASSIGN", style: Normal, search_matches: [], inline_styles: [(28, 30, Code), (59, 71, Code)], syntax_colors: [] }, RenderedLine { text: "tokens instead of one token.EQ token. The solution is to use our new", style: Normal, search_matches: [], inline_styles: [(22, 30, Code)], syntax_colors: [] }, RenderedLine { text: "peekChar() method. In the branches of the switch statement for '=' and '!'", style: Normal, search_matches: [], inline_styles: [(0, 10, Code), (63, 66, Code), (71, 74, Code)], syntax_colors: [] }, RenderedLine { text: "we “peek” ahead. If the next token is also a = we create either a token.EQ", style: Normal, search_matches: [], inline_styles: [(49, 50, Code), (70, 78, Code)], syntax_colors: [] }, RenderedLine { text: "or a token.NOT_EQ token:", style: Normal, search_matches: [], inline_styles: [(6, 18, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) NextToken() token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch l.ch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '=':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        if l.peekChar() == '=' {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "            ch := l.ch", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "            l.readChar()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            literal := string(ch) + string(l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok = token.Token{Type: token.EQ, Literal: literal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "        } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok = newToken(token.ASSIGN, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '!':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        if l.peekChar() == '=' {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "            ch := l.ch", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "            l.readChar()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            literal := string(ch) + string(l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok = token.Token{Type: token.NOT_EQ, Literal: literal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "        } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            tok = newToken(token.BANG, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Note that we save l.ch in a local variable before calling l.readChar()", style: Normal, search_matches: [], inline_styles: [(18, 22, Code), (58, 70, Code)], syntax_colors: [] }, RenderedLine { text: "again. This way we don’t lose the current character and can safely advance", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the lexer so it leaves the NextToken() with l.position and l.readPosition", style: Normal, search_matches: [], inline_styles: [(28, 39, Code), (45, 55, Code), (60, 73, Code)], syntax_colors: [] }, RenderedLine { text: "in the correct state. If we were to start supporting more two-character", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "tokens in Monkey, we should probably abstract the behaviour away in a method", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "called makeTwoCharToken that peeks and advances if it found the right token.", style: Normal, search_matches: [], inline_styles: [(9, 25, Code)], syntax_colors: [] }, RenderedLine { text: "Because those two branches look awfully similar. For now though == and !=", style: Normal, search_matches: [], inline_styles: [(66, 68, Code)], syntax_colors: [] }, RenderedLine { text: "are the only two-character tokens in Monkey, so let’s leave it as it is and", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "run our tests again to make sure it works:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/lexer 0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "They pass! We did it! The lexer can now produce the extended set of tokens", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and we’re ready to write our parser. But before we do that, let’s lay", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "another ground stone we can build upon in the coming chapters…", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "1.5 - Start of a REPL", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The Monkey language needs a REPL. REPL stands for “Read Eval Print Loop” and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "you probably know what it is from other interpreted languages: Python has", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a REPL, Ruby has one, every JavaScript runtime has one, most Lisps have one", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and a lot of other languages too. Sometimes the REPL is called “console”,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "sometimes “interactive mode”. The concept is the same: the REPL reads input,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "sends it to the interpreter for evaluation, prints the result/output of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter and starts again. Read, Eval, Print, Loop.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We don’t know how to fully “Eval” Monkey source code yet. We only have one", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "part of the process that hides behind “Eval”: we can tokenize Monkey source", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "code. But we also know how to read and print something, and I don’t think", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "looping poses a problem.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is a REPL that tokenizes Monkey source code and prints the tokens.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Later on, we will expand on this and add parsing and evaluation to it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// repl/repl.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package repl", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"bufio\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"fmt\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"io\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/lexer\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/token\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const PROMPT = \">> \"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Start(in io.Reader, out io.Writer) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    scanner := bufio.NewScanner(in)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        fmt.Fprintf(out, PROMPT)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        scanned := scanner.Scan()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !scanned {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "            return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        line := scanner.Text()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        l := lexer.New(line)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        for tok := l.NextToken(); tok.Type != token.EOF; tok = l.NextToken() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 78, Rgb(192, 197, 206))] }, RenderedLine { text: "            fmt.Fprintf(out, \"%+v\\n\", tok)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This is all pretty straightforward: read from the input source until", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "encountering a newline, take the just read line and pass it to an instance", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of our lexer and finally print all the tokens the lexer gives us until we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "encounter EOF.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In a main.go file (which we’ve been missing until now!) we welcome the user", style: Normal, search_matches: [], inline_styles: [(5, 12, Code)], syntax_colors: [] }, RenderedLine { text: "of the REPL and start it:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package main", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"fmt\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"os\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"os/user\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/repl\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func main() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "    user, err := user.Current()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    if err != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        panic(err)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    fmt.Printf(\"Hello %s! This is the Monkey programming language!\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "        user.Username)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    fmt.Printf(\"Feel free to type in commands\\n\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    repl.Start(os.Stdin, os.Stdout)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And with that we can now interactively produce tokens:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let add = fn(x, y) { x + y; };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:LET Literal:let}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:IDENT Literal:add}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:= Literal:=}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:FUNCTION Literal:fn}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:( Literal:(}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:IDENT Literal:x}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:, Literal:,}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:IDENT Literal:y}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:) Literal:)}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:{ Literal:{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:IDENT Literal:x}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:+ Literal:+}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:IDENT Literal:y}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:; Literal:;}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:} Literal:}}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "{Type:; Literal:;}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: ">>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Perfect! And now it’s time to start parsing these tokens.", style: Normal, search_matches: [], inline_styles: [(13, 16, Bold)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>ch003.xhtml</title>\n  <style>\npre > code.sourceCode { white-space: pre; position: relative; }\npre > code.sourceCode > span { display: inline-block; line-height: 1.25; }\npre > code.sourceCode > span:empty { height: 1.2em; }\ncode.sourceCode > span { color: inherit; text-decoration: inherit; }\ndiv.sourceCode { margin: 1em 0; }\npre.sourceCode { margin: 0; }\n@media screen {\ndiv.sourceCode { overflow: auto; }\n}\n@media print {\npre > code.sourceCode { white-space: pre-wrap; }\npre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }\n}\npre.numberSource code\n  { counter-reset: source-line 0; }\npre.numberSource code > span\n  { position: relative; left: -4em; counter-increment: source-line; }\npre.numberSource code > span > a:first-child::before\n  { content: counter(source-line);\n    position: relative; left: -1em; text-align: right; vertical-align: baseline;\n    border: none; display: inline-block;\n    -webkit-touch-callout: none; -webkit-user-select: none;\n    -khtml-user-select: none; -moz-user-select: none;\n    -ms-user-select: none; user-select: none;\n    padding: 0 4px; width: 4em;\n    color: #aaaaaa;\n  }\npre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\ndiv.sourceCode\n  {   }\n@media screen {\npre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }\n}\ncode span.al { color: #ff0000; font-weight: bold; } /* Alert */\ncode span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */\ncode span.at { color: #7d9029; } /* Attribute */\ncode span.bn { color: #40a070; } /* BaseN */\ncode span.bu { } /* BuiltIn */\ncode span.cf { color: #007020; font-weight: bold; } /* ControlFlow */\ncode span.ch { color: #4070a0; } /* Char */\ncode span.cn { color: #880000; } /* Constant */\ncode span.co { color: #60a0b0; font-style: italic; } /* Comment */\ncode span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */\ncode span.do { color: #ba2121; font-style: italic; } /* Documentation */\ncode span.dt { color: #902000; } /* DataType */\ncode span.dv { color: #40a070; } /* DecVal */\ncode span.er { color: #ff0000; font-weight: bold; } /* Error */\ncode span.ex { } /* Extension */\ncode span.fl { color: #40a070; } /* Float */\ncode span.fu { color: #06287e; } /* Function */\ncode span.im { } /* Import */\ncode span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */\ncode span.kw { color: #007020; font-weight: bold; } /* Keyword */\ncode span.op { color: #666666; } /* Operator */\ncode span.ot { color: #007020; } /* Other */\ncode span.pp { color: #bc7a00; } /* Preprocessor */\ncode span.sc { color: #4070a0; } /* SpecialChar */\ncode span.ss { color: #bb6688; } /* SpecialString */\ncode span.st { color: #4070a0; } /* String */\ncode span.va { color: #19177c; } /* Variable */\ncode span.vs { color: #4070a0; } /* VerbatimString */\ncode span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */\n/* Apple Books 2.4+ doesn't like overflow:auto on syntax highlighting generated by skylighting */\n@media screen {\n  div.sourceCode { overflow: visible !important; }\n  p, span, pre, code, blockquote { overflow: visible !important; }\n}\n  </style>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"bodymatter\">\n<section id=\"lexing\" class=\"level1\" data-number=\"1\">\n<h1 data-number=\"1\">Lexing</h1>\n<section id=\"lexical-analysis\" class=\"level2\" data-number=\"1.1\">\n<h2 data-number=\"1.1\">1.1 - Lexical Analysis</h2>\n<p>In order for us to work with source code we need to turn it into a more accessible form. As easy as plain text is to work with in our editor, it becomes cumbersome pretty fast when trying to interpret it in a programming language as another programming language.</p>\n<p>So, what we need to do is represent our source code in other forms that <strong>are</strong> easier to work with. We’re going to change the representation of our source code two times before we evaluate it:</p>\n<figure>\n<img src=\"../media/file0.png\" width=\"400\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p>The first transformation, from source code to tokens, is called “lexical analysis”, or “lexing” for short. It’s done by a lexer (also called tokenizer or scanner – some use one word or the other to denote subtle differences in behaviour, which we can ignore in this book).</p>\n<p>Tokens themselves are small, easily categorizable data structures that are then fed to the parser, which does the second transformation and turns the tokens into an “Abstract Syntax Tree”.</p>\n<p>Here’s an example. This is the input one gives to a lexer:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb1-1\"><a href=\"#cb1-1\"></a><span class=\"st\">&quot;let x = 5 + 5;&quot;</span></span></code></pre></div>\n<p>And what comes out of the lexer looks kinda like this:</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb2-1\"><a href=\"#cb2-1\"></a>[</span>\n<span id=\"cb2-2\"><a href=\"#cb2-2\"></a>  LET<span class=\"op\">,</span></span>\n<span id=\"cb2-3\"><a href=\"#cb2-3\"></a>  IDENTIFIER(<span class=\"st\">&quot;x&quot;</span>)<span class=\"op\">,</span></span>\n<span id=\"cb2-4\"><a href=\"#cb2-4\"></a>  EQUAL_SIGN<span class=\"op\">,</span></span>\n<span id=\"cb2-5\"><a href=\"#cb2-5\"></a>  INTEGER(<span class=\"dv\">5</span>)<span class=\"op\">,</span></span>\n<span id=\"cb2-6\"><a href=\"#cb2-6\"></a>  PLUS_SIGN<span class=\"op\">,</span></span>\n<span id=\"cb2-7\"><a href=\"#cb2-7\"></a>  INTEGER(<span class=\"dv\">5</span>)<span class=\"op\">,</span></span>\n<span id=\"cb2-8\"><a href=\"#cb2-8\"></a>  SEMICOLON</span>\n<span id=\"cb2-9\"><a href=\"#cb2-9\"></a>]</span></code></pre></div>\n<p>All of these tokens have the original source code representation attached. <code>\"let\"</code> in the case of <code>LET</code>, <code>\"+\"</code> in the case of <code>PLUS_SIGN</code>, and so on. Some, like <code>IDENTIFIER</code> and <code>INTEGER</code> in our example, also have the concrete values they represent attached: <code>5</code> (not <code>\"5\"</code>!) in the case of <code>INTEGER</code> and <code>\"x\"</code> in the case of <code>IDENTIFIER</code>. But what exactly constitutes a “token” varies between different lexer implementations. As an example, some lexers only convert the <code>\"5\"</code> to an integer in the parsing stage, or even later, and not when constructing tokens.</p>\n<p>A thing to note about this example: whitespace characters don’t show up as tokens. In our case that’s okay, because whitespace length is not significant in the Monkey language. Whitespace merely acts as a separator for other tokens. It doesn’t matter if we type this:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb3-1\"><a href=\"#cb3-1\"></a><span class=\"kw\">let</span> x <span class=\"op\">=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span></code></pre></div>\n<p>Or if we type this:</p>\n<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb4-1\"><a href=\"#cb4-1\"></a><span class=\"kw\">let</span>   x   <span class=\"op\">=</span>   <span class=\"dv\">5</span><span class=\"op\">;</span></span></code></pre></div>\n<p>In other languages, like Python, the length of whitespace <em>is</em> significant. That means the lexer can’t just “eat up” the whitespace and newline characters. It has to output the whitespace characters as tokens so the parser can later on make sense of them (or output an error, of course, if there are not enough or too many).</p>\n<p>A production-ready lexer might also attach the line number, column number and filename to a token. Why? For example, to later output more useful error messages in the parsing stage. Instead of <code>\"error: expected semicolon token\"</code> it can output:</p>\n<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb5-1\"><a href=\"#cb5-1\"></a>&quot;error: expected semicolon token. line 42, column 23, program.monkey&quot;</span></code></pre></div>\n<p>We’re not going to bother with that. Not because it’s too complex, but because it would take away from the essential simpleness of the tokens and the lexer, making it harder to understand.</p>\n</section>\n<section id=\"defining-our-tokens\" class=\"level2\" data-number=\"1.2\">\n<h2 data-number=\"1.2\">1.2 - Defining Our Tokens</h2>\n<p>The first thing we have to do is to define the tokens our lexer is going to output. We’re going to start with just a few token definitions and then add more when extending the lexer.</p>\n<p>The subset of the Monkey language we’re going to lex in our first step looks like this:</p>\n<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb6-1\"><a href=\"#cb6-1\"></a><span class=\"kw\">let</span> five <span class=\"op\">=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb6-2\"><a href=\"#cb6-2\"></a><span class=\"kw\">let</span> ten <span class=\"op\">=</span> <span class=\"dv\">10</span><span class=\"op\">;</span></span>\n<span id=\"cb6-3\"><a href=\"#cb6-3\"></a></span>\n<span id=\"cb6-4\"><a href=\"#cb6-4\"></a><span class=\"kw\">let</span> add <span class=\"op\">=</span> fn(x<span class=\"op\">,</span> y) {</span>\n<span id=\"cb6-5\"><a href=\"#cb6-5\"></a>  x <span class=\"op\">+</span> y<span class=\"op\">;</span></span>\n<span id=\"cb6-6\"><a href=\"#cb6-6\"></a>}<span class=\"op\">;</span></span>\n<span id=\"cb6-7\"><a href=\"#cb6-7\"></a></span>\n<span id=\"cb6-8\"><a href=\"#cb6-8\"></a><span class=\"kw\">let</span> result <span class=\"op\">=</span> add(five<span class=\"op\">,</span> ten)<span class=\"op\">;</span></span></code></pre></div>\n<p>Let’s break this down: which types of tokens does this example contain? First of all, there are the numbers like <code>5</code> and <code>10</code>. These are pretty obvious. Then we have the variable names <code>x</code>, <code>y</code>, <code>add</code> and <code>result</code>. And then there are also these parts of the language that are not numbers, just words, but no variable names either, like <code>let</code> and <code>fn</code>. Of course, there are also a lot of special characters: <code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, <code>=</code>, <code>,</code>, <code>;</code>.</p>\n<p>The numbers are just integers and we’re going to treat them as such and give them a separate type. In the lexer or parser we don’t care if the number is <code>5</code> or <code>10</code>, we just want to know if it’s a number. The same goes for “variable names”: we’ll call them “identifiers” and treat them the same. Now, the other words, the ones that look like identifiers, but aren’t really identifiers, since they’re part of the language, are called “keywords”. We won’t group these together since it <strong>should</strong> make a difference in the parsing stage whether we encounter a <code>let</code> or a <code>fn</code>. The same goes for the last category we identified: the special characters. We’ll treat each of them separately, since it is a big difference whether or not we have a <code>(</code> or a <code>)</code> in the source code.</p>\n<p>Let’s define our <code>Token</code> data structure. Which fields does it need? As we just saw, we definitely need a “type” attribute, so we can distinguish between “integers” and “right bracket” for example. And it also needs a field that holds the literal value of the token, so we can reuse it later and the information whether a “number” token is a <code>5</code> or a <code>10</code> doesn’t get lost.</p>\n<p>In a new <code>token</code> package we define our <code>Token</code> struct and our <code>TokenType</code> type:</p>\n<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb7-1\"><a href=\"#cb7-1\"></a><span class=\"co\">// token/token.go</span></span>\n<span id=\"cb7-2\"><a href=\"#cb7-2\"></a></span>\n<span id=\"cb7-3\"><a href=\"#cb7-3\"></a><span class=\"kw\">package</span> token</span>\n<span id=\"cb7-4\"><a href=\"#cb7-4\"></a></span>\n<span id=\"cb7-5\"><a href=\"#cb7-5\"></a><span class=\"kw\">type</span> TokenType <span class=\"dt\">string</span></span>\n<span id=\"cb7-6\"><a href=\"#cb7-6\"></a></span>\n<span id=\"cb7-7\"><a href=\"#cb7-7\"></a><span class=\"kw\">type</span> Token <span class=\"kw\">struct</span> {</span>\n<span id=\"cb7-8\"><a href=\"#cb7-8\"></a>    Type    TokenType</span>\n<span id=\"cb7-9\"><a href=\"#cb7-9\"></a>    Literal <span class=\"dt\">string</span></span>\n<span id=\"cb7-10\"><a href=\"#cb7-10\"></a>}</span></code></pre></div>\n<p>We defined the <code>TokenType</code> type to be a <code>string</code>. That allows us to use many different values as <code>TokenType</code>s, which in turn allows us to distinguish between different types of tokens. Using <code>string</code> also has the advantage of being easy to debug without a lot of boilerplate and helper functions: we can just print a <code>string</code>. Of course, using a <code>string</code> might not lead to the same performance as using an <code>int</code> or a <code>byte</code> would, but for this book a <code>string</code> is perfect.</p>\n<p>As we just saw, there is a limited number of different token types in the Monkey language. That means we can define the possible <code>TokenType</code>s as constants. In the same file we add this:</p>\n<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb8-1\"><a href=\"#cb8-1\"></a><span class=\"co\">// token/token.go</span></span>\n<span id=\"cb8-2\"><a href=\"#cb8-2\"></a></span>\n<span id=\"cb8-3\"><a href=\"#cb8-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb8-4\"><a href=\"#cb8-4\"></a>    ILLEGAL = <span class=\"st\">&quot;ILLEGAL&quot;</span></span>\n<span id=\"cb8-5\"><a href=\"#cb8-5\"></a>    EOF     = <span class=\"st\">&quot;EOF&quot;</span></span>\n<span id=\"cb8-6\"><a href=\"#cb8-6\"></a></span>\n<span id=\"cb8-7\"><a href=\"#cb8-7\"></a>    <span class=\"co\">// Identifiers + literals</span></span>\n<span id=\"cb8-8\"><a href=\"#cb8-8\"></a>    IDENT = <span class=\"st\">&quot;IDENT&quot;</span> <span class=\"co\">// add, foobar, x, y, ...</span></span>\n<span id=\"cb8-9\"><a href=\"#cb8-9\"></a>    INT   = <span class=\"st\">&quot;INT&quot;</span>   <span class=\"co\">// 1343456</span></span>\n<span id=\"cb8-10\"><a href=\"#cb8-10\"></a></span>\n<span id=\"cb8-11\"><a href=\"#cb8-11\"></a>    <span class=\"co\">// Operators</span></span>\n<span id=\"cb8-12\"><a href=\"#cb8-12\"></a>    ASSIGN   = <span class=\"st\">&quot;=&quot;</span></span>\n<span id=\"cb8-13\"><a href=\"#cb8-13\"></a>    PLUS     = <span class=\"st\">&quot;+&quot;</span></span>\n<span id=\"cb8-14\"><a href=\"#cb8-14\"></a></span>\n<span id=\"cb8-15\"><a href=\"#cb8-15\"></a>    <span class=\"co\">// Delimiters</span></span>\n<span id=\"cb8-16\"><a href=\"#cb8-16\"></a>    COMMA     = <span class=\"st\">&quot;,&quot;</span></span>\n<span id=\"cb8-17\"><a href=\"#cb8-17\"></a>    SEMICOLON = <span class=\"st\">&quot;;&quot;</span></span>\n<span id=\"cb8-18\"><a href=\"#cb8-18\"></a></span>\n<span id=\"cb8-19\"><a href=\"#cb8-19\"></a>    LPAREN = <span class=\"st\">&quot;(&quot;</span></span>\n<span id=\"cb8-20\"><a href=\"#cb8-20\"></a>    RPAREN = <span class=\"st\">&quot;)&quot;</span></span>\n<span id=\"cb8-21\"><a href=\"#cb8-21\"></a>    LBRACE = <span class=\"st\">&quot;{&quot;</span></span>\n<span id=\"cb8-22\"><a href=\"#cb8-22\"></a>    RBRACE = <span class=\"st\">&quot;}&quot;</span></span>\n<span id=\"cb8-23\"><a href=\"#cb8-23\"></a></span>\n<span id=\"cb8-24\"><a href=\"#cb8-24\"></a>    <span class=\"co\">// Keywords</span></span>\n<span id=\"cb8-25\"><a href=\"#cb8-25\"></a>    FUNCTION = <span class=\"st\">&quot;FUNCTION&quot;</span></span>\n<span id=\"cb8-26\"><a href=\"#cb8-26\"></a>    LET      = <span class=\"st\">&quot;LET&quot;</span></span>\n<span id=\"cb8-27\"><a href=\"#cb8-27\"></a>)</span></code></pre></div>\n<p>As you can see there are two special types: <code>ILLEGAL</code> and <code>EOF</code>. We didn’t see them in the example above, but we’ll need them. <code>ILLEGAL</code> signifies a token/character we don’t know about and <code>EOF</code> stands for “end of file”, which tells our parser later on that it can stop.</p>\n<p>So far so good! We are ready to start writing our lexer.</p>\n</section>\n<section id=\"the-lexer\" class=\"level2\" data-number=\"1.3\">\n<h2 data-number=\"1.3\">1.3 - The Lexer</h2>\n<p>Before we start to write code, let’s be clear about the goal of this section. We’re going to write our own lexer. It will take source code as input and output the tokens that represent the source code. It will go through its input and output the next token it recognizes. It doesn’t need to buffer or save tokens, since there will only be one method called <code>NextToken()</code>, which will output the next token.</p>\n<p>That means, we’ll initialize the lexer with our source code and then repeatedly call <code>NextToken()</code> on it to go through the source code, token by token, character by character. We’ll also make life simpler here by using <code>string</code> as the type for our source code. Again: in a production environment it makes sense to attach filenames and line numbers to tokens, to better track down lexing and parsing errors. So it would be better to initialize the lexer with an <code>io.Reader</code> and the filename. But since that would add more complexity we’re not here to handle, we’ll start small and just use a <code>string</code> and ignore filenames and line numbers.</p>\n<p>Having thought this through, we now realize that what our lexer needs to do is pretty clear. So let’s create a new package and add a first test that we can continuously run to get feedback about the working state of the lexer. We’re starting small here and will extend the test case as we add more capabilities to the lexer:</p>\n<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb9-1\"><a href=\"#cb9-1\"></a><span class=\"co\">// lexer/lexer_test.go</span></span>\n<span id=\"cb9-2\"><a href=\"#cb9-2\"></a></span>\n<span id=\"cb9-3\"><a href=\"#cb9-3\"></a><span class=\"kw\">package</span> lexer</span>\n<span id=\"cb9-4\"><a href=\"#cb9-4\"></a></span>\n<span id=\"cb9-5\"><a href=\"#cb9-5\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb9-6\"><a href=\"#cb9-6\"></a>    <span class=\"st\">&quot;testing&quot;</span></span>\n<span id=\"cb9-7\"><a href=\"#cb9-7\"></a></span>\n<span id=\"cb9-8\"><a href=\"#cb9-8\"></a>    <span class=\"st\">&quot;monkey/token&quot;</span></span>\n<span id=\"cb9-9\"><a href=\"#cb9-9\"></a>)</span>\n<span id=\"cb9-10\"><a href=\"#cb9-10\"></a></span>\n<span id=\"cb9-11\"><a href=\"#cb9-11\"></a><span class=\"kw\">func</span> TestNextToken(t *testing.T) {</span>\n<span id=\"cb9-12\"><a href=\"#cb9-12\"></a>    input := <span class=\"st\">`=+(){},;`</span></span>\n<span id=\"cb9-13\"><a href=\"#cb9-13\"></a></span>\n<span id=\"cb9-14\"><a href=\"#cb9-14\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb9-15\"><a href=\"#cb9-15\"></a>        expectedType    token.TokenType</span>\n<span id=\"cb9-16\"><a href=\"#cb9-16\"></a>        expectedLiteral <span class=\"dt\">string</span></span>\n<span id=\"cb9-17\"><a href=\"#cb9-17\"></a>    }{</span>\n<span id=\"cb9-18\"><a href=\"#cb9-18\"></a>        {token.ASSIGN, <span class=\"st\">&quot;=&quot;</span>},</span>\n<span id=\"cb9-19\"><a href=\"#cb9-19\"></a>        {token.PLUS, <span class=\"st\">&quot;+&quot;</span>},</span>\n<span id=\"cb9-20\"><a href=\"#cb9-20\"></a>        {token.LPAREN, <span class=\"st\">&quot;(&quot;</span>},</span>\n<span id=\"cb9-21\"><a href=\"#cb9-21\"></a>        {token.RPAREN, <span class=\"st\">&quot;)&quot;</span>},</span>\n<span id=\"cb9-22\"><a href=\"#cb9-22\"></a>        {token.LBRACE, <span class=\"st\">&quot;{&quot;</span>},</span>\n<span id=\"cb9-23\"><a href=\"#cb9-23\"></a>        {token.RBRACE, <span class=\"st\">&quot;}&quot;</span>},</span>\n<span id=\"cb9-24\"><a href=\"#cb9-24\"></a>        {token.COMMA, <span class=\"st\">&quot;,&quot;</span>},</span>\n<span id=\"cb9-25\"><a href=\"#cb9-25\"></a>        {token.SEMICOLON, <span class=\"st\">&quot;;&quot;</span>},</span>\n<span id=\"cb9-26\"><a href=\"#cb9-26\"></a>        {token.EOF, <span class=\"st\">&quot;&quot;</span>},</span>\n<span id=\"cb9-27\"><a href=\"#cb9-27\"></a>    }</span>\n<span id=\"cb9-28\"><a href=\"#cb9-28\"></a></span>\n<span id=\"cb9-29\"><a href=\"#cb9-29\"></a>    l := New(input)</span>\n<span id=\"cb9-30\"><a href=\"#cb9-30\"></a></span>\n<span id=\"cb9-31\"><a href=\"#cb9-31\"></a>    <span class=\"kw\">for</span> i, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb9-32\"><a href=\"#cb9-32\"></a>        tok := l.NextToken()</span>\n<span id=\"cb9-33\"><a href=\"#cb9-33\"></a></span>\n<span id=\"cb9-34\"><a href=\"#cb9-34\"></a>        <span class=\"kw\">if</span> tok.Type != tt.expectedType {</span>\n<span id=\"cb9-35\"><a href=\"#cb9-35\"></a>            t.Fatalf(<span class=\"st\">&quot;tests[%d] - tokentype wrong. expected=%q, got=%q&quot;</span>,</span>\n<span id=\"cb9-36\"><a href=\"#cb9-36\"></a>                i, tt.expectedType, tok.Type)</span>\n<span id=\"cb9-37\"><a href=\"#cb9-37\"></a>        }</span>\n<span id=\"cb9-38\"><a href=\"#cb9-38\"></a></span>\n<span id=\"cb9-39\"><a href=\"#cb9-39\"></a>        <span class=\"kw\">if</span> tok.Literal != tt.expectedLiteral {</span>\n<span id=\"cb9-40\"><a href=\"#cb9-40\"></a>            t.Fatalf(<span class=\"st\">&quot;tests[%d] - literal wrong. expected=%q, got=%q&quot;</span>,</span>\n<span id=\"cb9-41\"><a href=\"#cb9-41\"></a>                i, tt.expectedLiteral, tok.Literal)</span>\n<span id=\"cb9-42\"><a href=\"#cb9-42\"></a>        }</span>\n<span id=\"cb9-43\"><a href=\"#cb9-43\"></a>    }</span>\n<span id=\"cb9-44\"><a href=\"#cb9-44\"></a>}</span></code></pre></div>\n<p>Of course, the tests fail – we haven’t written any code yet:</p>\n<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb10-1\"><a href=\"#cb10-1\"></a>$ go test ./lexer</span>\n<span id=\"cb10-2\"><a href=\"#cb10-2\"></a># monkey/lexer</span>\n<span id=\"cb10-3\"><a href=\"#cb10-3\"></a>lexer/lexer_test.go:27: undefined: New</span>\n<span id=\"cb10-4\"><a href=\"#cb10-4\"></a>FAIL    monkey/lexer [build failed]</span></code></pre></div>\n<p>So let’s start by defining the <code>New()</code> function that returns <code>*Lexer</code>.</p>\n<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb11-1\"><a href=\"#cb11-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb11-2\"><a href=\"#cb11-2\"></a><span class=\"kw\">package</span> lexer</span>\n<span id=\"cb11-3\"><a href=\"#cb11-3\"></a></span>\n<span id=\"cb11-4\"><a href=\"#cb11-4\"></a><span class=\"kw\">type</span> Lexer <span class=\"kw\">struct</span> {</span>\n<span id=\"cb11-5\"><a href=\"#cb11-5\"></a>    input        <span class=\"dt\">string</span></span>\n<span id=\"cb11-6\"><a href=\"#cb11-6\"></a>    position     <span class=\"dt\">int</span>  <span class=\"co\">// current position in input (points to current char)</span></span>\n<span id=\"cb11-7\"><a href=\"#cb11-7\"></a>    readPosition <span class=\"dt\">int</span>  <span class=\"co\">// current reading position in input (after current char)</span></span>\n<span id=\"cb11-8\"><a href=\"#cb11-8\"></a>    ch           <span class=\"dt\">byte</span> <span class=\"co\">// current char under examination</span></span>\n<span id=\"cb11-9\"><a href=\"#cb11-9\"></a>}</span>\n<span id=\"cb11-10\"><a href=\"#cb11-10\"></a></span>\n<span id=\"cb11-11\"><a href=\"#cb11-11\"></a><span class=\"kw\">func</span> New(input <span class=\"dt\">string</span>) *Lexer {</span>\n<span id=\"cb11-12\"><a href=\"#cb11-12\"></a>    l := &amp;Lexer{input: input}</span>\n<span id=\"cb11-13\"><a href=\"#cb11-13\"></a>    <span class=\"kw\">return</span> l</span>\n<span id=\"cb11-14\"><a href=\"#cb11-14\"></a>}</span></code></pre></div>\n<p>Most of the fields in <code>Lexer</code> are pretty self-explanatory. The ones that might cause some confusion right now are <code>position</code> and <code>readPosition</code>. Both will be used to access characters in <code>input</code> by using them as an index, e.g.: <code>l.input[l.readPosition]</code>. The reason for these two “pointers” pointing into our input string is the fact that we will need to be able to “peek” further into the input and look after the current character to see what comes up next. <code>readPosition</code> always points to the “next” character in the input. <code>position</code> points to the character in the input that corresponds to the <code>ch</code> byte.</p>\n<p>A first helper method called <code>readChar()</code> should make the usage of these fields easier to understand:</p>\n<div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb12-1\"><a href=\"#cb12-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb12-2\"><a href=\"#cb12-2\"></a></span>\n<span id=\"cb12-3\"><a href=\"#cb12-3\"></a><span class=\"kw\">func</span> (l *Lexer) readChar() {</span>\n<span id=\"cb12-4\"><a href=\"#cb12-4\"></a>    <span class=\"kw\">if</span> l.readPosition &gt;= <span class=\"bu\">len</span>(l.input) {</span>\n<span id=\"cb12-5\"><a href=\"#cb12-5\"></a>        l.ch = <span class=\"dv\">0</span></span>\n<span id=\"cb12-6\"><a href=\"#cb12-6\"></a>    } <span class=\"kw\">else</span> {</span>\n<span id=\"cb12-7\"><a href=\"#cb12-7\"></a>        l.ch = l.input[l.readPosition]</span>\n<span id=\"cb12-8\"><a href=\"#cb12-8\"></a>    }</span>\n<span id=\"cb12-9\"><a href=\"#cb12-9\"></a>    l.position = l.readPosition</span>\n<span id=\"cb12-10\"><a href=\"#cb12-10\"></a>    l.readPosition += <span class=\"dv\">1</span></span>\n<span id=\"cb12-11\"><a href=\"#cb12-11\"></a>}</span></code></pre></div>\n<p>The purpose of <code>readChar</code> is to give us the next character and advance our position in the <code>input</code> string. The first thing it does is to check whether we have reached the end of <code>input</code>. If that’s the case it sets <code>l.ch</code> to <code>0</code>, which is the ASCII code for the <code>\"NUL\"</code> character and signifies either “we haven’t read anything yet” or “end of file” for us. But if we haven’t reached the end of <code>input</code> yet it sets <code>l.ch</code> to the next character by accessing <code>l.input[l.readPosition]</code>.</p>\n<p>After that <code>l.position</code> is updated to the just used <code>l.readPosition</code> and <code>l.readPosition</code> is incremented by one. That way, <code>l.readPosition</code> always points to the next position where we’re going to read from next and <code>l.position</code> always points to the position where we last read. This will come in handy soon enough.</p>\n<p>While talking about <code>readChar</code> it’s worth pointing out that the lexer only supports ASCII characters instead of the full Unicode range. Why? Because this lets us keep things simple and concentrate on the essential parts of our interpreter. In order to fully support Unicode and UTF-8 we would need to change <code>l.ch</code> from a <code>byte</code> to <code>rune</code> and change the way we read the next characters, since they could be multiple bytes wide now. Using <code>l.input[l.readPosition]</code> wouldn’t work anymore. And then we’d also need to change a few other methods and functions we’ll see later on. So it’s left as an exercise to the reader to fully support Unicode (and emojis!) in Monkey.</p>\n<p>Let’s use <code>readChar</code> in our <code>New()</code> function so our <code>*Lexer</code> is in a fully working state before anyone calls <code>NextToken()</code>, with <code>l.ch</code>, <code>l.position</code> and <code>l.readPosition</code> already initialized:</p>\n<div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb13-1\"><a href=\"#cb13-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb13-2\"><a href=\"#cb13-2\"></a></span>\n<span id=\"cb13-3\"><a href=\"#cb13-3\"></a><span class=\"kw\">func</span> New(input <span class=\"dt\">string</span>) *Lexer {</span>\n<span id=\"cb13-4\"><a href=\"#cb13-4\"></a>    l := &amp;Lexer{input: input}</span>\n<span id=\"cb13-5\"><a href=\"#cb13-5\"></a>    l.readChar()</span>\n<span id=\"cb13-6\"><a href=\"#cb13-6\"></a>    <span class=\"kw\">return</span> l</span>\n<span id=\"cb13-7\"><a href=\"#cb13-7\"></a>}</span></code></pre></div>\n<p>Our tests now tell us that calling <code>New(input)</code> doesn’t result in problems anymore, but the <code>NextToken()</code> method is still missing. Let’s fix that by adding a first version:</p>\n<div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb14-1\"><a href=\"#cb14-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb14-2\"><a href=\"#cb14-2\"></a></span>\n<span id=\"cb14-3\"><a href=\"#cb14-3\"></a><span class=\"kw\">package</span> lexer</span>\n<span id=\"cb14-4\"><a href=\"#cb14-4\"></a></span>\n<span id=\"cb14-5\"><a href=\"#cb14-5\"></a><span class=\"kw\">import</span> <span class=\"st\">&quot;monkey/token&quot;</span></span>\n<span id=\"cb14-6\"><a href=\"#cb14-6\"></a></span>\n<span id=\"cb14-7\"><a href=\"#cb14-7\"></a><span class=\"kw\">func</span> (l *Lexer) NextToken() token.Token {</span>\n<span id=\"cb14-8\"><a href=\"#cb14-8\"></a>    <span class=\"kw\">var</span> tok token.Token</span>\n<span id=\"cb14-9\"><a href=\"#cb14-9\"></a></span>\n<span id=\"cb14-10\"><a href=\"#cb14-10\"></a>    <span class=\"kw\">switch</span> l.ch {</span>\n<span id=\"cb14-11\"><a href=\"#cb14-11\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;=&#39;</span>:</span>\n<span id=\"cb14-12\"><a href=\"#cb14-12\"></a>        tok = newToken(token.ASSIGN, l.ch)</span>\n<span id=\"cb14-13\"><a href=\"#cb14-13\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;;&#39;</span>:</span>\n<span id=\"cb14-14\"><a href=\"#cb14-14\"></a>        tok = newToken(token.SEMICOLON, l.ch)</span>\n<span id=\"cb14-15\"><a href=\"#cb14-15\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;(&#39;</span>:</span>\n<span id=\"cb14-16\"><a href=\"#cb14-16\"></a>        tok = newToken(token.LPAREN, l.ch)</span>\n<span id=\"cb14-17\"><a href=\"#cb14-17\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;)&#39;</span>:</span>\n<span id=\"cb14-18\"><a href=\"#cb14-18\"></a>        tok = newToken(token.RPAREN, l.ch)</span>\n<span id=\"cb14-19\"><a href=\"#cb14-19\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;,&#39;</span>:</span>\n<span id=\"cb14-20\"><a href=\"#cb14-20\"></a>        tok = newToken(token.COMMA, l.ch)</span>\n<span id=\"cb14-21\"><a href=\"#cb14-21\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;+&#39;</span>:</span>\n<span id=\"cb14-22\"><a href=\"#cb14-22\"></a>        tok = newToken(token.PLUS, l.ch)</span>\n<span id=\"cb14-23\"><a href=\"#cb14-23\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;{&#39;</span>:</span>\n<span id=\"cb14-24\"><a href=\"#cb14-24\"></a>        tok = newToken(token.LBRACE, l.ch)</span>\n<span id=\"cb14-25\"><a href=\"#cb14-25\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;}&#39;</span>:</span>\n<span id=\"cb14-26\"><a href=\"#cb14-26\"></a>        tok = newToken(token.RBRACE, l.ch)</span>\n<span id=\"cb14-27\"><a href=\"#cb14-27\"></a>    <span class=\"kw\">case</span> <span class=\"dv\">0</span>:</span>\n<span id=\"cb14-28\"><a href=\"#cb14-28\"></a>        tok.Literal = <span class=\"st\">&quot;&quot;</span></span>\n<span id=\"cb14-29\"><a href=\"#cb14-29\"></a>        tok.Type = token.EOF</span>\n<span id=\"cb14-30\"><a href=\"#cb14-30\"></a>    }</span>\n<span id=\"cb14-31\"><a href=\"#cb14-31\"></a></span>\n<span id=\"cb14-32\"><a href=\"#cb14-32\"></a>    l.readChar()</span>\n<span id=\"cb14-33\"><a href=\"#cb14-33\"></a>    <span class=\"kw\">return</span> tok</span>\n<span id=\"cb14-34\"><a href=\"#cb14-34\"></a>}</span>\n<span id=\"cb14-35\"><a href=\"#cb14-35\"></a></span>\n<span id=\"cb14-36\"><a href=\"#cb14-36\"></a><span class=\"kw\">func</span> newToken(tokenType token.TokenType, ch <span class=\"dt\">byte</span>) token.Token {</span>\n<span id=\"cb14-37\"><a href=\"#cb14-37\"></a>    <span class=\"kw\">return</span> token.Token{Type: tokenType, Literal: <span class=\"dt\">string</span>(ch)}</span>\n<span id=\"cb14-38\"><a href=\"#cb14-38\"></a>}</span></code></pre></div>\n<p>That’s the basic structure of the <code>NextToken()</code> method. We look at the current character under examination (<code>l.ch</code>) and return a token depending on which character it is. Before returning the token we advance our pointers into the input so when we call <code>NextToken()</code> again the <code>l.ch</code> field is already updated. A small function called <code>newToken</code> helps us with initializing these tokens.</p>\n<p>Running the tests we can see that they pass:</p>\n<pre><code>$ go test ./lexer\nok      monkey/lexer 0.007s</code></pre>\n<p>Great! Let’s now extend the test case so it starts to resemble Monkey source code.</p>\n<div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb16-1\"><a href=\"#cb16-1\"></a><span class=\"co\">// lexer/lexer_test.go</span></span>\n<span id=\"cb16-2\"><a href=\"#cb16-2\"></a></span>\n<span id=\"cb16-3\"><a href=\"#cb16-3\"></a><span class=\"kw\">func</span> TestNextToken(t *testing.T) {</span>\n<span id=\"cb16-4\"><a href=\"#cb16-4\"></a>    input := <span class=\"st\">`let five = 5;</span></span>\n<span id=\"cb16-5\"><a href=\"#cb16-5\"></a><span class=\"st\">let ten = 10;</span></span>\n<span id=\"cb16-6\"><a href=\"#cb16-6\"></a></span>\n<span id=\"cb16-7\"><a href=\"#cb16-7\"></a><span class=\"st\">let add = fn(x, y) {</span></span>\n<span id=\"cb16-8\"><a href=\"#cb16-8\"></a><span class=\"st\">  x + y;</span></span>\n<span id=\"cb16-9\"><a href=\"#cb16-9\"></a><span class=\"st\">};</span></span>\n<span id=\"cb16-10\"><a href=\"#cb16-10\"></a></span>\n<span id=\"cb16-11\"><a href=\"#cb16-11\"></a><span class=\"st\">let result = add(five, ten);</span></span>\n<span id=\"cb16-12\"><a href=\"#cb16-12\"></a><span class=\"st\">`</span></span>\n<span id=\"cb16-13\"><a href=\"#cb16-13\"></a></span>\n<span id=\"cb16-14\"><a href=\"#cb16-14\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb16-15\"><a href=\"#cb16-15\"></a>        expectedType    token.TokenType</span>\n<span id=\"cb16-16\"><a href=\"#cb16-16\"></a>        expectedLiteral <span class=\"dt\">string</span></span>\n<span id=\"cb16-17\"><a href=\"#cb16-17\"></a>    }{</span>\n<span id=\"cb16-18\"><a href=\"#cb16-18\"></a>        {token.LET, <span class=\"st\">&quot;let&quot;</span>},</span>\n<span id=\"cb16-19\"><a href=\"#cb16-19\"></a>        {token.IDENT, <span class=\"st\">&quot;five&quot;</span>},</span>\n<span id=\"cb16-20\"><a href=\"#cb16-20\"></a>        {token.ASSIGN, <span class=\"st\">&quot;=&quot;</span>},</span>\n<span id=\"cb16-21\"><a href=\"#cb16-21\"></a>        {token.INT, <span class=\"st\">&quot;5&quot;</span>},</span>\n<span id=\"cb16-22\"><a href=\"#cb16-22\"></a>        {token.SEMICOLON, <span class=\"st\">&quot;;&quot;</span>},</span>\n<span id=\"cb16-23\"><a href=\"#cb16-23\"></a>        {token.LET, <span class=\"st\">&quot;let&quot;</span>},</span>\n<span id=\"cb16-24\"><a href=\"#cb16-24\"></a>        {token.IDENT, <span class=\"st\">&quot;ten&quot;</span>},</span>\n<span id=\"cb16-25\"><a href=\"#cb16-25\"></a>        {token.ASSIGN, <span class=\"st\">&quot;=&quot;</span>},</span>\n<span id=\"cb16-26\"><a href=\"#cb16-26\"></a>        {token.INT, <span class=\"st\">&quot;10&quot;</span>},</span>\n<span id=\"cb16-27\"><a href=\"#cb16-27\"></a>        {token.SEMICOLON, <span class=\"st\">&quot;;&quot;</span>},</span>\n<span id=\"cb16-28\"><a href=\"#cb16-28\"></a>        {token.LET, <span class=\"st\">&quot;let&quot;</span>},</span>\n<span id=\"cb16-29\"><a href=\"#cb16-29\"></a>        {token.IDENT, <span class=\"st\">&quot;add&quot;</span>},</span>\n<span id=\"cb16-30\"><a href=\"#cb16-30\"></a>        {token.ASSIGN, <span class=\"st\">&quot;=&quot;</span>},</span>\n<span id=\"cb16-31\"><a href=\"#cb16-31\"></a>        {token.FUNCTION, <span class=\"st\">&quot;fn&quot;</span>},</span>\n<span id=\"cb16-32\"><a href=\"#cb16-32\"></a>        {token.LPAREN, <span class=\"st\">&quot;(&quot;</span>},</span>\n<span id=\"cb16-33\"><a href=\"#cb16-33\"></a>        {token.IDENT, <span class=\"st\">&quot;x&quot;</span>},</span>\n<span id=\"cb16-34\"><a href=\"#cb16-34\"></a>        {token.COMMA, <span class=\"st\">&quot;,&quot;</span>},</span>\n<span id=\"cb16-35\"><a href=\"#cb16-35\"></a>        {token.IDENT, <span class=\"st\">&quot;y&quot;</span>},</span>\n<span id=\"cb16-36\"><a href=\"#cb16-36\"></a>        {token.RPAREN, <span class=\"st\">&quot;)&quot;</span>},</span>\n<span id=\"cb16-37\"><a href=\"#cb16-37\"></a>        {token.LBRACE, <span class=\"st\">&quot;{&quot;</span>},</span>\n<span id=\"cb16-38\"><a href=\"#cb16-38\"></a>        {token.IDENT, <span class=\"st\">&quot;x&quot;</span>},</span>\n<span id=\"cb16-39\"><a href=\"#cb16-39\"></a>        {token.PLUS, <span class=\"st\">&quot;+&quot;</span>},</span>\n<span id=\"cb16-40\"><a href=\"#cb16-40\"></a>        {token.IDENT, <span class=\"st\">&quot;y&quot;</span>},</span>\n<span id=\"cb16-41\"><a href=\"#cb16-41\"></a>        {token.SEMICOLON, <span class=\"st\">&quot;;&quot;</span>},</span>\n<span id=\"cb16-42\"><a href=\"#cb16-42\"></a>        {token.RBRACE, <span class=\"st\">&quot;}&quot;</span>},</span>\n<span id=\"cb16-43\"><a href=\"#cb16-43\"></a>        {token.SEMICOLON, <span class=\"st\">&quot;;&quot;</span>},</span>\n<span id=\"cb16-44\"><a href=\"#cb16-44\"></a>        {token.LET, <span class=\"st\">&quot;let&quot;</span>},</span>\n<span id=\"cb16-45\"><a href=\"#cb16-45\"></a>        {token.IDENT, <span class=\"st\">&quot;result&quot;</span>},</span>\n<span id=\"cb16-46\"><a href=\"#cb16-46\"></a>        {token.ASSIGN, <span class=\"st\">&quot;=&quot;</span>},</span>\n<span id=\"cb16-47\"><a href=\"#cb16-47\"></a>        {token.IDENT, <span class=\"st\">&quot;add&quot;</span>},</span>\n<span id=\"cb16-48\"><a href=\"#cb16-48\"></a>        {token.LPAREN, <span class=\"st\">&quot;(&quot;</span>},</span>\n<span id=\"cb16-49\"><a href=\"#cb16-49\"></a>        {token.IDENT, <span class=\"st\">&quot;five&quot;</span>},</span>\n<span id=\"cb16-50\"><a href=\"#cb16-50\"></a>        {token.COMMA, <span class=\"st\">&quot;,&quot;</span>},</span>\n<span id=\"cb16-51\"><a href=\"#cb16-51\"></a>        {token.IDENT, <span class=\"st\">&quot;ten&quot;</span>},</span>\n<span id=\"cb16-52\"><a href=\"#cb16-52\"></a>        {token.RPAREN, <span class=\"st\">&quot;)&quot;</span>},</span>\n<span id=\"cb16-53\"><a href=\"#cb16-53\"></a>        {token.SEMICOLON, <span class=\"st\">&quot;;&quot;</span>},</span>\n<span id=\"cb16-54\"><a href=\"#cb16-54\"></a>        {token.EOF, <span class=\"st\">&quot;&quot;</span>},</span>\n<span id=\"cb16-55\"><a href=\"#cb16-55\"></a>    }</span>\n<span id=\"cb16-56\"><a href=\"#cb16-56\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb16-57\"><a href=\"#cb16-57\"></a>}</span></code></pre></div>\n<p>Most notably the <code>input</code> in this test case has changed. It looks like a subset of the Monkey language. It contains all the symbols we already successfully turned into tokens, but also new things that are now causing our tests to fail: identifiers, keywords and numbers.</p>\n<p>Let’s start with the identifiers and keywords. What our lexer needs to do is recognize whether the current character is a letter and if so, it needs to read the rest of the identifier/keyword until it encounters a non-letter-character. Having read that identifier/keyword, we then need to find out if it is a identifier or a keyword, so we can use the correct <code>token.TokenType</code>. The first step is extending our switch statement:</p>\n<div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb17-1\"><a href=\"#cb17-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb17-2\"><a href=\"#cb17-2\"></a></span>\n<span id=\"cb17-3\"><a href=\"#cb17-3\"></a><span class=\"kw\">import</span> <span class=\"st\">&quot;monkey/token&quot;</span></span>\n<span id=\"cb17-4\"><a href=\"#cb17-4\"></a></span>\n<span id=\"cb17-5\"><a href=\"#cb17-5\"></a><span class=\"kw\">func</span> (l *Lexer) NextToken() token.Token {</span>\n<span id=\"cb17-6\"><a href=\"#cb17-6\"></a>    <span class=\"kw\">var</span> tok token.Token</span>\n<span id=\"cb17-7\"><a href=\"#cb17-7\"></a></span>\n<span id=\"cb17-8\"><a href=\"#cb17-8\"></a>    <span class=\"kw\">switch</span> l.ch {</span>\n<span id=\"cb17-9\"><a href=\"#cb17-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb17-10\"><a href=\"#cb17-10\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb17-11\"><a href=\"#cb17-11\"></a>        <span class=\"kw\">if</span> isLetter(l.ch) {</span>\n<span id=\"cb17-12\"><a href=\"#cb17-12\"></a>            tok.Literal = l.readIdentifier()</span>\n<span id=\"cb17-13\"><a href=\"#cb17-13\"></a>            <span class=\"kw\">return</span> tok</span>\n<span id=\"cb17-14\"><a href=\"#cb17-14\"></a>        } <span class=\"kw\">else</span> {</span>\n<span id=\"cb17-15\"><a href=\"#cb17-15\"></a>            tok = newToken(token.ILLEGAL, l.ch)</span>\n<span id=\"cb17-16\"><a href=\"#cb17-16\"></a>        }</span>\n<span id=\"cb17-17\"><a href=\"#cb17-17\"></a>    }</span>\n<span id=\"cb17-18\"><a href=\"#cb17-18\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb17-19\"><a href=\"#cb17-19\"></a>}</span>\n<span id=\"cb17-20\"><a href=\"#cb17-20\"></a></span>\n<span id=\"cb17-21\"><a href=\"#cb17-21\"></a><span class=\"kw\">func</span> (l *Lexer) readIdentifier() <span class=\"dt\">string</span> {</span>\n<span id=\"cb17-22\"><a href=\"#cb17-22\"></a>    position := l.position</span>\n<span id=\"cb17-23\"><a href=\"#cb17-23\"></a>    <span class=\"kw\">for</span> isLetter(l.ch) {</span>\n<span id=\"cb17-24\"><a href=\"#cb17-24\"></a>        l.readChar()</span>\n<span id=\"cb17-25\"><a href=\"#cb17-25\"></a>    }</span>\n<span id=\"cb17-26\"><a href=\"#cb17-26\"></a>    <span class=\"kw\">return</span> l.input[position:l.position]</span>\n<span id=\"cb17-27\"><a href=\"#cb17-27\"></a>}</span>\n<span id=\"cb17-28\"><a href=\"#cb17-28\"></a></span>\n<span id=\"cb17-29\"><a href=\"#cb17-29\"></a><span class=\"kw\">func</span> isLetter(ch <span class=\"dt\">byte</span>) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb17-30\"><a href=\"#cb17-30\"></a>    <span class=\"kw\">return</span> <span class=\"ch\">&#39;a&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class=\"ch\">&#39;z&#39;</span> || <span class=\"ch\">&#39;A&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class=\"ch\">&#39;Z&#39;</span> || ch == <span class=\"ch\">&#39;_&#39;</span></span>\n<span id=\"cb17-31\"><a href=\"#cb17-31\"></a>}</span></code></pre></div>\n<p>We added a <code>default</code> branch to our switch statement, so we can check for identifiers whenever the <code>l.ch</code> is not one of the recognized characters. We also added the generation of <code>token.ILLEGAL</code> tokens. If we end up there, we truly don’t know how to handle the current character and declare it as <code>token.ILLEGAL</code>.</p>\n<p>The <code>isLetter</code> helper function just checks whether the given argument is a letter. That sounds easy enough, but what’s noteworthy about <code>isLetter</code> is that changing this function has a larger impact on the language our interpreter will be able to parse than one would expect from such a small function. As you can see, in our case it contains the check <code>ch == '_'</code>, which means that we’ll treat <code>_</code> as a letter and allow it in identifiers and keywords. That means we can use variable names like <code>foo_bar</code>. Other programming languages even allow <code>!</code> and <code>?</code> in identifiers. If you want to allow that too, this is the place to sneak it in.</p>\n<p><code>readIdentifier()</code> does exactly what its name suggests: it reads in an identifier and advances our lexer’s positions until it encounters a non-letter-character.</p>\n<p>In the <code>default:</code> branch of the switch statement we use <code>readIdentifier()</code> to set the <code>Literal</code> field of our current token. But what about its <code>Type</code>? Now that we have read identifiers like <code>let</code>, <code>fn</code> or <code>foobar</code>, we need to be able to tell user-defined identifiers apart from language keywords. We need a function that returns the correct <code>TokenType</code> for the token literal we have. What better place than the <code>token</code> package to add such a function?</p>\n<div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb18-1\"><a href=\"#cb18-1\"></a><span class=\"co\">// token/token.go</span></span>\n<span id=\"cb18-2\"><a href=\"#cb18-2\"></a></span>\n<span id=\"cb18-3\"><a href=\"#cb18-3\"></a><span class=\"kw\">var</span> keywords = <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]TokenType{</span>\n<span id=\"cb18-4\"><a href=\"#cb18-4\"></a>    <span class=\"st\">&quot;fn&quot;</span>:  FUNCTION,</span>\n<span id=\"cb18-5\"><a href=\"#cb18-5\"></a>    <span class=\"st\">&quot;let&quot;</span>: LET,</span>\n<span id=\"cb18-6\"><a href=\"#cb18-6\"></a>}</span>\n<span id=\"cb18-7\"><a href=\"#cb18-7\"></a></span>\n<span id=\"cb18-8\"><a href=\"#cb18-8\"></a><span class=\"kw\">func</span> LookupIdent(ident <span class=\"dt\">string</span>) TokenType {</span>\n<span id=\"cb18-9\"><a href=\"#cb18-9\"></a>    <span class=\"kw\">if</span> tok, ok := keywords[ident]; ok {</span>\n<span id=\"cb18-10\"><a href=\"#cb18-10\"></a>        <span class=\"kw\">return</span> tok</span>\n<span id=\"cb18-11\"><a href=\"#cb18-11\"></a>    }</span>\n<span id=\"cb18-12\"><a href=\"#cb18-12\"></a>    <span class=\"kw\">return</span> IDENT</span>\n<span id=\"cb18-13\"><a href=\"#cb18-13\"></a>}</span></code></pre></div>\n<p><code>LookupIdent</code> checks the <code>keywords</code> table to see whether the given identifier is in fact a keyword. If it is, it returns the keyword’s <code>TokenType</code> constant. If it isn’t, we just get back <code>token.IDENT</code>, which is the <code>TokenType</code> for all user-defined identifiers.</p>\n<p>With this in hand we can now complete the lexing of identifiers and keywords:</p>\n<div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb19-1\"><a href=\"#cb19-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb19-2\"><a href=\"#cb19-2\"></a></span>\n<span id=\"cb19-3\"><a href=\"#cb19-3\"></a><span class=\"kw\">func</span> (l *Lexer) NextToken() token.Token {</span>\n<span id=\"cb19-4\"><a href=\"#cb19-4\"></a>    <span class=\"kw\">var</span> tok token.Token</span>\n<span id=\"cb19-5\"><a href=\"#cb19-5\"></a></span>\n<span id=\"cb19-6\"><a href=\"#cb19-6\"></a>    <span class=\"kw\">switch</span> l.ch {</span>\n<span id=\"cb19-7\"><a href=\"#cb19-7\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb19-8\"><a href=\"#cb19-8\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb19-9\"><a href=\"#cb19-9\"></a>        <span class=\"kw\">if</span> isLetter(l.ch) {</span>\n<span id=\"cb19-10\"><a href=\"#cb19-10\"></a>            tok.Literal = l.readIdentifier()</span>\n<span id=\"cb19-11\"><a href=\"#cb19-11\"></a>            tok.Type = token.LookupIdent(tok.Literal)</span>\n<span id=\"cb19-12\"><a href=\"#cb19-12\"></a>            <span class=\"kw\">return</span> tok</span>\n<span id=\"cb19-13\"><a href=\"#cb19-13\"></a>        } <span class=\"kw\">else</span> {</span>\n<span id=\"cb19-14\"><a href=\"#cb19-14\"></a>            tok = newToken(token.ILLEGAL, l.ch)</span>\n<span id=\"cb19-15\"><a href=\"#cb19-15\"></a>        }</span>\n<span id=\"cb19-16\"><a href=\"#cb19-16\"></a>    }</span>\n<span id=\"cb19-17\"><a href=\"#cb19-17\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb19-18\"><a href=\"#cb19-18\"></a>}</span></code></pre></div>\n<p>The early exit here, our <code>return tok</code> statement, is necessary because when calling <code>readIdentifier()</code>, we call <code>readChar()</code> repeatedly and advance our <code>readPosition</code> and <code>position</code> fields past the last character of the current identifier. So we don’t need the call to <code>readChar()</code> after the switch statement again.</p>\n<p>Running our tests now, we can see that <code>let</code> is identified correctly but the tests still fail:</p>\n<div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb20-1\"><a href=\"#cb20-1\"></a>$ go test ./lexer</span>\n<span id=\"cb20-2\"><a href=\"#cb20-2\"></a>--- FAIL: TestNextToken (0.00s)</span>\n<span id=\"cb20-3\"><a href=\"#cb20-3\"></a>  lexer_test.go:70: tests[1] - tokentype wrong. expected=&quot;IDENT&quot;, got=&quot;ILLEGAL&quot;</span>\n<span id=\"cb20-4\"><a href=\"#cb20-4\"></a>FAIL</span>\n<span id=\"cb20-5\"><a href=\"#cb20-5\"></a>FAIL    monkey/lexer 0.008s</span></code></pre></div>\n<p>The problem is the next token we want: a <code>IDENT</code> token with <code>\"five\"</code> in its <code>Literal</code> field. Instead we get an <code>ILLEGAL</code> token. Why is that? Because of the whitespace character between “let” and “five”. But in Monkey whitespace only acts as a separator of tokens and doesn’t have meaning, so we need to skip over it entirely:</p>\n<div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb21-1\"><a href=\"#cb21-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb21-2\"><a href=\"#cb21-2\"></a></span>\n<span id=\"cb21-3\"><a href=\"#cb21-3\"></a><span class=\"kw\">func</span> (l *Lexer) NextToken() token.Token {</span>\n<span id=\"cb21-4\"><a href=\"#cb21-4\"></a>    <span class=\"kw\">var</span> tok token.Token</span>\n<span id=\"cb21-5\"><a href=\"#cb21-5\"></a></span>\n<span id=\"cb21-6\"><a href=\"#cb21-6\"></a>    l.skipWhitespace()</span>\n<span id=\"cb21-7\"><a href=\"#cb21-7\"></a></span>\n<span id=\"cb21-8\"><a href=\"#cb21-8\"></a>    <span class=\"kw\">switch</span> l.ch {</span>\n<span id=\"cb21-9\"><a href=\"#cb21-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb21-10\"><a href=\"#cb21-10\"></a>}</span>\n<span id=\"cb21-11\"><a href=\"#cb21-11\"></a></span>\n<span id=\"cb21-12\"><a href=\"#cb21-12\"></a><span class=\"kw\">func</span> (l *Lexer) skipWhitespace() {</span>\n<span id=\"cb21-13\"><a href=\"#cb21-13\"></a>    <span class=\"kw\">for</span> l.ch == <span class=\"ch\">&#39; &#39;</span> || l.ch == <span class=\"ch\">&#39;\\t&#39;</span> || l.ch == <span class=\"ch\">&#39;\\n&#39;</span> || l.ch == <span class=\"ch\">&#39;\\r&#39;</span> {</span>\n<span id=\"cb21-14\"><a href=\"#cb21-14\"></a>        l.readChar()</span>\n<span id=\"cb21-15\"><a href=\"#cb21-15\"></a>    }</span>\n<span id=\"cb21-16\"><a href=\"#cb21-16\"></a>}</span></code></pre></div>\n<p>This little helper function is found in a lot of parsers. Sometimes it’s called <code>eatWhitespace</code> and sometimes <code>consumeWhitespace</code> and sometimes something entirely different. Which characters these functions actually skip depends on the language being lexed. Some language implementations do create tokens for newline characters for example and throw parsing errors if they are not at the correct place in the stream of tokens. We skip over newline characters to make the parsing step later on a little easier.</p>\n<p>With <code>skipWhitespace()</code> in place, the lexer trips over the <code>5</code> in the <code>let five = 5;</code> part of our test input. And that’s right, it doesn’t know yet how to turn numbers into tokens. It’s time to add this.</p>\n<p>As we did previously for identifiers, we now need to add more functionality to the <code>default</code> branch of our switch statement.</p>\n<div class=\"sourceCode\" id=\"cb22\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb22-1\"><a href=\"#cb22-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb22-2\"><a href=\"#cb22-2\"></a></span>\n<span id=\"cb22-3\"><a href=\"#cb22-3\"></a><span class=\"kw\">func</span> (l *Lexer) NextToken() token.Token {</span>\n<span id=\"cb22-4\"><a href=\"#cb22-4\"></a>    <span class=\"kw\">var</span> tok token.Token</span>\n<span id=\"cb22-5\"><a href=\"#cb22-5\"></a></span>\n<span id=\"cb22-6\"><a href=\"#cb22-6\"></a>    l.skipWhitespace()</span>\n<span id=\"cb22-7\"><a href=\"#cb22-7\"></a></span>\n<span id=\"cb22-8\"><a href=\"#cb22-8\"></a>    <span class=\"kw\">switch</span> l.ch {</span>\n<span id=\"cb22-9\"><a href=\"#cb22-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb22-10\"><a href=\"#cb22-10\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb22-11\"><a href=\"#cb22-11\"></a>        <span class=\"kw\">if</span> isLetter(l.ch) {</span>\n<span id=\"cb22-12\"><a href=\"#cb22-12\"></a>            tok.Literal = l.readIdentifier()</span>\n<span id=\"cb22-13\"><a href=\"#cb22-13\"></a>            tok.Type = token.LookupIdent(tok.Literal)</span>\n<span id=\"cb22-14\"><a href=\"#cb22-14\"></a>            <span class=\"kw\">return</span> tok</span>\n<span id=\"cb22-15\"><a href=\"#cb22-15\"></a>        } <span class=\"kw\">else</span> <span class=\"kw\">if</span> isDigit(l.ch) {</span>\n<span id=\"cb22-16\"><a href=\"#cb22-16\"></a>            tok.Type = token.INT</span>\n<span id=\"cb22-17\"><a href=\"#cb22-17\"></a>            tok.Literal = l.readNumber()</span>\n<span id=\"cb22-18\"><a href=\"#cb22-18\"></a>            <span class=\"kw\">return</span> tok</span>\n<span id=\"cb22-19\"><a href=\"#cb22-19\"></a>        } <span class=\"kw\">else</span> {</span>\n<span id=\"cb22-20\"><a href=\"#cb22-20\"></a>            tok = newToken(token.ILLEGAL, l.ch)</span>\n<span id=\"cb22-21\"><a href=\"#cb22-21\"></a>        }</span>\n<span id=\"cb22-22\"><a href=\"#cb22-22\"></a>    }</span>\n<span id=\"cb22-23\"><a href=\"#cb22-23\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb22-24\"><a href=\"#cb22-24\"></a>}</span>\n<span id=\"cb22-25\"><a href=\"#cb22-25\"></a></span>\n<span id=\"cb22-26\"><a href=\"#cb22-26\"></a><span class=\"kw\">func</span> (l *Lexer) readNumber() <span class=\"dt\">string</span> {</span>\n<span id=\"cb22-27\"><a href=\"#cb22-27\"></a>    position := l.position</span>\n<span id=\"cb22-28\"><a href=\"#cb22-28\"></a>    <span class=\"kw\">for</span> isDigit(l.ch) {</span>\n<span id=\"cb22-29\"><a href=\"#cb22-29\"></a>        l.readChar()</span>\n<span id=\"cb22-30\"><a href=\"#cb22-30\"></a>    }</span>\n<span id=\"cb22-31\"><a href=\"#cb22-31\"></a>    <span class=\"kw\">return</span> l.input[position:l.position]</span>\n<span id=\"cb22-32\"><a href=\"#cb22-32\"></a>}</span>\n<span id=\"cb22-33\"><a href=\"#cb22-33\"></a></span>\n<span id=\"cb22-34\"><a href=\"#cb22-34\"></a><span class=\"kw\">func</span> isDigit(ch <span class=\"dt\">byte</span>) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb22-35\"><a href=\"#cb22-35\"></a>    <span class=\"kw\">return</span> <span class=\"ch\">&#39;0&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class=\"ch\">&#39;9&#39;</span></span>\n<span id=\"cb22-36\"><a href=\"#cb22-36\"></a>}</span></code></pre></div>\n<p>As you can see, the added code closely mirrors the part concerned with reading identifiers and keywords. The <code>readNumber</code> method is exactly the same as <code>readIdentifier</code> except for its usage of <code>isDigit</code> instead of <code>isLetter</code>. We could probably generalize this by passing in the character-identifying functions as arguments, but won’t, for simplicity’s sake and ease of understanding.</p>\n<p>The <code>isDigit</code> function is as simple as <code>isLetter</code>. It just returns whether the passed in byte is a Latin digit between <code>0</code> and <code>9</code>.</p>\n<p>With this added, our tests pass:</p>\n<div class=\"sourceCode\" id=\"cb23\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb23-1\"><a href=\"#cb23-1\"></a>$ go test ./lexer</span>\n<span id=\"cb23-2\"><a href=\"#cb23-2\"></a>ok      monkey/lexer 0.008s</span></code></pre></div>\n<p>I don’t know if you noticed, but we simplified things a lot in <code>readNumber</code>. We only read in <em>integers</em>. What about floats? Or numbers in hex notation? Octal notation? We ignore them and just say that Monkey doesn’t support this. Of course, the reason for this is again the educational aim and limited scope of this book.</p>\n<p>It’s time to pop the champagne and celebrate: we successfully turned the small subset of the Monkey language we used in the our test case into tokens!</p>\n<p>With this victory under our belt, it’s easy to extend the lexer so it can tokenize a lot more of Monkey source code.</p>\n</section>\n<section id=\"extending-our-token-set-and-lexer\" class=\"level2\" data-number=\"1.4\">\n<h2 data-number=\"1.4\">1.4 - Extending our Token Set and Lexer</h2>\n<p>In order to eliminate the need to jump between packages when later writing our parser, we need to extend our lexer so it can recognize more of the Monkey language and output more tokens. So in this section we will add support for <code>==</code>, <code>!</code>, <code>!=</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>&lt;</code>, <code>&gt;</code> and the keywords <code>true</code>, <code>false</code>, <code>if</code>, <code>else</code> and <code>return</code>.</p>\n<p>The new tokens we will need to add, build and output can be classified as one of these three: one-character token (e.g.\u{a0}<code>-</code>), two-character token (e.g.\u{a0}<code>==</code>) and keyword token (e.g.\u{a0}<code>return</code>). We already know how to handle one-character and keyword tokens, so we add support for these first, before extending the lexer for two-character tokens.</p>\n<p>Adding support for <code>-</code>, <code>/</code>, <code>*</code>, <code>&lt;</code> and <code>&gt;</code> is trivial. The first thing we need to do, of course, is modify the input of our test case in <code>lexer/lexer_test.go</code> to include these characters. Just like we did before. In the code accompanying this chapter you can also find the extended <code>tests</code> table, which I won’t show in the remainder of this chapter, in order to save space and to keep you from getting bored.</p>\n<div class=\"sourceCode\" id=\"cb24\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb24-1\"><a href=\"#cb24-1\"></a><span class=\"co\">// lexer/lexer_test.go</span></span>\n<span id=\"cb24-2\"><a href=\"#cb24-2\"></a></span>\n<span id=\"cb24-3\"><a href=\"#cb24-3\"></a><span class=\"kw\">func</span> TestNextToken(t *testing.T) {</span>\n<span id=\"cb24-4\"><a href=\"#cb24-4\"></a>    input := <span class=\"st\">`let five = 5;</span></span>\n<span id=\"cb24-5\"><a href=\"#cb24-5\"></a><span class=\"st\">let ten = 10;</span></span>\n<span id=\"cb24-6\"><a href=\"#cb24-6\"></a></span>\n<span id=\"cb24-7\"><a href=\"#cb24-7\"></a><span class=\"st\">let add = fn(x, y) {</span></span>\n<span id=\"cb24-8\"><a href=\"#cb24-8\"></a><span class=\"st\">  x + y;</span></span>\n<span id=\"cb24-9\"><a href=\"#cb24-9\"></a><span class=\"st\">};</span></span>\n<span id=\"cb24-10\"><a href=\"#cb24-10\"></a></span>\n<span id=\"cb24-11\"><a href=\"#cb24-11\"></a><span class=\"st\">let result = add(five, ten);</span></span>\n<span id=\"cb24-12\"><a href=\"#cb24-12\"></a><span class=\"st\">!-/*5;</span></span>\n<span id=\"cb24-13\"><a href=\"#cb24-13\"></a><span class=\"st\">5 &lt; 10 &gt; 5;</span></span>\n<span id=\"cb24-14\"><a href=\"#cb24-14\"></a><span class=\"st\">`</span></span>\n<span id=\"cb24-15\"><a href=\"#cb24-15\"></a></span>\n<span id=\"cb24-16\"><a href=\"#cb24-16\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb24-17\"><a href=\"#cb24-17\"></a>}</span></code></pre></div>\n<p>Note that although the input looks like an actual piece of Monkey source code, some lines don’t really make sense, with gibberish like <code>!-/*5</code>. That’s okay. The lexer’s job is not to tell us whether code makes sense, works or contains errors. That comes in a later stage. The lexer should only turn this input into tokens. For that reason the test cases I write for lexers cover all tokens and also try to provoke off-by-one errors, edge cases at end-of-file, newline handling, multi-digit number parsing and so on. That’s why the “code” looks like gibberish.</p>\n<p>Running the test we get <code>undefined:</code> errors, because the tests contain references to undefined <code>TokenType</code>s. To fix them we add the following constants to <code>token/token.go</code>:</p>\n<div class=\"sourceCode\" id=\"cb25\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb25-1\"><a href=\"#cb25-1\"></a><span class=\"co\">// token/token.go</span></span>\n<span id=\"cb25-2\"><a href=\"#cb25-2\"></a></span>\n<span id=\"cb25-3\"><a href=\"#cb25-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb25-4\"><a href=\"#cb25-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb25-5\"><a href=\"#cb25-5\"></a></span>\n<span id=\"cb25-6\"><a href=\"#cb25-6\"></a>    <span class=\"co\">// Operators</span></span>\n<span id=\"cb25-7\"><a href=\"#cb25-7\"></a>    ASSIGN   = <span class=\"st\">&quot;=&quot;</span></span>\n<span id=\"cb25-8\"><a href=\"#cb25-8\"></a>    PLUS     = <span class=\"st\">&quot;+&quot;</span></span>\n<span id=\"cb25-9\"><a href=\"#cb25-9\"></a>    MINUS    = <span class=\"st\">&quot;-&quot;</span></span>\n<span id=\"cb25-10\"><a href=\"#cb25-10\"></a>    BANG     = <span class=\"st\">&quot;!&quot;</span></span>\n<span id=\"cb25-11\"><a href=\"#cb25-11\"></a>    ASTERISK = <span class=\"st\">&quot;*&quot;</span></span>\n<span id=\"cb25-12\"><a href=\"#cb25-12\"></a>    SLASH    = <span class=\"st\">&quot;/&quot;</span></span>\n<span id=\"cb25-13\"><a href=\"#cb25-13\"></a></span>\n<span id=\"cb25-14\"><a href=\"#cb25-14\"></a>    LT = <span class=\"st\">&quot;&lt;&quot;</span></span>\n<span id=\"cb25-15\"><a href=\"#cb25-15\"></a>    GT = <span class=\"st\">&quot;&gt;&quot;</span></span>\n<span id=\"cb25-16\"><a href=\"#cb25-16\"></a></span>\n<span id=\"cb25-17\"><a href=\"#cb25-17\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb25-18\"><a href=\"#cb25-18\"></a>)</span></code></pre></div>\n<p>With the new constants added, the tests still fail, because we don’t return the tokens with the expected <code>TokenType</code>s.</p>\n<div class=\"sourceCode\" id=\"cb26\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb26-1\"><a href=\"#cb26-1\"></a>$ go test ./lexer</span>\n<span id=\"cb26-2\"><a href=\"#cb26-2\"></a>--- FAIL: TestNextToken (0.00s)</span>\n<span id=\"cb26-3\"><a href=\"#cb26-3\"></a>  lexer_test.go:84: tests[36] - tokentype wrong. expected=&quot;!&quot;, got=&quot;ILLEGAL&quot;</span>\n<span id=\"cb26-4\"><a href=\"#cb26-4\"></a>FAIL</span>\n<span id=\"cb26-5\"><a href=\"#cb26-5\"></a>FAIL    monkey/lexer 0.007s</span></code></pre></div>\n<p>Turning these tests from failing to passing requires us to extend our switch statement in the <code>NextToken()</code> method of <code>Lexer</code>:</p>\n<div class=\"sourceCode\" id=\"cb27\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb27-1\"><a href=\"#cb27-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb27-2\"><a href=\"#cb27-2\"></a></span>\n<span id=\"cb27-3\"><a href=\"#cb27-3\"></a><span class=\"kw\">func</span> (l *Lexer) NextToken() token.Token {</span>\n<span id=\"cb27-4\"><a href=\"#cb27-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb27-5\"><a href=\"#cb27-5\"></a>    <span class=\"kw\">switch</span> l.ch {</span>\n<span id=\"cb27-6\"><a href=\"#cb27-6\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;=&#39;</span>:</span>\n<span id=\"cb27-7\"><a href=\"#cb27-7\"></a>        tok = newToken(token.ASSIGN, l.ch)</span>\n<span id=\"cb27-8\"><a href=\"#cb27-8\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;+&#39;</span>:</span>\n<span id=\"cb27-9\"><a href=\"#cb27-9\"></a>        tok = newToken(token.PLUS, l.ch)</span>\n<span id=\"cb27-10\"><a href=\"#cb27-10\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;-&#39;</span>:</span>\n<span id=\"cb27-11\"><a href=\"#cb27-11\"></a>        tok = newToken(token.MINUS, l.ch)</span>\n<span id=\"cb27-12\"><a href=\"#cb27-12\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;!&#39;</span>:</span>\n<span id=\"cb27-13\"><a href=\"#cb27-13\"></a>        tok = newToken(token.BANG, l.ch)</span>\n<span id=\"cb27-14\"><a href=\"#cb27-14\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;/&#39;</span>:</span>\n<span id=\"cb27-15\"><a href=\"#cb27-15\"></a>        tok = newToken(token.SLASH, l.ch)</span>\n<span id=\"cb27-16\"><a href=\"#cb27-16\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;*&#39;</span>:</span>\n<span id=\"cb27-17\"><a href=\"#cb27-17\"></a>        tok = newToken(token.ASTERISK, l.ch)</span>\n<span id=\"cb27-18\"><a href=\"#cb27-18\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;&lt;&#39;</span>:</span>\n<span id=\"cb27-19\"><a href=\"#cb27-19\"></a>        tok = newToken(token.LT, l.ch)</span>\n<span id=\"cb27-20\"><a href=\"#cb27-20\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;&gt;&#39;</span>:</span>\n<span id=\"cb27-21\"><a href=\"#cb27-21\"></a>        tok = newToken(token.GT, l.ch)</span>\n<span id=\"cb27-22\"><a href=\"#cb27-22\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;;&#39;</span>:</span>\n<span id=\"cb27-23\"><a href=\"#cb27-23\"></a>        tok = newToken(token.SEMICOLON, l.ch)</span>\n<span id=\"cb27-24\"><a href=\"#cb27-24\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;,&#39;</span>:</span>\n<span id=\"cb27-25\"><a href=\"#cb27-25\"></a>        tok = newToken(token.COMMA, l.ch)</span>\n<span id=\"cb27-26\"><a href=\"#cb27-26\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb27-27\"><a href=\"#cb27-27\"></a>}</span></code></pre></div>\n<p>The tokens are now added and the cases of the switch statement have been reordered to reflect the structure of the constants in <code>token/token.go</code>. This small change makes our tests pass:</p>\n<div class=\"sourceCode\" id=\"cb28\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb28-1\"><a href=\"#cb28-1\"></a>$ go test ./lexer</span>\n<span id=\"cb28-2\"><a href=\"#cb28-2\"></a>ok      monkey/lexer 0.007s</span></code></pre></div>\n<p>The new one-character tokens have been successfully added. Next step: add the new keywords <code>true</code>, <code>false</code>, <code>if</code>, <code>else</code> and <code>return</code>.</p>\n<p>Again, the first step is to extend the input in our test to include these new keywords. Here is what the <code>input</code> in <code>TestNextToken</code> looks like now:</p>\n<div class=\"sourceCode\" id=\"cb29\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb29-1\"><a href=\"#cb29-1\"></a><span class=\"co\">// lexer/lexer_test.go</span></span>\n<span id=\"cb29-2\"><a href=\"#cb29-2\"></a></span>\n<span id=\"cb29-3\"><a href=\"#cb29-3\"></a><span class=\"kw\">func</span> TestNextToken(t *testing.T) {</span>\n<span id=\"cb29-4\"><a href=\"#cb29-4\"></a>    input := <span class=\"st\">`let five = 5;</span></span>\n<span id=\"cb29-5\"><a href=\"#cb29-5\"></a><span class=\"st\">let ten = 10;</span></span>\n<span id=\"cb29-6\"><a href=\"#cb29-6\"></a></span>\n<span id=\"cb29-7\"><a href=\"#cb29-7\"></a><span class=\"st\">let add = fn(x, y) {</span></span>\n<span id=\"cb29-8\"><a href=\"#cb29-8\"></a><span class=\"st\">  x + y;</span></span>\n<span id=\"cb29-9\"><a href=\"#cb29-9\"></a><span class=\"st\">};</span></span>\n<span id=\"cb29-10\"><a href=\"#cb29-10\"></a></span>\n<span id=\"cb29-11\"><a href=\"#cb29-11\"></a><span class=\"st\">let result = add(five, ten);</span></span>\n<span id=\"cb29-12\"><a href=\"#cb29-12\"></a><span class=\"st\">!-/*5;</span></span>\n<span id=\"cb29-13\"><a href=\"#cb29-13\"></a><span class=\"st\">5 &lt; 10 &gt; 5;</span></span>\n<span id=\"cb29-14\"><a href=\"#cb29-14\"></a></span>\n<span id=\"cb29-15\"><a href=\"#cb29-15\"></a><span class=\"st\">if (5 &lt; 10) {</span></span>\n<span id=\"cb29-16\"><a href=\"#cb29-16\"></a><span class=\"st\">    return true;</span></span>\n<span id=\"cb29-17\"><a href=\"#cb29-17\"></a><span class=\"st\">} else {</span></span>\n<span id=\"cb29-18\"><a href=\"#cb29-18\"></a><span class=\"st\">    return false;</span></span>\n<span id=\"cb29-19\"><a href=\"#cb29-19\"></a><span class=\"st\">}`</span></span>\n<span id=\"cb29-20\"><a href=\"#cb29-20\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb29-21\"><a href=\"#cb29-21\"></a>}</span></code></pre></div>\n<p>The tests do not even compile since the references in the test expectations to the new keywords are undefined. Fixing that, again, means just adding new constants and in this case, adding the keywords to the lookup table for <code>LookupIdent()</code>.</p>\n<div class=\"sourceCode\" id=\"cb30\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb30-1\"><a href=\"#cb30-1\"></a><span class=\"co\">// token/token.go</span></span>\n<span id=\"cb30-2\"><a href=\"#cb30-2\"></a></span>\n<span id=\"cb30-3\"><a href=\"#cb30-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb30-4\"><a href=\"#cb30-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb30-5\"><a href=\"#cb30-5\"></a></span>\n<span id=\"cb30-6\"><a href=\"#cb30-6\"></a>    <span class=\"co\">// Keywords</span></span>\n<span id=\"cb30-7\"><a href=\"#cb30-7\"></a>    FUNCTION = <span class=\"st\">&quot;FUNCTION&quot;</span></span>\n<span id=\"cb30-8\"><a href=\"#cb30-8\"></a>    LET      = <span class=\"st\">&quot;LET&quot;</span></span>\n<span id=\"cb30-9\"><a href=\"#cb30-9\"></a>    TRUE     = <span class=\"st\">&quot;TRUE&quot;</span></span>\n<span id=\"cb30-10\"><a href=\"#cb30-10\"></a>    FALSE    = <span class=\"st\">&quot;FALSE&quot;</span></span>\n<span id=\"cb30-11\"><a href=\"#cb30-11\"></a>    IF       = <span class=\"st\">&quot;IF&quot;</span></span>\n<span id=\"cb30-12\"><a href=\"#cb30-12\"></a>    ELSE     = <span class=\"st\">&quot;ELSE&quot;</span></span>\n<span id=\"cb30-13\"><a href=\"#cb30-13\"></a>    RETURN   = <span class=\"st\">&quot;RETURN&quot;</span></span>\n<span id=\"cb30-14\"><a href=\"#cb30-14\"></a>)</span>\n<span id=\"cb30-15\"><a href=\"#cb30-15\"></a></span>\n<span id=\"cb30-16\"><a href=\"#cb30-16\"></a><span class=\"kw\">var</span> keywords = <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]TokenType{</span>\n<span id=\"cb30-17\"><a href=\"#cb30-17\"></a>    <span class=\"st\">&quot;fn&quot;</span>:     FUNCTION,</span>\n<span id=\"cb30-18\"><a href=\"#cb30-18\"></a>    <span class=\"st\">&quot;let&quot;</span>:    LET,</span>\n<span id=\"cb30-19\"><a href=\"#cb30-19\"></a>    <span class=\"st\">&quot;true&quot;</span>:   TRUE,</span>\n<span id=\"cb30-20\"><a href=\"#cb30-20\"></a>    <span class=\"st\">&quot;false&quot;</span>:  FALSE,</span>\n<span id=\"cb30-21\"><a href=\"#cb30-21\"></a>    <span class=\"st\">&quot;if&quot;</span>:     IF,</span>\n<span id=\"cb30-22\"><a href=\"#cb30-22\"></a>    <span class=\"st\">&quot;else&quot;</span>:   ELSE,</span>\n<span id=\"cb30-23\"><a href=\"#cb30-23\"></a>    <span class=\"st\">&quot;return&quot;</span>: RETURN,</span>\n<span id=\"cb30-24\"><a href=\"#cb30-24\"></a>}</span></code></pre></div>\n<p>And it turns out that we not only fixed the compilation error by fixing references to undefined variables, we even made the tests pass:</p>\n<div class=\"sourceCode\" id=\"cb31\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb31-1\"><a href=\"#cb31-1\"></a>$ go test ./lexer</span>\n<span id=\"cb31-2\"><a href=\"#cb31-2\"></a>ok      monkey/lexer 0.007s</span></code></pre></div>\n<p>The lexer now recognizes the new keywords and the necessary changes were trivial, easy to predict and easy to make. I’d say a pat on the back is in order. We did a great job!</p>\n<p>But before we can move onto the next chapter and start with our parser, we still need to extend the lexer so it recognizes tokens that are composed of two characters. The tokens we want to support look like this in the source code: <code>==</code> and <code>!=</code>.</p>\n<p>At first glance you may be thinking: “why not add a new case to our switch statement and be done with it?” Since our switch statement takes the current character <code>l.ch</code> as the expression to compare against the cases, we can’t just add new cases like <code>case \"==\"</code> - the compiler won’t let us. We can’t compare our <code>l.ch</code> byte with strings like <code>\"==\"</code>.</p>\n<p>What we can do instead is to reuse the existing branches for <code>'='</code> and <code>'!'</code> and extend them. So what we’re going to do is to look ahead in the input and then determine whether to return a token for <code>=</code> or <code>==</code>. After extending <code>input</code> in <code>lexer/lexer_test.go</code> again, it now looks like this:</p>\n<div class=\"sourceCode\" id=\"cb32\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb32-1\"><a href=\"#cb32-1\"></a><span class=\"co\">// lexer/lexer_test.go</span></span>\n<span id=\"cb32-2\"><a href=\"#cb32-2\"></a></span>\n<span id=\"cb32-3\"><a href=\"#cb32-3\"></a><span class=\"kw\">func</span> TestNextToken(t *testing.T) {</span>\n<span id=\"cb32-4\"><a href=\"#cb32-4\"></a>    input := <span class=\"st\">`let five = 5;</span></span>\n<span id=\"cb32-5\"><a href=\"#cb32-5\"></a><span class=\"st\">let ten = 10;</span></span>\n<span id=\"cb32-6\"><a href=\"#cb32-6\"></a></span>\n<span id=\"cb32-7\"><a href=\"#cb32-7\"></a><span class=\"st\">let add = fn(x, y) {</span></span>\n<span id=\"cb32-8\"><a href=\"#cb32-8\"></a><span class=\"st\">  x + y;</span></span>\n<span id=\"cb32-9\"><a href=\"#cb32-9\"></a><span class=\"st\">};</span></span>\n<span id=\"cb32-10\"><a href=\"#cb32-10\"></a></span>\n<span id=\"cb32-11\"><a href=\"#cb32-11\"></a><span class=\"st\">let result = add(five, ten);</span></span>\n<span id=\"cb32-12\"><a href=\"#cb32-12\"></a><span class=\"st\">!-/*5;</span></span>\n<span id=\"cb32-13\"><a href=\"#cb32-13\"></a><span class=\"st\">5 &lt; 10 &gt; 5;</span></span>\n<span id=\"cb32-14\"><a href=\"#cb32-14\"></a></span>\n<span id=\"cb32-15\"><a href=\"#cb32-15\"></a><span class=\"st\">if (5 &lt; 10) {</span></span>\n<span id=\"cb32-16\"><a href=\"#cb32-16\"></a><span class=\"st\">    return true;</span></span>\n<span id=\"cb32-17\"><a href=\"#cb32-17\"></a><span class=\"st\">} else {</span></span>\n<span id=\"cb32-18\"><a href=\"#cb32-18\"></a><span class=\"st\">    return false;</span></span>\n<span id=\"cb32-19\"><a href=\"#cb32-19\"></a><span class=\"st\">}</span></span>\n<span id=\"cb32-20\"><a href=\"#cb32-20\"></a></span>\n<span id=\"cb32-21\"><a href=\"#cb32-21\"></a><span class=\"st\">10 == 10;</span></span>\n<span id=\"cb32-22\"><a href=\"#cb32-22\"></a><span class=\"st\">10 != 9;</span></span>\n<span id=\"cb32-23\"><a href=\"#cb32-23\"></a><span class=\"st\">`</span></span>\n<span id=\"cb32-24\"><a href=\"#cb32-24\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb32-25\"><a href=\"#cb32-25\"></a>}</span></code></pre></div>\n<p>Before we start working on the switch statement in <code>NextToken()</code>, we need to add a new helper method defined on <code>*Lexer</code> called <code>peekChar()</code>:</p>\n<div class=\"sourceCode\" id=\"cb33\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb33-1\"><a href=\"#cb33-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb33-2\"><a href=\"#cb33-2\"></a></span>\n<span id=\"cb33-3\"><a href=\"#cb33-3\"></a><span class=\"kw\">func</span> (l *Lexer) peekChar() <span class=\"dt\">byte</span> {</span>\n<span id=\"cb33-4\"><a href=\"#cb33-4\"></a>    <span class=\"kw\">if</span> l.readPosition &gt;= <span class=\"bu\">len</span>(l.input) {</span>\n<span id=\"cb33-5\"><a href=\"#cb33-5\"></a>        <span class=\"kw\">return</span> <span class=\"dv\">0</span></span>\n<span id=\"cb33-6\"><a href=\"#cb33-6\"></a>    } <span class=\"kw\">else</span> {</span>\n<span id=\"cb33-7\"><a href=\"#cb33-7\"></a>        <span class=\"kw\">return</span> l.input[l.readPosition]</span>\n<span id=\"cb33-8\"><a href=\"#cb33-8\"></a>    }</span>\n<span id=\"cb33-9\"><a href=\"#cb33-9\"></a>}</span></code></pre></div>\n<p><code>peekChar()</code> is really similar to <code>readChar()</code>, except that it doesn’t increment <code>l.position</code> and <code>l.readPosition</code>. We only want to “peek” ahead in the input and not move around in it, so we know what a call to <code>readChar()</code> would return. Most lexers and parser have such a “peek” function that looks ahead and most of the time it only returns the immediately next character. The difficulty of parsing different languages often comes down to how far you have to peek ahead (or look backwards!) in the source code to make sense of it.</p>\n<p>With <code>peekChar()</code> added, the code with the updated test input doesn’t compile. Of course, since we’re referencing undefined token constants in the tests. Fixing that, again, is easy:</p>\n<div class=\"sourceCode\" id=\"cb34\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb34-1\"><a href=\"#cb34-1\"></a><span class=\"co\">// token/token.go</span></span>\n<span id=\"cb34-2\"><a href=\"#cb34-2\"></a></span>\n<span id=\"cb34-3\"><a href=\"#cb34-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb34-4\"><a href=\"#cb34-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb34-5\"><a href=\"#cb34-5\"></a></span>\n<span id=\"cb34-6\"><a href=\"#cb34-6\"></a>    EQ     = <span class=\"st\">&quot;==&quot;</span></span>\n<span id=\"cb34-7\"><a href=\"#cb34-7\"></a>    NOT_EQ = <span class=\"st\">&quot;!=&quot;</span></span>\n<span id=\"cb34-8\"><a href=\"#cb34-8\"></a></span>\n<span id=\"cb34-9\"><a href=\"#cb34-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb34-10\"><a href=\"#cb34-10\"></a>)</span></code></pre></div>\n<p>With the references to <code>token.EQ</code> and <code>token.NOT_EQ</code> in the tests for the lexer fixed, running <code>go test</code> now returns the correct failure message:</p>\n<div class=\"sourceCode\" id=\"cb35\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb35-1\"><a href=\"#cb35-1\"></a>$ go test ./lexer</span>\n<span id=\"cb35-2\"><a href=\"#cb35-2\"></a>--- FAIL: TestNextToken (0.00s)</span>\n<span id=\"cb35-3\"><a href=\"#cb35-3\"></a>  lexer_test.go:118: tests[66] - tokentype wrong. expected=&quot;==&quot;, got=&quot;=&quot;</span>\n<span id=\"cb35-4\"><a href=\"#cb35-4\"></a>FAIL</span>\n<span id=\"cb35-5\"><a href=\"#cb35-5\"></a>FAIL    monkey/lexer 0.007s</span></code></pre></div>\n<p>When the lexer comes upon a <code>==</code> in the input it creates two <code>token.ASSIGN</code> tokens instead of one <code>token.EQ</code> token. The solution is to use our new <code>peekChar()</code> method. In the branches of the switch statement for <code>'='</code> and <code>'!'</code> we “peek” ahead. If the next token is also a <code>=</code> we create either a <code>token.EQ</code> or a <code>token.NOT_EQ</code> token:</p>\n<div class=\"sourceCode\" id=\"cb36\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb36-1\"><a href=\"#cb36-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb36-2\"><a href=\"#cb36-2\"></a></span>\n<span id=\"cb36-3\"><a href=\"#cb36-3\"></a><span class=\"kw\">func</span> (l *Lexer) NextToken() token.Token {</span>\n<span id=\"cb36-4\"><a href=\"#cb36-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb36-5\"><a href=\"#cb36-5\"></a>    <span class=\"kw\">switch</span> l.ch {</span>\n<span id=\"cb36-6\"><a href=\"#cb36-6\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;=&#39;</span>:</span>\n<span id=\"cb36-7\"><a href=\"#cb36-7\"></a>        <span class=\"kw\">if</span> l.peekChar() == <span class=\"ch\">&#39;=&#39;</span> {</span>\n<span id=\"cb36-8\"><a href=\"#cb36-8\"></a>            ch := l.ch</span>\n<span id=\"cb36-9\"><a href=\"#cb36-9\"></a>            l.readChar()</span>\n<span id=\"cb36-10\"><a href=\"#cb36-10\"></a>            literal := <span class=\"dt\">string</span>(ch) + <span class=\"dt\">string</span>(l.ch)</span>\n<span id=\"cb36-11\"><a href=\"#cb36-11\"></a>            tok = token.Token{Type: token.EQ, Literal: literal}</span>\n<span id=\"cb36-12\"><a href=\"#cb36-12\"></a>        } <span class=\"kw\">else</span> {</span>\n<span id=\"cb36-13\"><a href=\"#cb36-13\"></a>            tok = newToken(token.ASSIGN, l.ch)</span>\n<span id=\"cb36-14\"><a href=\"#cb36-14\"></a>        }</span>\n<span id=\"cb36-15\"><a href=\"#cb36-15\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb36-16\"><a href=\"#cb36-16\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;!&#39;</span>:</span>\n<span id=\"cb36-17\"><a href=\"#cb36-17\"></a>        <span class=\"kw\">if</span> l.peekChar() == <span class=\"ch\">&#39;=&#39;</span> {</span>\n<span id=\"cb36-18\"><a href=\"#cb36-18\"></a>            ch := l.ch</span>\n<span id=\"cb36-19\"><a href=\"#cb36-19\"></a>            l.readChar()</span>\n<span id=\"cb36-20\"><a href=\"#cb36-20\"></a>            literal := <span class=\"dt\">string</span>(ch) + <span class=\"dt\">string</span>(l.ch)</span>\n<span id=\"cb36-21\"><a href=\"#cb36-21\"></a>            tok = token.Token{Type: token.NOT_EQ, Literal: literal}</span>\n<span id=\"cb36-22\"><a href=\"#cb36-22\"></a>        } <span class=\"kw\">else</span> {</span>\n<span id=\"cb36-23\"><a href=\"#cb36-23\"></a>            tok = newToken(token.BANG, l.ch)</span>\n<span id=\"cb36-24\"><a href=\"#cb36-24\"></a>        }</span>\n<span id=\"cb36-25\"><a href=\"#cb36-25\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb36-26\"><a href=\"#cb36-26\"></a>}</span></code></pre></div>\n<p>Note that we save <code>l.ch</code> in a local variable before calling <code>l.readChar()</code> again. This way we don’t lose the current character and can safely advance the lexer so it leaves the <code>NextToken()</code> with <code>l.position</code> and <code>l.readPosition</code> in the correct state. If we were to start supporting more two-character tokens in Monkey, we should probably abstract the behaviour away in a method called <code>makeTwoCharToken</code> that peeks and advances if it found the right token. Because those two branches look awfully similar. For now though <code>==</code> and <code>!=</code> are the only two-character tokens in Monkey, so let’s leave it as it is and run our tests again to make sure it works:</p>\n<div class=\"sourceCode\" id=\"cb37\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb37-1\"><a href=\"#cb37-1\"></a>$ go test ./lexer</span>\n<span id=\"cb37-2\"><a href=\"#cb37-2\"></a>ok      monkey/lexer 0.006s</span></code></pre></div>\n<p>They pass! We did it! The lexer can now produce the extended set of tokens and we’re ready to write our parser. But before we do that, let’s lay another ground stone we can build upon in the coming chapters…</p>\n</section>\n<section id=\"start-of-a-repl\" class=\"level2\" data-number=\"1.5\">\n<h2 data-number=\"1.5\">1.5 - Start of a REPL</h2>\n<p>The Monkey language needs a REPL. REPL stands for “Read Eval Print Loop” and you probably know what it is from other interpreted languages: Python has a REPL, Ruby has one, every JavaScript runtime has one, most Lisps have one and a lot of other languages too. Sometimes the REPL is called “console”, sometimes “interactive mode”. The concept is the same: the REPL reads input, sends it to the interpreter for evaluation, prints the result/output of the interpreter and starts again. Read, Eval, Print, Loop.</p>\n<p>We don’t know how to fully “Eval” Monkey source code yet. We only have one part of the process that hides behind “Eval”: we can tokenize Monkey source code. But we also know how to read and print something, and I don’t think looping poses a problem.</p>\n<p>Here is a REPL that tokenizes Monkey source code and prints the tokens. Later on, we will expand on this and add parsing and evaluation to it.</p>\n<div class=\"sourceCode\" id=\"cb38\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb38-1\"><a href=\"#cb38-1\"></a><span class=\"co\">// repl/repl.go</span></span>\n<span id=\"cb38-2\"><a href=\"#cb38-2\"></a></span>\n<span id=\"cb38-3\"><a href=\"#cb38-3\"></a><span class=\"kw\">package</span> repl</span>\n<span id=\"cb38-4\"><a href=\"#cb38-4\"></a></span>\n<span id=\"cb38-5\"><a href=\"#cb38-5\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb38-6\"><a href=\"#cb38-6\"></a>    <span class=\"st\">&quot;bufio&quot;</span></span>\n<span id=\"cb38-7\"><a href=\"#cb38-7\"></a>    <span class=\"st\">&quot;fmt&quot;</span></span>\n<span id=\"cb38-8\"><a href=\"#cb38-8\"></a>    <span class=\"st\">&quot;io&quot;</span></span>\n<span id=\"cb38-9\"><a href=\"#cb38-9\"></a>    <span class=\"st\">&quot;monkey/lexer&quot;</span></span>\n<span id=\"cb38-10\"><a href=\"#cb38-10\"></a>    <span class=\"st\">&quot;monkey/token&quot;</span></span>\n<span id=\"cb38-11\"><a href=\"#cb38-11\"></a>)</span>\n<span id=\"cb38-12\"><a href=\"#cb38-12\"></a></span>\n<span id=\"cb38-13\"><a href=\"#cb38-13\"></a><span class=\"kw\">const</span> PROMPT = <span class=\"st\">&quot;&gt;&gt; &quot;</span></span>\n<span id=\"cb38-14\"><a href=\"#cb38-14\"></a></span>\n<span id=\"cb38-15\"><a href=\"#cb38-15\"></a><span class=\"kw\">func</span> Start(in io.Reader, out io.Writer) {</span>\n<span id=\"cb38-16\"><a href=\"#cb38-16\"></a>    scanner := bufio.NewScanner(in)</span>\n<span id=\"cb38-17\"><a href=\"#cb38-17\"></a></span>\n<span id=\"cb38-18\"><a href=\"#cb38-18\"></a>    <span class=\"kw\">for</span> {</span>\n<span id=\"cb38-19\"><a href=\"#cb38-19\"></a>        fmt.Fprintf(out, PROMPT)</span>\n<span id=\"cb38-20\"><a href=\"#cb38-20\"></a>        scanned := scanner.Scan()</span>\n<span id=\"cb38-21\"><a href=\"#cb38-21\"></a>        <span class=\"kw\">if</span> !scanned {</span>\n<span id=\"cb38-22\"><a href=\"#cb38-22\"></a>            <span class=\"kw\">return</span></span>\n<span id=\"cb38-23\"><a href=\"#cb38-23\"></a>        }</span>\n<span id=\"cb38-24\"><a href=\"#cb38-24\"></a></span>\n<span id=\"cb38-25\"><a href=\"#cb38-25\"></a>        line := scanner.Text()</span>\n<span id=\"cb38-26\"><a href=\"#cb38-26\"></a>        l := lexer.New(line)</span>\n<span id=\"cb38-27\"><a href=\"#cb38-27\"></a></span>\n<span id=\"cb38-28\"><a href=\"#cb38-28\"></a>        <span class=\"kw\">for</span> tok := l.NextToken(); tok.Type != token.EOF; tok = l.NextToken() {</span>\n<span id=\"cb38-29\"><a href=\"#cb38-29\"></a>            fmt.Fprintf(out, <span class=\"st\">&quot;%+v</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>, tok)</span>\n<span id=\"cb38-30\"><a href=\"#cb38-30\"></a>        }</span>\n<span id=\"cb38-31\"><a href=\"#cb38-31\"></a>    }</span>\n<span id=\"cb38-32\"><a href=\"#cb38-32\"></a>}</span></code></pre></div>\n<p>This is all pretty straightforward: read from the input source until encountering a newline, take the just read line and pass it to an instance of our lexer and finally print all the tokens the lexer gives us until we encounter EOF.</p>\n<p>In a <code>main.go</code> file (which we’ve been missing until now!) we welcome the user of the REPL and start it:</p>\n<div class=\"sourceCode\" id=\"cb39\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb39-1\"><a href=\"#cb39-1\"></a><span class=\"co\">// main.go</span></span>\n<span id=\"cb39-2\"><a href=\"#cb39-2\"></a></span>\n<span id=\"cb39-3\"><a href=\"#cb39-3\"></a><span class=\"kw\">package</span> main</span>\n<span id=\"cb39-4\"><a href=\"#cb39-4\"></a></span>\n<span id=\"cb39-5\"><a href=\"#cb39-5\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb39-6\"><a href=\"#cb39-6\"></a>    <span class=\"st\">&quot;fmt&quot;</span></span>\n<span id=\"cb39-7\"><a href=\"#cb39-7\"></a>    <span class=\"st\">&quot;os&quot;</span></span>\n<span id=\"cb39-8\"><a href=\"#cb39-8\"></a>    <span class=\"st\">&quot;os/user&quot;</span></span>\n<span id=\"cb39-9\"><a href=\"#cb39-9\"></a>    <span class=\"st\">&quot;monkey/repl&quot;</span></span>\n<span id=\"cb39-10\"><a href=\"#cb39-10\"></a>)</span>\n<span id=\"cb39-11\"><a href=\"#cb39-11\"></a></span>\n<span id=\"cb39-12\"><a href=\"#cb39-12\"></a><span class=\"kw\">func</span> main() {</span>\n<span id=\"cb39-13\"><a href=\"#cb39-13\"></a>    user, err := user.Current()</span>\n<span id=\"cb39-14\"><a href=\"#cb39-14\"></a>    <span class=\"kw\">if</span> err != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb39-15\"><a href=\"#cb39-15\"></a>        <span class=\"bu\">panic</span>(err)</span>\n<span id=\"cb39-16\"><a href=\"#cb39-16\"></a>    }</span>\n<span id=\"cb39-17\"><a href=\"#cb39-17\"></a>    fmt.Printf(<span class=\"st\">&quot;Hello %s! This is the Monkey programming language!</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb39-18\"><a href=\"#cb39-18\"></a>        user.Username)</span>\n<span id=\"cb39-19\"><a href=\"#cb39-19\"></a>    fmt.Printf(<span class=\"st\">&quot;Feel free to type in commands</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>)</span>\n<span id=\"cb39-20\"><a href=\"#cb39-20\"></a>    repl.Start(os.Stdin, os.Stdout)</span>\n<span id=\"cb39-21\"><a href=\"#cb39-21\"></a>}</span></code></pre></div>\n<p>And with that we can now interactively produce tokens:</p>\n<div class=\"sourceCode\" id=\"cb40\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb40-1\"><a href=\"#cb40-1\"></a>$ go run main.go</span>\n<span id=\"cb40-2\"><a href=\"#cb40-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb40-3\"><a href=\"#cb40-3\"></a>Feel free to type in commands</span>\n<span id=\"cb40-4\"><a href=\"#cb40-4\"></a>&gt;&gt; let add = fn(x, y) { x + y; };</span>\n<span id=\"cb40-5\"><a href=\"#cb40-5\"></a>{Type:LET Literal:let}</span>\n<span id=\"cb40-6\"><a href=\"#cb40-6\"></a>{Type:IDENT Literal:add}</span>\n<span id=\"cb40-7\"><a href=\"#cb40-7\"></a>{Type:= Literal:=}</span>\n<span id=\"cb40-8\"><a href=\"#cb40-8\"></a>{Type:FUNCTION Literal:fn}</span>\n<span id=\"cb40-9\"><a href=\"#cb40-9\"></a>{Type:( Literal:(}</span>\n<span id=\"cb40-10\"><a href=\"#cb40-10\"></a>{Type:IDENT Literal:x}</span>\n<span id=\"cb40-11\"><a href=\"#cb40-11\"></a>{Type:, Literal:,}</span>\n<span id=\"cb40-12\"><a href=\"#cb40-12\"></a>{Type:IDENT Literal:y}</span>\n<span id=\"cb40-13\"><a href=\"#cb40-13\"></a>{Type:) Literal:)}</span>\n<span id=\"cb40-14\"><a href=\"#cb40-14\"></a>{Type:{ Literal:{}</span>\n<span id=\"cb40-15\"><a href=\"#cb40-15\"></a>{Type:IDENT Literal:x}</span>\n<span id=\"cb40-16\"><a href=\"#cb40-16\"></a>{Type:+ Literal:+}</span>\n<span id=\"cb40-17\"><a href=\"#cb40-17\"></a>{Type:IDENT Literal:y}</span>\n<span id=\"cb40-18\"><a href=\"#cb40-18\"></a>{Type:; Literal:;}</span>\n<span id=\"cb40-19\"><a href=\"#cb40-19\"></a>{Type:} Literal:}}</span>\n<span id=\"cb40-20\"><a href=\"#cb40-20\"></a>{Type:; Literal:;}</span>\n<span id=\"cb40-21\"><a href=\"#cb40-21\"></a>&gt;&gt;</span></code></pre></div>\n<p>Perfect! And <strong>now</strong> it’s time to start parsing these tokens.</p>\n</section>\n</section>\n</body>\n</html>\n" }, Chapter { title: "Parsing", sections: [Section { title: "Parsing", start_line: 0, fragment_id: Some("parsing") }, Section { title: "2.1 - Parsers", start_line: 2, fragment_id: Some("parsers") }, Section { title: "2.2 - Why not a parser generator?", start_line: 146, fragment_id: Some("why-not-a-parser-generator") }, Section { title: "2.3 - Writing a Parser for the Monkey Programming Language", start_line: 222, fragment_id: Some("writing-a-parser-for-the-monkey-programming-language") }, Section { title: "2.4 - Parser’s first steps: parsing let statements", start_line: 261, fragment_id: Some("parsers-first-steps-parsing-let-statements") }, Section { title: "2.5 - Parsing Return Statements", start_line: 961, fragment_id: Some("parsing-return-statements") }, Section { title: "2.6 - Parsing Expressions", start_line: 1096, fragment_id: Some("parsing-expressions") }, Section { title: "2.7 - How Pratt Parsing Works", start_line: 2542, fragment_id: Some("how-pratt-parsing-works") }, Section { title: "2.8 - Extending the Parser", start_line: 2979, fragment_id: Some("extending-the-parser") }, Section { title: "2.9 - Read-Parse-Print-Loop", start_line: 4339, fragment_id: Some("read-parse-print-loop") }], content_lines: [RenderedLine { text: "Parsing", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "2.1 - Parsers", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Everyone who has ever programmed has probably heard about parsers, mostly", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "by encountering a “parser error”. Or maybe heard or even said something", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "like “we need to parse this”, “after it’s parsed”, “the parser blows up with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this input”. The word “parser” is as common as “compiler”, “interpreter”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and “programming language”. Everyone knows that parsers exist. They have to,", style: Normal, search_matches: [], inline_styles: [(62, 67, Italic)], syntax_colors: [] }, RenderedLine { text: "right? Because who else would be responsible for “parser errors”?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But what is a parser exactly? What is its job and how does it do it? This is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "what Wikipedia has to say:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A parser is a software component that takes input data (frequently text)", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and builds a data structure – often some kind of parse tree, abstract syntax", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tree or other hierarchical structure – giving a structural representation", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of the input, checking for correct syntax in the process. […] The parser is", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "often preceded by a separate lexical analyser, which creates tokens from the", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "sequence of input characters;", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "For a Wikipedia article about a computer science topic this excerpt is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "remarkably easy to understand. We can even recognize our lexer in there!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A parser turns its input into a data structure that represents the input.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That sounds pretty abstract, so let me illustrate this with an example. Here", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is a little bit of JavaScript:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "> var input = '{\"name\": \"Thorsten\", \"age\": 28}';", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "> var output = JSON.parse(input);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "> output", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "{ name: 'Thorsten', age: 28 }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "> output.name", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "'Thorsten'", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "> output.age", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "28", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Our input is just some text, a string. We then pass it to a parser hidden", style: Normal, search_matches: [], inline_styles: [(4, 9, Code)], syntax_colors: [] }, RenderedLine { text: "behind the JSON.parse function and receive an output value. This output is", style: Normal, search_matches: [], inline_styles: [(11, 21, Code)], syntax_colors: [] }, RenderedLine { text: "the data structure that represents the input: a JavaScript object with two", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fields named name and age, their values also corresponding to the input. We", style: Normal, search_matches: [], inline_styles: [(13, 17, Code), (22, 25, Code)], syntax_colors: [] }, RenderedLine { text: "can now easily work with this data structure as demonstrated by accessing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the name and age fields.", style: Normal, search_matches: [], inline_styles: [(4, 8, Code), (13, 16, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“But”, I hear you say, “a JSON parser isn’t the same as a parser for a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programming language! They’re different!” I can see where you’re coming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "from with this, but no, they are not different. At least not on a conceptual", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "level. A JSON parser takes text as input and builds a data structure that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "represents the input. That’s exactly what the parser of a programming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language does. The difference is that in the case of a JSON parser you", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "can see the data structure when looking at the input. Whereas if you look", style: Normal, search_matches: [], inline_styles: [(8, 11, Italic)], syntax_colors: [] }, RenderedLine { text: "at this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if ((5 + 2 * 3) == 91) { return computeStuff(input1, input2); }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it’s not immediately obvious how this could be represented with a data", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "structure. This is why, at least for me, they seemed different on a deeper,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "conceptional level. My guess is that this perception of conceptional", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "difference is mainly due to a lack of familiarity with programming language", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parsers and the data structures they produce. I have a lot more experience", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "with writing JSON, parsing it with a parser and inspecting the output of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the parser than with parsing programming languages. As users of programming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "languages we seldom get to see or interact with the parsed source code, with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "its internal representation. Lisp programmers are the exception to the rule", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "– in Lisp the data structures used to represent the source code are the ones", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "used by a Lisp user. The parsed source code is easily accessible as data in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the program. “Code is data, data is code” is something you hear a lot from", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Lisp programmers.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So, in order to bring our conceptual understanding of programming language", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parsers up to the level of our familiarity and intuitiveness with parsers of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "serialization languages (like JSON, YAML, TOML, INI, and so on) we need to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "understand the data structures they produce.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In most interpreters and compilers the data structure used for the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "internal representation of the source code is called a “syntax tree” or an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“abstract syntax tree” (AST for short). The “abstract” is based on the fact", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that certain details visible in the source code are omitted in the AST.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Semicolons, newlines, whitespace, comments, braces, bracket and parentheses", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "– depending on the language and the parser these details are not represented", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in the AST, but merely guide the parser when constructing it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A fact to note is that there is not one true, universal AST format that’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "used by every parser. Their implementations are all pretty similar, the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "concept is the same, but they differ in details. The concrete implementation", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "depends on the programming language being parsed.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A small example should make things clearer. Let’s say that we have the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "following source code:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (3 * 5 > 10) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "  return \"hello\";", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "} else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "  return  \"goodbye\";", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And let’s say we are using JavaScript, have a MagicLexer, a MagicParser", style: Normal, search_matches: [], inline_styles: [(48, 58, Code), (62, 73, Code)], syntax_colors: [] }, RenderedLine { text: "and the AST is built out of JavaScript objects, then the parsing step might", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "produce something like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "> var input = 'if (3 * 5 > 10) { return \"hello\"; } else { return \"goodbye\"; }';", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "> var tokens = MagicLexer.parse(input);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "> MagicParser.parse(tokens);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "  type: \"if-statement\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "  condition: {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "    type: \"operator-expression\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    operator: \">\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    left: {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "      type: \"operator-expression\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "      operator: \"*\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "      left: { type: \"integer-literal\", value: 3 },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "      right: { type: \"integer-literal\", value: 5 }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "    right: { type: \"integer-literal\", value: 10 }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "  },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "  consequence: {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    type: \"return-statement\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    returnValue: { type: \"string-literal\", value: \"hello\" }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "  },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "  alternative: {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    type: \"return-statement\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    returnValue: { type: \"string-literal\", value: \"goodbye\" }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As you can see, the output of the parser, the AST, is pretty abstract: there", style: Normal, search_matches: [], inline_styles: [(51, 53, Italic)], syntax_colors: [] }, RenderedLine { text: "are no parentheses, no semicolons and no braces. But it does represent the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "source code pretty accurately, don’t you think? I bet that you can now “see”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the AST structure when looking back at the source code!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So, this is what parsers do. They take source code as input (either as text", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "or tokens) and produce a data structure which represents this source code.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "While building up the data structure, they unavoidably analyse the input,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "checking that it conforms to the expected structure. Thus the process of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parsing is also called syntactic analysis.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In this chapter, we’re going to write our parser for the Monkey programming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language. Its input will be the tokens we defined in the previous chapter,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "produced by the lexer we already wrote. We will define our own AST, suited", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to our needs as interpreters of the Monkey programming language, and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "construct instances of this AST while recursively parsing tokens.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "2.2 - Why not a parser generator?", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Maybe you’ve already heard about parser generators, like the tools yacc,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "bison or ANTLR. Parser generators are tools that, when fed with a formal", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "description of a language, produce parsers as their output. This output is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "code that can then be compiled/interpreted and itself fed with source code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "as input to produce a syntax tree.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There are a lot of parser generators, differing in the format of the input", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "they accept and the language of the output they produce. The majority of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "them use a context-free grammar (CFG) as their input. A CFG is a set of", style: Normal, search_matches: [], inline_styles: [(11, 31, Italic)], syntax_colors: [] }, RenderedLine { text: "rules that describe how to form correct (valid according to the syntax)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "sentences in a language. The most common notational formats of CFGs are the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Backus-Naur Form (BNF) or the Extended Backus-Naur Form (EBNF).", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "PrimaryExpression ::= \"this\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "                    | ObjectLiteral", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "                    | ( \"(\" Expression \")\" )", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "                    | Identifier", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "                    | ArrayLiteral", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "                    | Literal", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "Literal ::= ( <DECIMAL_LITERAL>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "            | <HEX_INTEGER_LITERAL>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "            | <STRING_LITERAL>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            | <BOOLEAN_LITERAL>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "            | <NULL_LITERAL>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "            | <REGULAR_EXPRESSION_LITERAL> )", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "Identifier ::= <IDENTIFIER_NAME>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "ArrayLiteral ::= \"[\" ( ( Elision )? \"]\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "                 | ElementList Elision \"]\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "                 | ( ElementList )? \"]\" )", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "ElementList ::= ( Elision )? AssignmentExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "                ( Elision AssignmentExpression )*", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "Elision ::= ( \",\" )+", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "ObjectLiteral ::= \"{\" ( PropertyNameAndValueList )? \"}\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "PropertyNameAndValueList ::= PropertyNameAndValue ( \",\" PropertyNameAndValue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "                                                  | \",\" )*", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "PropertyNameAndValue ::= PropertyName \":\" AssignmentExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "PropertyName ::= Identifier", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "              | <STRING_LITERAL>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "              | <DECIMAL_LITERAL>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This is part of a full description of the EcmaScript syntax, in BNF. A", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser generator would take something like this and turn it into compilable", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "C code, for example.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Maybe you’ve also heard that you should use a parser generator instead", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of writing a parser by hand. “Just skip this part”, they say, “it’s a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "solved problem.” The reason for this recommendation is that parsers are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "exceptionally well suited to being automatically generated. Parsing is one", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of the most well-understood branches of computer science and really smart", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "people have already invested a lot of time into the problems of parsing.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The results of their work are CFG, BNF, EBNF, parser generators and advanced", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parsing techniques used in them. Why shouldn’t you take advantage of that?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I don’t think that learning to write your own parser is a waste of time.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I actually think it’s immensely valuable. Only after having written your", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "own parser, or at least attempted to, will you see the benefits parser", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "generators provide, the drawbacks they have and the problems they solve. For", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "me the concept of a parser generator only “clicked” after I wrote my first", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser. I looked at it and only then really and truly understood how it’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "possible to generate this code automatically.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Most people that recommend using a parser generator, when others want to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "get started with interpreters and compilers, only do so because they’ve", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "written a parser themselves before. They’ve seen the problems and solutions", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "available and decided it’s better to use an existing tool for the job.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And they’re correct - when you want to get something done and are in a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "production environment, where correctness and robustness are priorities. Of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "course you shouldn’t try to write your own parser then, especially not if", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "you’ve never written one before.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But we are here to learn, we want to understand how parsers work. And it’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "my opinion that the best way to do that is by getting our hands dirty and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "writing a parser ourselves. Also, I think it’s immense fun.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "2.3 - Writing a Parser for the Monkey Programming Language", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There are two main strategies when parsing a programming language: top-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "down parsing or bottom-up parsing. A lot of slightly different forms of each", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "strategy exist. For example, “recursive descent parsing”, “Early parsing” or", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“predictive parsing” are all variations of top down parsing.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The parser we are going to write is a recursive descent parser. And in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "particular, it’s a “top down operator precedence” parser, sometimes called", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“Pratt parser”, after its inventor Vaughan Pratt.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I won’t go into the details of different parsing strategies here, because", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this is neither the place nor am I qualified enough to accurately describe", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "them. Instead, let me just say, that the difference between top down", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and bottom up parsers is that the former starts with constructing root", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "node of the AST and then descends while the latter does it the other way", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "around. A recursive descent parser, which works from the top down, is often", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "recommended for newcomers to parsing, since it closely mirrors the way we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "think about ASTs and their construction. I personally found the recursive", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "approach starting at the root node really nice, even though it took writing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "some code before the concept really clicked. Which is another reason to get", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "started with the code instead of delving into parsing strategies.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now, when writing a parser ourselves, we have to make some trade-offs, yes.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Our parser won’t be the fastest of all time, we won’t have formal proof of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "its correctness and its error-recovery process and detection of erroneous", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "syntax won’t be bullet proof. The last one is especially hard to get right", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "without extensive study of the theory surrounding parsing. But what we’re", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "going to have is a fully working parser for the Monkey programming language", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that’s open for extensions and improvements, easy to understand and a great", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "start to further dive into the topic of parsing, if one were so inclined.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to start by parsing statements: let and return statements. When", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we can parse statements and the basic structure of our parser stands, we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "will look at expressions and how to parse these (this is where Vaughan Pratt", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "will come into play). Afterwards we extend the parser to make it capable of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parsing a large subset of the Monkey programming language. As we go along we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "build up the necessary structures for our AST.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "2.4 - Parser’s first steps: parsing let statements", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In Monkey, variable bindings are statements of the following form:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let x = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "let y = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "let foobar = add(5, 5);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "let barfoo = 5 * 5 / 10 + 18 - add(5, 5) + multiply(124);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "let anotherName = barfoo;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "These statements are called “let statements” and bind a value to the given", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "name. let x = 5; binds the value 5 to the name x. Our job in this section is", style: Normal, search_matches: [], inline_styles: [(7, 17, Code), (34, 35, Code), (48, 49, Code)], syntax_colors: [] }, RenderedLine { text: "to parse let statements correctly. For now we’re going to skip parsing the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions that produce the value of a given variable binding and come back", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to this later - as soon as we know how to parse expressions on their own.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What does it mean to parse let statements correctly? It means that the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser produces an AST that accurately represents the information contained", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in the original let statement. That sounds reasonable, but we don’t have", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an AST yet, nor do we know what it should look like. So our first task is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to take a close look at Monkey source code and see how it’s structured, so", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that we can define the necessary parts of an AST that’s able to accurately", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "represent let statements.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is a fully valid program written in Monkey:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let x = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "let y = 15;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(a, b) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  return a + b;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Programs in Monkey are a series of statements. In this example we can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "see three statements, three variable bindings - let statements - of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "following form:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let <identifier> = <expression>;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A let statement in Monkey consists of two changing parts: an identifier and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an expression. In the example above x, y and add are identifiers. 10, 15 and", style: Normal, search_matches: [], inline_styles: [(36, 37, Code), (39, 40, Code), (45, 48, Code), (66, 68, Code), (70, 72, Code)], syntax_colors: [] }, RenderedLine { text: "the function literal are expressions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Before we go on, a few words about the difference between statements and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions are needed. Expressions produce values, statements don’t. let", style: Normal, search_matches: [], inline_styles: [(72, 75, Code)], syntax_colors: [] }, RenderedLine { text: "x = 5 doesn’t produce a value, whereas 5 does (the value it produces is", style: Normal, search_matches: [], inline_styles: [(0, 5, Code), (41, 42, Code)], syntax_colors: [] }, RenderedLine { text: "5). A return 5; statement doesn’t produce a value, but add(5, 5) does.", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (6, 15, Code), (57, 66, Code)], syntax_colors: [] }, RenderedLine { text: "This distinction - expressions produce values, statements don’t - changes", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "depending on who you ask, but it’s good enough for our needs.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What exactly an expression is or a statement, what produces values and what", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "doesn’t, depends on the programming language. In some languages function", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "literals (e.g.: fn(x, y) { return x + y; }) are expressions and can be used", style: Normal, search_matches: [], inline_styles: [(17, 43, Code)], syntax_colors: [] }, RenderedLine { text: "in any place where any other expression is allowed. In other programming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "languages though function literals can only be part of a function", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "declaration statement, in the top level of the program. Some languages", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "also have “if expressions”, where conditionals are expressions and produce", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a value. This is entirely dependent on the choices the language designers", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "made. As you’ll see, a lot of things in Monkey are expressions, including", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function literals.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Back to our AST. Looking at the example above, we can see that it needs two", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "different types of nodes: expressions and statements. Take a look at the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "start of our AST:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package ast", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Node interface {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    TokenLiteral() string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Statement interface {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    Node", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    statementNode()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Expression interface {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    Node", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    expressionNode()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here we have three interfaces called Node, Statement and Expression. Every", style: Normal, search_matches: [], inline_styles: [(37, 41, Code), (43, 52, Code), (57, 67, Code)], syntax_colors: [] }, RenderedLine { text: "node in our AST has to implement the Node interface, meaning it has to", style: Normal, search_matches: [], inline_styles: [(37, 41, Code)], syntax_colors: [] }, RenderedLine { text: "provide a TokenLiteral() method that returns the literal value of the token", style: Normal, search_matches: [], inline_styles: [(10, 24, Code)], syntax_colors: [] }, RenderedLine { text: "it’s associated with. TokenLiteral() will be used only for debugging and", style: Normal, search_matches: [], inline_styles: [(24, 38, Code)], syntax_colors: [] }, RenderedLine { text: "testing. The AST we are going to construct consists solely of Nodes that", style: Normal, search_matches: [], inline_styles: [(63, 67, Code)], syntax_colors: [] }, RenderedLine { text: "are connected to each other - it’s a tree after all. Some of these nodes", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implement the Statement and some the Expression interface. These interfaces", style: Normal, search_matches: [], inline_styles: [(17, 26, Code), (40, 50, Code)], syntax_colors: [] }, RenderedLine { text: "only contain dummy methods called statementNode and expressionNode", style: Normal, search_matches: [], inline_styles: [(38, 51, Code), (56, 66, Code)], syntax_colors: [] }, RenderedLine { text: "respectively. They are not strictly necessary but help us by guiding the", style: Normal, search_matches: [], inline_styles: [(0, 3, Code)], syntax_colors: [] }, RenderedLine { text: "Go compiler and possibly causing it to throw errors when we use a Statement", style: Normal, search_matches: [], inline_styles: [(70, 75, Code)], syntax_colors: [] }, RenderedLine { text: "where an Expression should’ve been used, and vice versa.", style: Normal, search_matches: [], inline_styles: [(0, 3, Code), (13, 23, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And here is our first implementation of Node:", style: Normal, search_matches: [], inline_styles: [(40, 44, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Program struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Statements []Statement", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Program) TokenLiteral() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    if len(p.Statements) > 0 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        return p.Statements[0].TokenLiteral()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return \"\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This Program node is going to be the root node of every AST our parser", style: Normal, search_matches: [], inline_styles: [(5, 12, Code)], syntax_colors: [] }, RenderedLine { text: "produces. Every valid Monkey program is a series of statements. These", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statements are contained in the Program.Statements, which is just a slice of", style: Normal, search_matches: [], inline_styles: [(32, 50, Code)], syntax_colors: [] }, RenderedLine { text: "AST nodes that implement the Statement interface.", style: Normal, search_matches: [], inline_styles: [(29, 38, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With these basic building blocks for our AST construction defined, let’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "think about what a node for a variable binding in the form of let x = 5;", style: Normal, search_matches: [], inline_styles: [(63, 72, Code)], syntax_colors: [] }, RenderedLine { text: "might look like. Which fields should it have? Definitely one for the name", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "of the variable. And it also needs a field that points to the expression", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "on the right side of the equal sign. It needs to be able to point to any", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expression. It can’t just point to a literal value (the integer literal 5", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in this case), since every expression is valid after the equal sign: let x", style: Normal, search_matches: [], inline_styles: [(1, 2, Code), (72, 74, Code)], syntax_colors: [] }, RenderedLine { text: "= 5 * 5 is as valid as let y = add(2, 2) * 5 / 10;. And then the node also", style: Normal, search_matches: [], inline_styles: [(0, 11, Code), (27, 54, Code)], syntax_colors: [] }, RenderedLine { text: "needs to keep track of the token the AST node is associated with, so we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "can implement the TokenLiteral() method. That makes three fields: one for", style: Normal, search_matches: [], inline_styles: [(22, 36, Code)], syntax_colors: [] }, RenderedLine { text: "the identifier, one for the expression that produces the value in the let", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statement and one for the token.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import \"monkey/token\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type LetStatement struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token token.Token // the token.LET token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    Name  *Identifier", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (ls *LetStatement) statementNode()       {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "func (ls *LetStatement) TokenLiteral() string { return ls.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 73, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Identifier struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token token.Token // the token.IDENT token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (i *Identifier) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "func (i *Identifier) TokenLiteral() string { return i.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "LetStatement has the fields we need: Name to hold the identifier of the", style: Normal, search_matches: [], inline_styles: [(0, 12, Code), (37, 41, Code)], syntax_colors: [] }, RenderedLine { text: "binding and Value for the expression that produces the value. The two", style: Normal, search_matches: [], inline_styles: [(12, 17, Code)], syntax_colors: [] }, RenderedLine { text: "methods statementNode and TokenLiteral satisfy the Statement and Node", style: Normal, search_matches: [], inline_styles: [(8, 21, Code), (26, 38, Code), (51, 60, Code), (65, 69, Code)], syntax_colors: [] }, RenderedLine { text: "interfaces respectively.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "To hold the identifier of the binding, the x in let x = 5;, we have the", style: Normal, search_matches: [], inline_styles: [(43, 44, Code), (48, 58, Code)], syntax_colors: [] }, RenderedLine { text: "Identifier struct type, which implements the Expression interface. But the", style: Normal, search_matches: [], inline_styles: [(0, 10, Code), (45, 55, Code)], syntax_colors: [] }, RenderedLine { text: "identifier in a let statement doesn’t produce a value, right? So why is it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an Expression? It’s to keep things simple. Identifiers in other parts of a", style: Normal, search_matches: [], inline_styles: [(4, 14, Code)], syntax_colors: [] }, RenderedLine { text: "Monkey program do produce values, e.g.: let x = valueProducingIdentifier;.", style: Normal, search_matches: [], inline_styles: [(17, 19, Bold), (42, 74, Code)], syntax_colors: [] }, RenderedLine { text: "And to keep the number of different node types small, we’ll use Identifier", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (69, 76, Code)], syntax_colors: [] }, RenderedLine { text: "here to represent the name in a variable binding and later reuse it, to", style: Normal, search_matches: [], inline_styles: [(0, 3, Code)], syntax_colors: [] }, RenderedLine { text: "represent an identifier as part of or as a complete expression.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With Program, LetStatement and Identifier defined this piece of Monkey", style: Normal, search_matches: [], inline_styles: [(5, 12, Code), (14, 26, Code), (31, 41, Code)], syntax_colors: [] }, RenderedLine { text: "source code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let x = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "could be represented by an AST looking like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now that we know what it’s supposed to look like, the next task is to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "construct such an AST. So, without further ado here is the beginning of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "our parser:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/ast\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/lexer\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/token\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Parser struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    l *lexer.Lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    curToken  token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    peekToken token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := &Parser{l: l}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // Read two tokens, so curToken and peekToken are both set", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return p", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) nextToken() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.curToken = p.peekToken", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.peekToken = p.l.NextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) ParseProgram() *ast.Program {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The Parser has three fields: l, curToken and peekToken. l is a pointer to", style: Normal, search_matches: [], inline_styles: [(4, 10, Code), (29, 30, Code), (32, 40, Code), (45, 54, Code), (56, 57, Code)], syntax_colors: [] }, RenderedLine { text: "an instance of the lexer, on which we repeatedly call NextToken() to get", style: Normal, search_matches: [], inline_styles: [(54, 65, Code)], syntax_colors: [] }, RenderedLine { text: "the next token in the input. curToken and peekToken act exactly like the", style: Normal, search_matches: [], inline_styles: [(29, 37, Code), (42, 51, Code)], syntax_colors: [] }, RenderedLine { text: "two “pointers” our lexer has: position and readPosition. But instead of", style: Normal, search_matches: [], inline_styles: [(34, 42, Code), (47, 59, Code)], syntax_colors: [] }, RenderedLine { text: "pointing to a character in the input, they point to the current and the next", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "token. Both are important: we need to look at the curToken, which is the", style: Normal, search_matches: [], inline_styles: [(52, 60, Code)], syntax_colors: [] }, RenderedLine { text: "current token under examination, to decide what to do next, and we also need", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "peekToken for this decision if curToken doesn’t give us enough information.", style: Normal, search_matches: [], inline_styles: [(4, 13, Code), (35, 43, Code)], syntax_colors: [] }, RenderedLine { text: "Think of a single line only containing 5;. Then curToken is a token.INT and", style: Normal, search_matches: [], inline_styles: [(44, 46, Code), (53, 61, Code), (67, 75, Code)], syntax_colors: [] }, RenderedLine { text: "we need peekToken to decide whether we are at the end of the line or if we", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (14, 23, Code)], syntax_colors: [] }, RenderedLine { text: "are at just the start of an arithmetic expression.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The New function is pretty self-explanatory and the nextToken method is a", style: Normal, search_matches: [], inline_styles: [(4, 7, Code), (52, 61, Code)], syntax_colors: [] }, RenderedLine { text: "small helper that advances both curToken and peekToken. But ParseProgram is", style: Normal, search_matches: [], inline_styles: [(32, 40, Code), (45, 54, Code), (60, 72, Code)], syntax_colors: [] }, RenderedLine { text: "empty, for now.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now before we start writing tests and filling out the ParseProgram method", style: Normal, search_matches: [], inline_styles: [(54, 66, Code)], syntax_colors: [] }, RenderedLine { text: "I want to show you the basic idea and structure behind a recursive descent", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser. That makes it a lot easier to understand our own parser later on.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What follows are the major parts of such a parser in pseudocode. Read this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "carefully and try to understand what happens in the parseProgram function:", style: Normal, search_matches: [], inline_styles: [(52, 64, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function parseProgram() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "  program = newProgramASTNode()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  advanceTokens()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  for (currentToken() != EOF_TOKEN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    statement = null", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if (currentToken() == LET_TOKEN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "      statement = parseLetStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else if (currentToken() == RETURN_TOKEN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "      statement = parseReturnStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else if (currentToken() == IF_TOKEN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "      statement = parseIfStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if (statement != null) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "      program.Statements.push(statement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    advanceTokens()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  return program", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function parseLetStatement() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "  advanceTokens()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  identifier = parseIdentifier()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  advanceTokens()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  if currentToken() != EQUAL_TOKEN {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    parseError(\"no equal sign!\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    return null", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  advanceTokens()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  value = parseExpression()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  variableStatement = newVariableStatementASTNode()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "  variableStatement.identifier = identifier", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "  variableStatement.value = value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "  return variableStatement", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function parseIdentifier() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "  identifier = newIdentifierASTNode()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "  identifier.token = currentToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  return identifier", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function parseExpression() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "  if (currentToken() == INTEGER_TOKEN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    if (nextToken() == PLUS_TOKEN)  {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "      return parseOperatorExpression()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else if (nextToken() == SEMICOLON_TOKEN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "      return parseIntegerLiteral()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "  } else if (currentToken() == LEFT_PAREN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    return parseGroupedExpression()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function parseOperatorExpression() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "  operatorExpression = newOperatorExpression()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  operatorExpression.left = parseIntegerLiteral()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "  advanceTokens()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "  operatorExpression.operator = currentToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "  advanceTokens()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "  operatorExpression.right = parseExpression()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  return operatorExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Since this is pseudocode there are a lot of omissions, of course. But", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the basic idea behind recursive-descent parsing is there. The entry", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "point is parseProgram and it constructs the root node of the AST", style: Normal, search_matches: [], inline_styles: [(9, 21, Code)], syntax_colors: [] }, RenderedLine { text: "(newProgramASTNode()). It then builds the child nodes, the statements, by", style: Normal, search_matches: [], inline_styles: [(1, 20, Code)], syntax_colors: [] }, RenderedLine { text: "calling other functions that know which AST node to construct based on the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "current token. These other functions call each other again, recursively.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The most recursive part of this is in parseExpression and is only hinted at.", style: Normal, search_matches: [], inline_styles: [(38, 53, Code)], syntax_colors: [] }, RenderedLine { text: "But we can already see that in order to parse an expression like 5 + 5, we", style: Normal, search_matches: [], inline_styles: [(65, 70, Code)], syntax_colors: [] }, RenderedLine { text: "need to first parse 5 + and then call parseExpression() again to parse the", style: Normal, search_matches: [], inline_styles: [(20, 23, Code), (38, 55, Code)], syntax_colors: [] }, RenderedLine { text: "rest, since after the + might be another operator expression, like this: 5 +", style: Normal, search_matches: [], inline_styles: [(22, 23, Code), (73, 76, Code)], syntax_colors: [] }, RenderedLine { text: "5 * 10. We will get to this later and look at expression parsing in detail,", style: Normal, search_matches: [], inline_styles: [(0, 6, Code)], syntax_colors: [] }, RenderedLine { text: "since it’s probably the most complicated but also the most beautiful part of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the parser, making heavy use of “Pratt parsing”.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But for now, we can already see what the parser has to do. It repeatedly", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "advances the tokens and checks the current token to decide what to do next:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "either call another parsing function or throw an error. Each function then", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "does its job and possibly constructs an AST node so that the “main loop” in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseProgram() can advance the tokens and decide what to do again.", style: Normal, search_matches: [], inline_styles: [(1, 15, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If you looked at that pseudocode and thought “Well, that’s actually pretty", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "easy to understand” I have great news for you: our ParseProgram method and", style: Normal, search_matches: [], inline_styles: [(54, 66, Code)], syntax_colors: [] }, RenderedLine { text: "the parser will look pretty similar! Let’s get to work!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Again, we’re starting with a test before we flesh out ParseProgram. Here is", style: Normal, search_matches: [], inline_styles: [(56, 68, Code)], syntax_colors: [] }, RenderedLine { text: "a test case to make sure that the parsing of let statements works:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"testing\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/ast\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/lexer\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestLetStatements(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "let x = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "let y = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "let foobar = 838383;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    if program == nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"ParseProgram() returned nil\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    if len(program.Statements) != 3 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program.Statements does not contain 3 statements. got=%d\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "            len(program.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedIdentifier string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"x\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"y\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"foobar\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for i, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        stmt := program.Statements[i]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !testLetStatement(t, stmt, tt.expectedIdentifier) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "            return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testLetStatement(t *testing.T, s ast.Statement, name string) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "    if s.TokenLiteral() != \"let\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"s.TokenLiteral not 'let'. got=%q\", s.TokenLiteral())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    letStmt, ok := s.(*ast.LetStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"s not *ast.LetStatement. got=%T\", s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if letStmt.Name.Value != name {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"letStmt.Name.Value not '%s'. got=%s\", name, letStmt.Name.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 81, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if letStmt.Name.TokenLiteral() != name {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"letStmt.Name.TokenLiteral() not '%s'. got=%s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "            name, letStmt.Name.TokenLiteral())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The test case follows the same principle as the test for our lexer and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "pretty much every other unit test we’re going to write: we provide Monkey", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "source code as input and then set expectations on what we want the AST -", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that’s produced by the parser - to look like. We do this by checking as many", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fields of the AST nodes as possible to make sure that nothing is missing.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I found that a parser is a breeding ground for off-by-one bugs and the more", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tests and assertions it has the better.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I choose not to mock or stub out the lexer and provide source code as", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "input instead of tokens, since that makes the tests much more readable and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "understandable. Of course there’s the problem of bugs in the lexer blowing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "up tests for the parser and generating unneeded noise, but I deem the risk", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "too minimal, especially judged against the advantages of using readable", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "source code as input.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There are two noteworthy things about this test case. The first one is that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we ignore the Value field of the *ast.LetStatement. Why don’t we check if", style: Normal, search_matches: [], inline_styles: [(14, 19, Code), (33, 50, Code)], syntax_colors: [] }, RenderedLine { text: "the integer literals (5, 10, …) are parsed correctly? Answer: we’re going", style: Normal, search_matches: [], inline_styles: [(23, 24, Code), (26, 28, Code)], syntax_colors: [] }, RenderedLine { text: "to! But first we need to make sure that the parsing of let statements works", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and ignore the Value.", style: Normal, search_matches: [], inline_styles: [(17, 21, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The second one is the helper function testLetStatement. It might seem like", style: Normal, search_matches: [], inline_styles: [(38, 54, Code)], syntax_colors: [] }, RenderedLine { text: "over-engineering to use a separate function, but we’re going to need this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function soon enough. And then it’s going to make our test cases a lot more", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "readable than lines and lines of type conversions strewn about.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As an aside: we won’t look at all of the parser tests in this chapter, since", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "they are just too long. But the code provided with the book contains all", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of them.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That being said, the tests fail as expected:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestLetStatements (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:20: ParseProgram() returned nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser    0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s time to flesh out the ParseProgram() method of the Parser.", style: Normal, search_matches: [], inline_styles: [(29, 43, Code), (58, 64, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) ParseProgram() *ast.Program {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := &ast.Program{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    program.Statements = []ast.Statement{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for p.curToken.Type != token.EOF {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "        stmt := p.parseStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        if stmt != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            program.Statements = append(program.Statements, stmt)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return program", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Doesn’t this look really similar to the parseProgram() pseudocode function", style: Normal, search_matches: [], inline_styles: [(42, 56, Code)], syntax_colors: [] }, RenderedLine { text: "we saw earlier? See! I told you! And what it does is the same too.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing ParseProgram does is construct the root node of the AST,", style: Normal, search_matches: [], inline_styles: [(16, 28, Code)], syntax_colors: [] }, RenderedLine { text: "an *ast.Program. It then iterates over every token in the input until it", style: Normal, search_matches: [], inline_styles: [(3, 15, Code)], syntax_colors: [] }, RenderedLine { text: "encounters an token.EOF token. It does this by repeatedly calling nextToken,", style: Normal, search_matches: [], inline_styles: [(14, 23, Code), (66, 75, Code)], syntax_colors: [] }, RenderedLine { text: "which advances both p.curToken and p.peekToken. In every iteration it calls", style: Normal, search_matches: [], inline_styles: [(20, 30, Code), (35, 46, Code)], syntax_colors: [] }, RenderedLine { text: "parseStatement, whose job it is to parse a statement. If parseStatement", style: Normal, search_matches: [], inline_styles: [(0, 14, Code), (57, 71, Code)], syntax_colors: [] }, RenderedLine { text: "returned something other than nil, a ast.Statement, its return value is", style: Normal, search_matches: [], inline_styles: [(30, 33, Code), (37, 50, Code)], syntax_colors: [] }, RenderedLine { text: "added to Statements slice of the AST root node. When nothing is left to", style: Normal, search_matches: [], inline_styles: [(9, 19, Code)], syntax_colors: [] }, RenderedLine { text: "parse the *ast.Program root node is returned.", style: Normal, search_matches: [], inline_styles: [(10, 22, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The parseStatement method looks like this:", style: Normal, search_matches: [], inline_styles: [(4, 18, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseStatement() ast.Statement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch p.curToken.Type {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    case token.LET:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        return p.parseLetStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Don’t worry, the switch statement will get more branches. But for now,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it only calls parseLetStatement when it encounters a token.LET token. And", style: Normal, search_matches: [], inline_styles: [(15, 32, Code), (54, 63, Code)], syntax_colors: [] }, RenderedLine { text: "parseLetStatement is the method where we turn our tests from red to green:", style: Normal, search_matches: [], inline_styles: [(2, 19, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseLetStatement() *ast.LetStatement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    stmt := &ast.LetStatement{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.IDENT) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt.Name = &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.ASSIGN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // TODO: We're skipping the expressions until we", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    // encounter a semicolon", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    for !p.curTokenIs(token.SEMICOLON) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return stmt", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) curTokenIs(t token.TokenType) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "    return p.curToken.Type == t", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) peekTokenIs(t token.TokenType) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "    return p.peekToken.Type == t", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) expectPeek(t token.TokenType) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "    if p.peekTokenIs(t) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It works! The tests are green:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can parse let statements! That’s amazing! But, wait, how?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s start with parseLetStatement. It constructs an *ast.LetStatement", style: Normal, search_matches: [], inline_styles: [(19, 36, Code), (55, 72, Code)], syntax_colors: [] }, RenderedLine { text: "node with the token it’s currently sitting on (a token.LET token) and then", style: Normal, search_matches: [], inline_styles: [(52, 61, Code)], syntax_colors: [] }, RenderedLine { text: "advances the tokens while making assertions about the next token with calls", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to expectPeek. First it expects a token.IDENT token, which it then uses to", style: Normal, search_matches: [], inline_styles: [(6, 16, Code), (37, 48, Code)], syntax_colors: [] }, RenderedLine { text: "construct an *ast.Identifier node. Then it expects an equal sign and finally", style: Normal, search_matches: [], inline_styles: [(17, 32, Code)], syntax_colors: [] }, RenderedLine { text: "it jumps over the expression following the equal sign until it encounters a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "semicolon. The skipping of expressions will be replaced, of course, as soon", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "as we know how to parse them.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The curTokenIs and peekTokenIs methods do not need much of an explanation.", style: Normal, search_matches: [], inline_styles: [(4, 14, Code), (19, 30, Code)], syntax_colors: [] }, RenderedLine { text: "They are useful methods that we will see again and again when fleshing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "out the parser. Already, we can replace the p.curToken.Type != token.EOF", style: Normal, search_matches: [], inline_styles: [(44, 72, Code)], syntax_colors: [] }, RenderedLine { text: "condition of the for-loop in ParseProgram with !p.curTokenIs(token.EOF).", style: Normal, search_matches: [], inline_styles: [(29, 41, Code), (47, 71, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Instead of dissecting these tiny methods, let’s talk about expectPeek. The", style: Normal, search_matches: [], inline_styles: [(61, 71, Code)], syntax_colors: [] }, RenderedLine { text: "expectPeek method is one of the “assertion functions” nearly all parsers", style: Normal, search_matches: [], inline_styles: [(1, 11, Code)], syntax_colors: [] }, RenderedLine { text: "share. Their primary purpose is to enforce the correctness of the order of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tokens by checking the type of the next token. Our expectPeek here checks", style: Normal, search_matches: [], inline_styles: [(54, 64, Code)], syntax_colors: [] }, RenderedLine { text: "the type of the peekToken and only if the type is correct does it advance", style: Normal, search_matches: [], inline_styles: [(20, 29, Code)], syntax_colors: [] }, RenderedLine { text: "the tokens by calling nextToken. As you’ll see, this is something a parser", style: Normal, search_matches: [], inline_styles: [(27, 36, Code)], syntax_colors: [] }, RenderedLine { text: "does a lot.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But what happens if we encounter a token in expectPeek that’s not of the", style: Normal, search_matches: [], inline_styles: [(44, 54, Code)], syntax_colors: [] }, RenderedLine { text: "expected type? At the moment, we just return nil, which gets ignored in", style: Normal, search_matches: [], inline_styles: [(46, 49, Code)], syntax_colors: [] }, RenderedLine { text: "ParseProgram, which results in entire statements being ignored because of", style: Normal, search_matches: [], inline_styles: [(2, 14, Code)], syntax_colors: [] }, RenderedLine { text: "an error in the input. Silently. You can probably imagine that this makes", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "debugging really tough. And since nobody likes tough debugging we need to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "add error handling to our parser.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Thankfully, the changes we need to make are minimal:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"fmt\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Parser struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    errors []string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := &Parser{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "        l:      l,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        errors: []string{},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) Errors() []string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    return p.errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) peekError(t token.TokenType) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    msg := fmt.Sprintf(\"expected next token to be %s, got %s instead\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "        t, p.peekToken.Type)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.errors = append(p.errors, msg)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The Parser now has an errors field, which is just a slice of strings. This", style: Normal, search_matches: [], inline_styles: [(4, 10, Code), (22, 28, Code)], syntax_colors: [] }, RenderedLine { text: "field gets initialized in New and the helper function peekError can now be", style: Normal, search_matches: [], inline_styles: [(26, 29, Code), (54, 63, Code)], syntax_colors: [] }, RenderedLine { text: "used to add an error to errors when the type of peekToken doesn’t match the", style: Normal, search_matches: [], inline_styles: [(24, 30, Code), (48, 57, Code)], syntax_colors: [] }, RenderedLine { text: "expectation. With the Errors method we can check if the parser encountered", style: Normal, search_matches: [], inline_styles: [(23, 29, Code)], syntax_colors: [] }, RenderedLine { text: "any errors.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Extending the test suite to make use of this is as easy as you’d expect:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestLetStatements(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func checkParserErrors(t *testing.T, p *Parser) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    errors := p.Errors()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    if len(errors) == 0 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    t.Errorf(\"parser has %d errors\", len(errors))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    for _, msg := range errors {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"parser error: %q\", msg)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    t.FailNow()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The new checkParserErrors helper function does nothing more than check the", style: Normal, search_matches: [], inline_styles: [(8, 25, Code)], syntax_colors: [] }, RenderedLine { text: "parser for errors and if it has any it prints them as test errors and stops", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the execution of the current test. Pretty straightforward.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But nothing in our parser creates errors yet. By changing expectPeek we can", style: Normal, search_matches: [], inline_styles: [(58, 68, Code)], syntax_colors: [] }, RenderedLine { text: "automatically add an error every time one of our expectations about the next", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "token was wrong:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) expectPeek(t token.TokenType) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "    if p.peekTokenIs(t) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.peekError(t)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If we now change our test case input from this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    input := `", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "let x = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "let y = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "let foobar = 838383;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to this invalid input where tokens are missing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    input := `", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "let x 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "let = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "let 838383;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we can run our tests to see our new parser errors:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestLetStatements (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:20: parser has 3 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:22: parser error: \"expected next token to be =,\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "    got INT instead\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:22: parser error: \"expected next token to be IDENT,\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "    got = instead\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:22: parser error: \"expected next token to be IDENT,\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "    got INT instead\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As you can see, our parser showcases a neat little feature here: it gives", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "us errors for each erroneous statement it encounters. It doesn’t exit on", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the first one, potentially saving us the grunt work of rerunning the parsing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "process again and again to catch all of the syntax errors. That’s pretty", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "helpful - even with line and column numbers missing.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "2.5 - Parsing Return Statements", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I said earlier that we’re going to flesh out our sparse looking ParseProgram", style: Normal, search_matches: [], inline_styles: [(66, 78, Code)], syntax_colors: [] }, RenderedLine { text: "method. Now’s the time. We’re going to parse return statements. And the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "first step, as with let statements before them, is to define the necessary", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "structures in the ast package with which we can represent return statements", style: Normal, search_matches: [], inline_styles: [(21, 24, Code)], syntax_colors: [] }, RenderedLine { text: "in our AST.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is what return statements look like in Monkey:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "return 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "return 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "return add(15);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Experienced with let statements, we can easily spot the structure behind", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "these statements:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "return <expression>;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Return statements consist solely of the keyword return and an expression.", style: Normal, search_matches: [], inline_styles: [(48, 54, Code)], syntax_colors: [] }, RenderedLine { text: "That makes the definition of ast.ReturnStatement really simple:", style: Normal, search_matches: [], inline_styles: [(29, 48, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type ReturnStatement struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token       token.Token // the 'return' token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    ReturnValue Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (rs *ReturnStatement) statementNode()       {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "func (rs *ReturnStatement) TokenLiteral() string { return rs.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There is nothing about this node that you haven’t seen before: it has a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "field for the initial token and a ReturnValue field that will contain the", style: Normal, search_matches: [], inline_styles: [(35, 46, Code)], syntax_colors: [] }, RenderedLine { text: "expression that’s to be returned. We will again skip the parsing of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions and the semicolon handling for now, but will come back to this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "later. The statementNode and TokenLiteral methods are there to fulfill the", style: Normal, search_matches: [], inline_styles: [(15, 28, Code), (33, 45, Code)], syntax_colors: [] }, RenderedLine { text: "Node and Statement interfaces and look identical to the methods defined", style: Normal, search_matches: [], inline_styles: [(4, 8, Code), (13, 22, Code)], syntax_colors: [] }, RenderedLine { text: "on *ast.LetStatement.", style: Normal, search_matches: [], inline_styles: [(7, 21, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The test we write next also looks pretty similar to the one for let", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statements:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestReturnStatements(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "return 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "return 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "return 993322;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(program.Statements) != 3 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program.Statements does not contain 3 statements. got=%d\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "            len(program.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, stmt := range program.Statements {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        returnStmt, ok := stmt.(*ast.ReturnStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Errorf(\"stmt not *ast.ReturnStatement. got=%T\", stmt)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "            continue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        if returnStmt.TokenLiteral() != \"return\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Errorf(\"returnStmt.TokenLiteral not 'return', got %q\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "                returnStmt.TokenLiteral())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of course these test cases will also have to be extended as soon as", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expression parsing is in place. But that’s okay, tests are not immutable.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But they are, in fact, failing:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestReturnStatements (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:77: program.Statements does not contain 3 statements. got=0", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So let’s make them pass by changing our parseStatement method to also take", style: Normal, search_matches: [], inline_styles: [(42, 56, Code)], syntax_colors: [] }, RenderedLine { text: "token.RETURN tokens into account:", style: Normal, search_matches: [], inline_styles: [(1, 13, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseStatement() ast.Statement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch p.curToken.Type {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    case token.LET:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        return p.parseLetStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    case token.RETURN:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        return p.parseReturnStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I could make a lot of fuss about the parseReturnStatement method before", style: Normal, search_matches: [], inline_styles: [(37, 57, Code)], syntax_colors: [] }, RenderedLine { text: "showing it to you, but, well, I won’t. Because it’s tiny. There is nothing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to fuss about.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseReturnStatement() *ast.ReturnStatement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    stmt := &ast.ReturnStatement{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // TODO: We're skipping the expressions until we", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    // encounter a semicolon", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    for !p.curTokenIs(token.SEMICOLON) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return stmt", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I told you: it’s tiny. The only thing it does is construct an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "ast.ReturnStatement, with the current token it’s sitting on as Token.", style: Normal, search_matches: [], inline_styles: [(1, 20, Code), (66, 71, Code)], syntax_colors: [] }, RenderedLine { text: "It then brings the parser in place for the expression that comes next by", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "calling nextToken() and finally, there’s the cop-out. It skips over every", style: Normal, search_matches: [], inline_styles: [(10, 21, Code)], syntax_colors: [] }, RenderedLine { text: "expression until it encounters a semicolon. That’s it. Our tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.009s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s time to celebrate again! We can now parse all of the statements in the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Monkey programming language! That’s right: there are only two of them. Let", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statements and return statements. The rest of the language consists solely", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of expressions. And that’s what we’re going to parse next.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "2.6 - Parsing Expressions", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Personally, I think that parsing expressions is the most interesting part", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of writing a parser. As we just saw, parsing statements is relatively", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "straightforward. We process tokens from “left to right”, expect or reject", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the next tokens and if everything fits we return an AST node.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Parsing expressions, on the other hand, contains a few more challenges.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Operator precedence is probably the first one that comes to mind and is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "best illustrated with an example. Let’s say we want to parse the following", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "arithmetic expression:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 * 5 + 10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What we want here is an AST that represents the expression like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "((5 * 5) + 10)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That is to say, 5 * 5 needs to be “deeper” in the AST and evaluated earlier", style: Normal, search_matches: [], inline_styles: [(16, 21, Code)], syntax_colors: [] }, RenderedLine { text: "than the addition. In order to produce an AST that looks like this, the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser has to know about operator precedences where the precedence of * is", style: Normal, search_matches: [], inline_styles: [(72, 73, Code)], syntax_colors: [] }, RenderedLine { text: "higher than +. That’s the most common example for operator precedence, but", style: Normal, search_matches: [], inline_styles: [(15, 16, Code)], syntax_colors: [] }, RenderedLine { text: "there are a lot more cases where it’s important. Consider this expression:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 * (5 + 10)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here the parenthesis group together the 5 + 10 expression and give them", style: Normal, search_matches: [], inline_styles: [(40, 46, Code)], syntax_colors: [] }, RenderedLine { text: "a “precedence bump”: the addition now has to be evaluated before the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "multiplication. That’s because parentheses have a higher precedence than the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "* operator. As we will soon see, there are a few more cases where precedence", style: Normal, search_matches: [], inline_styles: [(2, 3, Code)], syntax_colors: [] }, RenderedLine { text: "is playing a crucial role.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The other big challenge is that in expressions tokens of the same type can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "appear in multiple positions. In contrast to this, the let token can only", style: Normal, search_matches: [], inline_styles: [(55, 58, Code)], syntax_colors: [] }, RenderedLine { text: "appear once at the beginning of a let statement, which makes it easy to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "determine what the rest of the statement is supposed to be. Now look at", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this expression:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "-5 - 10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here the - operator appears at the beginning of the expression, as a prefix", style: Normal, search_matches: [], inline_styles: [(9, 10, Code)], syntax_colors: [] }, RenderedLine { text: "operator, and then as an infix operator in the middle. A variation of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "same challenge appears here:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 * (add(2, 3) + 10)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Even though you might not recognize the parentheses as operators yet, they", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "pose the same problem to us as the - in the previous example. The outer pair", style: Normal, search_matches: [], inline_styles: [(35, 36, Code)], syntax_colors: [] }, RenderedLine { text: "of parentheses in this example denotes a grouped expression. The inner pair", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "denotes a “call expression”. The validity of a token’s position now depends", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "on the context, the tokens that come before and after, and their precedence.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Expressions in Monkey", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In the Monkey programming language everything besides let and return", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statements is an expression. These expressions come in different varieties.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Monkey has expressions involving prefix operators:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "-5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "!true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "!false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And of course it has infix operators (or “binary operators”):", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 + 5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "5 - 5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "5 / 5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "5 * 5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides these basic arithmetic operators, there are also the following", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "comparison operators:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "foo == bar", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "foo != bar", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "foo < bar", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "foo > bar", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And of course, as we previously saw, we can use parentheses to group", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions and influence the order of evaluation:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 * (5 + 5)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "((5 + 5) * 5) * 5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Then there are call expressions:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "add(2, 3)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "add(add(2, 3), add(5, 10))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "max(5, add(5, (5 * 5)))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Identifiers are expressions too:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "foo * bar / foobar", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "add(foo, bar)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Functions in Monkey are first-class citizens and, yes, function literals are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions too. We can use a let statement to bind a function to a name.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The function literal is just the expression in the statement:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(x, y) { return x + y };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And here we use a function literal in place of an identifier:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fn(x, y) { return x + y }(5, 5)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "(fn(x) { return x }(5) + 10 ) * 10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In contrast to a lot of widely used programming languages we also have “if", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions” in Monkey:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let result = if (10 > 5) { true } else { false };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "result // => true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Looking at all these different forms of expressions it becomes clear that we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "need a really good approach to parse them correctly and in an understandable", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and extendable way. Our old approach of deciding what to do based on the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "current token won’t get us very far - at least not without wanting to tear", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "our hair out. And that is where Vaughan Pratt comes in.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Top Down Operator Precedence (or: Pratt Parsing)", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In his paper “Top Down Operator Precedence” Vaughan Pratt presents an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "approach to parsing expressions that, in his own words:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[…] is very simple to understand, trivial to implement, easy to use,", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "extremely efficient in practice if not in theory, yet flexible enough to", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "meet most reasonable syntactic needs of users […]", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Quote, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The paper was published in 1973 but in the many years since then the ideas", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "presented by Pratt didn’t gain a huge following. Only in recent years, other", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programmers rediscovered Pratt’s paper, wrote about it and caused Pratt’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "approach to parsing to rise in popularity. There’s Douglas Crockford’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "(of “JavaScript: The Good Parts” fame) article called “Top Down Operator", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Precedence” that shows how to translate Pratt’s ideas to JavaScript (which", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Crockford did when building JSLint). And then there’s the highly recommended", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "article by Bob Nystrom, author of the excellent “Game Programming Patterns”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "book, that makes Pratt’s approach really easy to understand and to follow by", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "providing clean example code in Java.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The parsing approach described by all three, which is called Top Down", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Operator Precedence Parsing, or Pratt parsing, was invented as an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "alternative to parsers based on context-free grammars and the Backus-Naur-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Form.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that is also the main difference: instead of associating parsing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "functions (think of our parseLetStatement method here) with grammar rules", style: Normal, search_matches: [], inline_styles: [(24, 41, Code)], syntax_colors: [] }, RenderedLine { text: "(defined in BNF or EBNF), Pratt associates these functions (which he calls", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“semantic code”) with single token types. A crucial part of this idea is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that each token type can have two parsing functions associated with it,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "depending on the token’s position - infix or prefix.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I guess that doesn’t make a lot of sense yet. We never saw how to associate", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parsing functions with grammar rules, so the idea of using token types", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "instead of these rules doesn’t register as anything really novel or", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "revelatory. To be completely honest: I was facing a chicken-and-egg problem", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "when writing this section. Is it better to explain this algorithm in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "abstract terms and then show the implementation, possibly causing you to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "jump back and forth between pages, or to show the implementation with the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "explanation following, causing you to probably skip over the implementation", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and not getting a lot out of the explanation?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The answer, I decided, is neither of these two options. What we’re going", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to do instead is start implementing the expression parsing part of our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser. Then we’re going to take a closer look at it and its algorithm.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Afterwards we will extend and complete it so it’s able to parse all possible", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions in Monkey.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And before we start writing any code, let’s just be clear on the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "terminology.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Terminology", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A prefix operator is an operator “in front of” its operand. Example:", style: Normal, search_matches: [], inline_styles: [(2, 17, Bold)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "--5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here the operator is -- (decrement), the operand is the integer literal 5", style: Normal, search_matches: [], inline_styles: [(21, 23, Code), (72, 73, Code)], syntax_colors: [] }, RenderedLine { text: "and the operator is in the prefix position.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A postfix operator is an operator “after” its operand. Example:", style: Normal, search_matches: [], inline_styles: [(2, 18, Bold)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "foobar++", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here the operator is ++ (increment), the operand is the identifier foobar", style: Normal, search_matches: [], inline_styles: [(21, 23, Code), (67, 73, Code)], syntax_colors: [] }, RenderedLine { text: "and the operator is in the postfix position. The Monkey interpreter", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we’ll build won’t have postfix operators. Not because of some technical", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "limitations, but purely in order to keep the scope of the book limited.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now, infix operators are something we’ve all seen before. An infix operator", style: Normal, search_matches: [], inline_styles: [(5, 20, Bold)], syntax_colors: [] }, RenderedLine { text: "sits between its operands, like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 * 8", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The * operator sits in the infix position between the two integer literals 5", style: Normal, search_matches: [], inline_styles: [(4, 5, Code), (75, 76, Code)], syntax_colors: [] }, RenderedLine { text: "and 8. Infix operators appear in binary expressions - where the operator has", style: Normal, search_matches: [], inline_styles: [(4, 5, Code), (33, 51, Bold)], syntax_colors: [] }, RenderedLine { text: "two operands.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The other term we already stumbled upon and will find again later is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operator precedence. An alternative term for this is order of operations,", style: Normal, search_matches: [], inline_styles: [(0, 19, Bold), (53, 72, Bold)], syntax_colors: [] }, RenderedLine { text: "which should make clearer what operator precedence describes: which priority", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "do different operators have. The canonical example is this one, which we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "saw earlier:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 + 5 * 10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The result of this expression is 55 and not 100. And that’s because the *", style: Normal, search_matches: [], inline_styles: [(33, 35, Code), (44, 47, Code), (74, 75, Code)], syntax_colors: [] }, RenderedLine { text: "operator has a higher precedence, a “higher rank”. It’s “more important”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "than the + operator. It gets evaluated before the other operator. I", style: Normal, search_matches: [], inline_styles: [(10, 11, Code)], syntax_colors: [] }, RenderedLine { text: "sometimes think of operator precedence as “operator stickiness”: how much do", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the operands next to the operator “stick” to it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "These are all basic terms: prefix, postfix, infix operator and precedence.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But it’s important that we keep these simple definitions in mind later on,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "where we’ll use these terms in other places.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But for now: let’s get typing and write some code!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Preparing the AST", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we need to do for expression parsing is to prepare our AST.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As we saw before, a program in Monkey is a series of statements. Some are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let statements, others return statements. We need to add a third type of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statement to our AST: expression statements.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This may sound confusing, after I told you that let and return statements", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "are the only type of statements in Monkey. But an expression statement is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "not really a distinct statement; it’s a statement that consists solely of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "one expression. It’s only a wrapper. We need it because it’s totally legal", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in Monkey to write the following code:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let x = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "x + 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first line is a let statement, the second line is an expression", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statement. Other languages don’t have these expression statements, but most", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "scripting languages do. They make it possible to have one line consisting", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "only of an expression. So let’s add this node type to our AST:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type ExpressionStatement struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token      token.Token // the first token of the expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "    Expression Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (es *ExpressionStatement) statementNode()       {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "func (es *ExpressionStatement) TokenLiteral() string { return es.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The ast.ExpressionStatement type has two fields: the Token field, which", style: Normal, search_matches: [], inline_styles: [(4, 27, Code), (53, 58, Code)], syntax_colors: [] }, RenderedLine { text: "every node has, and the Expression field, which holds the expression.", style: Normal, search_matches: [], inline_styles: [(24, 34, Code)], syntax_colors: [] }, RenderedLine { text: "ast.ExpressionStatement fulfills the ast.Statement interface, which means", style: Normal, search_matches: [], inline_styles: [(0, 23, Code), (37, 50, Code)], syntax_colors: [] }, RenderedLine { text: "we can add it to the Statements slice of ast.Program. And that’s the whole", style: Normal, search_matches: [], inline_styles: [(21, 31, Code), (41, 52, Code)], syntax_colors: [] }, RenderedLine { text: "reason why we’re adding ast.ExpressionStatement.", style: Normal, search_matches: [], inline_styles: [(27, 50, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With ast.ExpressionStatement defined we could resume work on the parser.", style: Normal, search_matches: [], inline_styles: [(5, 28, Code)], syntax_colors: [] }, RenderedLine { text: "But instead, let’s make our lives much easier by adding a String() method", style: Normal, search_matches: [], inline_styles: [(60, 68, Code)], syntax_colors: [] }, RenderedLine { text: "to our AST nodes. This will allow us to print AST nodes for debugging and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to compare them with other AST nodes. This is going to be really handy in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tests!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to make this String() method part of the ast.Node interface:", style: Normal, search_matches: [], inline_styles: [(27, 35, Code), (55, 63, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Node interface {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    TokenLiteral() string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    String() string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now every node type in our ast package has to implement this method. With", style: Normal, search_matches: [], inline_styles: [(27, 30, Code)], syntax_colors: [] }, RenderedLine { text: "that change made, our code won’t compile because the compiler complains", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "about our AST nodes not fully implementing the updated Node interface. Let’s", style: Normal, search_matches: [], inline_styles: [(56, 60, Code)], syntax_colors: [] }, RenderedLine { text: "start with *ast.Program and add its String() method first:", style: Normal, search_matches: [], inline_styles: [(13, 25, Code), (38, 46, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"bytes\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Program) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, s := range p.Statements {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        out.WriteString(s.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This method doesn’t do much. It only creates a buffer and writes the return", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "value of each statement’s String() method to it. And then it returns the", style: Normal, search_matches: [], inline_styles: [(29, 37, Code)], syntax_colors: [] }, RenderedLine { text: "buffer as a string. It delegates most of its work to the Statements of", style: Normal, search_matches: [], inline_styles: [(59, 69, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.Program.", style: Normal, search_matches: [], inline_styles: [(3, 13, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The “real work” happens in the String() methods of our three statement types", style: Normal, search_matches: [], inline_styles: [(35, 43, Code)], syntax_colors: [] }, RenderedLine { text: "ast.LetStatement, ast.ReturnStatement and ast.ExpressionStatement:", style: Normal, search_matches: [], inline_styles: [(1, 17, Code), (19, 38, Code), (43, 66, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (ls *LetStatement) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(ls.TokenLiteral() + \" \")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(ls.Name.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\" = \")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if ls.Value != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        out.WriteString(ls.Value.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\";\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (rs *ReturnStatement) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(rs.TokenLiteral() + \" \")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if rs.ReturnValue != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        out.WriteString(rs.ReturnValue.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\";\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (es *ExpressionStatement) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    if es.Expression != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        return es.Expression.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    return \"\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The nil-checks will be taken out, later on, when we can fully build", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now we only need to add a last String() method to ast.Identifier:", style: Normal, search_matches: [], inline_styles: [(31, 39, Code), (50, 64, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (i *Identifier) String() string { return i.Value }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With these methods in place, we can now just call String() on *ast.Program", style: Normal, search_matches: [], inline_styles: [(50, 58, Code), (62, 74, Code)], syntax_colors: [] }, RenderedLine { text: "and get our whole program back as a string. That makes the structure of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "*ast.Program easily testable. Let’s use the following line of Monkey source", style: Normal, search_matches: [], inline_styles: [(0, 12, Code)], syntax_colors: [] }, RenderedLine { text: "code as an example:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let myVar = anotherVar;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If we construct an AST out of this, we can make an assertion about the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "return value of String() like this:", style: Normal, search_matches: [], inline_styles: [(16, 24, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package ast", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/token\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"testing\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestString(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := &Program{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        Statements: []Statement{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "            &LetStatement{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "                Token: token.Token{Type: token.LET, Literal: \"let\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "                Name: &Identifier{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "                    Token: token.Token{Type: token.IDENT, Literal: \"myVar\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "                    Value: \"myVar\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "                },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "                Value: &Identifier{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "                    Token: token.Token{Type: token.IDENT, Literal: \"anotherVar\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 81, Rgb(192, 197, 206))] }, RenderedLine { text: "                    Value: \"anotherVar\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "                },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "            },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if program.String() != \"let myVar = anotherVar;\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"program.String() wrong. got=%q\", program.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In this test we construct the AST by hand. When writing tests for the parser", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we don’t, of course, but make assertions about the AST the parser produces.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "For demonstration purposes, this test shows us how we can add another easily", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "readable layer of tests for our parser by just comparing the parser output", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "with strings. That’s going to be especially handy when parsing expressions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So, good news: preparation is done! It’s time to write a Pratt parser.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Implementing the Pratt Parser", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A Pratt parser’s main idea is the association of parsing functions (which", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Pratt calls “semantic code”) with token types. Whenever this token type", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is encountered, the parsing functions are called to parse the appropriate", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expression and return an AST node that represents it. Each token type can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "have up to two parsing functions associated with it, depending on whether", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the token is found in a prefix or an infix position.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we need to do is to setup these associations. We define two", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "types of functions: a prefix parsing function and an infix parsing function.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "    prefixParseFn func() ast.Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    infixParseFn  func(ast.Expression) ast.Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Both function types return an ast.Expression, since that’s what we’re", style: Normal, search_matches: [], inline_styles: [(30, 44, Code)], syntax_colors: [] }, RenderedLine { text: "here to parse. But only the infixParseFn takes an argument: another", style: Normal, search_matches: [], inline_styles: [(29, 41, Code)], syntax_colors: [] }, RenderedLine { text: "ast.Expression. This argument is “left side” of the infix operator that’s", style: Normal, search_matches: [], inline_styles: [(2, 16, Code)], syntax_colors: [] }, RenderedLine { text: "being parsed. A prefix operator doesn’t have a “left side”, per definition.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I know that this doesn’t make a lot of sense yet, but bear with me here,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "you’ll see how this works. For now, just remember that prefixParseFns gets", style: Normal, search_matches: [], inline_styles: [(62, 75, Code)], syntax_colors: [] }, RenderedLine { text: "called when we encounter the associated token type in prefix position and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "infixParseFn gets called when we encounter the token type in infix position.", style: Normal, search_matches: [], inline_styles: [(6, 18, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order for our parser to get the correct prefixParseFn or infixParseFn for", style: Normal, search_matches: [], inline_styles: [(43, 56, Code), (60, 72, Code)], syntax_colors: [] }, RenderedLine { text: "the current token type, we add two maps to the Parser structure:", style: Normal, search_matches: [], inline_styles: [(47, 53, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Parser struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    l      *lexer.Lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    errors []string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    curToken  token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    peekToken token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    prefixParseFns map[token.TokenType]prefixParseFn", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    infixParseFns  map[token.TokenType]infixParseFn", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With these maps in place, we can just check if the appropriate map (infix or", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "prefix) has a parsing function associated with curToken.Type.", style: Normal, search_matches: [], inline_styles: [(47, 60, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We also give the Parser two helper methods that add entries to these maps:", style: Normal, search_matches: [], inline_styles: [(17, 23, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) registerPrefix(tokenType token.TokenType, fn prefixParseFn) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 78, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.prefixParseFns[tokenType] = fn", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) registerInfix(tokenType token.TokenType, fn infixParseFn) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.infixParseFns[tokenType] = fn", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now we are ready to get to the heart of the algorithm.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Identifiers", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to start with possibly the simplest expression type in the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Monkey programming language: identifiers. Used in an expression statement an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "identifier looks like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "foobar;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of course, the foobar is arbitrary and identifiers are expressions in other", style: Normal, search_matches: [], inline_styles: [(15, 21, Code)], syntax_colors: [] }, RenderedLine { text: "contexts too, not just in an expression statement:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "add(foobar, barfoo);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "foobar + barfoo;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "if (foobar) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "  // [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here we have identifiers as arguments in a function call, as operands in an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "infix expression and as a standalone expression as part of a conditional.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "They can be used in all of these contexts, because identifiers are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions just like 1 + 2. And just like any other expression identifiers", style: Normal, search_matches: [], inline_styles: [(22, 27, Code)], syntax_colors: [] }, RenderedLine { text: "produce a value: they evaluate to the value they are bound to.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We start with a test:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestIdentifierExpression(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := \"foobar;\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(program.Statements) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program has not enough statements. got=%d\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "            len(program.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    stmt, ok := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "            program.Statements[0])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    ident, ok := stmt.Expression.(*ast.Identifier)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"exp not *ast.Identifier. got=%T\", stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    if ident.Value != \"foobar\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"ident.Value not %s. got=%s\", \"foobar\", ident.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    if ident.TokenLiteral() != \"foobar\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"ident.TokenLiteral not %s. got=%s\", \"foobar\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "            ident.TokenLiteral())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s a lot of lines, but it’s mostly just grunt work. We parse our input", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "foobar;, check the parser for errors, make an assertion about the number of", style: Normal, search_matches: [], inline_styles: [(1, 8, Code)], syntax_colors: [] }, RenderedLine { text: "statements in the *ast.Program node and then check that the only statement", style: Normal, search_matches: [], inline_styles: [(20, 32, Code)], syntax_colors: [] }, RenderedLine { text: "in program.Statements is an *ast.ExpressionStatement. Then we check that the", style: Normal, search_matches: [], inline_styles: [(6, 24, Code), (31, 55, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.ExpressionStatement.Expression is an *ast.Identifier. Finally we check", style: Normal, search_matches: [], inline_styles: [(4, 39, Code), (46, 61, Code)], syntax_colors: [] }, RenderedLine { text: "that our identifier has the correct value of \"foobar\".", style: Normal, search_matches: [], inline_styles: [(49, 54, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of course, the parser tests fail:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestIdentifierExpression (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:110: program has not enough statements. got=0", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The parser doesn’t know anything about expressions yet. We need to write a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseExpression method.", style: Normal, search_matches: [], inline_styles: [(1, 16, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we need to do is to extend the parseStatement() method of", style: Normal, search_matches: [], inline_styles: [(47, 63, Code)], syntax_colors: [] }, RenderedLine { text: "the parser, so that it parses expression statements. Since the only two real", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statement types in Monkey are let and return statements, we try to parse", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expression statements if we don’t encounter one of the other two:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseStatement() ast.Statement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch p.curToken.Type {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    case token.LET:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        return p.parseLetStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    case token.RETURN:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        return p.parseReturnStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return p.parseExpressionStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The parseExpressionStatement method looks like this:", style: Normal, search_matches: [], inline_styles: [(4, 28, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "    stmt := &ast.ExpressionStatement{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt.Expression = p.parseExpression(LOWEST)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if p.peekTokenIs(token.SEMICOLON) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return stmt", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We already know the drill: we build our AST node and then try to fill", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "its field by calling other parsing functions. In this case there are a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "few differences though: we call parseExpression(), which doesn’t exist", style: Normal, search_matches: [], inline_styles: [(32, 49, Code)], syntax_colors: [] }, RenderedLine { text: "yet, with the constant LOWEST, that doesn’t exist yet, and then we check", style: Normal, search_matches: [], inline_styles: [(24, 30, Code)], syntax_colors: [] }, RenderedLine { text: "for an optional semicolon. Yes, it’s optional. If the peekToken is a", style: Normal, search_matches: [], inline_styles: [(58, 67, Code)], syntax_colors: [] }, RenderedLine { text: "token.SEMICOLON, we advance so it’s the curToken. If it’s not there, that’s", style: Normal, search_matches: [], inline_styles: [(3, 18, Code), (45, 53, Code)], syntax_colors: [] }, RenderedLine { text: "okay too, we don’t add an error to the parser if it’s not there. That’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "because we want expression statements to have optional semicolons (which", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "makes it easier to type something like 5 + 5 into the REPL later on).", style: Normal, search_matches: [], inline_styles: [(45, 50, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If we now run the tests we can see that compilation fails, because LOWEST is", style: Normal, search_matches: [], inline_styles: [(67, 73, Code)], syntax_colors: [] }, RenderedLine { text: "undefined. That’s alright, let’s add it now, by defining the precedences of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the Monkey programming language:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "    _ int = iota", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    LOWEST", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    EQUALS      // ==", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    LESSGREATER // > or <", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    SUM         // +", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    PRODUCT     // *", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    PREFIX      // -X or !X", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    CALL        // myFunction(X)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here we use iota to give the following constants incrementing numbers", style: Normal, search_matches: [], inline_styles: [(12, 16, Code)], syntax_colors: [] }, RenderedLine { text: "as values. The blank identifier _ takes the zero value and the following", style: Normal, search_matches: [], inline_styles: [(32, 33, Code)], syntax_colors: [] }, RenderedLine { text: "constants get assigned the values 1 to 7. Which numbers we use doesn’t", style: Normal, search_matches: [], inline_styles: [(34, 35, Code), (39, 40, Code)], syntax_colors: [] }, RenderedLine { text: "matter, but the order and the relation to each other do. What we want out of", style: Normal, search_matches: [], inline_styles: [(17, 22, Bold)], syntax_colors: [] }, RenderedLine { text: "these constants is to later be able to answer: “does the * operator have a", style: Normal, search_matches: [], inline_styles: [(61, 62, Code)], syntax_colors: [] }, RenderedLine { text: "higher precedence than the == operator? Does a prefix operator have a higher", style: Normal, search_matches: [], inline_styles: [(30, 32, Code)], syntax_colors: [] }, RenderedLine { text: "precedence than a call expression?”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In parseExpressionStatement we pass the lowest possible precedence to", style: Normal, search_matches: [], inline_styles: [(3, 27, Code)], syntax_colors: [] }, RenderedLine { text: "parseExpression, since we didn’t parse anything yet and we can’t compare", style: Normal, search_matches: [], inline_styles: [(0, 15, Code)], syntax_colors: [] }, RenderedLine { text: "precedences. That’s going to make more sense in a short while, I promise.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s write parseExpression:", style: Normal, search_matches: [], inline_styles: [(16, 30, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseExpression(precedence int) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "    prefix := p.prefixParseFns[p.curToken.Type]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    if prefix == nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    leftExp := prefix()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return leftExp", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s the first version. All it does is checking whether we have a parsing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function associated with p.curToken.Type in the prefix position. If we do,", style: Normal, search_matches: [], inline_styles: [(26, 41, Code)], syntax_colors: [] }, RenderedLine { text: "it calls this parsing function, if not, it returns nil. Which it does at the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "moment, since we haven’t associated any tokens with any parsing functions", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "yet. That’s our next step:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.prefixParseFns = make(map[token.TokenType]prefixParseFn)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.IDENT, p.parseIdentifier)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseIdentifier() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "    return &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We modified the New() function to initialize the prefixParseFns map on", style: Normal, search_matches: [], inline_styles: [(16, 21, Code), (49, 63, Code)], syntax_colors: [] }, RenderedLine { text: "Parser and register a parsing function: if we encounter a token of type", style: Normal, search_matches: [], inline_styles: [(0, 6, Code)], syntax_colors: [] }, RenderedLine { text: "token.IDENT the parsing function to call is parseIdentifier, a method we", style: Normal, search_matches: [], inline_styles: [(0, 11, Code), (44, 59, Code)], syntax_colors: [] }, RenderedLine { text: "defined on *Parser.", style: Normal, search_matches: [], inline_styles: [(11, 18, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The parseIdentifier method doesn’t do a lot. It only returns a", style: Normal, search_matches: [], inline_styles: [(4, 19, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.Identifier with the current token in the Token field and the literal", style: Normal, search_matches: [], inline_styles: [(1, 16, Code), (47, 52, Code)], syntax_colors: [] }, RenderedLine { text: "value of the token in Value. It doesn’t advance the tokens, it doesn’t call", style: Normal, search_matches: [], inline_styles: [(24, 29, Code)], syntax_colors: [] }, RenderedLine { text: "nextToken. That’s important. All of our parsing functions, prefixParseFn or", style: Normal, search_matches: [], inline_styles: [(3, 12, Code), (64, 77, Code)], syntax_colors: [] }, RenderedLine { text: "infixParseFn, are going to follow this protocol: start with curToken being", style: Normal, search_matches: [], inline_styles: [(4, 16, Code), (64, 72, Code)], syntax_colors: [] }, RenderedLine { text: "the type of token you’re associated with and return with curToken being the", style: Normal, search_matches: [], inline_styles: [(63, 71, Code)], syntax_colors: [] }, RenderedLine { text: "last token that’s part of your expression type. Never advance the tokens", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "too far.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Believe it or not, our tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We successfully parsed an identifier expression! Alright! But, before we get", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "off the computer, find someone and proudly tell them, let’s keep our breath", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a little longer and write some more parsing functions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Integer Literals", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Nearly as easy to parse as identifiers are integer literals, which look", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, that’s it. Integer literals are expressions. The value they produce", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is the integer itself. Again, imagine in which places integer literals can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "occur to understand why they are expressions:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let x = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "add(5, 10);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "5 + 5 + 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can use any other expression instead of integer literals here and it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "would still be valid: identifiers, call expressions, grouped expressions,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function literals and so on. All the expression types are interchangeable", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and integer literals are one of them.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The test case for integer literals looks really similar to the one for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "identifiers:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestIntegerLiteralExpression(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := \"5;\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(program.Statements) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program has not enough statements. got=%d\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "            len(program.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    stmt, ok := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "            program.Statements[0])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    literal, ok := stmt.Expression.(*ast.IntegerLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"exp not *ast.IntegerLiteral. got=%T\", stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    if literal.Value != 5 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"literal.Value not %d. got=%d\", 5, literal.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    if literal.TokenLiteral() != \"5\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"literal.TokenLiteral not %s. got=%s\", \"5\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "            literal.TokenLiteral())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And as in the test case for identifiers we use a simple input, feed it to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the parser and then check that the parser didn’t encounter any errors and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "produced the correct number of statements in *ast.Program.Statements. Then", style: Normal, search_matches: [], inline_styles: [(46, 69, Code)], syntax_colors: [] }, RenderedLine { text: "we add an assertion that the first statement is an *ast.ExpressionStatement.", style: Normal, search_matches: [], inline_styles: [(53, 76, Code)], syntax_colors: [] }, RenderedLine { text: "And finally we expect a well-formed *ast.IntegerLiteral.", style: Normal, search_matches: [], inline_styles: [(38, 56, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The tests do not compile, since *ast.IntegerLiteral doesn’t exist yet.", style: Normal, search_matches: [], inline_styles: [(32, 51, Code)], syntax_colors: [] }, RenderedLine { text: "Defining it is easy though:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type IntegerLiteral struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (il *IntegerLiteral) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "func (il *IntegerLiteral) TokenLiteral() string { return il.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "func (il *IntegerLiteral) String() string       { return il.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "*ast.IntegerLiteral fulfills the ast.Expression interface, just like", style: Normal, search_matches: [], inline_styles: [(0, 19, Code), (33, 47, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.Identifier does, but there’s a notable difference to ast.Identifier in", style: Normal, search_matches: [], inline_styles: [(0, 15, Code), (60, 74, Code)], syntax_colors: [] }, RenderedLine { text: "the structure itself: Value is an int64 and not a string. This is the field", style: Normal, search_matches: [], inline_styles: [(23, 28, Code), (35, 40, Code), (51, 57, Code)], syntax_colors: [] }, RenderedLine { text: "that’s going to contain the actual value the integer literal represents in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the source code. When we build an *ast.IntegerLiteral we have to convert the", style: Normal, search_matches: [], inline_styles: [(37, 56, Code)], syntax_colors: [] }, RenderedLine { text: "string in *ast.IntegerLiteral.Token.Literal (which is something like \"5\") to", style: Normal, search_matches: [], inline_styles: [(14, 47, Code), (73, 76, Code)], syntax_colors: [] }, RenderedLine { text: "an int64.", style: Normal, search_matches: [], inline_styles: [(7, 9, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The best place to do this is in the parsing function associated with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "token.INT, called parseIntegerLiteral:", style: Normal, search_matches: [], inline_styles: [(0, 9, Code), (18, 37, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"strconv\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseIntegerLiteral() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    lit := &ast.IntegerLiteral{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "    if err != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        msg := fmt.Sprintf(\"could not parse %q as integer\", p.curToken.Literal)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.errors = append(p.errors, msg)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    lit.Value = value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return lit", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Like parseIdentifier the method is strikingly simple. The only thing that’s", style: Normal, search_matches: [], inline_styles: [(5, 20, Code)], syntax_colors: [] }, RenderedLine { text: "really different is a call to strconv.ParseInt, which converts the string", style: Normal, search_matches: [], inline_styles: [(31, 47, Code)], syntax_colors: [] }, RenderedLine { text: "in p.curToken.Literal into an int64. The int64 then gets saved to the Value", style: Normal, search_matches: [], inline_styles: [(5, 23, Code), (32, 37, Code), (43, 48, Code), (72, 75, Code)], syntax_colors: [] }, RenderedLine { text: "field and we return the newly constructed *ast.IntegerLiteral node. If that", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (44, 63, Code)], syntax_colors: [] }, RenderedLine { text: "doesn’t work, we add a new error to the parser’s errors field.", style: Normal, search_matches: [], inline_styles: [(55, 61, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But the tests don’t pass yet:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestIntegerLiteralExpression (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:162: exp not *ast.IntegerLiteral. got=<nil>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.008s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We have a nil instead of an *ast.IntegerLiteral in our AST. The reason", style: Normal, search_matches: [], inline_styles: [(10, 13, Code), (28, 47, Code)], syntax_colors: [] }, RenderedLine { text: "is that parseExpression can’t find a prefixParseFn for a token of type", style: Normal, search_matches: [], inline_styles: [(8, 23, Code), (39, 52, Code)], syntax_colors: [] }, RenderedLine { text: "token.INT. All we have to do to make the tests pass is to register our", style: Normal, search_matches: [], inline_styles: [(1, 10, Code)], syntax_colors: [] }, RenderedLine { text: "parseIntegerLiteral method:", style: Normal, search_matches: [], inline_styles: [(2, 21, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.prefixParseFns = make(map[token.TokenType]prefixParseFn)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.IDENT, p.parseIdentifier)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.INT, p.parseIntegerLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With parseIntegerLiteral registered, parseExpression now knows what to do", style: Normal, search_matches: [], inline_styles: [(5, 24, Code), (37, 52, Code)], syntax_colors: [] }, RenderedLine { text: "with a token.INT token, calls parseIntegerLiteral and returns its return", style: Normal, search_matches: [], inline_styles: [(7, 16, Code), (30, 49, Code)], syntax_colors: [] }, RenderedLine { text: "value, an *ast.IntegerLiteral. The tests pass:", style: Normal, search_matches: [], inline_styles: [(10, 29, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I think it’s time to say: we are on a roll here! Identifiers and integer", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "literals are in the bag, let’s step it up a notch and parse prefix", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operators.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Prefix Operators", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There are two prefix operators in the Monkey programming language: ! and -.", style: Normal, search_matches: [], inline_styles: [(67, 68, Code), (73, 74, Code)], syntax_colors: [] }, RenderedLine { text: "Their usage is pretty much what you’d expect from other languages:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "-5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "!foobar;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "5 + -10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The structure of their usage is the following:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "<prefix operator><expression>;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, that’s right. Any expression can follow a prefix operator as operand.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "These are valid:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "!isGreaterThanZero(2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "5 + -add(5, 5);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That means that an AST node for a prefix operator expression has to be", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "flexible enough to point to any expression as its operand.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But first things first, here is the test case for prefix operators, or", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“prefix expressions”:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestParsingPrefixExpressions(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    prefixTests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        input        string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        operator     string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        integerValue int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"!5;\", \"!\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"-15;\", \"-\", 15},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range prefixTests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        l := lexer.New(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if len(program.Statements) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"program.Statements does not contain %d statements. got=%d\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 83, Rgb(192, 197, 206))] }, RenderedLine { text: "                1, len(program.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        stmt, ok := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 84, Rgb(192, 197, 206))] }, RenderedLine { text: "                program.Statements[0])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        exp, ok := stmt.Expression.(*ast.PrefixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"stmt is not ast.PrefixExpression. got=%T\", stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 81, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        if exp.Operator != tt.operator {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"exp.Operator is not '%s'. got=%s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "                tt.operator, exp.Operator)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !testIntegerLiteral(t, exp.Right, tt.integerValue) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "            return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This test function, again, has a lot of lines. For two reasons: manually", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "creating error messages with t.Errorf takes up some space and we’re using a", style: Normal, search_matches: [], inline_styles: [(29, 37, Code)], syntax_colors: [] }, RenderedLine { text: "table-driven testing approach. The reason for this approach is that it saves", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "us a lot of test code. Yes, it’s only two test cases, but duplicating the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "complete test setup for each case would mean a lot more lines. And since the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "logic behind the test assertions is the same, we share the test setup. Both", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "test cases (!5 and -15 as input) differ only in the expected operators and", style: Normal, search_matches: [], inline_styles: [(16, 18, Code), (23, 26, Code)], syntax_colors: [] }, RenderedLine { text: "integer values (which we define here in prefixTests).", style: Normal, search_matches: [], inline_styles: [(44, 53, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In the test function we iterate through our slice of test inputs and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "make assertions about the produced AST based on the values defined in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the prefixTests slice of structs. As you can see, at the end we use a", style: Normal, search_matches: [], inline_styles: [(4, 15, Code)], syntax_colors: [] }, RenderedLine { text: "new helper function called testIntegerLiteral to test that the Right", style: Normal, search_matches: [], inline_styles: [(27, 45, Code), (63, 68, Code)], syntax_colors: [] }, RenderedLine { text: "value of *ast.PrefixExpression is the correct integer literal. We", style: Normal, search_matches: [], inline_styles: [(9, 30, Code)], syntax_colors: [] }, RenderedLine { text: "introduce this helper function here, so the focus of the test case is on", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "*ast.PrefixExpression and its fields and we will soon enough need it again.", style: Normal, search_matches: [], inline_styles: [(0, 21, Code)], syntax_colors: [] }, RenderedLine { text: "It looks like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"fmt\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testIntegerLiteral(t *testing.T, il ast.Expression, value int64) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "    integ, ok := il.(*ast.IntegerLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"il not *ast.IntegerLiteral. got=%T\", il)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if integ.Value != value {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"integ.Value not %d. got=%d\", value, integ.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if integ.TokenLiteral() != fmt.Sprintf(\"%d\", value) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"integ.TokenLiteral not %d. got=%s\", value,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "            integ.TokenLiteral())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There is nothing new here, we’ve seen this before in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestIntegerLiteralExpression. But now it’s hidden behind a small helper", style: Normal, search_matches: [], inline_styles: [(1, 29, Code)], syntax_colors: [] }, RenderedLine { text: "function that makes these new tests more readable.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As expected the tests don’t even compile:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "# monkey/parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "parser/parser_test.go:210: undefined: ast.PrefixExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser [build failed]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We need to define the ast.PrefixExpression node:", style: Normal, search_matches: [], inline_styles: [(22, 42, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type PrefixExpression struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token    token.Token // The prefix token, e.g. !", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    Operator string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    Right    Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (pe *PrefixExpression) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "func (pe *PrefixExpression) TokenLiteral() string { return pe.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "func (pe *PrefixExpression) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\"(\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(pe.Operator)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(pe.Right.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\")\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This doesn’t contain any surprises. The *ast.PrefixExpression node has two", style: Normal, search_matches: [], inline_styles: [(42, 63, Code)], syntax_colors: [] }, RenderedLine { text: "noteworthy fields: Operator and Right. Operator is a string that’s going to", style: Normal, search_matches: [], inline_styles: [(20, 28, Code), (33, 38, Code), (40, 48, Code)], syntax_colors: [] }, RenderedLine { text: "contain either \"-\" or \"!\". The Right field contains the expression to the", style: Normal, search_matches: [], inline_styles: [(17, 20, Code), (24, 27, Code), (33, 38, Code)], syntax_colors: [] }, RenderedLine { text: "right of the operator.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In the String() method we deliberately add parentheses around the operator", style: Normal, search_matches: [], inline_styles: [(7, 15, Code)], syntax_colors: [] }, RenderedLine { text: "and its operand, the expression in Right. That allows us to see which", style: Normal, search_matches: [], inline_styles: [(35, 40, Code)], syntax_colors: [] }, RenderedLine { text: "operands belong to which operator.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With *ast.PrefixExpression defined, the tests now fail with a strange error", style: Normal, search_matches: [], inline_styles: [(5, 26, Code)], syntax_colors: [] }, RenderedLine { text: "message:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestParsingPrefixExpressions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:198: program.Statements does not contain 1 statements. got=2", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Why does program.Statements contain two statements instead of the expected", style: Normal, search_matches: [], inline_styles: [(9, 27, Code)], syntax_colors: [] }, RenderedLine { text: "one statement? The reason is that parseExpression doesn’t recognize our", style: Normal, search_matches: [], inline_styles: [(34, 49, Code)], syntax_colors: [] }, RenderedLine { text: "prefix operators yet and simply returns nil. program.Statements does not", style: Normal, search_matches: [], inline_styles: [(41, 44, Code), (46, 64, Code)], syntax_colors: [] }, RenderedLine { text: "contain one statement but simply two nils.", style: Normal, search_matches: [], inline_styles: [(39, 42, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can do better than this, we can extend our parser and the parseExpression", style: Normal, search_matches: [], inline_styles: [(61, 76, Code)], syntax_colors: [] }, RenderedLine { text: "method to give us better error messages when this happens:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) noPrefixParseFnError(t token.TokenType) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "    msg := fmt.Sprintf(\"no prefix parse function for %s found\", t)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.errors = append(p.errors, msg)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseExpression(precedence int) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "    prefix := p.prefixParseFns[p.curToken.Type]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    if prefix == nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.noPrefixParseFnError(p.curToken.Type)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    leftExp := prefix()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return leftExp", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The small helper method noPrefixParseFnError just adds a formatted error", style: Normal, search_matches: [], inline_styles: [(24, 44, Code)], syntax_colors: [] }, RenderedLine { text: "message to our parser’s errors field. But that’s enough to get better error", style: Normal, search_matches: [], inline_styles: [(26, 32, Code)], syntax_colors: [] }, RenderedLine { text: "messages in our failing test:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestParsingPrefixExpressions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:227: parser has 1 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:229: parser error: \"no prefix parse function for ! found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.010s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now it’s clear what we have to do: write a parsing function for prefix", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions and register it in our parser.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.BANG, p.parsePrefixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.MINUS, p.parsePrefixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parsePrefixExpression() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression := &ast.PrefixExpression{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        Token:    p.curToken,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        Operator: p.curToken.Literal,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    expression.Right = p.parseExpression(PREFIX)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "For token.BANG and token.MINUS we register the same method as prefixParseFn:", style: Normal, search_matches: [], inline_styles: [(4, 14, Code), (19, 30, Code), (62, 75, Code)], syntax_colors: [] }, RenderedLine { text: "the newly created parsePrefixExpression. This method builds an AST node,", style: Normal, search_matches: [], inline_styles: [(18, 39, Code)], syntax_colors: [] }, RenderedLine { text: "in this case *ast.PrefixExpression, just like the parsing functions we", style: Normal, search_matches: [], inline_styles: [(13, 34, Code)], syntax_colors: [] }, RenderedLine { text: "saw before. But then it does something different: it actually advances our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tokens by calling p.nextToken()!", style: Normal, search_matches: [], inline_styles: [(18, 31, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When parsePrefixExpression is called, p.curToken is either of type", style: Normal, search_matches: [], inline_styles: [(5, 26, Code), (38, 48, Code)], syntax_colors: [] }, RenderedLine { text: "token.BANG or token.MINUS, because otherwise it wouldn’t have been", style: Normal, search_matches: [], inline_styles: [(0, 10, Code), (14, 25, Code)], syntax_colors: [] }, RenderedLine { text: "called. But in order to correctly parse a prefix expression like -5 more", style: Normal, search_matches: [], inline_styles: [(66, 68, Code)], syntax_colors: [] }, RenderedLine { text: "than one token has to be “consumed”. So after using p.curToken to build", style: Normal, search_matches: [], inline_styles: [(58, 68, Code)], syntax_colors: [] }, RenderedLine { text: "a *ast.PrefixExpression node, the method advances the tokens and calls", style: Normal, search_matches: [], inline_styles: [(5, 26, Code)], syntax_colors: [] }, RenderedLine { text: "parseExpression again. This time with the precedence of prefix operators as", style: Normal, search_matches: [], inline_styles: [(4, 19, Code)], syntax_colors: [] }, RenderedLine { text: "argument. It’s still unused, but we’ll shortly see what it’s good for and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "how to make use of it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now, when parseExpression is called by parsePrefixExpression the tokens have", style: Normal, search_matches: [], inline_styles: [(10, 25, Code), (39, 60, Code)], syntax_colors: [] }, RenderedLine { text: "been advanced and the current token is the one after the prefix operator.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In the case of -5, when parseExpression is called the p.curToken.Type", style: Normal, search_matches: [], inline_styles: [(15, 17, Code), (24, 39, Code), (54, 69, Code)], syntax_colors: [] }, RenderedLine { text: "is token.INT. parseExpression then checks the registered prefix parsing", style: Normal, search_matches: [], inline_styles: [(3, 12, Code), (14, 29, Code)], syntax_colors: [] }, RenderedLine { text: "functions and finds parseIntegerLiteral, which builds an *ast.IntegerLiteral", style: Normal, search_matches: [], inline_styles: [(20, 39, Code), (57, 76, Code)], syntax_colors: [] }, RenderedLine { text: "node and returns it. parseExpression returns this newly constructed", style: Normal, search_matches: [], inline_styles: [(21, 36, Code)], syntax_colors: [] }, RenderedLine { text: "node and parsePrefixExpression uses it to fill the Right field of", style: Normal, search_matches: [], inline_styles: [(9, 30, Code), (51, 56, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.PrefixExpression.", style: Normal, search_matches: [], inline_styles: [(0, 21, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, this works, our tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Note how the “protocol” for our parsing functions plays out here:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parsePrefixExpression starts with p.curToken being the token of the prefix", style: Normal, search_matches: [], inline_styles: [(0, 21, Code), (34, 44, Code)], syntax_colors: [] }, RenderedLine { text: "operator and it returns with p.curToken being the operand of the prefix", style: Normal, search_matches: [], inline_styles: [(29, 39, Code)], syntax_colors: [] }, RenderedLine { text: "expression, which is the last token of the expression. The tokens get", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "advanced just enough, which works beautifully. The neat thing is how few", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "lines of code are needed for this. The power lies in the recursive approach.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Granted, the precedence argument in parseExpression is confusing, since", style: Normal, search_matches: [], inline_styles: [(13, 23, Code), (36, 51, Code)], syntax_colors: [] }, RenderedLine { text: "it’s unused. But we’ve already seen something important about its usage:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the value changes depending on the caller’s knowledge and its context.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseExpressionStatement (the top-level method that kicks off expression", style: Normal, search_matches: [], inline_styles: [(1, 25, Code)], syntax_colors: [] }, RenderedLine { text: "parsing here) knows nothing about a precedence level and just uses LOWEST.", style: Normal, search_matches: [], inline_styles: [(69, 74, Code)], syntax_colors: [] }, RenderedLine { text: "But parsePrefixExpression passes the PREFIX precedence to parseExpression,", style: Normal, search_matches: [], inline_styles: [(6, 27, Code), (39, 45, Code), (60, 74, Code)], syntax_colors: [] }, RenderedLine { text: "since it’s parsing a prefix expression.", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And now we’ll see how precedence in parseExpression is used. Because now", style: Normal, search_matches: [], inline_styles: [(24, 34, Code), (38, 53, Code)], syntax_colors: [] }, RenderedLine { text: "we’re going to parse infix expressions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Infix Operators", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Next up we’re going to parse these eight infix operators:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 + 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 - 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 * 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 / 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 > 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 < 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 == 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "5 != 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Don’t be bothered by the 5 here. As with prefix operator expressions, we can", style: Normal, search_matches: [], inline_styles: [(27, 28, Code)], syntax_colors: [] }, RenderedLine { text: "use any expressions to the left and right of the operator.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "<expression> <infix operator> <expression>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Because of the two operands (left and right) these expressions are sometimes", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "called “binary expressions” (whereas our prefix expressions would be called", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“unary expressions”). Even though we can use any expressions on either", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "side of the operator, we’re going to start by writing a test that only uses", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "integer literals as operands. As soon as we can get the test to pass, we’ll", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "extend it to incorporate more operand types. Here it is:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestParsingInfixExpressions(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    infixTests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        input      string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        leftValue  int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        operator   string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        rightValue int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 + 5;\", 5, \"+\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 - 5;\", 5, \"-\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 * 5;\", 5, \"*\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 / 5;\", 5, \"/\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 > 5;\", 5, \">\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 < 5;\", 5, \"<\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 == 5;\", 5, \"==\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 != 5;\", 5, \"!=\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range infixTests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        l := lexer.New(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if len(program.Statements) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"program.Statements does not contain %d statements. got=%d\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 83, Rgb(192, 197, 206))] }, RenderedLine { text: "                1, len(program.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        stmt, ok := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 84, Rgb(192, 197, 206))] }, RenderedLine { text: "                program.Statements[0])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        exp, ok := stmt.Expression.(*ast.InfixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"exp is not ast.InfixExpression. got=%T\", stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if !testIntegerLiteral(t, exp.Left, tt.leftValue) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "            return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if exp.Operator != tt.operator {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"exp.Operator is not '%s'. got=%s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "                tt.operator, exp.Operator)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if !testIntegerLiteral(t, exp.Right, tt.rightValue) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "            return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This test is nearly a straight copy of TestParsingPrefixExpressions, except", style: Normal, search_matches: [], inline_styles: [(39, 67, Code)], syntax_colors: [] }, RenderedLine { text: "that we now make assertions about the Right and Left fields of the resulting", style: Normal, search_matches: [], inline_styles: [(38, 43, Code), (44, 47, Italic), (48, 52, Code)], syntax_colors: [] }, RenderedLine { text: "AST node. Here the table-driven approach gives us great leverage that we’ll", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "soon use when we extend the test to also include identifiers.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The tests fail, of course, because they can’t find a definition of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "*ast.InfixExpression. And in order to get real failing tests, we define", style: Normal, search_matches: [], inline_styles: [(1, 21, Code)], syntax_colors: [] }, RenderedLine { text: "ast.InfixExpression:", style: Normal, search_matches: [], inline_styles: [(2, 20, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type InfixExpression struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token    token.Token // The operator token, e.g. +", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "    Left     Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    Operator string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    Right    Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (ie *InfixExpression) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "func (ie *InfixExpression) TokenLiteral() string { return ie.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "func (ie *InfixExpression) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\"(\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(ie.Left.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\" \" + ie.Operator + \" \")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(ie.Right.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\")\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Just like with ast.PrefixExpression, we define ast.InfixExpression to", style: Normal, search_matches: [], inline_styles: [(15, 35, Code), (47, 66, Code)], syntax_colors: [] }, RenderedLine { text: "fulfill the ast.Expression and ast.Node interfaces, by defining the", style: Normal, search_matches: [], inline_styles: [(12, 26, Code), (31, 39, Code)], syntax_colors: [] }, RenderedLine { text: "expressionNode(), TokenLiteral() and String() methods. The only difference", style: Normal, search_matches: [], inline_styles: [(0, 16, Code), (18, 32, Code), (37, 45, Code)], syntax_colors: [] }, RenderedLine { text: "to ast.PrefixExpression is the new field called Left, which can hold any", style: Normal, search_matches: [], inline_styles: [(3, 23, Code), (48, 52, Code)], syntax_colors: [] }, RenderedLine { text: "expression.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With that out of the way, we can build and run our tests. And the tests even", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "return one of our own new error messages:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestParsingInfixExpressions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:246: parser has 1 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:248: parser error: \"no prefix parse function for + found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But that error message is deceiving. It says “no prefix parse function for +", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "found”. The problem is that we do not want our parser to find a prefix parse", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function for +. We want it to find an infix parse function.", style: Normal, search_matches: [], inline_styles: [(15, 16, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This is the point where we’re going from “I guess it’s neat” to “Wow, this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is beautiful”, because we now need to complete our parseExpression method.", style: Normal, search_matches: [], inline_styles: [(54, 69, Code)], syntax_colors: [] }, RenderedLine { text: "And to do that, we first need a precedence table and a few helper methods:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var precedences = map[token.TokenType]int{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    token.EQ:       EQUALS,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    token.NOT_EQ:   EQUALS,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    token.LT:       LESSGREATER,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    token.GT:       LESSGREATER,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    token.PLUS:     SUM,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    token.MINUS:    SUM,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    token.SLASH:    PRODUCT,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    token.ASTERISK: PRODUCT,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) peekPrecedence() int {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    if p, ok := precedences[p.peekToken.Type]; ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "        return p", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return LOWEST", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) curPrecedence() int {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    if p, ok := precedences[p.curToken.Type]; ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "        return p", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return LOWEST", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "precedences is our precedence table: it associates token types with their", style: Normal, search_matches: [], inline_styles: [(0, 11, Code)], syntax_colors: [] }, RenderedLine { text: "precedence. The precedence values themselves are the constants we defined", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "earlier, the integers with increasing value. This table can now tell us that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "+ (token.PLUS) and - (token.MINUS) have the same precedence, which is lower", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (3, 13, Code), (19, 20, Code), (22, 33, Code)], syntax_colors: [] }, RenderedLine { text: "than the precedence of * (token.ASTERISK) and / (token.SLASH), for example.", style: Normal, search_matches: [], inline_styles: [(23, 24, Code), (26, 40, Code), (46, 47, Code), (49, 60, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The peekPrecedence method returns the precedence associated with the token", style: Normal, search_matches: [], inline_styles: [(4, 18, Code)], syntax_colors: [] }, RenderedLine { text: "type of p.peekToken. If it doesn’t find a precedence for p.peekToken it", style: Normal, search_matches: [], inline_styles: [(8, 19, Code), (59, 70, Code)], syntax_colors: [] }, RenderedLine { text: "defaults to LOWEST, the lowest possible precedence any operator can have.", style: Normal, search_matches: [], inline_styles: [(13, 19, Code)], syntax_colors: [] }, RenderedLine { text: "The curPrecedence method does the same thing, but for p.curToken.", style: Normal, search_matches: [], inline_styles: [(6, 19, Code), (56, 65, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The next step is to register one infix parse function for all of our infix", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operators:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.infixParseFns = make(map[token.TokenType]infixParseFn)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerInfix(token.PLUS, p.parseInfixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerInfix(token.MINUS, p.parseInfixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerInfix(token.SLASH, p.parseInfixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerInfix(token.ASTERISK, p.parseInfixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerInfix(token.EQ, p.parseInfixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerInfix(token.NOT_EQ, p.parseInfixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerInfix(token.LT, p.parseInfixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerInfix(token.GT, p.parseInfixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We already have the registerInfix method in our repertoire and now we", style: Normal, search_matches: [], inline_styles: [(20, 33, Code)], syntax_colors: [] }, RenderedLine { text: "finally use it. Every infix operator gets associated with the same parsing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function called parseInfixExpression, which looks like this:", style: Normal, search_matches: [], inline_styles: [(16, 36, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression := &ast.InfixExpression{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        Token:    p.curToken,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        Operator: p.curToken.Literal,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        Left:     left,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    precedence := p.curPrecedence()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression.Right = p.parseExpression(precedence)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The notable difference here is that, in contrast to parsePrefixExpression,", style: Normal, search_matches: [], inline_styles: [(52, 73, Code)], syntax_colors: [] }, RenderedLine { text: "this new method takes an argument, an ast.Expression called left. It uses", style: Normal, search_matches: [], inline_styles: [(38, 52, Code), (60, 64, Code)], syntax_colors: [] }, RenderedLine { text: "this argument to construct an *ast.InfixExpression node, with left being in", style: Normal, search_matches: [], inline_styles: [(30, 50, Code), (62, 66, Code)], syntax_colors: [] }, RenderedLine { text: "the Left field. Then it assigns the precedence of the current token (which", style: Normal, search_matches: [], inline_styles: [(4, 8, Code)], syntax_colors: [] }, RenderedLine { text: "is the operator of the infix expression) to the local variable precedence,", style: Normal, search_matches: [], inline_styles: [(63, 73, Code)], syntax_colors: [] }, RenderedLine { text: "before advancing the tokens by calling nextToken and filling the Right field", style: Normal, search_matches: [], inline_styles: [(39, 48, Code), (65, 70, Code)], syntax_colors: [] }, RenderedLine { text: "of the node with another call to parseExpression - this time passing in the", style: Normal, search_matches: [], inline_styles: [(33, 48, Code)], syntax_colors: [] }, RenderedLine { text: "precedence of the operator token.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s time to lift the curtain. Here is the heart of our Pratt parser, here", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is the final version of parseExpression:", style: Normal, search_matches: [], inline_styles: [(25, 40, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseExpression(precedence int) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "    prefix := p.prefixParseFns[p.curToken.Type]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    if prefix == nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.noPrefixParseFnError(p.curToken.Type)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    leftExp := prefix()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "        infix := p.infixParseFns[p.peekToken.Type]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "        if infix == nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "            return leftExp", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        leftExp = infix(leftExp)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return leftExp", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And, boom! Our tests pass! It’s all green, baby:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We are now officially able to parse infix operator expressions correctly!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Wait, what? What the hell did just happen? How does this work?", style: Normal, search_matches: [], inline_styles: [(0, 62, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Obviously parseExpression now does a few more things. We already know how it", style: Normal, search_matches: [], inline_styles: [(10, 25, Code)], syntax_colors: [] }, RenderedLine { text: "finds an associated prefixParseFn with the current token and calls it. We’ve", style: Normal, search_matches: [], inline_styles: [(20, 33, Code)], syntax_colors: [] }, RenderedLine { text: "seen this work with prefix operators, identifiers and integer literals.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What’s new is the loop right in the middle of parseExpression. In the", style: Normal, search_matches: [], inline_styles: [(48, 63, Code)], syntax_colors: [] }, RenderedLine { text: "loop’s body the method tries to find infixParseFns for the next token. If it", style: Normal, search_matches: [], inline_styles: [(40, 52, Code)], syntax_colors: [] }, RenderedLine { text: "finds such a function, it calls it, passing in the expression returned by a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "prefixParseFn as an argument. And it does all this again and again until it", style: Normal, search_matches: [], inline_styles: [(3, 16, Code)], syntax_colors: [] }, RenderedLine { text: "encounters a token that has a lower precedence.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This works beautifully. Look at these tests that use multiple operators with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "different precedences and how the AST in string form correctly represents", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestOperatorPrecedenceParsing(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"-a * b\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((-a) * b)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"!-a\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"(!(-a))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"a + b + c\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((a + b) + c)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"a + b - c\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((a + b) - c)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"a * b * c\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((a * b) * c)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"a * b / c\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((a * b) / c)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"a + b / c\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"(a + (b / c))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"a + b * c + d / e - f\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"(((a + (b * c)) + (d / e)) - f)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"3 + 4; -5 * 5\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"(3 + 4)((-5) * 5)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"5 > 4 == 3 < 4\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((5 > 4) == (3 < 4))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"5 < 4 != 3 > 4\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((5 < 4) != (3 > 4))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"3 + 4 * 5 == 3 * 1 + 4 * 5\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((3 + (4 * 5)) == ((3 * 1) + (4 * 5)))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        l := lexer.New(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        actual := program.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        if actual != tt.expected {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Errorf(\"expected=%q, got=%q\", tt.expected, actual)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "They’re all passing! That’s pretty amazing, isn’t it?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The different *ast.InfixExpressions are nested correctly, which we can", style: Normal, search_matches: [], inline_styles: [(14, 34, Code)], syntax_colors: [] }, RenderedLine { text: "observe thanks to our usage of parentheses in the String() methods of the", style: Normal, search_matches: [], inline_styles: [(50, 58, Code)], syntax_colors: [] }, RenderedLine { text: "AST nodes.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If you’re scratching your head and wondering how all of this works, don’t", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "worry. We’re now going to take a really close look at our parseExpression", style: Normal, search_matches: [], inline_styles: [(61, 75, Code)], syntax_colors: [] }, RenderedLine { text: "method.", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "2.7 - How Pratt Parsing Works", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The algorithm behind the parseExpression method and its combination of", style: Normal, search_matches: [], inline_styles: [(25, 40, Code)], syntax_colors: [] }, RenderedLine { text: "parsing functions and precedences is fully described by Vaughan Pratt in his", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“Top Down Operator Precedence” paper. But there are differences between his", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and our implementation.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Pratt doesn’t use a Parser structure and doesn’t pass around methods defined", style: Normal, search_matches: [], inline_styles: [(22, 28, Code)], syntax_colors: [] }, RenderedLine { text: "on *Parser. He also doesn’t use maps and, of course, he didn’t use Go. His", style: Normal, search_matches: [], inline_styles: [(4, 11, Code)], syntax_colors: [] }, RenderedLine { text: "paper predates the release of Go by 36 years. And then there are naming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "differences: what we call prefixParseFns are “nuds” (for “null denotations”)", style: Normal, search_matches: [], inline_styles: [(29, 42, Code)], syntax_colors: [] }, RenderedLine { text: "for Pratt. infixParseFns are “leds” (for “left denotations”).", style: Normal, search_matches: [], inline_styles: [(15, 28, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Formulated in pseudocode though, our parseExpression method looks strikingly", style: Normal, search_matches: [], inline_styles: [(37, 52, Code)], syntax_colors: [] }, RenderedLine { text: "similar to the code presented in Pratt’s paper. It uses the same algorithm", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "with barely any changes.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to skip the theory that answers why it works and just follow", style: Normal, search_matches: [], inline_styles: [(46, 49, Italic)], syntax_colors: [] }, RenderedLine { text: "how it works and how all the pieces (parseExpression, parsing functions and", style: Normal, search_matches: [], inline_styles: [(1, 4, Italic), (38, 53, Code)], syntax_colors: [] }, RenderedLine { text: "precedences) fit together by looking at an example. Suppose we’re parsing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the following expression statement:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "1 + 2 + 3;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The big challenge here is not to represent every operator and operand in the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "resulting AST, but to nest the nodes of the AST correctly. What we want is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an AST that (serialized as a string) looks like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "((1 + 2) + 3)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The AST needs to have two *ast.InfixExpression nodes. The", style: Normal, search_matches: [], inline_styles: [(26, 46, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.InfixExpression higher in the tree should have the integer literal", style: Normal, search_matches: [], inline_styles: [(0, 20, Code)], syntax_colors: [] }, RenderedLine { text: "3 as its Right child node and its Left child node needs to be the other", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (9, 14, Code), (34, 38, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.InfixExpression. This second *ast.InfixExpression then needs to", style: Normal, search_matches: [], inline_styles: [(0, 20, Code), (34, 54, Code)], syntax_colors: [] }, RenderedLine { text: "have the integer literals 1 and 2 as its Left and Right child nodes,", style: Normal, search_matches: [], inline_styles: [(26, 27, Code), (32, 33, Code), (41, 45, Code), (50, 55, Code)], syntax_colors: [] }, RenderedLine { text: "respectively. Like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And this is exactly what our parser outputs when it parses 1 + 2 +", style: Normal, search_matches: [], inline_styles: [(59, 66, Code)], syntax_colors: [] }, RenderedLine { text: "3;. But how? We’ll answer that question in the following paragraphs.", style: Normal, search_matches: [], inline_styles: [(0, 2, Code)], syntax_colors: [] }, RenderedLine { text: "We’re going take a close look at what the parser does as soon as", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseExpressionStatement is called for the first time. It’s not a mistake to", style: Normal, search_matches: [], inline_styles: [(2, 26, Code)], syntax_colors: [] }, RenderedLine { text: "have the code open while reading the following paragraphs.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So here we go. Here is what happens when we parse 1 + 2 + 3;:", style: Normal, search_matches: [], inline_styles: [(50, 60, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseExpressionStatement calls parseExpression(LOWEST). The p.curToken and", style: Normal, search_matches: [], inline_styles: [(0, 24, Code), (31, 54, Code), (60, 70, Code)], syntax_colors: [] }, RenderedLine { text: "p.peekToken are the 1 and the first +:", style: Normal, search_matches: [], inline_styles: [(0, 11, Code), (20, 21, Code), (36, 37, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing parseExpression then does is to check whether there", style: Normal, search_matches: [], inline_styles: [(16, 31, Code)], syntax_colors: [] }, RenderedLine { text: "is a prefixParseFn associated with the current p.curToken.Type, which", style: Normal, search_matches: [], inline_styles: [(5, 18, Code), (47, 62, Code)], syntax_colors: [] }, RenderedLine { text: "is a token.INT. And, yes, there is: parseIntegerLiteral. So it calls", style: Normal, search_matches: [], inline_styles: [(5, 14, Code), (36, 55, Code)], syntax_colors: [] }, RenderedLine { text: "parseIntegerLiteral, which returns an *ast.IntegerLiteral. parseExpression", style: Normal, search_matches: [], inline_styles: [(0, 19, Code), (38, 57, Code), (59, 74, Code)], syntax_colors: [] }, RenderedLine { text: "assigns this to leftExp.", style: Normal, search_matches: [], inline_styles: [(16, 23, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Then comes the new for-loop in parseExpression. Its condition evaluates", style: Normal, search_matches: [], inline_styles: [(31, 46, Code)], syntax_colors: [] }, RenderedLine { text: "to true:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "p.peekToken is not a token.SEMICOLON and peekPrecedence (which returns", style: Normal, search_matches: [], inline_styles: [(0, 11, Code), (21, 36, Code), (41, 55, Code)], syntax_colors: [] }, RenderedLine { text: "the precedence of the + token) is higher than the argument passed to", style: Normal, search_matches: [], inline_styles: [(22, 23, Code)], syntax_colors: [] }, RenderedLine { text: "parseExpression, which is LOWEST. Here are our defined precedences again to", style: Normal, search_matches: [], inline_styles: [(0, 15, Code), (26, 32, Code)], syntax_colors: [] }, RenderedLine { text: "refresh our memory:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "    _ int = iota", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    LOWEST", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    EQUALS      // ==", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    LESSGREATER // > or <", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    SUM         // +", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    PRODUCT     // *", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    PREFIX      // -X or !X", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    CALL        // myFunction(X)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So the condition evaluates to true and parseExpression executes the body of", style: Normal, search_matches: [], inline_styles: [(39, 54, Code)], syntax_colors: [] }, RenderedLine { text: "the loop, which looks like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "infix := p.infixParseFns[p.peekToken.Type]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "if infix == nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "  return leftExp", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "leftExp = infix(leftExp)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now it fetches the infixParseFn for p.peekToken.Type, which is", style: Normal, search_matches: [], inline_styles: [(19, 31, Code), (36, 52, Code)], syntax_colors: [] }, RenderedLine { text: "parseInfixExpression defined on *Parser. Before calling it and assigning", style: Normal, search_matches: [], inline_styles: [(0, 20, Code), (32, 39, Code)], syntax_colors: [] }, RenderedLine { text: "its return value to leftExp (reusing the leftExp variable!) it advances the", style: Normal, search_matches: [], inline_styles: [(20, 27, Code), (41, 48, Code)], syntax_colors: [] }, RenderedLine { text: "tokens so they now look like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With the tokens in this state, it calls parseInfixExpression and passes", style: Normal, search_matches: [], inline_styles: [(40, 60, Code)], syntax_colors: [] }, RenderedLine { text: "in the already parsed *ast.IntegerLiteral (assigned to leftExp outside the", style: Normal, search_matches: [], inline_styles: [(22, 41, Code), (55, 62, Code)], syntax_colors: [] }, RenderedLine { text: "for-loop). What happens next in parseInfixExpression is where things get", style: Normal, search_matches: [], inline_styles: [(32, 52, Code)], syntax_colors: [] }, RenderedLine { text: "interesting. Here is the method again:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression := &ast.InfixExpression{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        Token:    p.curToken,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        Operator: p.curToken.Literal,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        Left:     left,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    precedence := p.curPrecedence()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression.Right = p.parseExpression(precedence)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s important to note that left is our already parsed *ast.IntegerLiteral", style: Normal, search_matches: [], inline_styles: [(30, 34, Code), (57, 76, Code)], syntax_colors: [] }, RenderedLine { text: "that represents the 1.", style: Normal, search_matches: [], inline_styles: [(21, 22, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseInfixExpression saves the precedence of p.curToken (the first +", style: Normal, search_matches: [], inline_styles: [(0, 20, Code), (45, 55, Code), (67, 68, Code)], syntax_colors: [] }, RenderedLine { text: "token!), advances the tokens and calls parseExpression - passing in the just", style: Normal, search_matches: [], inline_styles: [(39, 54, Code)], syntax_colors: [] }, RenderedLine { text: "saved precedence. So now parseExpression is called the second time, with the", style: Normal, search_matches: [], inline_styles: [(25, 40, Code)], syntax_colors: [] }, RenderedLine { text: "tokens looking like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing parseExpression does again is to look for a prefixParseFn", style: Normal, search_matches: [], inline_styles: [(16, 31, Code), (60, 73, Code)], syntax_colors: [] }, RenderedLine { text: "for p.curToken. And again it’s parseIntegerLiteral. But now the condition", style: Normal, search_matches: [], inline_styles: [(4, 14, Code), (33, 52, Code)], syntax_colors: [] }, RenderedLine { text: "of the for-loop doesn’t evaluate to true: precedence (the argument passed", style: Normal, search_matches: [], inline_styles: [(45, 55, Code)], syntax_colors: [] }, RenderedLine { text: "to parseExpression) is the precedence of the first + operator in 1 + 2 +", style: Normal, search_matches: [], inline_styles: [(4, 19, Code), (46, 51, Italic), (52, 53, Code), (66, 72, Code)], syntax_colors: [] }, RenderedLine { text: "3, which is not smaller than the precedence of p.peekToken, the second +", style: Normal, search_matches: [], inline_styles: [(0, 2, Code), (13, 16, Italic), (48, 59, Code)], syntax_colors: [] }, RenderedLine { text: "operator. They are equal. The body of the for-loop is not executed and the", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.IntegerLiteral representing the 2 is returned.", style: Normal, search_matches: [], inline_styles: [(3, 22, Code), (40, 41, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now back in parseInfixExpression the return-value of parseExpression is", style: Normal, search_matches: [], inline_styles: [(12, 32, Code), (53, 68, Code)], syntax_colors: [] }, RenderedLine { text: "assigned to the Right field of the newly constructed *ast.InfixExpression.", style: Normal, search_matches: [], inline_styles: [(16, 21, Code), (53, 73, Code)], syntax_colors: [] }, RenderedLine { text: "So now we have this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This *ast.InfixExpression gets returned by parseInfixExpression and now", style: Normal, search_matches: [], inline_styles: [(5, 25, Code), (43, 63, Code)], syntax_colors: [] }, RenderedLine { text: "we’re back in the outer-most call to parseExpression, where precedence is", style: Normal, search_matches: [], inline_styles: [(39, 54, Code), (62, 72, Code)], syntax_colors: [] }, RenderedLine { text: "still LOWEST. We are back where we started and the condition of the for-loop", style: Normal, search_matches: [], inline_styles: [(7, 13, Code)], syntax_colors: [] }, RenderedLine { text: "is evaluated again.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This still evaluates to true, since precedence is LOWEST and peekPrecedence", style: Normal, search_matches: [], inline_styles: [(36, 46, Code), (50, 56, Code), (61, 75, Code)], syntax_colors: [] }, RenderedLine { text: "now returns the precedence of the second + in our expression, which is", style: Normal, search_matches: [], inline_styles: [(41, 42, Code)], syntax_colors: [] }, RenderedLine { text: "higher. parseExpression executes the body of the for-loop a second time. The", style: Normal, search_matches: [], inline_styles: [(8, 23, Code)], syntax_colors: [] }, RenderedLine { text: "difference is that now leftExp is not an *ast.IntegerLiteral representing", style: Normal, search_matches: [], inline_styles: [(23, 30, Code), (41, 60, Code)], syntax_colors: [] }, RenderedLine { text: "the 1, but the *ast.InfixExpression returned by parseInfixExpression,", style: Normal, search_matches: [], inline_styles: [(4, 5, Code), (15, 35, Code), (48, 68, Code)], syntax_colors: [] }, RenderedLine { text: "representing 1 + 2.", style: Normal, search_matches: [], inline_styles: [(13, 18, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In the body of the loop parseExpression fetches parseInfixExpression as", style: Normal, search_matches: [], inline_styles: [(24, 39, Code), (48, 68, Code)], syntax_colors: [] }, RenderedLine { text: "the infixParseFn for p.peekToken.Type (which is the second +), advances", style: Normal, search_matches: [], inline_styles: [(4, 16, Code), (21, 37, Code), (59, 60, Code)], syntax_colors: [] }, RenderedLine { text: "the tokens and calls parseInfixExpression with leftExp as the argument.", style: Normal, search_matches: [], inline_styles: [(21, 41, Code), (47, 54, Code)], syntax_colors: [] }, RenderedLine { text: "parseInfixExpression in turn calls parseExpression again, which returns the", style: Normal, search_matches: [], inline_styles: [(0, 20, Code), (35, 50, Code)], syntax_colors: [] }, RenderedLine { text: "last *ast.IntegerLiteral (that represents the 3 in our expression).", style: Normal, search_matches: [], inline_styles: [(5, 24, Code), (46, 47, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "After all this, at the end of the loop-body, leftExp looks like this:", style: Normal, search_matches: [], inline_styles: [(45, 52, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s exactly what we wanted! The operators and operands are nested", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "correctly! And our tokens look like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The condition of the for-loop evaluates to false:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now p.peekTokenIs(token.SEMICOLON) evaluates to true, which stops the body", style: Normal, search_matches: [], inline_styles: [(4, 34, Code)], syntax_colors: [] }, RenderedLine { text: "of the loop from being executed again.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "(The call to p.peekTokenIs(token.SEMICOLON) is not strictly necessary. Our", style: Normal, search_matches: [], inline_styles: [(13, 43, Code)], syntax_colors: [] }, RenderedLine { text: "peekPrecedence method returns LOWEST as the default value if no precedence", style: Normal, search_matches: [], inline_styles: [(0, 14, Code), (30, 36, Code)], syntax_colors: [] }, RenderedLine { text: "for p.peekToken.Type can be found - which is the case for token.SEMICOLON", style: Normal, search_matches: [], inline_styles: [(4, 20, Code), (58, 73, Code)], syntax_colors: [] }, RenderedLine { text: "tokens. But I think it makes the behaviour of semicolons as expression-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "ending-delimiters more explicit and easier to understand.)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s it! The for-loop is done and leftExp is returned. We’re back in", style: Normal, search_matches: [], inline_styles: [(42, 49, Code)], syntax_colors: [] }, RenderedLine { text: "parseExpressionStatement and have the final and correct *ast.InfixExpression", style: Normal, search_matches: [], inline_styles: [(1, 25, Code), (57, 76, Code)], syntax_colors: [] }, RenderedLine { text: "at hand. And that’s used as the Expression in *ast.ExpressionStatement.", style: Normal, search_matches: [], inline_styles: [(35, 45, Code), (49, 73, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now we know how our parser manages to parse 1 + 2 + 3 correctly. It’s pretty", style: Normal, search_matches: [], inline_styles: [(44, 53, Code)], syntax_colors: [] }, RenderedLine { text: "fascinating, isn’t it? I think the usage of precedence and peekPrecedence is", style: Normal, search_matches: [], inline_styles: [(47, 57, Code), (62, 76, Code)], syntax_colors: [] }, RenderedLine { text: "particularly interesting.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But what about “real precedence issues”? In our example every operator (the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "+) had the same precedence. What do the different precedence levels for", style: Normal, search_matches: [], inline_styles: [(1, 2, Code)], syntax_colors: [] }, RenderedLine { text: "operators accomplish? Couldn’t we just use LOWEST per default and something", style: Normal, search_matches: [], inline_styles: [(47, 53, Code)], syntax_colors: [] }, RenderedLine { text: "called HIGHEST for all operators?", style: Normal, search_matches: [], inline_styles: [(10, 17, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "No, because that would give us a wrong AST. The goal is to have expressions", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "involving operators with a higher precedence to be deeper in the tree than", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions with lower precedence operators. This is accomplished by the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "precedence value (the argument) in parseExpression.", style: Normal, search_matches: [], inline_styles: [(0, 10, Code), (35, 50, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When parseExpression is called the value of precedence stands for the", style: Normal, search_matches: [], inline_styles: [(5, 20, Code), (44, 54, Code)], syntax_colors: [] }, RenderedLine { text: "current “right-binding power” of the current parseExpression invocation.", style: Normal, search_matches: [], inline_styles: [(49, 64, Code)], syntax_colors: [] }, RenderedLine { text: "What does “right-binding power” mean? Well, the higher it is, the more", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tokens/operators/operands to the right of the current expressions (the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "future peek tokens) can we “bind” to it, or as I like to think, “suck in”.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In case our current right-binding power is of the highest possible", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "value, what we parsed so far (assigned to leftExp) is never passed to an", style: Normal, search_matches: [], inline_styles: [(42, 49, Code), (54, 59, Italic)], syntax_colors: [] }, RenderedLine { text: "infixParseFn associated with the next operator (or token). It will never", style: Normal, search_matches: [], inline_styles: [(0, 12, Code)], syntax_colors: [] }, RenderedLine { text: "end up as a “left” child node. Because the condition of the for-loop never", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluates to true.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A counterpart to right-binding power exists and it’s called (you guessed", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it!) “left-binding power”. But which value signifies this left-binding", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "power? Since the precedence argument in parseExpression stands for the", style: Normal, search_matches: [], inline_styles: [(19, 29, Code), (42, 57, Code)], syntax_colors: [] }, RenderedLine { text: "current right-binding power, where does the left-binding power of the next", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operator come from? Simply put: from our call to peekPrecedence. The value", style: Normal, search_matches: [], inline_styles: [(53, 67, Code)], syntax_colors: [] }, RenderedLine { text: "this call returns stands for the left-binding power of the next operator,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of p.peekToken.", style: Normal, search_matches: [], inline_styles: [(9, 15, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It all comes down to the precedence < p.peekPrecedence() condition of", style: Normal, search_matches: [], inline_styles: [(25, 56, Code)], syntax_colors: [] }, RenderedLine { text: "our for-loop. This condition checks if the left-binding power of the next", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operator/token is higher than our current right-binding power. If it is,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "what we parsed so far gets “sucked in” by the next operator, from left to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "right, and ends up being passed to the infixParseFn of the next operator.", style: Normal, search_matches: [], inline_styles: [(40, 52, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "An example: let’s say we’re parsing the expression statement -1 + 2;. What", style: Normal, search_matches: [], inline_styles: [(65, 72, Code)], syntax_colors: [] }, RenderedLine { text: "we want the AST to represent is (-1) + 2 and not -(1 + 2). The first method", style: Normal, search_matches: [], inline_styles: [(33, 41, Code), (50, 58, Code)], syntax_colors: [] }, RenderedLine { text: "we end up in (after parseExpressionStatement and parseExpression) is the", style: Normal, search_matches: [], inline_styles: [(21, 45, Code), (50, 65, Code)], syntax_colors: [] }, RenderedLine { text: "prefixParseFn we associated with token.MINUS: parsePrefixExpression. To", style: Normal, search_matches: [], inline_styles: [(2, 15, Code), (35, 46, Code), (48, 69, Code)], syntax_colors: [] }, RenderedLine { text: "refresh our memory of parsePrefixExpression here it is in its entirety:", style: Normal, search_matches: [], inline_styles: [(25, 46, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parsePrefixExpression() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "  expression := &ast.PrefixExpression{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token:    p.curToken,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    Operator: p.curToken.Literal,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "  p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "  expression.Right = p.parseExpression(PREFIX)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "  return expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This passes PREFIX to parseExpression as precedence, turning PREFIX into", style: Normal, search_matches: [], inline_styles: [(12, 18, Code), (22, 37, Code), (41, 51, Code), (61, 67, Code)], syntax_colors: [] }, RenderedLine { text: "the right-binding power of that parseExpression invocation. PREFIX is a", style: Normal, search_matches: [], inline_styles: [(32, 47, Code), (60, 66, Code)], syntax_colors: [] }, RenderedLine { text: "really high precedence, as per our definition. The result of this is that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseExpression(PREFIX) is never going to parse the 1 in -1 and pass it to", style: Normal, search_matches: [], inline_styles: [(0, 23, Code), (27, 32, Italic), (52, 53, Code), (57, 59, Code)], syntax_colors: [] }, RenderedLine { text: "another infixParseFn. The precedence < p.peekPrecedence() will never be true", style: Normal, search_matches: [], inline_styles: [(8, 20, Code), (26, 57, Code)], syntax_colors: [] }, RenderedLine { text: "in this case, meaning that no other infixParseFn is going to get our 1 as", style: Normal, search_matches: [], inline_styles: [(36, 48, Code), (69, 70, Code)], syntax_colors: [] }, RenderedLine { text: "the left arm. Instead the 1 is returned as the “right” arm of our prefix", style: Normal, search_matches: [], inline_styles: [(26, 27, Code)], syntax_colors: [] }, RenderedLine { text: "expression. Just the 1, not some other expression that comes after and needs", style: Normal, search_matches: [], inline_styles: [(22, 23, Code)], syntax_colors: [] }, RenderedLine { text: "to be parsed.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Back in the outer call to parseExpression (in which we called", style: Normal, search_matches: [], inline_styles: [(26, 41, Code)], syntax_colors: [] }, RenderedLine { text: "parsePrefixExpression as a prefixParseFn), right after the first leftExp :=", style: Normal, search_matches: [], inline_styles: [(0, 21, Code), (27, 40, Code), (65, 75, Code)], syntax_colors: [] }, RenderedLine { text: "prefix(), the value of precedence is still LOWEST. Since that was the value", style: Normal, search_matches: [], inline_styles: [(0, 8, Code), (23, 33, Code), (43, 49, Code)], syntax_colors: [] }, RenderedLine { text: "we used in the outer-most call. Our right-binding power is still LOWEST. The", style: Normal, search_matches: [], inline_styles: [(65, 71, Code)], syntax_colors: [] }, RenderedLine { text: "p.peekToken is now the + in -1 + 2.", style: Normal, search_matches: [], inline_styles: [(0, 11, Code), (23, 24, Code), (28, 34, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re now sitting on the condition of the for-loop and evaluate it to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "determine whether we should execute the body of the loop. And it turns out", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that the precedence of the + operator (returned by p.peekPrecedence()) is", style: Normal, search_matches: [], inline_styles: [(29, 30, Code), (53, 71, Code)], syntax_colors: [] }, RenderedLine { text: "higher than our current right-binding power. What we parsed so far (the -1", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "prefix expression) is now passed to the infixParseFn associated with +. The", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (42, 54, Code), (71, 72, Code)], syntax_colors: [] }, RenderedLine { text: "left-binding power of the + “sucks in” what we parsed so far and uses it as", style: Normal, search_matches: [], inline_styles: [(28, 29, Code)], syntax_colors: [] }, RenderedLine { text: "the “left arm” of the AST node it is constructing.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The infixParseFn for + is parseInfixExpression, which now uses the", style: Normal, search_matches: [], inline_styles: [(4, 16, Code), (21, 22, Code), (26, 46, Code)], syntax_colors: [] }, RenderedLine { text: "precedence of + as the right-binding power in its call to parseExpression.", style: Normal, search_matches: [], inline_styles: [(14, 15, Code), (58, 73, Code)], syntax_colors: [] }, RenderedLine { text: "It doesn’t use LOWEST, because that would result in another + having a", style: Normal, search_matches: [], inline_styles: [(17, 23, Code), (62, 63, Code)], syntax_colors: [] }, RenderedLine { text: "higher left-binding power and “sucking” away our “right arm”. If it did,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "then an expression like a + b + c would result in (a + (b + c)), which is", style: Normal, search_matches: [], inline_styles: [(26, 35, Code), (52, 65, Code)], syntax_colors: [] }, RenderedLine { text: "not what we want. We want ((a + b) + c).", style: Normal, search_matches: [], inline_styles: [(29, 40, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The high precedence of prefix operators worked. And it even works great for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "infix operators. In the classic example for operator precedences 1 + 2 *", style: Normal, search_matches: [], inline_styles: [(65, 72, Code)], syntax_colors: [] }, RenderedLine { text: "3, the left-binding power of * would be higher than the right-binding power", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (29, 30, Code)], syntax_colors: [] }, RenderedLine { text: "of +. Parsing this would result in the 2 being passed to the infixParseFn", style: Normal, search_matches: [], inline_styles: [(3, 4, Code), (39, 40, Code), (61, 73, Code)], syntax_colors: [] }, RenderedLine { text: "associated with the * token.", style: Normal, search_matches: [], inline_styles: [(20, 21, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Notable is that in our parser, every token has the same right- and left-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "binding power. We simply use one value (in our precedences table) as both.", style: Normal, search_matches: [], inline_styles: [(47, 58, Code)], syntax_colors: [] }, RenderedLine { text: "What this value means changes depending on the context.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If an operator should be right-associative instead of left-associative (in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the case of + that would result in (a + (b  + c)) instead of ((a + b) + c),", style: Normal, search_matches: [], inline_styles: [(12, 13, Code), (35, 49, Code), (61, 74, Code)], syntax_colors: [] }, RenderedLine { text: "then we must use a smaller “right-binding power” when parsing the “right", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "arm” of the operator expression. If you think about the ++ and -- operators", style: Normal, search_matches: [], inline_styles: [(59, 61, Code), (66, 68, Code)], syntax_colors: [] }, RenderedLine { text: "in other languages, where they can be used in a pre- and a postfix position,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "you can see why it’s sometimes useful to have differing left- and right-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "binding powers for operators.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Since we did not define separate right- and left-binding powers for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operators, but only use one value, we can’t just change a definition to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "achieve this. But, as an example, to make + right-associate we can decrement", style: Normal, search_matches: [], inline_styles: [(43, 44, Code)], syntax_colors: [] }, RenderedLine { text: "its precedence when calling parseExpression:", style: Normal, search_matches: [], inline_styles: [(30, 44, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression := &ast.InfixExpression{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        Token:    p.curToken,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        Operator: p.curToken.Literal,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        Left:     left,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    precedence := p.curPrecedence()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression.Right = p.parseExpression(precedence)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    //                                   ^^^ decrement here for right-associativity", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 83, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "For demonstration purposes, let’s change this method for a minute and see", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "what happens:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression := &ast.InfixExpression{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        Token:    p.curToken,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        Operator: p.curToken.Literal,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        Left:     left,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    precedence := p.curPrecedence()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if expression.Operator == \"+\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        expression.Right = p.parseExpression(precedence - 1)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        expression.Right = p.parseExpression(precedence)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With this change made, our tests tell us that + is officially right-", style: Normal, search_matches: [], inline_styles: [(46, 47, Code)], syntax_colors: [] }, RenderedLine { text: "associative:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test -run TestOperatorPrecedenceParsing ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestOperatorPrecedenceParsing (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:359: expected=\"((a + b) + c)\", got=\"(a + (b + c))\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:359: expected=\"((a + b) - c)\", got=\"(a + (b - c))\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:359: expected=\"(((a + (b * c)) + (d / e)) - f)\",\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=\"(a + ((b * c) + ((d / e) - f)))\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that marks the end of our deep dive into the bowels of parseExpression.", style: Normal, search_matches: [], inline_styles: [(59, 74, Code)], syntax_colors: [] }, RenderedLine { text: "If you’re still unsure and can’t grasp how it works, don’t worry, I felt", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the same. What really helped though was putting tracing statements in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the methods of Parser to see what was happening when parsing certain", style: Normal, search_matches: [], inline_styles: [(17, 23, Code)], syntax_colors: [] }, RenderedLine { text: "expressions. In the folder of code accompanying this chapter I’ve included", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a file called ./parser/parser_tracing.go, which we haven’t looked at before.", style: Normal, search_matches: [], inline_styles: [(18, 44, Code)], syntax_colors: [] }, RenderedLine { text: "The file includes two function definitions that are really helpful when", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "trying to understand what the parser does: trace and untrace. Use them like", style: Normal, search_matches: [], inline_styles: [(49, 54, Code), (59, 66, Code)], syntax_colors: [] }, RenderedLine { text: "this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "    defer untrace(trace(\"parseExpressionStatement\"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseExpression(precedence int) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "    defer untrace(trace(\"parseExpression\"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseIntegerLiteral() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    defer untrace(trace(\"parseIntegerLiteral\"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parsePrefixExpression() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "    defer untrace(trace(\"parsePrefixExpression\"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "    defer untrace(trace(\"parseInfixExpression\"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With these tracing statements included we can now use our parser and see", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "what it does. Here is the output when parsing the expression statement -1 *", style: Normal, search_matches: [], inline_styles: [(71, 75, Code)], syntax_colors: [] }, RenderedLine { text: "2 + 3 in the test suite:", style: Normal, search_matches: [], inline_styles: [(0, 5, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test -v -run TestOperatorPrecedenceParsing ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "=== RUN   TestOperatorPrecedenceParsing", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "BEGIN parseExpressionStatement", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        BEGIN parseExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "                BEGIN parsePrefixExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "                        BEGIN parseExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "                                BEGIN parseIntegerLiteral", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "                                END parseIntegerLiteral", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "                        END parseExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "                END parsePrefixExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "                BEGIN parseInfixExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "                        BEGIN parseExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "                                BEGIN parseIntegerLiteral", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "                                END parseIntegerLiteral", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "                        END parseExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "                END parseInfixExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "                BEGIN parseInfixExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "                        BEGIN parseExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "                                BEGIN parseIntegerLiteral", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "                                END parseIntegerLiteral", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "                        END parseExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "                END parseInfixExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        END parseExpression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "END parseExpressionStatement", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "--- PASS: TestOperatorPrecedenceParsing (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "PASS", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.008s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "2.8 - Extending the Parser", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Before we move on and extend our parser, we first need to clean up and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "extend our existing test suite. I won’t bore you by listing the complete", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "changes, but I will show you a few small helper functions that make the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tests easier to understand.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We already have a testIntegerLiteral test helper. A second function called", style: Normal, search_matches: [], inline_styles: [(18, 36, Code)], syntax_colors: [] }, RenderedLine { text: "testIdentifier can clean up a lot of other tests:", style: Normal, search_matches: [], inline_styles: [(0, 14, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testIdentifier(t *testing.T, exp ast.Expression, value string) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "    ident, ok := exp.(*ast.Identifier)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"exp not *ast.Identifier. got=%T\", exp)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if ident.Value != value {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"ident.Value not %s. got=%s\", value, ident.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if ident.TokenLiteral() != value {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"ident.TokenLiteral not %s. got=%s\", value,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "            ident.TokenLiteral())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The fun part is now using testIntegerLiteral and testIdentifier to build", style: Normal, search_matches: [], inline_styles: [(26, 44, Code), (49, 63, Code)], syntax_colors: [] }, RenderedLine { text: "more generic helper functions:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testLiteralExpression(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    t *testing.T,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    exp ast.Expression,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    expected interface{},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: ") bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch v := expected.(type) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "    case int:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        return testIntegerLiteral(t, exp, int64(v))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "    case int64:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "        return testIntegerLiteral(t, exp, v)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    case string:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "        return testIdentifier(t, exp, v)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    t.Errorf(\"type of exp not handled. got=%T\", exp)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testInfixExpression(t *testing.T, exp ast.Expression, left interface{},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "    operator string, right interface{}) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    opExp, ok := exp.(*ast.InfixExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"exp is not ast.InfixExpression. got=%T(%s)\", exp, exp)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !testLiteralExpression(t, opExp.Left, left) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if opExp.Operator != operator {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"exp.Operator is not '%s'. got=%q\", operator, opExp.Operator)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 78, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !testLiteralExpression(t, opExp.Right, right) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With these in place it’s possible to write test code like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "testInfixExpression(t, stmt.Expression, 5, \"+\", 10)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "testInfixExpression(t, stmt.Expression, \"alice\", \"*\", \"bob\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That makes it a lot easier to test properties of the ASTs produced by our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser. I went ahead and changed our existing parser tests to use these", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "new test helpers. In parser/parser_test.go you can see the cleaned up and", style: Normal, search_matches: [], inline_styles: [(21, 42, Code)], syntax_colors: [] }, RenderedLine { text: "extended test suite.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Boolean Literals", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There are a few things in the Monkey programming language that we still need", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to implement in our parser and AST. Easiest are boolean literals. In Monkey", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we can use booleans in place of any other expression:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "true;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "false;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "let foobar = true;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "let barfoo = false;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Like identifiers and integer literals their AST representation is simple", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and small:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Boolean struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value bool", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (b *Boolean) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "func (b *Boolean) TokenLiteral() string { return b.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "func (b *Boolean) String() string       { return b.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The Value field can hold values of the type bool, which means that we’re", style: Normal, search_matches: [], inline_styles: [(4, 9, Code), (44, 48, Code)], syntax_colors: [] }, RenderedLine { text: "going to save either true or false in there (the Go bool values, not the", style: Normal, search_matches: [], inline_styles: [(22, 26, Code), (30, 35, Code), (53, 57, Code)], syntax_colors: [] }, RenderedLine { text: "Monkey literals). With the AST node defined we can now add our tests.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The single TestBooleanExpression test function is so similar to the existing", style: Normal, search_matches: [], inline_styles: [(11, 32, Code)], syntax_colors: [] }, RenderedLine { text: "TestIdentifierExpression and TestIntegerLiteralExpression that I won’t show", style: Normal, search_matches: [], inline_styles: [(0, 24, Code), (29, 57, Code)], syntax_colors: [] }, RenderedLine { text: "it here. It’s enough to show the error message which points us in the right", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "direction as to how to implement boolean literal parsing:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestBooleanExpression (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:470: parser has 1 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:472: parser error: \"no prefix parse function for TRUE found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.008s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of course, yes. We need to register a prefixParseFn for token.TRUE and", style: Normal, search_matches: [], inline_styles: [(38, 51, Code), (56, 66, Code)], syntax_colors: [] }, RenderedLine { text: "token.FALSE tokens.", style: Normal, search_matches: [], inline_styles: [(0, 11, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.TRUE, p.parseBoolean)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.FALSE, p.parseBoolean)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And the parseBoolean method is exactly what you imagine it to be:", style: Normal, search_matches: [], inline_styles: [(8, 20, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseBoolean() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    return &ast.Boolean{Token: p.curToken, Value: p.curTokenIs(token.TRUE)}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The only mildly interesting part about this method is the inlining of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the p.curTokenIs(token.TRUE) call, which is not really interesting. Other", style: Normal, search_matches: [], inline_styles: [(4, 28, Code)], syntax_colors: [] }, RenderedLine { text: "than that it’s straightforward, maybe even boring. Or in other words: the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "structure of our parser serves us well! That actually is one of the beauties", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of Pratt’s approach: it’s so easy to extend.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And boom! The tests are green:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But what’s interesting is that we can now extend several tests to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "incorporate the newly implemented boolean literals. The first candidate is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestOperatorPrecedenceParsing, with its string comparison mechanism:", style: Normal, search_matches: [], inline_styles: [(2, 31, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestOperatorPrecedenceParsing(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"true\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"true\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"false\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"false\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"3 > 5 == false\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((3 > 5) == false)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"3 < 5 == true\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((3 < 5) == true)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can test for boolean literals in even more tests by extending our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "testLiteralExpression helper and providing a new testBooleanLiteral", style: Normal, search_matches: [], inline_styles: [(0, 21, Code), (49, 67, Code)], syntax_colors: [] }, RenderedLine { text: "function:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testLiteralExpression(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    t *testing.T,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    exp ast.Expression,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    expected interface{},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: ") bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch v := expected.(type) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case bool:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        return testBooleanLiteral(t, exp, v)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testBooleanLiteral(t *testing.T, exp ast.Expression, value bool) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "    bo, ok := exp.(*ast.Boolean)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"exp not *ast.Boolean. got=%T\", exp)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if bo.Value != value {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"bo.Value not %t. got=%t\", value, bo.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if bo.TokenLiteral() != fmt.Sprintf(\"%t\", value) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"bo.TokenLiteral not %t. got=%s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "            value, bo.TokenLiteral())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Nothing surprising here, just another case in a switch statement and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a new helper function. But with this in place, it’s easy to extend", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestParsingInfixExpressions:", style: Normal, search_matches: [], inline_styles: [(1, 28, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestParsingInfixExpressions(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    infixTests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        input      string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        leftValue  interface{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        operator   string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        rightValue interface{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"true == true\", true, \"==\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"true != false\", true, \"!=\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"false == false\", false, \"==\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range infixTests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if !testInfixExpression(t, stmt.Expression, tt.leftValue,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "            tt.operator, tt.rightValue) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "            return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And also TestParsingPrefixExpressions is easy to extend by just adding new", style: Normal, search_matches: [], inline_styles: [(9, 37, Code)], syntax_colors: [] }, RenderedLine { text: "entries to the test table:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestParsingPrefixExpressions(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    prefixTests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        operator string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        value    interface{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"!true;\", \"!\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"!false;\", \"!\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s time to pat ourselves on the back! We implemented the parsing of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "booleans and extended our tests in a way that gives us more test coverage", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "now and better tools later on. Good job!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Grouped Expressions", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What we’re about to see next is sometimes called “the greatest trick Vaughan", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Pratt ever pulled”. Actually, no, I just lied there, nobody says that.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But they should! I’m talking about parsing grouped expressions, of course.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In Monkey we can group expression with parentheses to influence their", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "precedence and thus the order in which they are evaluated in their context.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’ve seen the canonical example for this before:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "(5 + 5) * 2;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The parentheses group the 5 + 5 expression in order to give them a higher", style: Normal, search_matches: [], inline_styles: [(26, 31, Code)], syntax_colors: [] }, RenderedLine { text: "precedence and position them deeper in the AST, resulting in the correct", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluation order for this mathematical expression.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now you might be thinking “Oh come on, not with the precedence stuff again!", style: Normal, search_matches: [], inline_styles: [(26, 77, Italic)], syntax_colors: [] }, RenderedLine { text: "My head still hurts! This guy…” and you contemplate whether to skip to the", style: Normal, search_matches: [], inline_styles: [(0, 36, Italic)], syntax_colors: [] }, RenderedLine { text: "end of this chapter. Don’t! You have to see this!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re not going to write a unit test for grouped expressions, since they are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "not represented by a separate AST node type. Yes, that’s right. We do not", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "need to change our AST in order to parse grouped expressions correctly! What", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we’re going to do instead is to extend our TestOperatorPrecedenceParsing", style: Normal, search_matches: [], inline_styles: [(48, 74, Code)], syntax_colors: [] }, RenderedLine { text: "test function to make sure that parentheses actually group expressions and", style: Normal, search_matches: [], inline_styles: [(0, 3, Code)], syntax_colors: [] }, RenderedLine { text: "have an effect on the resulting AST.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestOperatorPrecedenceParsing(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"1 + (2 + 3) + 4\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((1 + (2 + 3)) + 4)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"(5 + 5) * 2\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((5 + 5) * 2)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"2 / (5 + 5)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"(2 / (5 + 5))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"-(5 + 5)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"(-(5 + 5))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"!(true == true)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"(!(true == true))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "They fail, as expected:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestOperatorPrecedenceParsing (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:531: parser has 3 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:533: parser error: \"no prefix parse function for ( found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:533: parser error: \"no prefix parse function for ) found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:533: parser error: \"no prefix parse function for + found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here comes the mind-blowing part. In order to get these tests to pass, all", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we need to do is add this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.LPAREN, p.parseGroupedExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseGroupedExpression() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    exp := p.parseExpression(LOWEST)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.RPAREN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return exp", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s it! Yes, it really is. The tests pass and the parentheses work as", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expected by boosting the precedence of the enclosed expressions. The concept", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of associating token types with functions really shines here. That’s all", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "there is to it. There is nothing happening here that we haven’t seen before.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I told you, didn’t I? It’s a great trick. With that said, let’s keep some of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the magic and move on.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If Expressions", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In Monkey we can use if and else just like we did hundreds of times in other", style: Normal, search_matches: [], inline_styles: [(21, 23, Code), (28, 32, Code)], syntax_colors: [] }, RenderedLine { text: "programming languages:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (x > y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "  return x;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "} else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "  return y;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The else is optional and can be left out:", style: Normal, search_matches: [], inline_styles: [(4, 8, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (x > y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "  return x;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s all very familiar. In Monkey though, if-else-conditionals are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions. That means that they produce a value and in the case of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if expressions that’s the last evaluated line. We don’t need the return", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statements here:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let foobar = if (x > y) { x } else { y };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Explaining the structure of if-else-conditionals is probably not necessary,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "but just so we’re clear on the naming, here it is:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (<condition>) <consequence> else <alternative>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The braces are part of consequence and alternative, because both are block", style: Normal, search_matches: [], inline_styles: [(23, 34, Code), (39, 50, Code)], syntax_colors: [] }, RenderedLine { text: "statements. Block statements are a series of statements (just like programs", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in Monkey) enclosed by an opening { and a closing }.", style: Normal, search_matches: [], inline_styles: [(34, 35, Code), (50, 51, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So far our recipe for success has been to “define AST nodes, write tests,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "make tests pass by writing parsing code, celebrate, pat ourselves on the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "back, congratulate each other, tell everyone” and, well, there’s no reason", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to change it now.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is the definition of the ast.IfExpression AST node:", style: Normal, search_matches: [], inline_styles: [(30, 46, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type IfExpression struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token       token.Token // The 'if' token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    Condition   Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    Consequence *BlockStatement", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    Alternative *BlockStatement", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (ie *IfExpression) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "func (ie *IfExpression) TokenLiteral() string { return ie.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 73, Rgb(192, 197, 206))] }, RenderedLine { text: "func (ie *IfExpression) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\"if\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(ie.Condition.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\" \")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(ie.Consequence.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if ie.Alternative != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        out.WriteString(\"else \")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        out.WriteString(ie.Alternative.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "No surprises here. ast.IfExpression fulfills the ast.Expression interface", style: Normal, search_matches: [], inline_styles: [(19, 35, Code), (49, 63, Code)], syntax_colors: [] }, RenderedLine { text: "and has three fields that can represent an if-else-conditional. Condition", style: Normal, search_matches: [], inline_styles: [(64, 73, Code)], syntax_colors: [] }, RenderedLine { text: "holds the condition, which can be any expression, and Consequence and", style: Normal, search_matches: [], inline_styles: [(54, 65, Code)], syntax_colors: [] }, RenderedLine { text: "Alternative point to the consequence and alternative of the conditional", style: Normal, search_matches: [], inline_styles: [(0, 11, Code)], syntax_colors: [] }, RenderedLine { text: "respectively. But they reference a new type, ast.BlockStatement. As we saw", style: Normal, search_matches: [], inline_styles: [(45, 63, Code)], syntax_colors: [] }, RenderedLine { text: "before, the consequence/alternative of an if-else-condition is just a series", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of statements. That’s exactly what ast.BlockStatement represents:", style: Normal, search_matches: [], inline_styles: [(37, 55, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type BlockStatement struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token      token.Token // the { token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    Statements []Statement", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (bs *BlockStatement) statementNode()       {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "func (bs *BlockStatement) TokenLiteral() string { return bs.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "func (bs *BlockStatement) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, s := range bs.Statements {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        out.WriteString(s.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The next step in our recipe for success is to add a test. By now, we know", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the drill and the test looks familiar:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestIfExpression(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `if (x < y) { x }`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(program.Statements) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program.Statements does not contain %d statements. got=%d\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "            1, len(program.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt, ok := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "            program.Statements[0])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    exp, ok := stmt.Expression.(*ast.IfExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"stmt.Expression is not ast.IfExpression. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "            stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !testInfixExpression(t, exp.Condition, \"x\", \"<\", \"y\") {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "        return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(exp.Consequence.Statements) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"consequence is not 1 statements. got=%d\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "            len(exp.Consequence.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    consequence, ok := exp.Consequence.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"Statements[0] is not ast.ExpressionStatement. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "            exp.Consequence.Statements[0])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !testIdentifier(t, consequence.Expression, \"x\") {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "        return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if exp.Alternative != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"exp.Alternative.Statements was not nil. got=%+v\", exp.Alternative)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 84, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I also added a TestIfElseExpression test function that uses the following", style: Normal, search_matches: [], inline_styles: [(15, 35, Code)], syntax_colors: [] }, RenderedLine { text: "test input:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (x < y) { x } else { y }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In TestIfElseExpression there are additional assertions on the Alternative", style: Normal, search_matches: [], inline_styles: [(3, 23, Code), (63, 74, Code)], syntax_colors: [] }, RenderedLine { text: "field of *ast.IfExpression. Both tests make assertions about the structure", style: Normal, search_matches: [], inline_styles: [(9, 26, Code)], syntax_colors: [] }, RenderedLine { text: "of the resulting *ast.IfExpression node and use the helper functions", style: Normal, search_matches: [], inline_styles: [(17, 34, Code)], syntax_colors: [] }, RenderedLine { text: "testInfixExpression and testIdentifier to keep the focus on the conditional", style: Normal, search_matches: [], inline_styles: [(0, 19, Code), (24, 38, Code)], syntax_colors: [] }, RenderedLine { text: "itself but also make sure that the rest of our parser is correctly", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "integrated.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Both tests fail with a lot of error messages. But we are familiar with all", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of them by now:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestIfExpression (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:659: parser has 3 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for IF found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for { found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for } found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestIfElseExpression (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:659: parser has 6 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for IF found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for { found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for } found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for ELSE found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for { found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for } found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to start with the first failing test: TestIfExpression. Clearly,", style: Normal, search_matches: [], inline_styles: [(52, 68, Code)], syntax_colors: [] }, RenderedLine { text: "we need to register a prefixParseFn for token.IF tokens.", style: Normal, search_matches: [], inline_styles: [(23, 36, Code), (41, 49, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.IF, p.parseIfExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseIfExpression() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression := &ast.IfExpression{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.LPAREN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression.Condition = p.parseExpression(LOWEST)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.RPAREN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.LBRACE) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    expression.Consequence = p.parseBlockStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In no other parsing function did we use expectPeek so extensively. There", style: Normal, search_matches: [], inline_styles: [(40, 50, Code)], syntax_colors: [] }, RenderedLine { text: "just wasn’t a need. Here it makes sense. expectPeek adds an error to the", style: Normal, search_matches: [], inline_styles: [(43, 53, Code)], syntax_colors: [] }, RenderedLine { text: "parser if p.peekToken is not of the expected type, but if it is, then it", style: Normal, search_matches: [], inline_styles: [(11, 22, Code)], syntax_colors: [] }, RenderedLine { text: "advances the tokens by calling the nextToken method. That’s exactly what we", style: Normal, search_matches: [], inline_styles: [(37, 46, Code)], syntax_colors: [] }, RenderedLine { text: "need here. We need there to be a ( right after the if and if it’s there we", style: Normal, search_matches: [], inline_styles: [(36, 37, Code), (54, 56, Code)], syntax_colors: [] }, RenderedLine { text: "need to jump over it. The same goes for the ) after the expression and the", style: Normal, search_matches: [], inline_styles: [(48, 49, Code)], syntax_colors: [] }, RenderedLine { text: "{ that marks the beginning of a block statement.", style: Normal, search_matches: [], inline_styles: [(4, 5, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This method also follows our parsing function protocol: the tokens get", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "advanced just enough so that parseBlockStatement sits on the { with", style: Normal, search_matches: [], inline_styles: [(29, 48, Code), (61, 62, Code)], syntax_colors: [] }, RenderedLine { text: "p.curToken being of type token.LBRACE. Here is parseBlockStatement:", style: Normal, search_matches: [], inline_styles: [(0, 10, Code), (25, 37, Code), (47, 66, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseBlockStatement() *ast.BlockStatement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    block := &ast.BlockStatement{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "    block.Statements = []ast.Statement{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for !p.curTokenIs(token.RBRACE) && !p.curTokenIs(token.EOF) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "        stmt := p.parseStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        if stmt != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            block.Statements = append(block.Statements, stmt)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return block", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseBlockStatement calls parseStatement until it encounters either a },", style: Normal, search_matches: [], inline_styles: [(0, 19, Code), (26, 40, Code), (70, 71, Code)], syntax_colors: [] }, RenderedLine { text: "which signifies the end of the block statement, or a token.EOF, which", style: Normal, search_matches: [], inline_styles: [(53, 62, Code)], syntax_colors: [] }, RenderedLine { text: "tells us that there’s no more tokens left to parse. In that case, we can’t", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "successfully parse the block statement and there’s no need to keep on", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "calling parseStatement in an endless loop.", style: Normal, search_matches: [], inline_styles: [(10, 24, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This looks really similar to our top-level ParseProgram method, where we", style: Normal, search_matches: [], inline_styles: [(43, 55, Code)], syntax_colors: [] }, RenderedLine { text: "also call parseStatement repeatedly until we encounter an “end token”, which", style: Normal, search_matches: [], inline_styles: [(10, 24, Code)], syntax_colors: [] }, RenderedLine { text: "in the case of ParseProgram is just the token.EOF token. The duplication of", style: Normal, search_matches: [], inline_styles: [(16, 28, Code), (41, 50, Code)], syntax_colors: [] }, RenderedLine { text: "the loop doesn’t hurt though, so we leave these two methods be and instead", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "take care of our tests:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestIfElseExpression (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:659: parser has 3 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for ELSE found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for { found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:661: parser error: \"no prefix parse function for } found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestIfExpression passes and TestIfElseExpression does not, exactly as", style: Normal, search_matches: [], inline_styles: [(0, 16, Code), (28, 48, Code)], syntax_colors: [] }, RenderedLine { text: "expected. Now, in order to support the else part of an if-else-condition,", style: Normal, search_matches: [], inline_styles: [(39, 43, Code)], syntax_colors: [] }, RenderedLine { text: "we need to check if it even exists and if so we need to parse the block", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statement that comes directly after the else:", style: Normal, search_matches: [], inline_styles: [(40, 44, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseIfExpression() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    expression.Consequence = p.parseBlockStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if p.peekTokenIs(token.ELSE) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if !p.expectPeek(token.LBRACE) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "            return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        expression.Alternative = p.parseBlockStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s all there is to it. The whole part of this method is constructed in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a way that allows an optional else but doesn’t add a parser error if there", style: Normal, search_matches: [], inline_styles: [(30, 34, Code)], syntax_colors: [] }, RenderedLine { text: "is none. After we parse the consequence-block-statement we check if the next", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "token is a token.ELSE token. Remember, at the end of parseBlockStatement", style: Normal, search_matches: [], inline_styles: [(13, 23, Code), (55, 72, Code)], syntax_colors: [] }, RenderedLine { text: "we’re sitting on the }. If we have a token.ELSE, we advance the tokens two", style: Normal, search_matches: [], inline_styles: [(0, 2, Code), (26, 27, Code), (42, 52, Code)], syntax_colors: [] }, RenderedLine { text: "times. The first time with a call to nextToken, since we already know that", style: Normal, search_matches: [], inline_styles: [(41, 50, Code)], syntax_colors: [] }, RenderedLine { text: "the p.peekToken is the else. Then with a call to expectPeek since now the", style: Normal, search_matches: [], inline_styles: [(9, 20, Code), (28, 32, Code), (54, 64, Code)], syntax_colors: [] }, RenderedLine { text: "next token has to be the opening brace of a block statement, otherwise the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "program is invalid.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, parsing is prone to off-by-one errors. It’s easy to forget advancing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the tokens or make a wrong call to nextToken. Having a strict protocol", style: Normal, search_matches: [], inline_styles: [(36, 45, Code)], syntax_colors: [] }, RenderedLine { text: "that dictates how every parsing function has to advance tokens helps a lot.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Luckily we also have a great test suite that lets us know everything works:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I don’t think I have to tell you anymore: good job all around! We did it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "- again.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Function Literals", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "You may have noticed that the parseIfExpression method we just added has a", style: Normal, search_matches: [], inline_styles: [(30, 47, Code)], syntax_colors: [] }, RenderedLine { text: "lot more meat to it than any of the prefixParseFns or infixParseFns we wrote", style: Normal, search_matches: [], inline_styles: [(36, 49, Code), (54, 66, Code)], syntax_colors: [] }, RenderedLine { text: "before. The main reason is that we had to work with many different token", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and expression types and even optional parts. What we’re going to do next is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "similar in its difficulty and variety of involved token types. We’re going", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to parse function literals.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In Monkey a function literal is how we define functions: which parameters", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "they have and what the function does. Function literals look like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fn(x, y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "  return x + y;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It starts with the keyword fn, followed by a list of parameters, followed by", style: Normal, search_matches: [], inline_styles: [(27, 29, Code)], syntax_colors: [] }, RenderedLine { text: "a block statement, which is the function’s body, that gets executed when the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function is called. The abstract structure of a function literal is this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fn <parameters> <block statement>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We already know what block statements are and how to parse them. The", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parameters are new though, but not much more difficult to parse. They", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "are just a list of identifiers that are comma-separated and surrounded by", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parentheses:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "(<parameter one>, <parameter two>, <parameter three>, ...)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This list can also be empty:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fn() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "  return foobar + barfoo;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s the structure of function literals. But what type of AST node are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "they? Expressions, of course! We can use function literals in every place", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "where any other expression is valid. For example, here is a function literal", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "as the expression in a let statement:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let myFunction = fn(x, y) { return x + y; }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And here is a function literal as the expression in a return statement", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "inside another function literal:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fn() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "  return fn(x, y) { return x > y; };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Using a function literal as an argument when calling another function is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "also possible:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "myFunc(x, y, fn(x, y) { return x > y; });", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That does sound complicated, but it’s not. One of the great things about our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser is that once we define function literals as expressions and provide a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function to correctly parse them the rest works. Sounds amazing? I agree.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We just saw that the two main parts of a function literal are the list of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parameters and the block statement that is the function’s body. That’s all", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we need to keep in mind when defining the AST node:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"strings\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type FunctionLiteral struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token      token.Token // The 'fn' token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    Parameters []*Identifier", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    Body       *BlockStatement", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (fl *FunctionLiteral) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "func (fl *FunctionLiteral) TokenLiteral() string { return fl.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "func (fl *FunctionLiteral) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    params := []string{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    for _, p := range fl.Parameters {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        params = append(params, p.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(fl.TokenLiteral())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\"(\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(strings.Join(params, \", \"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\") \")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(fl.Body.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The Parameters field is a slice of *ast.Identifiers, because that’s all", style: Normal, search_matches: [], inline_styles: [(4, 14, Code), (35, 51, Code)], syntax_colors: [] }, RenderedLine { text: "there is to it, and Body is an *ast.BlockStatement, which we saw and used", style: Normal, search_matches: [], inline_styles: [(21, 25, Code), (32, 51, Code)], syntax_colors: [] }, RenderedLine { text: "before.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is the test, in which we can use our helper functions", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "testLiteralExpression and testInfixExpression again:", style: Normal, search_matches: [], inline_styles: [(0, 21, Code), (26, 45, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestFunctionLiteralParsing(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `fn(x, y) { x + y; }`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(program.Statements) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program.Statements does not contain %d statements. got=%d\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "            1, len(program.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt, ok := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "            program.Statements[0])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    function, ok := stmt.Expression.(*ast.FunctionLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"stmt.Expression is not ast.FunctionLiteral. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "            stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(function.Parameters) != 2 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"function literal parameters wrong. want 2, got=%d\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "            len(function.Parameters))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    testLiteralExpression(t, function.Parameters[0], \"x\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "    testLiteralExpression(t, function.Parameters[1], \"y\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(function.Body.Statements) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"function.Body.Statements has not 1 statements. got=%d\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "            len(function.Body.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    bodyStmt, ok := function.Body.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"function body stmt is not ast.ExpressionStatement. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "            function.Body.Statements[0])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    testInfixExpression(t, bodyStmt.Expression, \"x\", \"+\", \"y\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So, the test has three main parts: check that the *ast.FunctionLiteral", style: Normal, search_matches: [], inline_styles: [(50, 70, Code)], syntax_colors: [] }, RenderedLine { text: "is there, check that the parameter list is correct and make sure that the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function body contains the correct statements. The last part is not strictly", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "necessary, since we already tested parsing block statements before in our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tests for IfExpressions. But I’m okay with duplicating some test assertions", style: Normal, search_matches: [], inline_styles: [(10, 22, Code)], syntax_colors: [] }, RenderedLine { text: "here that possibly alarm us when hooking up the parsing of block statements", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "failed.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With only ast.FunctionLiteral defined and nothing changed in the parser, the", style: Normal, search_matches: [], inline_styles: [(10, 29, Code)], syntax_colors: [] }, RenderedLine { text: "tests fail:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestFunctionLiteralParsing (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:755: parser has 6 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:757: parser error: \"no prefix parse function for FUNCTION found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 81, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:757: parser error: \"expected next token to be ), got , instead\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:757: parser error: \"no prefix parse function for , found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:757: parser error: \"no prefix parse function for ) found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:757: parser error: \"no prefix parse function for { found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:757: parser error: \"no prefix parse function for } found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s clear that we need to register a new prefixParseFn for token.FUNCTION", style: Normal, search_matches: [], inline_styles: [(44, 57, Code), (62, 76, Code)], syntax_colors: [] }, RenderedLine { text: "tokens.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.FUNCTION, p.parseFunctionLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseFunctionLiteral() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    lit := &ast.FunctionLiteral{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.LPAREN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    lit.Parameters = p.parseFunctionParameters()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.LBRACE) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    lit.Body = p.parseBlockStatement()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return lit", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The parseFunctionParameters method we use here to parse the literal’s", style: Normal, search_matches: [], inline_styles: [(4, 27, Code)], syntax_colors: [] }, RenderedLine { text: "parameters looks like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseFunctionParameters() []*ast.Identifier {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    identifiers := []*ast.Identifier{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if p.peekTokenIs(token.RPAREN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        return identifiers", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    ident := &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "    identifiers = append(identifiers, ident)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for p.peekTokenIs(token.COMMA) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        ident := &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 78, Rgb(192, 197, 206))] }, RenderedLine { text: "        identifiers = append(identifiers, ident)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.RPAREN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return identifiers", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There’s the heart of the matter. parseFunctionParameters constructs the", style: Normal, search_matches: [], inline_styles: [(35, 58, Code)], syntax_colors: [] }, RenderedLine { text: "slice of parameters by repeatedly building identifiers from the comma", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "separated list. It also makes an early exit if the list is empty and it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "carefully handles lists of varying sizes.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "For a method like this it really pays off to have another set of tests that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "check the edge cases: an empty parameter list, a list with one parameter and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a list with multiple parameters.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestFunctionParameterParsing(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input          string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedParams []string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {input: \"fn() {};\", expectedParams: []string{}},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "        {input: \"fn(x) {};\", expectedParams: []string{\"x\"}},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "        {input: \"fn(x, y, z) {};\", expectedParams: []string{\"x\", \"y\", \"z\"}},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        l := lexer.New(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        stmt := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "        function := stmt.Expression.(*ast.FunctionLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if len(function.Parameters) != len(tt.expectedParams) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Errorf(\"length parameters wrong. want %d, got=%d\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "                len(tt.expectedParams), len(function.Parameters))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        for i, ident := range tt.expectedParams {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "            testLiteralExpression(t, function.Parameters[i], ident)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Both of these test functions now pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Function literals are in the bag! Sweet! There is only one last thing to do", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "now before we can leave the parser and start talking about the evaluation of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "our AST.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Call Expressions", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now that we know how to parse function literals the next step is to parse", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the calling of a function: call expressions. Here is their structure:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "<expression>(<comma separated expressions>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What? Yup, that’s it, but granted, a few examples are needed. Here is the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "normal call expression we all know:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "add(2, 3)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now think about this: the add is an identifier. And identifiers are", style: Normal, search_matches: [], inline_styles: [(26, 29, Code)], syntax_colors: [] }, RenderedLine { text: "expressions. The arguments 2 and 3 are expressions too - integer literals.", style: Normal, search_matches: [], inline_styles: [(27, 28, Code), (33, 34, Code)], syntax_colors: [] }, RenderedLine { text: "But they don’t have to be, the arguments are just a list of expressions:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "add(2 + 2, 3 * 3 * 3)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s valid, too. The first argument is the infix expression 2 + 2 and", style: Normal, search_matches: [], inline_styles: [(64, 69, Code)], syntax_colors: [] }, RenderedLine { text: "the second one is 3 * 3 * 3. So far, so good. Now, let’s look at the", style: Normal, search_matches: [], inline_styles: [(19, 28, Code)], syntax_colors: [] }, RenderedLine { text: "function that’s being called here. In this case the function is bound", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to the identifier add. The identifier add returns this function when", style: Normal, search_matches: [], inline_styles: [(21, 24, Code), (41, 44, Code)], syntax_colors: [] }, RenderedLine { text: "it’s evaluated. That means, we could go straight to the source, skip the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "identifier and replace add with a function literal:", style: Normal, search_matches: [], inline_styles: [(28, 31, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fn(x, y) { x + y; }(2, 3)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, that’s valid. We can also use function literals as arguments:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "callsFunction(2, 3, fn(x, y) { x + y; });", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s look at the structure again:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "<expression>(<comma separated expressions>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Call expressions consist of an expression that results in a function when", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluated and a list of expressions that are the arguments to this function", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "call. As an AST node they look like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type CallExpression struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token     token.Token // The '(' token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    Function  Expression  // Identifier or FunctionLiteral", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "    Arguments []Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (ce *CallExpression) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "func (ce *CallExpression) TokenLiteral() string { return ce.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "func (ce *CallExpression) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    args := []string{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    for _, a := range ce.Arguments {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        args = append(args, a.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(ce.Function.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\"(\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(strings.Join(args, \", \"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\")\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The test case for call expressions is just like the rest of our test suite", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and makes assertions about the *ast.CallExpression structure:", style: Normal, search_matches: [], inline_styles: [(31, 50, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestCallExpressionParsing(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := \"add(1, 2 * 3, 4 + 5);\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(program.Statements) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"program.Statements does not contain %d statements. got=%d\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "            1, len(program.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt, ok := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"stmt is not ast.ExpressionStatement. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "            program.Statements[0])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    exp, ok := stmt.Expression.(*ast.CallExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"stmt.Expression is not ast.CallExpression. got=%T\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "            stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !testIdentifier(t, exp.Function, \"add\") {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "        return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(exp.Arguments) != 3 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"wrong length of arguments. got=%d\", len(exp.Arguments))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 73, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    testLiteralExpression(t, exp.Arguments[0], 1)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    testInfixExpression(t, exp.Arguments[1], 2, \"*\", 3)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    testInfixExpression(t, exp.Arguments[2], 4, \"+\", 5)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As with function literals and parameter parsing it’s also a good", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "idea to add a separate test for the argument parsing. Just to make", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "sure that every corner case works and is covered by a test. I added a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestCallExpressionParameterParsing test function that does exactly this. You", style: Normal, search_matches: [], inline_styles: [(2, 36, Code)], syntax_colors: [] }, RenderedLine { text: "can see it in the code for this chapter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So far, so familiar. But now comes the twist. If we run the tests we get", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this error message:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestCallExpressionParsing (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:853: parser has 4 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:855: parser error: \"expected next token to be ), got , instead\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:855: parser error: \"no prefix parse function for , found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:855: parser error: \"no prefix parse function for , found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:855: parser error: \"no prefix parse function for ) found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Huh, that doesn’t make a lot of sense. Why is there no error message telling", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "us to register a prefixParseFn for call expressions? Because there are no", style: Normal, search_matches: [], inline_styles: [(18, 31, Code), (68, 73, Italic)], syntax_colors: [] }, RenderedLine { text: "new token types in call expressions. So what do we do instead of registering", style: Normal, search_matches: [], inline_styles: [(0, 17, Italic)], syntax_colors: [] }, RenderedLine { text: "a prefixParseFn? Take at look at this:", style: Normal, search_matches: [], inline_styles: [(4, 17, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "add(2, 3);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The add is an identifier that’s parsed by a prefixParseFn. And after the", style: Normal, search_matches: [], inline_styles: [(4, 7, Code), (46, 59, Code)], syntax_colors: [] }, RenderedLine { text: "identifier comes a token.LPAREN, right between the identifier and the", style: Normal, search_matches: [], inline_styles: [(20, 32, Code)], syntax_colors: [] }, RenderedLine { text: "list of arguments, just in the middle, in infix position… Yes, we need to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "register an infixParseFn for token.LPAREN. This way we parse the expression", style: Normal, search_matches: [], inline_styles: [(15, 27, Code), (32, 44, Code)], syntax_colors: [] }, RenderedLine { text: "that is the function (either an identifier, or a function literal), then", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "check for an infixParseFn associated with token.LPAREN and call it with the", style: Normal, search_matches: [], inline_styles: [(17, 29, Code), (46, 58, Code)], syntax_colors: [] }, RenderedLine { text: "already parsed expression as argument. And in this infixParseFn we can then", style: Normal, search_matches: [], inline_styles: [(55, 67, Code)], syntax_colors: [] }, RenderedLine { text: "parse the argument list. Perfect!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerInfix(token.LPAREN, p.parseCallExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseCallExpression(function ast.Expression) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 78, Rgb(192, 197, 206))] }, RenderedLine { text: "    exp := &ast.CallExpression{Token: p.curToken, Function: function}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "    exp.Arguments = p.parseCallArguments()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    return exp", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseCallArguments() []ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    args := []ast.Expression{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if p.peekTokenIs(token.RPAREN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        return args", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    args = append(args, p.parseExpression(LOWEST))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for p.peekTokenIs(token.COMMA) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        args = append(args, p.parseExpression(LOWEST))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.RPAREN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return args", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseCallExpression receives the already parsed function as argument and", style: Normal, search_matches: [], inline_styles: [(0, 19, Code), (48, 56, Code)], syntax_colors: [] }, RenderedLine { text: "uses it to construct an *ast.CallExpression node. To parse the argument", style: Normal, search_matches: [], inline_styles: [(24, 43, Code)], syntax_colors: [] }, RenderedLine { text: "list we call parseCallArguments, which looks strikingly similar to", style: Normal, search_matches: [], inline_styles: [(13, 31, Code)], syntax_colors: [] }, RenderedLine { text: "parseFunctionParameters, except that it’s more generic and returns a slice", style: Normal, search_matches: [], inline_styles: [(0, 23, Code)], syntax_colors: [] }, RenderedLine { text: "of ast.Expression and not *ast.Identifier.", style: Normal, search_matches: [], inline_styles: [(4, 18, Code), (27, 42, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There is nothing here we haven’t seen before. All we did was register a new", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "infixParseFn. The tests still fail though:", style: Normal, search_matches: [], inline_styles: [(1, 13, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestCallExpressionParsing (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:853: parser has 4 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:855: parser error: \"expected next token to be ), got , instead\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:855: parser error: \"no prefix parse function for , found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:855: parser error: \"no prefix parse function for , found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:855: parser error: \"no prefix parse function for ) found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The reason that it still doesn’t work is that the ( in add(1, 2) acts", style: Normal, search_matches: [], inline_styles: [(52, 53, Code), (57, 66, Code)], syntax_colors: [] }, RenderedLine { text: "like an infix operator now, but we haven’t assigned a precedence to it. It", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "doesn’t have the right “stickiness” yet, so parseExpression doesn’t return", style: Normal, search_matches: [], inline_styles: [(52, 67, Code)], syntax_colors: [] }, RenderedLine { text: "what we want. But call expressions have the highest precedence of all, so", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it’s important that we fix our precedences table:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var precedences = map[token.TokenType]int{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    token.LPAREN:   CALL,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "To make sure that call expressions really have the highest precedence we can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "just extend our TestOperatorPrecedenceParsing test function:", style: Normal, search_matches: [], inline_styles: [(16, 45, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestOperatorPrecedenceParsing(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"a + add(b * c) + d\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((a + add((b * c))) + d)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"add(a, b, 1, 2 * 3, 4 + 5, add(6, 7 * 8))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"add(a, b, 1, (2 * 3), (4 + 5), add(6, (7 * 8)))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"add(a + b + c * d / f + g)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"add((((a + b) + ((c * d) / f)) + g))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If we now run the tests again, we can see that all of them pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.008s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, all of them: the unit test, the test for argument parsing and the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "precedence tests - wow! They all pass! And if that wasn’t enough, here’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "some more good news: we are done. Yes, the parser is finished. Granted,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we’ll come back to it later, at the end of the book, to extend it once more.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But for now: that’s it! The AST is fully defined and the parser works - it’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "time to move on to the topic of evaluation.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Before we do that though, let’s remove the TODOs we left in the code and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "extend our REPL to integrate the parser.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Removing TODOs", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When we wrote the code that parses let and return statements we took a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "shortcut by skipping over the expressions:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseLetStatement() *ast.LetStatement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    stmt := &ast.LetStatement{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.IDENT) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt.Name = &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.ASSIGN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // TODO: We're skipping the expressions until we", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    // encounter a semicolon", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    for !p.curTokenIs(token.SEMICOLON) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return stmt", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The same TODO sits in parseReturnStatement. It’s time to get rid of them. No", style: Normal, search_matches: [], inline_styles: [(9, 13, Code), (22, 42, Code)], syntax_colors: [] }, RenderedLine { text: "shortcuts. First of all, we need to extend our existing tests to make sure", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that the expressions, that are parsed as part of a let or return statement,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "are actually there. We do this by using our helper functions (that don’t", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "distract from the focus of the test) and different expression types, so we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "know that parseExpression is correctly integrated.", style: Normal, search_matches: [], inline_styles: [(14, 29, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is what the TestLetStatement function looks like:", style: Normal, search_matches: [], inline_styles: [(17, 33, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestLetStatements(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input              string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedIdentifier string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedValue      interface{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let x = 5;\", \"x\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let y = true;\", \"y\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let foobar = y;\", \"foobar\", \"y\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        l := lexer.New(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if len(program.Statements) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Fatalf(\"program.Statements does not contain 1 statements. got=%d\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "                len(program.Statements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        stmt := program.Statements[0]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !testLetStatement(t, stmt, tt.expectedIdentifier) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "            return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        val := stmt.(*ast.LetStatement).Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !testLiteralExpression(t, val, tt.expectedValue) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "            return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The same needs to be done for TestReturnStatements. And the fix is", style: Normal, search_matches: [], inline_styles: [(30, 50, Code)], syntax_colors: [] }, RenderedLine { text: "trivial, since we did such great work before. We merely need to hook up", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseExpression in parseReturnStatement and parseLetStatement. And we also", style: Normal, search_matches: [], inline_styles: [(0, 15, Code), (19, 39, Code), (44, 61, Code)], syntax_colors: [] }, RenderedLine { text: "need to take care of optional semicolons, which we already know how to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "do from parseExpressionStatement. The updated, fully-working versions of", style: Normal, search_matches: [], inline_styles: [(8, 32, Code)], syntax_colors: [] }, RenderedLine { text: "parseReturnStatement and parseLetStatement look like this:", style: Normal, search_matches: [], inline_styles: [(0, 20, Code), (25, 42, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseReturnStatement() *ast.ReturnStatement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    stmt := &ast.ReturnStatement{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt.ReturnValue = p.parseExpression(LOWEST)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if p.peekTokenIs(token.SEMICOLON) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return stmt", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseLetStatement() *ast.LetStatement {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    stmt := &ast.LetStatement{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.IDENT) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt.Name = &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.ASSIGN) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt.Value = p.parseExpression(LOWEST)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if p.peekTokenIs(token.SEMICOLON) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return stmt", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Ah! All TODOs removed from the code. Let’s take this parser for a test", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "drive.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "2.9 - Read-Parse-Print-Loop", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Up until now our REPL was more of a RLPL, a read-lex-print-loop. We don’t", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "know how to evaluate code yet, so replacing the “lex” with “evaluate”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is still out of the question. But what we most certainly know by now is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parsing. It’s time to replace the “lex” with “parse” and build a RPPL.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// repl/repl.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"bufio\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"fmt\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"io\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/lexer\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/parser\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Start(in io.Reader, out io.Writer) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    scanner := bufio.NewScanner(in)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        fmt.Fprintf(out, PROMPT)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        scanned := scanner.Scan()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !scanned {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "            return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        line := scanner.Text()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        l := lexer.New(line)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        p := parser.New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        if len(p.Errors()) != 0 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "            printParserErrors(out, p.Errors())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "            continue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        io.WriteString(out, program.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        io.WriteString(out, \"\\n\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func printParserErrors(out io.Writer, errors []string) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    for _, msg := range errors {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        io.WriteString(out, \"\\t\"+msg+\"\\n\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here we extend our loop to parse the line we just entered in the REPL.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The output of the parser, an *ast.Program, is then printed by calling its", style: Normal, search_matches: [], inline_styles: [(29, 41, Code)], syntax_colors: [] }, RenderedLine { text: "String method, which recursively calls the String method of all statements", style: Normal, search_matches: [], inline_styles: [(0, 6, Code), (43, 49, Code)], syntax_colors: [] }, RenderedLine { text: "belonging to that program. Now we can take the parser for a spin -", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interactively on the command line:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let x = 1 * 2 * 3 * 4 * 5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "let x = ((((1 * 2) * 3) * 4) * 5);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: ">> x * y / 2 + 3 * 8 - 123", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "((((x * y) / 2) + (3 * 8)) - 123)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: ">> true == false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "(true == false)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: ">>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Sweet! Now instead of calling String we could use any string-based", style: Normal, search_matches: [], inline_styles: [(30, 36, Code)], syntax_colors: [] }, RenderedLine { text: "representation of the AST to output here. We could add a PrettyPrint method", style: Normal, search_matches: [], inline_styles: [(57, 68, Code)], syntax_colors: [] }, RenderedLine { text: "that prints the type of the AST node and indents its child nodes correctly,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "or we could use ASCII color codes, or we could print an ASCII graph, or… The", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "point is: the sky is the limit.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But our RPPL still has a huge drawback. Here is what happens when the parser", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "runs into an error:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let x 12 * 3;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected next token to be =, got INT instead", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: ">>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s not a very nice error message. I mean, it does the job, yes, but it’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "not very nice, is it? The Monkey programming language deserves better. Here", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is a more user-friendly printParseError function that enhances the user-", style: Normal, search_matches: [], inline_styles: [(25, 40, Code)], syntax_colors: [] }, RenderedLine { text: "experience:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// repl/repl.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const MONKEY_FACE = `            __,__", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "   .--.  .-\"     \"-.  .--.", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "  / .. \\/  .-. .-.  \\/ .. \\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: " | |  '|  /   Y   \\  |'  | |", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: " | \\   \\  \\ 0 | 0 /  /   / |", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "  \\ '- ,\\.-\"\"\"\"\"\"\"-./, -' /", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "   ''-' /_   ^ ^   _\\ '-''", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "       |  \\._   _./  |", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "       \\   \\ '~' /   /", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        '._ '-=-' _.'", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "           '-----'", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func printParserErrors(out io.Writer, errors []string) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    io.WriteString(out, MONKEY_FACE)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    io.WriteString(out, \"Woops! We ran into some monkey business here!\\n\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "    io.WriteString(out, \" parser errors:\\n\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    for _, msg := range errors {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        io.WriteString(out, \"\\t\"+msg+\"\\n\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s better! If we now run into any parser errors, we get to see a monkey,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "which, really, is more than anyone could ask for:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let x 12 * 3", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "            __,__", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "   .--.  .-\"     \"-.  .--.", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "  / .. \\/  .-. .-.  \\/ .. \\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: " | |  '|  /   Y   \\  |'  | |", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: " | \\   \\  \\ 0 | 0 /  /   / |", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "  \\ '- ,\\.-\"\"\"\"\"\"\"-./, -' /", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "   ''-' /_   ^ ^   _\\ '-''", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "       |  \\._   _./  |", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "       \\   \\ '~' /   /", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        '._ '-=-' _.'", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "           '-----'", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "Woops! We ran into some monkey business here!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: " parser errors:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected next token to be =, got INT instead", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: ">>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "On second thought… Anyway, it’s time to start evaluating our AST.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>ch004.xhtml</title>\n  <style>\npre > code.sourceCode { white-space: pre; position: relative; }\npre > code.sourceCode > span { display: inline-block; line-height: 1.25; }\npre > code.sourceCode > span:empty { height: 1.2em; }\ncode.sourceCode > span { color: inherit; text-decoration: inherit; }\ndiv.sourceCode { margin: 1em 0; }\npre.sourceCode { margin: 0; }\n@media screen {\ndiv.sourceCode { overflow: auto; }\n}\n@media print {\npre > code.sourceCode { white-space: pre-wrap; }\npre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }\n}\npre.numberSource code\n  { counter-reset: source-line 0; }\npre.numberSource code > span\n  { position: relative; left: -4em; counter-increment: source-line; }\npre.numberSource code > span > a:first-child::before\n  { content: counter(source-line);\n    position: relative; left: -1em; text-align: right; vertical-align: baseline;\n    border: none; display: inline-block;\n    -webkit-touch-callout: none; -webkit-user-select: none;\n    -khtml-user-select: none; -moz-user-select: none;\n    -ms-user-select: none; user-select: none;\n    padding: 0 4px; width: 4em;\n    color: #aaaaaa;\n  }\npre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\ndiv.sourceCode\n  {   }\n@media screen {\npre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }\n}\ncode span.al { color: #ff0000; font-weight: bold; } /* Alert */\ncode span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */\ncode span.at { color: #7d9029; } /* Attribute */\ncode span.bn { color: #40a070; } /* BaseN */\ncode span.bu { } /* BuiltIn */\ncode span.cf { color: #007020; font-weight: bold; } /* ControlFlow */\ncode span.ch { color: #4070a0; } /* Char */\ncode span.cn { color: #880000; } /* Constant */\ncode span.co { color: #60a0b0; font-style: italic; } /* Comment */\ncode span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */\ncode span.do { color: #ba2121; font-style: italic; } /* Documentation */\ncode span.dt { color: #902000; } /* DataType */\ncode span.dv { color: #40a070; } /* DecVal */\ncode span.er { color: #ff0000; font-weight: bold; } /* Error */\ncode span.ex { } /* Extension */\ncode span.fl { color: #40a070; } /* Float */\ncode span.fu { color: #06287e; } /* Function */\ncode span.im { } /* Import */\ncode span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */\ncode span.kw { color: #007020; font-weight: bold; } /* Keyword */\ncode span.op { color: #666666; } /* Operator */\ncode span.ot { color: #007020; } /* Other */\ncode span.pp { color: #bc7a00; } /* Preprocessor */\ncode span.sc { color: #4070a0; } /* SpecialChar */\ncode span.ss { color: #bb6688; } /* SpecialString */\ncode span.st { color: #4070a0; } /* String */\ncode span.va { color: #19177c; } /* Variable */\ncode span.vs { color: #4070a0; } /* VerbatimString */\ncode span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */\n/* Apple Books 2.4+ doesn't like overflow:auto on syntax highlighting generated by skylighting */\n@media screen {\n  div.sourceCode { overflow: visible !important; }\n  p, span, pre, code, blockquote { overflow: visible !important; }\n}\n  </style>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"bodymatter\">\n<section id=\"parsing\" class=\"level1\" data-number=\"2\">\n<h1 data-number=\"2\">Parsing</h1>\n<section id=\"parsers\" class=\"level2\" data-number=\"2.1\">\n<h2 data-number=\"2.1\">2.1 - Parsers</h2>\n<p>Everyone who has ever programmed has probably heard about parsers, mostly by encountering a “parser error”. Or maybe heard or even said something like “we need to parse this”, “after it’s parsed”, “the parser blows up with this input”. The word “parser” is as common as “compiler”, “interpreter” and “programming language”. Everyone knows that parsers <em>exist</em>. They have to, right? Because who else would be responsible for “parser errors”?</p>\n<p>But what is a parser exactly? What is its job and how does it do it? This is what <a href=\"https://en.wikipedia.org/wiki/Parsing#Parser\">Wikipedia has to say</a>:</p>\n<blockquote>\n<p>A parser is a software component that takes input data (frequently text) and builds a data structure – often some kind of parse tree, abstract syntax tree or other hierarchical structure – giving a structural representation of the input, checking for correct syntax in the process. […] The parser is often preceded by a separate lexical analyser, which creates tokens from the sequence of input characters;</p>\n</blockquote>\n<p>For a Wikipedia article about a computer science topic this excerpt is remarkably easy to understand. We can even recognize our lexer in there!</p>\n<p>A parser turns its input into a data structure that represents the input. That sounds pretty abstract, so let me illustrate this with an example. Here is a little bit of JavaScript:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb1-1\"><a href=\"#cb1-1\"></a><span class=\"op\">&gt;</span> <span class=\"kw\">var</span> input <span class=\"op\">=</span> <span class=\"st\">&#39;{&quot;name&quot;: &quot;Thorsten&quot;, &quot;age&quot;: 28}&#39;</span><span class=\"op\">;</span></span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\"></a><span class=\"op\">&gt;</span> <span class=\"kw\">var</span> output <span class=\"op\">=</span> <span class=\"bu\">JSON</span><span class=\"op\">.</span><span class=\"fu\">parse</span>(input)<span class=\"op\">;</span></span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\"></a><span class=\"op\">&gt;</span> output</span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\"></a>{ <span class=\"dt\">name</span><span class=\"op\">:</span> <span class=\"st\">&#39;Thorsten&#39;</span><span class=\"op\">,</span> <span class=\"dt\">age</span><span class=\"op\">:</span> <span class=\"dv\">28</span> }</span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\"></a><span class=\"op\">&gt;</span> output<span class=\"op\">.</span><span class=\"at\">name</span></span>\n<span id=\"cb1-6\"><a href=\"#cb1-6\"></a><span class=\"st\">&#39;Thorsten&#39;</span></span>\n<span id=\"cb1-7\"><a href=\"#cb1-7\"></a><span class=\"op\">&gt;</span> output<span class=\"op\">.</span><span class=\"at\">age</span></span>\n<span id=\"cb1-8\"><a href=\"#cb1-8\"></a><span class=\"dv\">28</span></span>\n<span id=\"cb1-9\"><a href=\"#cb1-9\"></a><span class=\"op\">&gt;</span></span></code></pre></div>\n<p>Our <code>input</code> is just some text, a string. We then pass it to a parser hidden behind the <code>JSON.parse</code> function and receive an output value. This output is the data structure that represents the input: a JavaScript object with two fields named <code>name</code> and <code>age</code>, their values also corresponding to the input. We can now easily work with this data structure as demonstrated by accessing the <code>name</code> and <code>age</code> fields.</p>\n<p>“But”, I hear you say, “a JSON parser isn’t the same as a parser for a programming language! They’re different!” I can see where you’re coming from with this, but no, they are not different. At least not on a conceptual level. A JSON parser takes text as input and builds a data structure that represents the input. That’s exactly what the parser of a programming language does. The difference is that in the case of a JSON parser you can <em>see</em> the data structure when looking at the input. Whereas if you look at this</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb2-1\"><a href=\"#cb2-1\"></a><span class=\"cf\">if</span> ((<span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">2</span> <span class=\"op\">*</span> <span class=\"dv\">3</span>) <span class=\"op\">==</span> <span class=\"dv\">91</span>) { <span class=\"cf\">return</span> computeStuff(input1<span class=\"op\">,</span> input2)<span class=\"op\">;</span> }</span></code></pre></div>\n<p>it’s not immediately obvious how this could be represented with a data structure. This is why, at least for me, they seemed different on a deeper, conceptional level. My guess is that this perception of conceptional difference is mainly due to a lack of familiarity with programming language parsers and the data structures they produce. I have a lot more experience with writing JSON, parsing it with a parser and inspecting the output of the parser than with parsing programming languages. As users of programming languages we seldom get to see or interact with the parsed source code, with its internal representation. Lisp programmers are the exception to the rule – in Lisp the data structures used to represent the source code are the ones used by a Lisp user. The parsed source code is easily accessible as data in the program. “Code is data, data is code” is something you hear a lot from Lisp programmers.</p>\n<p>So, in order to bring our conceptual understanding of programming language parsers up to the level of our familiarity and intuitiveness with parsers of serialization languages (like JSON, YAML, TOML, INI, and so on) we need to understand the data structures they produce.</p>\n<p>In most interpreters and compilers the data structure used for the internal representation of the source code is called a “syntax tree” or an “abstract syntax tree” (AST for short). The “abstract” is based on the fact that certain details visible in the source code are omitted in the AST. Semicolons, newlines, whitespace, comments, braces, bracket and parentheses – depending on the language and the parser these details are not represented in the AST, but merely guide the parser when constructing it.</p>\n<p>A fact to note is that there is not one true, universal AST format that’s used by every parser. Their implementations are all pretty similar, the concept is the same, but they differ in details. The concrete implementation depends on the programming language being parsed.</p>\n<p>A small example should make things clearer. Let’s say that we have the following source code:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb3-1\"><a href=\"#cb3-1\"></a><span class=\"cf\">if</span> (<span class=\"dv\">3</span> <span class=\"op\">*</span> <span class=\"dv\">5</span> <span class=\"op\">&gt;</span> <span class=\"dv\">10</span>) {</span>\n<span id=\"cb3-2\"><a href=\"#cb3-2\"></a>  <span class=\"cf\">return</span> <span class=\"st\">&quot;hello&quot;</span><span class=\"op\">;</span></span>\n<span id=\"cb3-3\"><a href=\"#cb3-3\"></a>} <span class=\"cf\">else</span> {</span>\n<span id=\"cb3-4\"><a href=\"#cb3-4\"></a>  <span class=\"cf\">return</span>  <span class=\"st\">&quot;goodbye&quot;</span><span class=\"op\">;</span></span>\n<span id=\"cb3-5\"><a href=\"#cb3-5\"></a>}</span></code></pre></div>\n<p>And let’s say we are using JavaScript, have a <code>MagicLexer</code>, a <code>MagicParser</code> and the AST is built out of JavaScript objects, then the parsing step might produce something like this:</p>\n<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb4-1\"><a href=\"#cb4-1\"></a><span class=\"op\">&gt;</span> <span class=\"kw\">var</span> input <span class=\"op\">=</span> <span class=\"st\">&#39;if (3 * 5 &gt; 10) { return &quot;hello&quot;; } else { return &quot;goodbye&quot;; }&#39;</span><span class=\"op\">;</span></span>\n<span id=\"cb4-2\"><a href=\"#cb4-2\"></a><span class=\"op\">&gt;</span> <span class=\"kw\">var</span> tokens <span class=\"op\">=</span> MagicLexer<span class=\"op\">.</span><span class=\"fu\">parse</span>(input)<span class=\"op\">;</span></span>\n<span id=\"cb4-3\"><a href=\"#cb4-3\"></a><span class=\"op\">&gt;</span> MagicParser<span class=\"op\">.</span><span class=\"fu\">parse</span>(tokens)<span class=\"op\">;</span></span>\n<span id=\"cb4-4\"><a href=\"#cb4-4\"></a>{</span>\n<span id=\"cb4-5\"><a href=\"#cb4-5\"></a>  <span class=\"dt\">type</span><span class=\"op\">:</span> <span class=\"st\">&quot;if-statement&quot;</span><span class=\"op\">,</span></span>\n<span id=\"cb4-6\"><a href=\"#cb4-6\"></a>  <span class=\"dt\">condition</span><span class=\"op\">:</span> {</span>\n<span id=\"cb4-7\"><a href=\"#cb4-7\"></a>    <span class=\"dt\">type</span><span class=\"op\">:</span> <span class=\"st\">&quot;operator-expression&quot;</span><span class=\"op\">,</span></span>\n<span id=\"cb4-8\"><a href=\"#cb4-8\"></a>    <span class=\"dt\">operator</span><span class=\"op\">:</span> <span class=\"st\">&quot;&gt;&quot;</span><span class=\"op\">,</span></span>\n<span id=\"cb4-9\"><a href=\"#cb4-9\"></a>    <span class=\"dt\">left</span><span class=\"op\">:</span> {</span>\n<span id=\"cb4-10\"><a href=\"#cb4-10\"></a>      <span class=\"dt\">type</span><span class=\"op\">:</span> <span class=\"st\">&quot;operator-expression&quot;</span><span class=\"op\">,</span></span>\n<span id=\"cb4-11\"><a href=\"#cb4-11\"></a>      <span class=\"dt\">operator</span><span class=\"op\">:</span> <span class=\"st\">&quot;*&quot;</span><span class=\"op\">,</span></span>\n<span id=\"cb4-12\"><a href=\"#cb4-12\"></a>      <span class=\"dt\">left</span><span class=\"op\">:</span> { <span class=\"dt\">type</span><span class=\"op\">:</span> <span class=\"st\">&quot;integer-literal&quot;</span><span class=\"op\">,</span> <span class=\"dt\">value</span><span class=\"op\">:</span> <span class=\"dv\">3</span> }<span class=\"op\">,</span></span>\n<span id=\"cb4-13\"><a href=\"#cb4-13\"></a>      <span class=\"dt\">right</span><span class=\"op\">:</span> { <span class=\"dt\">type</span><span class=\"op\">:</span> <span class=\"st\">&quot;integer-literal&quot;</span><span class=\"op\">,</span> <span class=\"dt\">value</span><span class=\"op\">:</span> <span class=\"dv\">5</span> }</span>\n<span id=\"cb4-14\"><a href=\"#cb4-14\"></a>    }<span class=\"op\">,</span></span>\n<span id=\"cb4-15\"><a href=\"#cb4-15\"></a>    <span class=\"dt\">right</span><span class=\"op\">:</span> { <span class=\"dt\">type</span><span class=\"op\">:</span> <span class=\"st\">&quot;integer-literal&quot;</span><span class=\"op\">,</span> <span class=\"dt\">value</span><span class=\"op\">:</span> <span class=\"dv\">10</span> }</span>\n<span id=\"cb4-16\"><a href=\"#cb4-16\"></a>  }<span class=\"op\">,</span></span>\n<span id=\"cb4-17\"><a href=\"#cb4-17\"></a>  <span class=\"dt\">consequence</span><span class=\"op\">:</span> {</span>\n<span id=\"cb4-18\"><a href=\"#cb4-18\"></a>    <span class=\"dt\">type</span><span class=\"op\">:</span> <span class=\"st\">&quot;return-statement&quot;</span><span class=\"op\">,</span></span>\n<span id=\"cb4-19\"><a href=\"#cb4-19\"></a>    <span class=\"dt\">returnValue</span><span class=\"op\">:</span> { <span class=\"dt\">type</span><span class=\"op\">:</span> <span class=\"st\">&quot;string-literal&quot;</span><span class=\"op\">,</span> <span class=\"dt\">value</span><span class=\"op\">:</span> <span class=\"st\">&quot;hello&quot;</span> }</span>\n<span id=\"cb4-20\"><a href=\"#cb4-20\"></a>  }<span class=\"op\">,</span></span>\n<span id=\"cb4-21\"><a href=\"#cb4-21\"></a>  <span class=\"dt\">alternative</span><span class=\"op\">:</span> {</span>\n<span id=\"cb4-22\"><a href=\"#cb4-22\"></a>    <span class=\"dt\">type</span><span class=\"op\">:</span> <span class=\"st\">&quot;return-statement&quot;</span><span class=\"op\">,</span></span>\n<span id=\"cb4-23\"><a href=\"#cb4-23\"></a>    <span class=\"dt\">returnValue</span><span class=\"op\">:</span> { <span class=\"dt\">type</span><span class=\"op\">:</span> <span class=\"st\">&quot;string-literal&quot;</span><span class=\"op\">,</span> <span class=\"dt\">value</span><span class=\"op\">:</span> <span class=\"st\">&quot;goodbye&quot;</span> }</span>\n<span id=\"cb4-24\"><a href=\"#cb4-24\"></a>  }</span>\n<span id=\"cb4-25\"><a href=\"#cb4-25\"></a>}</span></code></pre></div>\n<p>As you can see, the output of the parser, the AST, <em>is</em> pretty abstract: there are no parentheses, no semicolons and no braces. But it does represent the source code pretty accurately, don’t you think? I bet that you can now “see” the AST structure when looking back at the source code!</p>\n<p>So, this is what parsers do. They take source code as input (either as text or tokens) and produce a data structure which represents this source code. While building up the data structure, they unavoidably analyse the input, checking that it conforms to the expected structure. Thus the process of parsing is also called syntactic analysis.</p>\n<p>In this chapter, we’re going to write our parser for the Monkey programming language. Its input will be the tokens we defined in the previous chapter, produced by the lexer we already wrote. We will define our own AST, suited to our needs as interpreters of the Monkey programming language, and construct instances of this AST while recursively parsing tokens.</p>\n</section>\n<section id=\"why-not-a-parser-generator\" class=\"level2\" data-number=\"2.2\">\n<h2 data-number=\"2.2\">2.2 - Why not a parser generator?</h2>\n<p>Maybe you’ve already heard about parser generators, like the tools yacc, bison or ANTLR. Parser generators are tools that, when fed with a formal description of a language, produce parsers as their output. This output is code that can then be compiled/interpreted and itself fed with source code as input to produce a syntax tree.</p>\n<p>There are a lot of parser generators, differing in the format of the input they accept and the language of the output they produce. The majority of them use a <em>context-free grammar</em> (CFG) as their input. A CFG is a set of rules that describe how to form correct (valid according to the syntax) sentences in a language. The most common notational formats of CFGs are the Backus-Naur Form (BNF) or the Extended Backus-Naur Form (EBNF).</p>\n<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb5-1\"><a href=\"#cb5-1\"></a>PrimaryExpression ::= &quot;this&quot;</span>\n<span id=\"cb5-2\"><a href=\"#cb5-2\"></a>                    | ObjectLiteral</span>\n<span id=\"cb5-3\"><a href=\"#cb5-3\"></a>                    | ( &quot;(&quot; Expression &quot;)&quot; )</span>\n<span id=\"cb5-4\"><a href=\"#cb5-4\"></a>                    | Identifier</span>\n<span id=\"cb5-5\"><a href=\"#cb5-5\"></a>                    | ArrayLiteral</span>\n<span id=\"cb5-6\"><a href=\"#cb5-6\"></a>                    | Literal</span>\n<span id=\"cb5-7\"><a href=\"#cb5-7\"></a>Literal ::= ( &lt;DECIMAL_LITERAL&gt;</span>\n<span id=\"cb5-8\"><a href=\"#cb5-8\"></a>            | &lt;HEX_INTEGER_LITERAL&gt;</span>\n<span id=\"cb5-9\"><a href=\"#cb5-9\"></a>            | &lt;STRING_LITERAL&gt;</span>\n<span id=\"cb5-10\"><a href=\"#cb5-10\"></a>            | &lt;BOOLEAN_LITERAL&gt;</span>\n<span id=\"cb5-11\"><a href=\"#cb5-11\"></a>            | &lt;NULL_LITERAL&gt;</span>\n<span id=\"cb5-12\"><a href=\"#cb5-12\"></a>            | &lt;REGULAR_EXPRESSION_LITERAL&gt; )</span>\n<span id=\"cb5-13\"><a href=\"#cb5-13\"></a>Identifier ::= &lt;IDENTIFIER_NAME&gt;</span>\n<span id=\"cb5-14\"><a href=\"#cb5-14\"></a>ArrayLiteral ::= &quot;[&quot; ( ( Elision )? &quot;]&quot;</span>\n<span id=\"cb5-15\"><a href=\"#cb5-15\"></a>                 | ElementList Elision &quot;]&quot;</span>\n<span id=\"cb5-16\"><a href=\"#cb5-16\"></a>                 | ( ElementList )? &quot;]&quot; )</span>\n<span id=\"cb5-17\"><a href=\"#cb5-17\"></a>ElementList ::= ( Elision )? AssignmentExpression</span>\n<span id=\"cb5-18\"><a href=\"#cb5-18\"></a>                ( Elision AssignmentExpression )*</span>\n<span id=\"cb5-19\"><a href=\"#cb5-19\"></a>Elision ::= ( &quot;,&quot; )+</span>\n<span id=\"cb5-20\"><a href=\"#cb5-20\"></a>ObjectLiteral ::= &quot;{&quot; ( PropertyNameAndValueList )? &quot;}&quot;</span>\n<span id=\"cb5-21\"><a href=\"#cb5-21\"></a>PropertyNameAndValueList ::= PropertyNameAndValue ( &quot;,&quot; PropertyNameAndValue</span>\n<span id=\"cb5-22\"><a href=\"#cb5-22\"></a>                                                  | &quot;,&quot; )*</span>\n<span id=\"cb5-23\"><a href=\"#cb5-23\"></a>PropertyNameAndValue ::= PropertyName &quot;:&quot; AssignmentExpression</span>\n<span id=\"cb5-24\"><a href=\"#cb5-24\"></a>PropertyName ::= Identifier</span>\n<span id=\"cb5-25\"><a href=\"#cb5-25\"></a>              | &lt;STRING_LITERAL&gt;</span>\n<span id=\"cb5-26\"><a href=\"#cb5-26\"></a>              | &lt;DECIMAL_LITERAL&gt;</span></code></pre></div>\n<p>This is part of <a href=\"http://tomcopeland.blogs.com/EcmaScript.html\">a full description</a> of the EcmaScript syntax, in BNF. A parser generator would take something like this and turn it into compilable C code, for example.</p>\n<p>Maybe you’ve also heard that you should use a parser generator instead of writing a parser by hand. “Just skip this part”, they say, “it’s a solved problem.” The reason for this recommendation is that parsers are exceptionally well suited to being automatically generated. Parsing is one of the most well-understood branches of computer science and really smart people have already invested a lot of time into the problems of parsing. The results of their work are CFG, BNF, EBNF, parser generators and advanced parsing techniques used in them. Why shouldn’t you take advantage of that?</p>\n<p>I don’t think that learning to write your own parser is a waste of time. I actually think it’s immensely valuable. Only after having written your own parser, or at least attempted to, will you see the benefits parser generators provide, the drawbacks they have and the problems they solve. For me the concept of a parser generator only “clicked” after I wrote my first parser. I looked at it and only then really and truly understood how it’s possible to generate this code automatically.</p>\n<p>Most people that recommend using a parser generator, when others want to get started with interpreters and compilers, only do so because they’ve written a parser themselves before. They’ve seen the problems and solutions available and decided it’s better to use an existing tool for the job. And they’re correct - when you want to get something done and are in a production environment, where correctness and robustness are priorities. Of course you shouldn’t try to write your own parser then, especially not if you’ve never written one before.</p>\n<p>But we are here to learn, we want to understand how parsers work. And it’s my opinion that the best way to do that is by getting our hands dirty and writing a parser ourselves. Also, I think it’s immense fun.</p>\n</section>\n<section id=\"writing-a-parser-for-the-monkey-programming-language\" class=\"level2\" data-number=\"2.3\">\n<h2 data-number=\"2.3\">2.3 - Writing a Parser for the Monkey Programming Language</h2>\n<p>There are two main strategies when parsing a programming language: top-down parsing or bottom-up parsing. A lot of slightly different forms of each strategy exist. For example, “recursive descent parsing”, “Early parsing” or “predictive parsing” are all variations of top down parsing.</p>\n<p>The parser we are going to write is a recursive descent parser. And in particular, it’s a “top down operator precedence” parser, sometimes called “Pratt parser”, after its inventor Vaughan Pratt.</p>\n<p>I won’t go into the details of different parsing strategies here, because this is neither the place nor am I qualified enough to accurately describe them. Instead, let me just say, that the difference between top down and bottom up parsers is that the former starts with constructing root node of the AST and then descends while the latter does it the other way around. A recursive descent parser, which works from the top down, is often recommended for newcomers to parsing, since it closely mirrors the way we think about ASTs and their construction. I personally found the recursive approach starting at the root node really nice, even though it took writing some code before the concept really clicked. Which is another reason to get started with the code instead of delving into parsing strategies.</p>\n<p>Now, when writing a parser ourselves, we have to make some trade-offs, yes. Our parser won’t be the fastest of all time, we won’t have formal proof of its correctness and its error-recovery process and detection of erroneous syntax won’t be bullet proof. The last one is especially hard to get right without extensive study of the theory surrounding parsing. But what we’re going to have is a fully working parser for the Monkey programming language that’s open for extensions and improvements, easy to understand and a great start to further dive into the topic of parsing, if one were so inclined.</p>\n<p>We’re going to start by parsing statements: let and return statements. When we can parse statements and the basic structure of our parser stands, we will look at expressions and how to parse these (this is where Vaughan Pratt will come into play). Afterwards we extend the parser to make it capable of parsing a large subset of the Monkey programming language. As we go along we build up the necessary structures for our AST.</p>\n</section>\n<section id=\"parsers-first-steps-parsing-let-statements\" class=\"level2\" data-number=\"2.4\">\n<h2 data-number=\"2.4\">2.4 - Parser’s first steps: parsing let statements</h2>\n<p>In Monkey, variable bindings are statements of the following form:</p>\n<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb6-1\"><a href=\"#cb6-1\"></a><span class=\"kw\">let</span> x <span class=\"op\">=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb6-2\"><a href=\"#cb6-2\"></a><span class=\"kw\">let</span> y <span class=\"op\">=</span> <span class=\"dv\">10</span><span class=\"op\">;</span></span>\n<span id=\"cb6-3\"><a href=\"#cb6-3\"></a><span class=\"kw\">let</span> foobar <span class=\"op\">=</span> add(<span class=\"dv\">5</span><span class=\"op\">,</span> <span class=\"dv\">5</span>)<span class=\"op\">;</span></span>\n<span id=\"cb6-4\"><a href=\"#cb6-4\"></a><span class=\"kw\">let</span> barfoo <span class=\"op\">=</span> <span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">5</span> <span class=\"op\">/</span> <span class=\"dv\">10</span> <span class=\"op\">+</span> <span class=\"dv\">18</span> <span class=\"op\">-</span> add(<span class=\"dv\">5</span><span class=\"op\">,</span> <span class=\"dv\">5</span>) <span class=\"op\">+</span> multiply(<span class=\"dv\">124</span>)<span class=\"op\">;</span></span>\n<span id=\"cb6-5\"><a href=\"#cb6-5\"></a><span class=\"kw\">let</span> anotherName <span class=\"op\">=</span> barfoo<span class=\"op\">;</span></span></code></pre></div>\n<p>These statements are called “let statements” and bind a value to the given name. <code>let x = 5;</code> binds the value <code>5</code> to the name <code>x</code>. Our job in this section is to parse let statements correctly. For now we’re going to skip parsing the expressions that produce the value of a given variable binding and come back to this later - as soon as we know how to parse expressions on their own.</p>\n<p>What does it mean to parse let statements correctly? It means that the parser produces an AST that accurately represents the information contained in the original let statement. That sounds reasonable, but we don’t have an AST yet, nor do we know what it should look like. So our first task is to take a close look at Monkey source code and see how it’s structured, so that we can define the necessary parts of an AST that’s able to accurately represent let statements.</p>\n<p>Here is a fully valid program written in Monkey:</p>\n<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb7-1\"><a href=\"#cb7-1\"></a><span class=\"kw\">let</span> x <span class=\"op\">=</span> <span class=\"dv\">10</span><span class=\"op\">;</span></span>\n<span id=\"cb7-2\"><a href=\"#cb7-2\"></a><span class=\"kw\">let</span> y <span class=\"op\">=</span> <span class=\"dv\">15</span><span class=\"op\">;</span></span>\n<span id=\"cb7-3\"><a href=\"#cb7-3\"></a></span>\n<span id=\"cb7-4\"><a href=\"#cb7-4\"></a><span class=\"kw\">let</span> add <span class=\"op\">=</span> fn(a<span class=\"op\">,</span> b) {</span>\n<span id=\"cb7-5\"><a href=\"#cb7-5\"></a>  <span class=\"cf\">return</span> a <span class=\"op\">+</span> b<span class=\"op\">;</span></span>\n<span id=\"cb7-6\"><a href=\"#cb7-6\"></a>}<span class=\"op\">;</span></span></code></pre></div>\n<p>Programs in Monkey are a series of statements. In this example we can see three statements, three variable bindings - let statements - of the following form:</p>\n<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb8-1\"><a href=\"#cb8-1\"></a>let &lt;identifier&gt; = &lt;expression&gt;;</span></code></pre></div>\n<p>A let statement in Monkey consists of two changing parts: an identifier and an expression. In the example above <code>x</code>, <code>y</code> and <code>add</code> are identifiers. <code>10</code>, <code>15</code> and the function literal are expressions.</p>\n<p>Before we go on, a few words about the difference between statements and expressions are needed. Expressions produce values, statements don’t. <code>let x = 5</code> doesn’t produce a value, whereas <code>5</code> does (the value it produces is <code>5</code>). A <code>return 5;</code> statement doesn’t produce a value, but <code>add(5, 5)</code> does. This distinction - expressions produce values, statements don’t - changes depending on who you ask, but it’s good enough for our needs.</p>\n<p>What exactly an expression is or a statement, what produces values and what doesn’t, depends on the programming language. In some languages function literals (e.g.: <code>fn(x, y) { return x + y; }</code>) are expressions and can be used in any place where any other expression is allowed. In other programming languages though function literals can only be part of a function declaration statement, in the top level of the program. Some languages also have “if expressions”, where conditionals are expressions and produce a value. This is entirely dependent on the choices the language designers made. As you’ll see, a lot of things in Monkey are expressions, including function literals.</p>\n<p>Back to our AST. Looking at the example above, we can see that it needs two different types of nodes: expressions and statements. Take a look at the start of our AST:</p>\n<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb9-1\"><a href=\"#cb9-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb9-2\"><a href=\"#cb9-2\"></a></span>\n<span id=\"cb9-3\"><a href=\"#cb9-3\"></a><span class=\"kw\">package</span> ast</span>\n<span id=\"cb9-4\"><a href=\"#cb9-4\"></a></span>\n<span id=\"cb9-5\"><a href=\"#cb9-5\"></a><span class=\"kw\">type</span> Node <span class=\"kw\">interface</span> {</span>\n<span id=\"cb9-6\"><a href=\"#cb9-6\"></a>    TokenLiteral() <span class=\"dt\">string</span></span>\n<span id=\"cb9-7\"><a href=\"#cb9-7\"></a>}</span>\n<span id=\"cb9-8\"><a href=\"#cb9-8\"></a></span>\n<span id=\"cb9-9\"><a href=\"#cb9-9\"></a><span class=\"kw\">type</span> Statement <span class=\"kw\">interface</span> {</span>\n<span id=\"cb9-10\"><a href=\"#cb9-10\"></a>    Node</span>\n<span id=\"cb9-11\"><a href=\"#cb9-11\"></a>    statementNode()</span>\n<span id=\"cb9-12\"><a href=\"#cb9-12\"></a>}</span>\n<span id=\"cb9-13\"><a href=\"#cb9-13\"></a></span>\n<span id=\"cb9-14\"><a href=\"#cb9-14\"></a><span class=\"kw\">type</span> Expression <span class=\"kw\">interface</span> {</span>\n<span id=\"cb9-15\"><a href=\"#cb9-15\"></a>    Node</span>\n<span id=\"cb9-16\"><a href=\"#cb9-16\"></a>    expressionNode()</span>\n<span id=\"cb9-17\"><a href=\"#cb9-17\"></a>}</span></code></pre></div>\n<p>Here we have three interfaces called <code>Node</code>, <code>Statement</code> and <code>Expression</code>. Every node in our AST has to implement the <code>Node</code> interface, meaning it has to provide a <code>TokenLiteral()</code> method that returns the literal value of the token it’s associated with. <code>TokenLiteral()</code> will be used only for debugging and testing. The AST we are going to construct consists solely of <code>Node</code>s that are connected to each other - it’s a tree after all. Some of these nodes implement the <code>Statement</code> and some the <code>Expression</code> interface. These interfaces only contain dummy methods called <code>statementNode</code> and <code>expressionNode</code> respectively. They are not strictly necessary but help us by guiding the Go compiler and possibly causing it to throw errors when we use a <code>Statement</code> where an <code>Expression</code> should’ve been used, and vice versa.</p>\n<p>And here is our first implementation of <code>Node</code>:</p>\n<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb10-1\"><a href=\"#cb10-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb10-2\"><a href=\"#cb10-2\"></a></span>\n<span id=\"cb10-3\"><a href=\"#cb10-3\"></a><span class=\"kw\">type</span> Program <span class=\"kw\">struct</span> {</span>\n<span id=\"cb10-4\"><a href=\"#cb10-4\"></a>    Statements []Statement</span>\n<span id=\"cb10-5\"><a href=\"#cb10-5\"></a>}</span>\n<span id=\"cb10-6\"><a href=\"#cb10-6\"></a></span>\n<span id=\"cb10-7\"><a href=\"#cb10-7\"></a><span class=\"kw\">func</span> (p *Program) TokenLiteral() <span class=\"dt\">string</span> {</span>\n<span id=\"cb10-8\"><a href=\"#cb10-8\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(p.Statements) &gt; <span class=\"dv\">0</span> {</span>\n<span id=\"cb10-9\"><a href=\"#cb10-9\"></a>        <span class=\"kw\">return</span> p.Statements[<span class=\"dv\">0</span>].TokenLiteral()</span>\n<span id=\"cb10-10\"><a href=\"#cb10-10\"></a>    } <span class=\"kw\">else</span> {</span>\n<span id=\"cb10-11\"><a href=\"#cb10-11\"></a>        <span class=\"kw\">return</span> <span class=\"st\">&quot;&quot;</span></span>\n<span id=\"cb10-12\"><a href=\"#cb10-12\"></a>    }</span>\n<span id=\"cb10-13\"><a href=\"#cb10-13\"></a>}</span></code></pre></div>\n<p>This <code>Program</code> node is going to be the root node of every AST our parser produces. Every valid Monkey program is a series of statements. These statements are contained in the <code>Program.Statements</code>, which is just a slice of AST nodes that implement the <code>Statement</code> interface.</p>\n<p>With these basic building blocks for our AST construction defined, let’s think about what a node for a variable binding in the form of <code>let x = 5;</code> might look like. Which fields should it have? Definitely one for the name of the variable. And it also needs a field that points to the expression on the right side of the equal sign. It needs to be able to point to any expression. It can’t just point to a literal value (the integer literal <code>5</code> in this case), since every expression is valid after the equal sign: <code>let x = 5 * 5</code> is as valid as <code>let y = add(2, 2) * 5 / 10;</code>. And then the node also needs to keep track of the token the AST node is associated with, so we can implement the <code>TokenLiteral()</code> method. That makes three fields: one for the identifier, one for the expression that produces the value in the let statement and one for the token.</p>\n<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb11-1\"><a href=\"#cb11-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb11-2\"><a href=\"#cb11-2\"></a></span>\n<span id=\"cb11-3\"><a href=\"#cb11-3\"></a><span class=\"kw\">import</span> <span class=\"st\">&quot;monkey/token&quot;</span></span>\n<span id=\"cb11-4\"><a href=\"#cb11-4\"></a></span>\n<span id=\"cb11-5\"><a href=\"#cb11-5\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb11-6\"><a href=\"#cb11-6\"></a></span>\n<span id=\"cb11-7\"><a href=\"#cb11-7\"></a><span class=\"kw\">type</span> LetStatement <span class=\"kw\">struct</span> {</span>\n<span id=\"cb11-8\"><a href=\"#cb11-8\"></a>    Token token.Token <span class=\"co\">// the token.LET token</span></span>\n<span id=\"cb11-9\"><a href=\"#cb11-9\"></a>    Name  *Identifier</span>\n<span id=\"cb11-10\"><a href=\"#cb11-10\"></a>    Value Expression</span>\n<span id=\"cb11-11\"><a href=\"#cb11-11\"></a>}</span>\n<span id=\"cb11-12\"><a href=\"#cb11-12\"></a></span>\n<span id=\"cb11-13\"><a href=\"#cb11-13\"></a><span class=\"kw\">func</span> (ls *LetStatement) statementNode()       {}</span>\n<span id=\"cb11-14\"><a href=\"#cb11-14\"></a><span class=\"kw\">func</span> (ls *LetStatement) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> ls.Token.Literal }</span>\n<span id=\"cb11-15\"><a href=\"#cb11-15\"></a></span>\n<span id=\"cb11-16\"><a href=\"#cb11-16\"></a><span class=\"kw\">type</span> Identifier <span class=\"kw\">struct</span> {</span>\n<span id=\"cb11-17\"><a href=\"#cb11-17\"></a>    Token token.Token <span class=\"co\">// the token.IDENT token</span></span>\n<span id=\"cb11-18\"><a href=\"#cb11-18\"></a>    Value <span class=\"dt\">string</span></span>\n<span id=\"cb11-19\"><a href=\"#cb11-19\"></a>}</span>\n<span id=\"cb11-20\"><a href=\"#cb11-20\"></a></span>\n<span id=\"cb11-21\"><a href=\"#cb11-21\"></a><span class=\"kw\">func</span> (i *Identifier) expressionNode()      {}</span>\n<span id=\"cb11-22\"><a href=\"#cb11-22\"></a><span class=\"kw\">func</span> (i *Identifier) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> i.Token.Literal }</span></code></pre></div>\n<p><code>LetStatement</code> has the fields we need: <code>Name</code> to hold the identifier of the binding and <code>Value</code> for the expression that produces the value. The two methods <code>statementNode</code> and <code>TokenLiteral</code> satisfy the <code>Statement</code> and <code>Node</code> interfaces respectively.</p>\n<p>To hold the identifier of the binding, the <code>x</code> in <code>let x = 5;</code>, we have the <code>Identifier</code> struct type, which implements the <code>Expression</code> interface. But the identifier in a let statement doesn’t produce a value, right? So why is it an <code>Expression</code>? It’s to keep things simple. Identifiers in other parts of a Monkey program <strong>do</strong> produce values, e.g.: <code>let x = valueProducingIdentifier;</code>. And to keep the number of different node types small, we’ll use <code>Identifier</code> here to represent the name in a variable binding and later reuse it, to represent an identifier as part of or as a complete expression.</p>\n<p>With <code>Program</code>, <code>LetStatement</code> and <code>Identifier</code> defined this piece of Monkey source code</p>\n<div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb12-1\"><a href=\"#cb12-1\"></a><span class=\"kw\">let</span> x <span class=\"op\">=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span></code></pre></div>\n<p>could be represented by an AST looking like this:</p>\n<figure>\n<img src=\"../media/file1.png\" width=\"400\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p>Now that we know what it’s supposed to look like, the next task is to construct such an AST. So, without further ado here is the beginning of our parser:</p>\n<div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb13-1\"><a href=\"#cb13-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb13-2\"><a href=\"#cb13-2\"></a></span>\n<span id=\"cb13-3\"><a href=\"#cb13-3\"></a><span class=\"kw\">package</span> parser</span>\n<span id=\"cb13-4\"><a href=\"#cb13-4\"></a></span>\n<span id=\"cb13-5\"><a href=\"#cb13-5\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb13-6\"><a href=\"#cb13-6\"></a>    <span class=\"st\">&quot;monkey/ast&quot;</span></span>\n<span id=\"cb13-7\"><a href=\"#cb13-7\"></a>    <span class=\"st\">&quot;monkey/lexer&quot;</span></span>\n<span id=\"cb13-8\"><a href=\"#cb13-8\"></a>    <span class=\"st\">&quot;monkey/token&quot;</span></span>\n<span id=\"cb13-9\"><a href=\"#cb13-9\"></a>)</span>\n<span id=\"cb13-10\"><a href=\"#cb13-10\"></a></span>\n<span id=\"cb13-11\"><a href=\"#cb13-11\"></a><span class=\"kw\">type</span> Parser <span class=\"kw\">struct</span> {</span>\n<span id=\"cb13-12\"><a href=\"#cb13-12\"></a>    l *lexer.Lexer</span>\n<span id=\"cb13-13\"><a href=\"#cb13-13\"></a></span>\n<span id=\"cb13-14\"><a href=\"#cb13-14\"></a>    curToken  token.Token</span>\n<span id=\"cb13-15\"><a href=\"#cb13-15\"></a>    peekToken token.Token</span>\n<span id=\"cb13-16\"><a href=\"#cb13-16\"></a>}</span>\n<span id=\"cb13-17\"><a href=\"#cb13-17\"></a></span>\n<span id=\"cb13-18\"><a href=\"#cb13-18\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb13-19\"><a href=\"#cb13-19\"></a>    p := &amp;Parser{l: l}</span>\n<span id=\"cb13-20\"><a href=\"#cb13-20\"></a></span>\n<span id=\"cb13-21\"><a href=\"#cb13-21\"></a>    <span class=\"co\">// Read two tokens, so curToken and peekToken are both set</span></span>\n<span id=\"cb13-22\"><a href=\"#cb13-22\"></a>    p.nextToken()</span>\n<span id=\"cb13-23\"><a href=\"#cb13-23\"></a>    p.nextToken()</span>\n<span id=\"cb13-24\"><a href=\"#cb13-24\"></a></span>\n<span id=\"cb13-25\"><a href=\"#cb13-25\"></a>    <span class=\"kw\">return</span> p</span>\n<span id=\"cb13-26\"><a href=\"#cb13-26\"></a>}</span>\n<span id=\"cb13-27\"><a href=\"#cb13-27\"></a></span>\n<span id=\"cb13-28\"><a href=\"#cb13-28\"></a><span class=\"kw\">func</span> (p *Parser) nextToken() {</span>\n<span id=\"cb13-29\"><a href=\"#cb13-29\"></a>    p.curToken = p.peekToken</span>\n<span id=\"cb13-30\"><a href=\"#cb13-30\"></a>    p.peekToken = p.l.NextToken()</span>\n<span id=\"cb13-31\"><a href=\"#cb13-31\"></a>}</span>\n<span id=\"cb13-32\"><a href=\"#cb13-32\"></a></span>\n<span id=\"cb13-33\"><a href=\"#cb13-33\"></a><span class=\"kw\">func</span> (p *Parser) ParseProgram() *ast.Program {</span>\n<span id=\"cb13-34\"><a href=\"#cb13-34\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb13-35\"><a href=\"#cb13-35\"></a>}</span></code></pre></div>\n<p>The <code>Parser</code> has three fields: <code>l</code>, <code>curToken</code> and <code>peekToken</code>. <code>l</code> is a pointer to an instance of the lexer, on which we repeatedly call <code>NextToken()</code> to get the next token in the input. <code>curToken</code> and <code>peekToken</code> act exactly like the two “pointers” our lexer has: <code>position</code> and <code>readPosition</code>. But instead of pointing to a character in the input, they point to the current and the next token. Both are important: we need to look at the <code>curToken</code>, which is the current token under examination, to decide what to do next, and we also need <code>peekToken</code> for this decision if <code>curToken</code> doesn’t give us enough information. Think of a single line only containing <code>5;</code>. Then <code>curToken</code> is a <code>token.INT</code> and we need <code>peekToken</code> to decide whether we are at the end of the line or if we are at just the start of an arithmetic expression.</p>\n<p>The <code>New</code> function is pretty self-explanatory and the <code>nextToken</code> method is a small helper that advances both <code>curToken</code> and <code>peekToken</code>. But <code>ParseProgram</code> is empty, for now.</p>\n<p>Now before we start writing tests and filling out the <code>ParseProgram</code> method I want to show you the basic idea and structure behind a recursive descent parser. That makes it a lot easier to understand our own parser later on. What follows are the major parts of such a parser in pseudocode. Read this carefully and try to understand what happens in the <code>parseProgram</code> function:</p>\n<div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb14-1\"><a href=\"#cb14-1\"></a><span class=\"kw\">function</span> <span class=\"fu\">parseProgram</span>() {</span>\n<span id=\"cb14-2\"><a href=\"#cb14-2\"></a>  program <span class=\"op\">=</span> newProgramASTNode()</span>\n<span id=\"cb14-3\"><a href=\"#cb14-3\"></a></span>\n<span id=\"cb14-4\"><a href=\"#cb14-4\"></a>  advanceTokens()</span>\n<span id=\"cb14-5\"><a href=\"#cb14-5\"></a></span>\n<span id=\"cb14-6\"><a href=\"#cb14-6\"></a>  <span class=\"cf\">for</span> (currentToken() <span class=\"op\">!=</span> EOF_TOKEN) {</span>\n<span id=\"cb14-7\"><a href=\"#cb14-7\"></a>    statement <span class=\"op\">=</span> <span class=\"kw\">null</span></span>\n<span id=\"cb14-8\"><a href=\"#cb14-8\"></a></span>\n<span id=\"cb14-9\"><a href=\"#cb14-9\"></a>    <span class=\"cf\">if</span> (currentToken() <span class=\"op\">==</span> LET_TOKEN) {</span>\n<span id=\"cb14-10\"><a href=\"#cb14-10\"></a>      statement <span class=\"op\">=</span> parseLetStatement()</span>\n<span id=\"cb14-11\"><a href=\"#cb14-11\"></a>    } <span class=\"cf\">else</span> <span class=\"cf\">if</span> (currentToken() <span class=\"op\">==</span> RETURN_TOKEN) {</span>\n<span id=\"cb14-12\"><a href=\"#cb14-12\"></a>      statement <span class=\"op\">=</span> parseReturnStatement()</span>\n<span id=\"cb14-13\"><a href=\"#cb14-13\"></a>    } <span class=\"cf\">else</span> <span class=\"cf\">if</span> (currentToken() <span class=\"op\">==</span> IF_TOKEN) {</span>\n<span id=\"cb14-14\"><a href=\"#cb14-14\"></a>      statement <span class=\"op\">=</span> parseIfStatement()</span>\n<span id=\"cb14-15\"><a href=\"#cb14-15\"></a>    }</span>\n<span id=\"cb14-16\"><a href=\"#cb14-16\"></a></span>\n<span id=\"cb14-17\"><a href=\"#cb14-17\"></a>    <span class=\"cf\">if</span> (statement <span class=\"op\">!=</span> <span class=\"kw\">null</span>) {</span>\n<span id=\"cb14-18\"><a href=\"#cb14-18\"></a>      program<span class=\"op\">.</span><span class=\"at\">Statements</span><span class=\"op\">.</span><span class=\"fu\">push</span>(statement)</span>\n<span id=\"cb14-19\"><a href=\"#cb14-19\"></a>    }</span>\n<span id=\"cb14-20\"><a href=\"#cb14-20\"></a></span>\n<span id=\"cb14-21\"><a href=\"#cb14-21\"></a>    advanceTokens()</span>\n<span id=\"cb14-22\"><a href=\"#cb14-22\"></a>  }</span>\n<span id=\"cb14-23\"><a href=\"#cb14-23\"></a></span>\n<span id=\"cb14-24\"><a href=\"#cb14-24\"></a>  <span class=\"cf\">return</span> program</span>\n<span id=\"cb14-25\"><a href=\"#cb14-25\"></a>}</span>\n<span id=\"cb14-26\"><a href=\"#cb14-26\"></a></span>\n<span id=\"cb14-27\"><a href=\"#cb14-27\"></a><span class=\"kw\">function</span> <span class=\"fu\">parseLetStatement</span>() {</span>\n<span id=\"cb14-28\"><a href=\"#cb14-28\"></a>  advanceTokens()</span>\n<span id=\"cb14-29\"><a href=\"#cb14-29\"></a></span>\n<span id=\"cb14-30\"><a href=\"#cb14-30\"></a>  identifier <span class=\"op\">=</span> parseIdentifier()</span>\n<span id=\"cb14-31\"><a href=\"#cb14-31\"></a></span>\n<span id=\"cb14-32\"><a href=\"#cb14-32\"></a>  advanceTokens()</span>\n<span id=\"cb14-33\"><a href=\"#cb14-33\"></a></span>\n<span id=\"cb14-34\"><a href=\"#cb14-34\"></a>  <span class=\"cf\">if</span> currentToken() <span class=\"op\">!=</span> EQUAL_TOKEN {</span>\n<span id=\"cb14-35\"><a href=\"#cb14-35\"></a>    parseError(<span class=\"st\">&quot;no equal sign!&quot;</span>)</span>\n<span id=\"cb14-36\"><a href=\"#cb14-36\"></a>    <span class=\"cf\">return</span> <span class=\"kw\">null</span></span>\n<span id=\"cb14-37\"><a href=\"#cb14-37\"></a>  }</span>\n<span id=\"cb14-38\"><a href=\"#cb14-38\"></a></span>\n<span id=\"cb14-39\"><a href=\"#cb14-39\"></a>  advanceTokens()</span>\n<span id=\"cb14-40\"><a href=\"#cb14-40\"></a></span>\n<span id=\"cb14-41\"><a href=\"#cb14-41\"></a>  value <span class=\"op\">=</span> parseExpression()</span>\n<span id=\"cb14-42\"><a href=\"#cb14-42\"></a></span>\n<span id=\"cb14-43\"><a href=\"#cb14-43\"></a>  variableStatement <span class=\"op\">=</span> newVariableStatementASTNode()</span>\n<span id=\"cb14-44\"><a href=\"#cb14-44\"></a>  variableStatement<span class=\"op\">.</span><span class=\"at\">identifier</span> <span class=\"op\">=</span> identifier</span>\n<span id=\"cb14-45\"><a href=\"#cb14-45\"></a>  variableStatement<span class=\"op\">.</span><span class=\"at\">value</span> <span class=\"op\">=</span> value</span>\n<span id=\"cb14-46\"><a href=\"#cb14-46\"></a>  <span class=\"cf\">return</span> variableStatement</span>\n<span id=\"cb14-47\"><a href=\"#cb14-47\"></a>}</span>\n<span id=\"cb14-48\"><a href=\"#cb14-48\"></a></span>\n<span id=\"cb14-49\"><a href=\"#cb14-49\"></a><span class=\"kw\">function</span> <span class=\"fu\">parseIdentifier</span>() {</span>\n<span id=\"cb14-50\"><a href=\"#cb14-50\"></a>  identifier <span class=\"op\">=</span> newIdentifierASTNode()</span>\n<span id=\"cb14-51\"><a href=\"#cb14-51\"></a>  identifier<span class=\"op\">.</span><span class=\"at\">token</span> <span class=\"op\">=</span> currentToken()</span>\n<span id=\"cb14-52\"><a href=\"#cb14-52\"></a>  <span class=\"cf\">return</span> identifier</span>\n<span id=\"cb14-53\"><a href=\"#cb14-53\"></a>}</span>\n<span id=\"cb14-54\"><a href=\"#cb14-54\"></a></span>\n<span id=\"cb14-55\"><a href=\"#cb14-55\"></a><span class=\"kw\">function</span> <span class=\"fu\">parseExpression</span>() {</span>\n<span id=\"cb14-56\"><a href=\"#cb14-56\"></a>  <span class=\"cf\">if</span> (currentToken() <span class=\"op\">==</span> INTEGER_TOKEN) {</span>\n<span id=\"cb14-57\"><a href=\"#cb14-57\"></a>    <span class=\"cf\">if</span> (nextToken() <span class=\"op\">==</span> PLUS_TOKEN)  {</span>\n<span id=\"cb14-58\"><a href=\"#cb14-58\"></a>      <span class=\"cf\">return</span> parseOperatorExpression()</span>\n<span id=\"cb14-59\"><a href=\"#cb14-59\"></a>    } <span class=\"cf\">else</span> <span class=\"cf\">if</span> (nextToken() <span class=\"op\">==</span> SEMICOLON_TOKEN) {</span>\n<span id=\"cb14-60\"><a href=\"#cb14-60\"></a>      <span class=\"cf\">return</span> parseIntegerLiteral()</span>\n<span id=\"cb14-61\"><a href=\"#cb14-61\"></a>    }</span>\n<span id=\"cb14-62\"><a href=\"#cb14-62\"></a>  } <span class=\"cf\">else</span> <span class=\"cf\">if</span> (currentToken() <span class=\"op\">==</span> LEFT_PAREN) {</span>\n<span id=\"cb14-63\"><a href=\"#cb14-63\"></a>    <span class=\"cf\">return</span> parseGroupedExpression()</span>\n<span id=\"cb14-64\"><a href=\"#cb14-64\"></a>  }</span>\n<span id=\"cb14-65\"><a href=\"#cb14-65\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb14-66\"><a href=\"#cb14-66\"></a>}</span>\n<span id=\"cb14-67\"><a href=\"#cb14-67\"></a></span>\n<span id=\"cb14-68\"><a href=\"#cb14-68\"></a><span class=\"kw\">function</span> <span class=\"fu\">parseOperatorExpression</span>() {</span>\n<span id=\"cb14-69\"><a href=\"#cb14-69\"></a>  operatorExpression <span class=\"op\">=</span> newOperatorExpression()</span>\n<span id=\"cb14-70\"><a href=\"#cb14-70\"></a></span>\n<span id=\"cb14-71\"><a href=\"#cb14-71\"></a>  operatorExpression<span class=\"op\">.</span><span class=\"at\">left</span> <span class=\"op\">=</span> parseIntegerLiteral()</span>\n<span id=\"cb14-72\"><a href=\"#cb14-72\"></a>  advanceTokens()</span>\n<span id=\"cb14-73\"><a href=\"#cb14-73\"></a>  operatorExpression<span class=\"op\">.</span><span class=\"at\">operator</span> <span class=\"op\">=</span> currentToken()</span>\n<span id=\"cb14-74\"><a href=\"#cb14-74\"></a>  advanceTokens()</span>\n<span id=\"cb14-75\"><a href=\"#cb14-75\"></a>  operatorExpression<span class=\"op\">.</span><span class=\"at\">right</span> <span class=\"op\">=</span> parseExpression()</span>\n<span id=\"cb14-76\"><a href=\"#cb14-76\"></a></span>\n<span id=\"cb14-77\"><a href=\"#cb14-77\"></a>  <span class=\"cf\">return</span> operatorExpression</span>\n<span id=\"cb14-78\"><a href=\"#cb14-78\"></a>}</span>\n<span id=\"cb14-79\"><a href=\"#cb14-79\"></a><span class=\"co\">// [...]</span></span></code></pre></div>\n<p>Since this is pseudocode there are a lot of omissions, of course. But the basic idea behind recursive-descent parsing is there. The entry point is <code>parseProgram</code> and it constructs the root node of the AST (<code>newProgramASTNode()</code>). It then builds the child nodes, the statements, by calling other functions that know which AST node to construct based on the current token. These other functions call each other again, recursively.</p>\n<p>The most recursive part of this is in <code>parseExpression</code> and is only hinted at. But we can already see that in order to parse an expression like <code>5 + 5</code>, we need to first parse <code>5 +</code> and then call <code>parseExpression()</code> again to parse the rest, since after the <code>+</code> might be another operator expression, like this: <code>5 + 5 * 10</code>. We will get to this later and look at expression parsing in detail, since it’s probably the most complicated but also the most beautiful part of the parser, making heavy use of “Pratt parsing”.</p>\n<p>But for now, we can already see what the parser has to do. It repeatedly advances the tokens and checks the current token to decide what to do next: either call another parsing function or throw an error. Each function then does its job and possibly constructs an AST node so that the “main loop” in <code>parseProgram()</code> can advance the tokens and decide what to do again.</p>\n<p>If you looked at that pseudocode and thought “Well, that’s actually pretty easy to understand” I have great news for you: our <code>ParseProgram</code> method and the parser will look pretty similar! Let’s get to work!</p>\n<p>Again, we’re starting with a test before we flesh out <code>ParseProgram</code>. Here is a test case to make sure that the parsing of let statements works:</p>\n<div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb15-1\"><a href=\"#cb15-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb15-2\"><a href=\"#cb15-2\"></a></span>\n<span id=\"cb15-3\"><a href=\"#cb15-3\"></a><span class=\"kw\">package</span> parser</span>\n<span id=\"cb15-4\"><a href=\"#cb15-4\"></a></span>\n<span id=\"cb15-5\"><a href=\"#cb15-5\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb15-6\"><a href=\"#cb15-6\"></a>    <span class=\"st\">&quot;testing&quot;</span></span>\n<span id=\"cb15-7\"><a href=\"#cb15-7\"></a>    <span class=\"st\">&quot;monkey/ast&quot;</span></span>\n<span id=\"cb15-8\"><a href=\"#cb15-8\"></a>    <span class=\"st\">&quot;monkey/lexer&quot;</span></span>\n<span id=\"cb15-9\"><a href=\"#cb15-9\"></a>)</span>\n<span id=\"cb15-10\"><a href=\"#cb15-10\"></a></span>\n<span id=\"cb15-11\"><a href=\"#cb15-11\"></a><span class=\"kw\">func</span> TestLetStatements(t *testing.T) {</span>\n<span id=\"cb15-12\"><a href=\"#cb15-12\"></a>    input := <span class=\"st\">`</span></span>\n<span id=\"cb15-13\"><a href=\"#cb15-13\"></a><span class=\"st\">let x = 5;</span></span>\n<span id=\"cb15-14\"><a href=\"#cb15-14\"></a><span class=\"st\">let y = 10;</span></span>\n<span id=\"cb15-15\"><a href=\"#cb15-15\"></a><span class=\"st\">let foobar = 838383;</span></span>\n<span id=\"cb15-16\"><a href=\"#cb15-16\"></a><span class=\"st\">`</span></span>\n<span id=\"cb15-17\"><a href=\"#cb15-17\"></a>    l := lexer.New(input)</span>\n<span id=\"cb15-18\"><a href=\"#cb15-18\"></a>    p := New(l)</span>\n<span id=\"cb15-19\"><a href=\"#cb15-19\"></a></span>\n<span id=\"cb15-20\"><a href=\"#cb15-20\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb15-21\"><a href=\"#cb15-21\"></a>    <span class=\"kw\">if</span> program == <span class=\"ot\">nil</span> {</span>\n<span id=\"cb15-22\"><a href=\"#cb15-22\"></a>        t.Fatalf(<span class=\"st\">&quot;ParseProgram() returned nil&quot;</span>)</span>\n<span id=\"cb15-23\"><a href=\"#cb15-23\"></a>    }</span>\n<span id=\"cb15-24\"><a href=\"#cb15-24\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(program.Statements) != <span class=\"dv\">3</span> {</span>\n<span id=\"cb15-25\"><a href=\"#cb15-25\"></a>        t.Fatalf(<span class=\"st\">&quot;program.Statements does not contain 3 statements. got=%d&quot;</span>,</span>\n<span id=\"cb15-26\"><a href=\"#cb15-26\"></a>            <span class=\"bu\">len</span>(program.Statements))</span>\n<span id=\"cb15-27\"><a href=\"#cb15-27\"></a>    }</span>\n<span id=\"cb15-28\"><a href=\"#cb15-28\"></a></span>\n<span id=\"cb15-29\"><a href=\"#cb15-29\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb15-30\"><a href=\"#cb15-30\"></a>        expectedIdentifier <span class=\"dt\">string</span></span>\n<span id=\"cb15-31\"><a href=\"#cb15-31\"></a>    }{</span>\n<span id=\"cb15-32\"><a href=\"#cb15-32\"></a>        {<span class=\"st\">&quot;x&quot;</span>},</span>\n<span id=\"cb15-33\"><a href=\"#cb15-33\"></a>        {<span class=\"st\">&quot;y&quot;</span>},</span>\n<span id=\"cb15-34\"><a href=\"#cb15-34\"></a>        {<span class=\"st\">&quot;foobar&quot;</span>},</span>\n<span id=\"cb15-35\"><a href=\"#cb15-35\"></a>    }</span>\n<span id=\"cb15-36\"><a href=\"#cb15-36\"></a></span>\n<span id=\"cb15-37\"><a href=\"#cb15-37\"></a>    <span class=\"kw\">for</span> i, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb15-38\"><a href=\"#cb15-38\"></a>        stmt := program.Statements[i]</span>\n<span id=\"cb15-39\"><a href=\"#cb15-39\"></a>        <span class=\"kw\">if</span> !testLetStatement(t, stmt, tt.expectedIdentifier) {</span>\n<span id=\"cb15-40\"><a href=\"#cb15-40\"></a>            <span class=\"kw\">return</span></span>\n<span id=\"cb15-41\"><a href=\"#cb15-41\"></a>        }</span>\n<span id=\"cb15-42\"><a href=\"#cb15-42\"></a>    }</span>\n<span id=\"cb15-43\"><a href=\"#cb15-43\"></a>}</span>\n<span id=\"cb15-44\"><a href=\"#cb15-44\"></a></span>\n<span id=\"cb15-45\"><a href=\"#cb15-45\"></a><span class=\"kw\">func</span> testLetStatement(t *testing.T, s ast.Statement, name <span class=\"dt\">string</span>) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb15-46\"><a href=\"#cb15-46\"></a>    <span class=\"kw\">if</span> s.TokenLiteral() != <span class=\"st\">&quot;let&quot;</span> {</span>\n<span id=\"cb15-47\"><a href=\"#cb15-47\"></a>        t.Errorf(<span class=\"st\">&quot;s.TokenLiteral not &#39;let&#39;. got=%q&quot;</span>, s.TokenLiteral())</span>\n<span id=\"cb15-48\"><a href=\"#cb15-48\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb15-49\"><a href=\"#cb15-49\"></a>    }</span>\n<span id=\"cb15-50\"><a href=\"#cb15-50\"></a></span>\n<span id=\"cb15-51\"><a href=\"#cb15-51\"></a>    letStmt, ok := s.(*ast.LetStatement)</span>\n<span id=\"cb15-52\"><a href=\"#cb15-52\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb15-53\"><a href=\"#cb15-53\"></a>        t.Errorf(<span class=\"st\">&quot;s not *ast.LetStatement. got=%T&quot;</span>, s)</span>\n<span id=\"cb15-54\"><a href=\"#cb15-54\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb15-55\"><a href=\"#cb15-55\"></a>    }</span>\n<span id=\"cb15-56\"><a href=\"#cb15-56\"></a></span>\n<span id=\"cb15-57\"><a href=\"#cb15-57\"></a>    <span class=\"kw\">if</span> letStmt.Name.Value != name {</span>\n<span id=\"cb15-58\"><a href=\"#cb15-58\"></a>        t.Errorf(<span class=\"st\">&quot;letStmt.Name.Value not &#39;%s&#39;. got=%s&quot;</span>, name, letStmt.Name.Value)</span>\n<span id=\"cb15-59\"><a href=\"#cb15-59\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb15-60\"><a href=\"#cb15-60\"></a>    }</span>\n<span id=\"cb15-61\"><a href=\"#cb15-61\"></a></span>\n<span id=\"cb15-62\"><a href=\"#cb15-62\"></a>    <span class=\"kw\">if</span> letStmt.Name.TokenLiteral() != name {</span>\n<span id=\"cb15-63\"><a href=\"#cb15-63\"></a>        t.Errorf(<span class=\"st\">&quot;letStmt.Name.TokenLiteral() not &#39;%s&#39;. got=%s&quot;</span>,</span>\n<span id=\"cb15-64\"><a href=\"#cb15-64\"></a>            name, letStmt.Name.TokenLiteral())</span>\n<span id=\"cb15-65\"><a href=\"#cb15-65\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb15-66\"><a href=\"#cb15-66\"></a>    }</span>\n<span id=\"cb15-67\"><a href=\"#cb15-67\"></a></span>\n<span id=\"cb15-68\"><a href=\"#cb15-68\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb15-69\"><a href=\"#cb15-69\"></a>}</span></code></pre></div>\n<p>The test case follows the same principle as the test for our lexer and pretty much every other unit test we’re going to write: we provide Monkey source code as input and then set expectations on what we want the AST - that’s produced by the parser - to look like. We do this by checking as many fields of the AST nodes as possible to make sure that nothing is missing. I found that a parser is a breeding ground for off-by-one bugs and the more tests and assertions it has the better.</p>\n<p>I choose not to mock or stub out the lexer and provide source code as input instead of tokens, since that makes the tests much more readable and understandable. Of course there’s the problem of bugs in the lexer blowing up tests for the parser and generating unneeded noise, but I deem the risk too minimal, especially judged against the advantages of using readable source code as input.</p>\n<p>There are two noteworthy things about this test case. The first one is that we ignore the <code>Value</code> field of the <code>*ast.LetStatement</code>. Why don’t we check if the integer literals (<code>5</code>, <code>10</code>, …) are parsed correctly? Answer: we’re going to! But first we need to make sure that the parsing of let statements works and ignore the <code>Value</code>.</p>\n<p>The second one is the helper function <code>testLetStatement</code>. It might seem like over-engineering to use a separate function, but we’re going to need this function soon enough. And then it’s going to make our test cases a lot more readable than lines and lines of type conversions strewn about.</p>\n<p>As an aside: we won’t look at all of the parser tests in this chapter, since they are just too long. But the code provided with the book contains all of them.</p>\n<p>That being said, the tests fail as expected:</p>\n<div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb16-1\"><a href=\"#cb16-1\"></a>$ go test ./parser</span>\n<span id=\"cb16-2\"><a href=\"#cb16-2\"></a>--- FAIL: TestLetStatements (0.00s)</span>\n<span id=\"cb16-3\"><a href=\"#cb16-3\"></a>  parser_test.go:20: ParseProgram() returned nil</span>\n<span id=\"cb16-4\"><a href=\"#cb16-4\"></a>FAIL</span>\n<span id=\"cb16-5\"><a href=\"#cb16-5\"></a>FAIL    monkey/parser    0.007s</span></code></pre></div>\n<p>It’s time to flesh out the <code>ParseProgram()</code> method of the <code>Parser</code>.</p>\n<div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb17-1\"><a href=\"#cb17-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb17-2\"><a href=\"#cb17-2\"></a></span>\n<span id=\"cb17-3\"><a href=\"#cb17-3\"></a><span class=\"kw\">func</span> (p *Parser) ParseProgram() *ast.Program {</span>\n<span id=\"cb17-4\"><a href=\"#cb17-4\"></a>    program := &amp;ast.Program{}</span>\n<span id=\"cb17-5\"><a href=\"#cb17-5\"></a>    program.Statements = []ast.Statement{}</span>\n<span id=\"cb17-6\"><a href=\"#cb17-6\"></a></span>\n<span id=\"cb17-7\"><a href=\"#cb17-7\"></a>    <span class=\"kw\">for</span> p.curToken.Type != token.EOF {</span>\n<span id=\"cb17-8\"><a href=\"#cb17-8\"></a>        stmt := p.parseStatement()</span>\n<span id=\"cb17-9\"><a href=\"#cb17-9\"></a>        <span class=\"kw\">if</span> stmt != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb17-10\"><a href=\"#cb17-10\"></a>            program.Statements = <span class=\"bu\">append</span>(program.Statements, stmt)</span>\n<span id=\"cb17-11\"><a href=\"#cb17-11\"></a>        }</span>\n<span id=\"cb17-12\"><a href=\"#cb17-12\"></a>        p.nextToken()</span>\n<span id=\"cb17-13\"><a href=\"#cb17-13\"></a>    }</span>\n<span id=\"cb17-14\"><a href=\"#cb17-14\"></a></span>\n<span id=\"cb17-15\"><a href=\"#cb17-15\"></a>    <span class=\"kw\">return</span> program</span>\n<span id=\"cb17-16\"><a href=\"#cb17-16\"></a>}</span></code></pre></div>\n<p>Doesn’t this look really similar to the <code>parseProgram()</code> pseudocode function we saw earlier? See! I told you! And what it does is the same too.</p>\n<p>The first thing <code>ParseProgram</code> does is construct the root node of the AST, an <code>*ast.Program</code>. It then iterates over every token in the input until it encounters an <code>token.EOF</code> token. It does this by repeatedly calling <code>nextToken</code>, which advances both <code>p.curToken</code> and <code>p.peekToken</code>. In every iteration it calls <code>parseStatement</code>, whose job it is to parse a statement. If <code>parseStatement</code> returned something other than <code>nil</code>, a <code>ast.Statement</code>, its return value is added to <code>Statements</code> slice of the AST root node. When nothing is left to parse the <code>*ast.Program</code> root node is returned.</p>\n<p>The <code>parseStatement</code> method looks like this:</p>\n<div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb18-1\"><a href=\"#cb18-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb18-2\"><a href=\"#cb18-2\"></a></span>\n<span id=\"cb18-3\"><a href=\"#cb18-3\"></a><span class=\"kw\">func</span> (p *Parser) parseStatement() ast.Statement {</span>\n<span id=\"cb18-4\"><a href=\"#cb18-4\"></a>    <span class=\"kw\">switch</span> p.curToken.Type {</span>\n<span id=\"cb18-5\"><a href=\"#cb18-5\"></a>    <span class=\"kw\">case</span> token.LET:</span>\n<span id=\"cb18-6\"><a href=\"#cb18-6\"></a>        <span class=\"kw\">return</span> p.parseLetStatement()</span>\n<span id=\"cb18-7\"><a href=\"#cb18-7\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb18-8\"><a href=\"#cb18-8\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb18-9\"><a href=\"#cb18-9\"></a>    }</span>\n<span id=\"cb18-10\"><a href=\"#cb18-10\"></a>}</span></code></pre></div>\n<p>Don’t worry, the switch statement will get more branches. But for now, it only calls <code>parseLetStatement</code> when it encounters a <code>token.LET</code> token. And <code>parseLetStatement</code> is the method where we turn our tests from red to green:</p>\n<div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb19-1\"><a href=\"#cb19-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb19-2\"><a href=\"#cb19-2\"></a></span>\n<span id=\"cb19-3\"><a href=\"#cb19-3\"></a><span class=\"kw\">func</span> (p *Parser) parseLetStatement() *ast.LetStatement {</span>\n<span id=\"cb19-4\"><a href=\"#cb19-4\"></a>    stmt := &amp;ast.LetStatement{Token: p.curToken}</span>\n<span id=\"cb19-5\"><a href=\"#cb19-5\"></a></span>\n<span id=\"cb19-6\"><a href=\"#cb19-6\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.IDENT) {</span>\n<span id=\"cb19-7\"><a href=\"#cb19-7\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb19-8\"><a href=\"#cb19-8\"></a>    }</span>\n<span id=\"cb19-9\"><a href=\"#cb19-9\"></a></span>\n<span id=\"cb19-10\"><a href=\"#cb19-10\"></a>    stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</span>\n<span id=\"cb19-11\"><a href=\"#cb19-11\"></a></span>\n<span id=\"cb19-12\"><a href=\"#cb19-12\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.ASSIGN) {</span>\n<span id=\"cb19-13\"><a href=\"#cb19-13\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb19-14\"><a href=\"#cb19-14\"></a>    }</span>\n<span id=\"cb19-15\"><a href=\"#cb19-15\"></a></span>\n<span id=\"cb19-16\"><a href=\"#cb19-16\"></a>    <span class=\"co\">// </span><span class=\"al\">TODO</span><span class=\"co\">: We&#39;re skipping the expressions until we</span></span>\n<span id=\"cb19-17\"><a href=\"#cb19-17\"></a>    <span class=\"co\">// encounter a semicolon</span></span>\n<span id=\"cb19-18\"><a href=\"#cb19-18\"></a>    <span class=\"kw\">for</span> !p.curTokenIs(token.SEMICOLON) {</span>\n<span id=\"cb19-19\"><a href=\"#cb19-19\"></a>        p.nextToken()</span>\n<span id=\"cb19-20\"><a href=\"#cb19-20\"></a>    }</span>\n<span id=\"cb19-21\"><a href=\"#cb19-21\"></a></span>\n<span id=\"cb19-22\"><a href=\"#cb19-22\"></a>    <span class=\"kw\">return</span> stmt</span>\n<span id=\"cb19-23\"><a href=\"#cb19-23\"></a>}</span>\n<span id=\"cb19-24\"><a href=\"#cb19-24\"></a></span>\n<span id=\"cb19-25\"><a href=\"#cb19-25\"></a><span class=\"kw\">func</span> (p *Parser) curTokenIs(t token.TokenType) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb19-26\"><a href=\"#cb19-26\"></a>    <span class=\"kw\">return</span> p.curToken.Type == t</span>\n<span id=\"cb19-27\"><a href=\"#cb19-27\"></a>}</span>\n<span id=\"cb19-28\"><a href=\"#cb19-28\"></a></span>\n<span id=\"cb19-29\"><a href=\"#cb19-29\"></a><span class=\"kw\">func</span> (p *Parser) peekTokenIs(t token.TokenType) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb19-30\"><a href=\"#cb19-30\"></a>    <span class=\"kw\">return</span> p.peekToken.Type == t</span>\n<span id=\"cb19-31\"><a href=\"#cb19-31\"></a>}</span>\n<span id=\"cb19-32\"><a href=\"#cb19-32\"></a></span>\n<span id=\"cb19-33\"><a href=\"#cb19-33\"></a><span class=\"kw\">func</span> (p *Parser) expectPeek(t token.TokenType) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb19-34\"><a href=\"#cb19-34\"></a>    <span class=\"kw\">if</span> p.peekTokenIs(t) {</span>\n<span id=\"cb19-35\"><a href=\"#cb19-35\"></a>        p.nextToken()</span>\n<span id=\"cb19-36\"><a href=\"#cb19-36\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb19-37\"><a href=\"#cb19-37\"></a>    } <span class=\"kw\">else</span> {</span>\n<span id=\"cb19-38\"><a href=\"#cb19-38\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb19-39\"><a href=\"#cb19-39\"></a>    }</span>\n<span id=\"cb19-40\"><a href=\"#cb19-40\"></a>}</span></code></pre></div>\n<p>It works! The tests are green:</p>\n<div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb20-1\"><a href=\"#cb20-1\"></a>$ go test ./parser</span>\n<span id=\"cb20-2\"><a href=\"#cb20-2\"></a>ok      monkey/parser   0.007s</span></code></pre></div>\n<p>We can parse let statements! That’s amazing! But, wait, how?</p>\n<p>Let’s start with <code>parseLetStatement</code>. It constructs an <code>*ast.LetStatement</code> node with the token it’s currently sitting on (a <code>token.LET</code> token) and then advances the tokens while making assertions about the next token with calls to <code>expectPeek</code>. First it expects a <code>token.IDENT</code> token, which it then uses to construct an <code>*ast.Identifier</code> node. Then it expects an equal sign and finally it jumps over the expression following the equal sign until it encounters a semicolon. The skipping of expressions will be replaced, of course, as soon as we know how to parse them.</p>\n<p>The <code>curTokenIs</code> and <code>peekTokenIs</code> methods do not need much of an explanation. They are useful methods that we will see again and again when fleshing out the parser. Already, we can replace the <code>p.curToken.Type != token.EOF</code> condition of the for-loop in <code>ParseProgram</code> with <code>!p.curTokenIs(token.EOF)</code>.</p>\n<p>Instead of dissecting these tiny methods, let’s talk about <code>expectPeek</code>. The <code>expectPeek</code> method is one of the “assertion functions” nearly all parsers share. Their primary purpose is to enforce the correctness of the order of tokens by checking the type of the next token. Our <code>expectPeek</code> here checks the type of the <code>peekToken</code> and only if the type is correct does it advance the tokens by calling <code>nextToken</code>. As you’ll see, this is something a parser does a lot.</p>\n<p>But what happens if we encounter a token in <code>expectPeek</code> that’s not of the expected type? At the moment, we just return <code>nil</code>, which gets ignored in <code>ParseProgram</code>, which results in entire statements being ignored because of an error in the input. Silently. You can probably imagine that this makes debugging really tough. And since nobody likes tough debugging we need to add error handling to our parser.</p>\n<p>Thankfully, the changes we need to make are minimal:</p>\n<div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb21-1\"><a href=\"#cb21-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb21-2\"><a href=\"#cb21-2\"></a></span>\n<span id=\"cb21-3\"><a href=\"#cb21-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb21-4\"><a href=\"#cb21-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb21-5\"><a href=\"#cb21-5\"></a>    <span class=\"st\">&quot;fmt&quot;</span></span>\n<span id=\"cb21-6\"><a href=\"#cb21-6\"></a>)</span>\n<span id=\"cb21-7\"><a href=\"#cb21-7\"></a></span>\n<span id=\"cb21-8\"><a href=\"#cb21-8\"></a><span class=\"kw\">type</span> Parser <span class=\"kw\">struct</span> {</span>\n<span id=\"cb21-9\"><a href=\"#cb21-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb21-10\"><a href=\"#cb21-10\"></a>    errors []<span class=\"dt\">string</span></span>\n<span id=\"cb21-11\"><a href=\"#cb21-11\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb21-12\"><a href=\"#cb21-12\"></a>}</span>\n<span id=\"cb21-13\"><a href=\"#cb21-13\"></a></span>\n<span id=\"cb21-14\"><a href=\"#cb21-14\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb21-15\"><a href=\"#cb21-15\"></a>    p := &amp;Parser{</span>\n<span id=\"cb21-16\"><a href=\"#cb21-16\"></a>        l:      l,</span>\n<span id=\"cb21-17\"><a href=\"#cb21-17\"></a>        errors: []<span class=\"dt\">string</span>{},</span>\n<span id=\"cb21-18\"><a href=\"#cb21-18\"></a>    }</span>\n<span id=\"cb21-19\"><a href=\"#cb21-19\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb21-20\"><a href=\"#cb21-20\"></a>}</span>\n<span id=\"cb21-21\"><a href=\"#cb21-21\"></a></span>\n<span id=\"cb21-22\"><a href=\"#cb21-22\"></a><span class=\"kw\">func</span> (p *Parser) Errors() []<span class=\"dt\">string</span> {</span>\n<span id=\"cb21-23\"><a href=\"#cb21-23\"></a>    <span class=\"kw\">return</span> p.errors</span>\n<span id=\"cb21-24\"><a href=\"#cb21-24\"></a>}</span>\n<span id=\"cb21-25\"><a href=\"#cb21-25\"></a></span>\n<span id=\"cb21-26\"><a href=\"#cb21-26\"></a><span class=\"kw\">func</span> (p *Parser) peekError(t token.TokenType) {</span>\n<span id=\"cb21-27\"><a href=\"#cb21-27\"></a>    msg := fmt.Sprintf(<span class=\"st\">&quot;expected next token to be %s, got %s instead&quot;</span>,</span>\n<span id=\"cb21-28\"><a href=\"#cb21-28\"></a>        t, p.peekToken.Type)</span>\n<span id=\"cb21-29\"><a href=\"#cb21-29\"></a>    p.errors = <span class=\"bu\">append</span>(p.errors, msg)</span>\n<span id=\"cb21-30\"><a href=\"#cb21-30\"></a>}</span></code></pre></div>\n<p>The <code>Parser</code> now has an <code>errors</code> field, which is just a slice of strings. This field gets initialized in <code>New</code> and the helper function <code>peekError</code> can now be used to add an error to <code>errors</code> when the type of <code>peekToken</code> doesn’t match the expectation. With the <code>Errors</code> method we can check if the parser encountered any errors.</p>\n<p>Extending the test suite to make use of this is as easy as you’d expect:</p>\n<div class=\"sourceCode\" id=\"cb22\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb22-1\"><a href=\"#cb22-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb22-2\"><a href=\"#cb22-2\"></a></span>\n<span id=\"cb22-3\"><a href=\"#cb22-3\"></a><span class=\"kw\">func</span> TestLetStatements(t *testing.T) {</span>\n<span id=\"cb22-4\"><a href=\"#cb22-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb22-5\"><a href=\"#cb22-5\"></a></span>\n<span id=\"cb22-6\"><a href=\"#cb22-6\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb22-7\"><a href=\"#cb22-7\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb22-8\"><a href=\"#cb22-8\"></a></span>\n<span id=\"cb22-9\"><a href=\"#cb22-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb22-10\"><a href=\"#cb22-10\"></a>}</span>\n<span id=\"cb22-11\"><a href=\"#cb22-11\"></a></span>\n<span id=\"cb22-12\"><a href=\"#cb22-12\"></a><span class=\"kw\">func</span> checkParserErrors(t *testing.T, p *Parser) {</span>\n<span id=\"cb22-13\"><a href=\"#cb22-13\"></a>    errors := p.Errors()</span>\n<span id=\"cb22-14\"><a href=\"#cb22-14\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(errors) == <span class=\"dv\">0</span> {</span>\n<span id=\"cb22-15\"><a href=\"#cb22-15\"></a>        <span class=\"kw\">return</span></span>\n<span id=\"cb22-16\"><a href=\"#cb22-16\"></a>    }</span>\n<span id=\"cb22-17\"><a href=\"#cb22-17\"></a></span>\n<span id=\"cb22-18\"><a href=\"#cb22-18\"></a>    t.Errorf(<span class=\"st\">&quot;parser has %d errors&quot;</span>, <span class=\"bu\">len</span>(errors))</span>\n<span id=\"cb22-19\"><a href=\"#cb22-19\"></a>    <span class=\"kw\">for</span> _, msg := <span class=\"kw\">range</span> errors {</span>\n<span id=\"cb22-20\"><a href=\"#cb22-20\"></a>        t.Errorf(<span class=\"st\">&quot;parser error: %q&quot;</span>, msg)</span>\n<span id=\"cb22-21\"><a href=\"#cb22-21\"></a>    }</span>\n<span id=\"cb22-22\"><a href=\"#cb22-22\"></a>    t.FailNow()</span>\n<span id=\"cb22-23\"><a href=\"#cb22-23\"></a>}</span></code></pre></div>\n<p>The new <code>checkParserErrors</code> helper function does nothing more than check the parser for errors and if it has any it prints them as test errors and stops the execution of the current test. Pretty straightforward.</p>\n<p>But nothing in our parser creates errors yet. By changing <code>expectPeek</code> we can automatically add an error every time one of our expectations about the next token was wrong:</p>\n<div class=\"sourceCode\" id=\"cb23\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb23-1\"><a href=\"#cb23-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb23-2\"><a href=\"#cb23-2\"></a></span>\n<span id=\"cb23-3\"><a href=\"#cb23-3\"></a><span class=\"kw\">func</span> (p *Parser) expectPeek(t token.TokenType) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb23-4\"><a href=\"#cb23-4\"></a>    <span class=\"kw\">if</span> p.peekTokenIs(t) {</span>\n<span id=\"cb23-5\"><a href=\"#cb23-5\"></a>        p.nextToken()</span>\n<span id=\"cb23-6\"><a href=\"#cb23-6\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb23-7\"><a href=\"#cb23-7\"></a>    } <span class=\"kw\">else</span> {</span>\n<span id=\"cb23-8\"><a href=\"#cb23-8\"></a>        p.peekError(t)</span>\n<span id=\"cb23-9\"><a href=\"#cb23-9\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb23-10\"><a href=\"#cb23-10\"></a>    }</span>\n<span id=\"cb23-11\"><a href=\"#cb23-11\"></a>}</span></code></pre></div>\n<p>If we now change our test case input from this</p>\n<div class=\"sourceCode\" id=\"cb24\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb24-1\"><a href=\"#cb24-1\"></a>    input := <span class=\"st\">`</span></span>\n<span id=\"cb24-2\"><a href=\"#cb24-2\"></a><span class=\"st\">let x = 5;</span></span>\n<span id=\"cb24-3\"><a href=\"#cb24-3\"></a><span class=\"st\">let y = 10;</span></span>\n<span id=\"cb24-4\"><a href=\"#cb24-4\"></a><span class=\"st\">let foobar = 838383;</span></span>\n<span id=\"cb24-5\"><a href=\"#cb24-5\"></a><span class=\"st\">`</span></span></code></pre></div>\n<p>to this invalid input where tokens are missing</p>\n<div class=\"sourceCode\" id=\"cb25\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb25-1\"><a href=\"#cb25-1\"></a>    input := <span class=\"st\">`</span></span>\n<span id=\"cb25-2\"><a href=\"#cb25-2\"></a><span class=\"st\">let x 5;</span></span>\n<span id=\"cb25-3\"><a href=\"#cb25-3\"></a><span class=\"st\">let = 10;</span></span>\n<span id=\"cb25-4\"><a href=\"#cb25-4\"></a><span class=\"st\">let 838383;</span></span>\n<span id=\"cb25-5\"><a href=\"#cb25-5\"></a><span class=\"st\">`</span></span></code></pre></div>\n<p>we can run our tests to see our new parser errors:</p>\n<div class=\"sourceCode\" id=\"cb26\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb26-1\"><a href=\"#cb26-1\"></a>$ go test ./parser</span>\n<span id=\"cb26-2\"><a href=\"#cb26-2\"></a>--- FAIL: TestLetStatements (0.00s)</span>\n<span id=\"cb26-3\"><a href=\"#cb26-3\"></a>  parser_test.go:20: parser has 3 errors</span>\n<span id=\"cb26-4\"><a href=\"#cb26-4\"></a>  parser_test.go:22: parser error: &quot;expected next token to be =,\\</span>\n<span id=\"cb26-5\"><a href=\"#cb26-5\"></a>    got INT instead&quot;</span>\n<span id=\"cb26-6\"><a href=\"#cb26-6\"></a>  parser_test.go:22: parser error: &quot;expected next token to be IDENT,\\</span>\n<span id=\"cb26-7\"><a href=\"#cb26-7\"></a>    got = instead&quot;</span>\n<span id=\"cb26-8\"><a href=\"#cb26-8\"></a>  parser_test.go:22: parser error: &quot;expected next token to be IDENT,\\</span>\n<span id=\"cb26-9\"><a href=\"#cb26-9\"></a>    got INT instead&quot;</span>\n<span id=\"cb26-10\"><a href=\"#cb26-10\"></a>FAIL</span>\n<span id=\"cb26-11\"><a href=\"#cb26-11\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>As you can see, our parser showcases a neat little feature here: it gives us errors for each erroneous statement it encounters. It doesn’t exit on the first one, potentially saving us the grunt work of rerunning the parsing process again and again to catch all of the syntax errors. That’s pretty helpful - even with line and column numbers missing.</p>\n</section>\n<section id=\"parsing-return-statements\" class=\"level2\" data-number=\"2.5\">\n<h2 data-number=\"2.5\">2.5 - Parsing Return Statements</h2>\n<p>I said earlier that we’re going to flesh out our sparse looking <code>ParseProgram</code> method. Now’s the time. We’re going to parse return statements. And the first step, as with let statements before them, is to define the necessary structures in the <code>ast</code> package with which we can represent return statements in our AST.</p>\n<p>Here is what return statements look like in Monkey:</p>\n<div class=\"sourceCode\" id=\"cb27\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb27-1\"><a href=\"#cb27-1\"></a><span class=\"cf\">return</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb27-2\"><a href=\"#cb27-2\"></a><span class=\"cf\">return</span> <span class=\"dv\">10</span><span class=\"op\">;</span></span>\n<span id=\"cb27-3\"><a href=\"#cb27-3\"></a><span class=\"cf\">return</span> add(<span class=\"dv\">15</span>)<span class=\"op\">;</span></span></code></pre></div>\n<p>Experienced with let statements, we can easily spot the structure behind these statements:</p>\n<div class=\"sourceCode\" id=\"cb28\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb28-1\"><a href=\"#cb28-1\"></a>return &lt;expression&gt;;</span></code></pre></div>\n<p>Return statements consist solely of the keyword <code>return</code> and an expression. That makes the definition of <code>ast.ReturnStatement</code> really simple:</p>\n<div class=\"sourceCode\" id=\"cb29\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb29-1\"><a href=\"#cb29-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb29-2\"><a href=\"#cb29-2\"></a></span>\n<span id=\"cb29-3\"><a href=\"#cb29-3\"></a><span class=\"kw\">type</span> ReturnStatement <span class=\"kw\">struct</span> {</span>\n<span id=\"cb29-4\"><a href=\"#cb29-4\"></a>    Token       token.Token <span class=\"co\">// the &#39;return&#39; token</span></span>\n<span id=\"cb29-5\"><a href=\"#cb29-5\"></a>    ReturnValue Expression</span>\n<span id=\"cb29-6\"><a href=\"#cb29-6\"></a>}</span>\n<span id=\"cb29-7\"><a href=\"#cb29-7\"></a></span>\n<span id=\"cb29-8\"><a href=\"#cb29-8\"></a><span class=\"kw\">func</span> (rs *ReturnStatement) statementNode()       {}</span>\n<span id=\"cb29-9\"><a href=\"#cb29-9\"></a><span class=\"kw\">func</span> (rs *ReturnStatement) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> rs.Token.Literal }</span></code></pre></div>\n<p>There is nothing about this node that you haven’t seen before: it has a field for the initial token and a <code>ReturnValue</code> field that will contain the expression that’s to be returned. We will again skip the parsing of the expressions and the semicolon handling for now, but will come back to this later. The <code>statementNode</code> and <code>TokenLiteral</code> methods are there to fulfill the <code>Node</code> and <code>Statement</code> interfaces and look identical to the methods defined on <code>*ast.LetStatement</code>.</p>\n<p>The test we write next also looks pretty similar to the one for let statements:</p>\n<div class=\"sourceCode\" id=\"cb30\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb30-1\"><a href=\"#cb30-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb30-2\"><a href=\"#cb30-2\"></a></span>\n<span id=\"cb30-3\"><a href=\"#cb30-3\"></a><span class=\"kw\">func</span> TestReturnStatements(t *testing.T) {</span>\n<span id=\"cb30-4\"><a href=\"#cb30-4\"></a>    input := <span class=\"st\">`</span></span>\n<span id=\"cb30-5\"><a href=\"#cb30-5\"></a><span class=\"st\">return 5;</span></span>\n<span id=\"cb30-6\"><a href=\"#cb30-6\"></a><span class=\"st\">return 10;</span></span>\n<span id=\"cb30-7\"><a href=\"#cb30-7\"></a><span class=\"st\">return 993322;</span></span>\n<span id=\"cb30-8\"><a href=\"#cb30-8\"></a><span class=\"st\">`</span></span>\n<span id=\"cb30-9\"><a href=\"#cb30-9\"></a>    l := lexer.New(input)</span>\n<span id=\"cb30-10\"><a href=\"#cb30-10\"></a>    p := New(l)</span>\n<span id=\"cb30-11\"><a href=\"#cb30-11\"></a></span>\n<span id=\"cb30-12\"><a href=\"#cb30-12\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb30-13\"><a href=\"#cb30-13\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb30-14\"><a href=\"#cb30-14\"></a></span>\n<span id=\"cb30-15\"><a href=\"#cb30-15\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(program.Statements) != <span class=\"dv\">3</span> {</span>\n<span id=\"cb30-16\"><a href=\"#cb30-16\"></a>        t.Fatalf(<span class=\"st\">&quot;program.Statements does not contain 3 statements. got=%d&quot;</span>,</span>\n<span id=\"cb30-17\"><a href=\"#cb30-17\"></a>            <span class=\"bu\">len</span>(program.Statements))</span>\n<span id=\"cb30-18\"><a href=\"#cb30-18\"></a>    }</span>\n<span id=\"cb30-19\"><a href=\"#cb30-19\"></a></span>\n<span id=\"cb30-20\"><a href=\"#cb30-20\"></a>    <span class=\"kw\">for</span> _, stmt := <span class=\"kw\">range</span> program.Statements {</span>\n<span id=\"cb30-21\"><a href=\"#cb30-21\"></a>        returnStmt, ok := stmt.(*ast.ReturnStatement)</span>\n<span id=\"cb30-22\"><a href=\"#cb30-22\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb30-23\"><a href=\"#cb30-23\"></a>            t.Errorf(<span class=\"st\">&quot;stmt not *ast.ReturnStatement. got=%T&quot;</span>, stmt)</span>\n<span id=\"cb30-24\"><a href=\"#cb30-24\"></a>            <span class=\"kw\">continue</span></span>\n<span id=\"cb30-25\"><a href=\"#cb30-25\"></a>        }</span>\n<span id=\"cb30-26\"><a href=\"#cb30-26\"></a>        <span class=\"kw\">if</span> returnStmt.TokenLiteral() != <span class=\"st\">&quot;return&quot;</span> {</span>\n<span id=\"cb30-27\"><a href=\"#cb30-27\"></a>            t.Errorf(<span class=\"st\">&quot;returnStmt.TokenLiteral not &#39;return&#39;, got %q&quot;</span>,</span>\n<span id=\"cb30-28\"><a href=\"#cb30-28\"></a>                returnStmt.TokenLiteral())</span>\n<span id=\"cb30-29\"><a href=\"#cb30-29\"></a>        }</span>\n<span id=\"cb30-30\"><a href=\"#cb30-30\"></a>    }</span>\n<span id=\"cb30-31\"><a href=\"#cb30-31\"></a>}</span></code></pre></div>\n<p>Of course these test cases will also have to be extended as soon as expression parsing is in place. But that’s okay, tests are not immutable. But they are, in fact, failing:</p>\n<div class=\"sourceCode\" id=\"cb31\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb31-1\"><a href=\"#cb31-1\"></a>$ go test ./parser</span>\n<span id=\"cb31-2\"><a href=\"#cb31-2\"></a>--- FAIL: TestReturnStatements (0.00s)</span>\n<span id=\"cb31-3\"><a href=\"#cb31-3\"></a>  parser_test.go:77: program.Statements does not contain 3 statements. got=0</span>\n<span id=\"cb31-4\"><a href=\"#cb31-4\"></a>FAIL</span>\n<span id=\"cb31-5\"><a href=\"#cb31-5\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>So let’s make them pass by changing our <code>parseStatement</code> method to also take <code>token.RETURN</code> tokens into account:</p>\n<div class=\"sourceCode\" id=\"cb32\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb32-1\"><a href=\"#cb32-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb32-2\"><a href=\"#cb32-2\"></a></span>\n<span id=\"cb32-3\"><a href=\"#cb32-3\"></a><span class=\"kw\">func</span> (p *Parser) parseStatement() ast.Statement {</span>\n<span id=\"cb32-4\"><a href=\"#cb32-4\"></a>    <span class=\"kw\">switch</span> p.curToken.Type {</span>\n<span id=\"cb32-5\"><a href=\"#cb32-5\"></a>    <span class=\"kw\">case</span> token.LET:</span>\n<span id=\"cb32-6\"><a href=\"#cb32-6\"></a>        <span class=\"kw\">return</span> p.parseLetStatement()</span>\n<span id=\"cb32-7\"><a href=\"#cb32-7\"></a>    <span class=\"kw\">case</span> token.RETURN:</span>\n<span id=\"cb32-8\"><a href=\"#cb32-8\"></a>        <span class=\"kw\">return</span> p.parseReturnStatement()</span>\n<span id=\"cb32-9\"><a href=\"#cb32-9\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb32-10\"><a href=\"#cb32-10\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb32-11\"><a href=\"#cb32-11\"></a>    }</span>\n<span id=\"cb32-12\"><a href=\"#cb32-12\"></a>}</span></code></pre></div>\n<p>I could make a lot of fuss about the <code>parseReturnStatement</code> method before showing it to you, but, well, I won’t. Because it’s tiny. There is nothing to fuss about.</p>\n<div class=\"sourceCode\" id=\"cb33\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb33-1\"><a href=\"#cb33-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb33-2\"><a href=\"#cb33-2\"></a></span>\n<span id=\"cb33-3\"><a href=\"#cb33-3\"></a><span class=\"kw\">func</span> (p *Parser) parseReturnStatement() *ast.ReturnStatement {</span>\n<span id=\"cb33-4\"><a href=\"#cb33-4\"></a>    stmt := &amp;ast.ReturnStatement{Token: p.curToken}</span>\n<span id=\"cb33-5\"><a href=\"#cb33-5\"></a></span>\n<span id=\"cb33-6\"><a href=\"#cb33-6\"></a>    p.nextToken()</span>\n<span id=\"cb33-7\"><a href=\"#cb33-7\"></a></span>\n<span id=\"cb33-8\"><a href=\"#cb33-8\"></a>    <span class=\"co\">// </span><span class=\"al\">TODO</span><span class=\"co\">: We&#39;re skipping the expressions until we</span></span>\n<span id=\"cb33-9\"><a href=\"#cb33-9\"></a>    <span class=\"co\">// encounter a semicolon</span></span>\n<span id=\"cb33-10\"><a href=\"#cb33-10\"></a>    <span class=\"kw\">for</span> !p.curTokenIs(token.SEMICOLON) {</span>\n<span id=\"cb33-11\"><a href=\"#cb33-11\"></a>        p.nextToken()</span>\n<span id=\"cb33-12\"><a href=\"#cb33-12\"></a>    }</span>\n<span id=\"cb33-13\"><a href=\"#cb33-13\"></a></span>\n<span id=\"cb33-14\"><a href=\"#cb33-14\"></a>    <span class=\"kw\">return</span> stmt</span>\n<span id=\"cb33-15\"><a href=\"#cb33-15\"></a>}</span></code></pre></div>\n<p>I told you: it’s tiny. The only thing it does is construct an <code>ast.ReturnStatement</code>, with the current token it’s sitting on as <code>Token</code>. It then brings the parser in place for the expression that comes next by calling <code>nextToken()</code> and finally, there’s the cop-out. It skips over every expression until it encounters a semicolon. That’s it. Our tests pass:</p>\n<div class=\"sourceCode\" id=\"cb34\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb34-1\"><a href=\"#cb34-1\"></a>$ go test ./parser</span>\n<span id=\"cb34-2\"><a href=\"#cb34-2\"></a>ok      monkey/parser   0.009s</span></code></pre></div>\n<p>It’s time to celebrate again! We can now parse all of the statements in the Monkey programming language! That’s right: there are only two of them. Let statements and return statements. The rest of the language consists solely of expressions. And that’s what we’re going to parse next.</p>\n</section>\n<section id=\"parsing-expressions\" class=\"level2\" data-number=\"2.6\">\n<h2 data-number=\"2.6\">2.6 - Parsing Expressions</h2>\n<p>Personally, I think that parsing expressions is the most interesting part of writing a parser. As we just saw, parsing statements is relatively straightforward. We process tokens from “left to right”, expect or reject the next tokens and if everything fits we return an AST node.</p>\n<p>Parsing expressions, on the other hand, contains a few more challenges. Operator precedence is probably the first one that comes to mind and is best illustrated with an example. Let’s say we want to parse the following arithmetic expression:</p>\n<div class=\"sourceCode\" id=\"cb35\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb35-1\"><a href=\"#cb35-1\"></a><span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">10</span></span></code></pre></div>\n<p>What we want here is an AST that represents the expression like this:</p>\n<div class=\"sourceCode\" id=\"cb36\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb36-1\"><a href=\"#cb36-1\"></a>((<span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">5</span>) <span class=\"op\">+</span> <span class=\"dv\">10</span>)</span></code></pre></div>\n<p>That is to say, <code>5 * 5</code> needs to be “deeper” in the AST and evaluated earlier than the addition. In order to produce an AST that looks like this, the parser has to know about operator precedences where the precedence of <code>*</code> is higher than <code>+</code>. That’s the most common example for operator precedence, but there are a lot more cases where it’s important. Consider this expression:</p>\n<div class=\"sourceCode\" id=\"cb37\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb37-1\"><a href=\"#cb37-1\"></a><span class=\"dv\">5</span> <span class=\"op\">*</span> (<span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">10</span>)</span></code></pre></div>\n<p>Here the parenthesis group together the <code>5 + 10</code> expression and give them a “precedence bump”: the addition now has to be evaluated before the multiplication. That’s because parentheses have a higher precedence than the <code>*</code> operator. As we will soon see, there are a few more cases where precedence is playing a crucial role.</p>\n<p>The other big challenge is that in expressions tokens of the same type can appear in multiple positions. In contrast to this, the <code>let</code> token can only appear once at the beginning of a let statement, which makes it easy to determine what the rest of the statement is supposed to be. Now look at this expression:</p>\n<div class=\"sourceCode\" id=\"cb38\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb38-1\"><a href=\"#cb38-1\"></a><span class=\"dv\">-5</span> <span class=\"op\">-</span> <span class=\"dv\">10</span></span></code></pre></div>\n<p>Here the <code>-</code> operator appears at the beginning of the expression, as a prefix operator, and then as an infix operator in the middle. A variation of the same challenge appears here:</p>\n<div class=\"sourceCode\" id=\"cb39\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb39-1\"><a href=\"#cb39-1\"></a><span class=\"dv\">5</span> <span class=\"op\">*</span> (add(<span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span>) <span class=\"op\">+</span> <span class=\"dv\">10</span>)</span></code></pre></div>\n<p>Even though you might not recognize the parentheses as operators yet, they pose the same problem to us as the <code>-</code> in the previous example. The outer pair of parentheses in this example denotes a grouped expression. The inner pair denotes a “call expression”. The validity of a token’s position now depends on the context, the tokens that come before and after, and their precedence.</p>\n<section id=\"expressions-in-monkey\" class=\"level3\" data-number=\"2.6.1\">\n<h3 data-number=\"2.6.1\">Expressions in Monkey</h3>\n<p>In the Monkey programming language everything besides let and return statements is an expression. These expressions come in different varieties.</p>\n<p>Monkey has expressions involving prefix operators:</p>\n<div class=\"sourceCode\" id=\"cb40\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb40-1\"><a href=\"#cb40-1\"></a><span class=\"dv\">-5</span></span>\n<span id=\"cb40-2\"><a href=\"#cb40-2\"></a><span class=\"op\">!</span><span class=\"kw\">true</span></span>\n<span id=\"cb40-3\"><a href=\"#cb40-3\"></a><span class=\"op\">!</span><span class=\"kw\">false</span></span></code></pre></div>\n<p>And of course it has infix operators (or “binary operators”):</p>\n<div class=\"sourceCode\" id=\"cb41\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb41-1\"><a href=\"#cb41-1\"></a><span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">5</span></span>\n<span id=\"cb41-2\"><a href=\"#cb41-2\"></a><span class=\"dv\">5</span> <span class=\"op\">-</span> <span class=\"dv\">5</span></span>\n<span id=\"cb41-3\"><a href=\"#cb41-3\"></a><span class=\"dv\">5</span> <span class=\"op\">/</span> <span class=\"dv\">5</span></span>\n<span id=\"cb41-4\"><a href=\"#cb41-4\"></a><span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">5</span></span></code></pre></div>\n<p>Besides these basic arithmetic operators, there are also the following comparison operators:</p>\n<div class=\"sourceCode\" id=\"cb42\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb42-1\"><a href=\"#cb42-1\"></a>foo <span class=\"op\">==</span> bar</span>\n<span id=\"cb42-2\"><a href=\"#cb42-2\"></a>foo <span class=\"op\">!=</span> bar</span>\n<span id=\"cb42-3\"><a href=\"#cb42-3\"></a>foo <span class=\"op\">&lt;</span> bar</span>\n<span id=\"cb42-4\"><a href=\"#cb42-4\"></a>foo <span class=\"op\">&gt;</span> bar</span></code></pre></div>\n<p>And of course, as we previously saw, we can use parentheses to group expressions and influence the order of evaluation:</p>\n<div class=\"sourceCode\" id=\"cb43\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb43-1\"><a href=\"#cb43-1\"></a><span class=\"dv\">5</span> <span class=\"op\">*</span> (<span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">5</span>)</span>\n<span id=\"cb43-2\"><a href=\"#cb43-2\"></a>((<span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">5</span>) <span class=\"op\">*</span> <span class=\"dv\">5</span>) <span class=\"op\">*</span> <span class=\"dv\">5</span></span></code></pre></div>\n<p>Then there are call expressions:</p>\n<div class=\"sourceCode\" id=\"cb44\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb44-1\"><a href=\"#cb44-1\"></a>add(<span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span>)</span>\n<span id=\"cb44-2\"><a href=\"#cb44-2\"></a>add(add(<span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span>)<span class=\"op\">,</span> add(<span class=\"dv\">5</span><span class=\"op\">,</span> <span class=\"dv\">10</span>))</span>\n<span id=\"cb44-3\"><a href=\"#cb44-3\"></a>max(<span class=\"dv\">5</span><span class=\"op\">,</span> add(<span class=\"dv\">5</span><span class=\"op\">,</span> (<span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">5</span>)))</span></code></pre></div>\n<p>Identifiers are expressions too:</p>\n<div class=\"sourceCode\" id=\"cb45\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb45-1\"><a href=\"#cb45-1\"></a>foo <span class=\"op\">*</span> bar <span class=\"op\">/</span> foobar</span>\n<span id=\"cb45-2\"><a href=\"#cb45-2\"></a>add(foo<span class=\"op\">,</span> bar)</span></code></pre></div>\n<p>Functions in Monkey are first-class citizens and, yes, function literals are expressions too. We can use a let statement to bind a function to a name. The function literal is just the expression in the statement:</p>\n<div class=\"sourceCode\" id=\"cb46\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb46-1\"><a href=\"#cb46-1\"></a><span class=\"kw\">let</span> add <span class=\"op\">=</span> fn(x<span class=\"op\">,</span> y) { <span class=\"cf\">return</span> x <span class=\"op\">+</span> y }<span class=\"op\">;</span></span></code></pre></div>\n<p>And here we use a function literal in place of an identifier:</p>\n<div class=\"sourceCode\" id=\"cb47\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb47-1\"><a href=\"#cb47-1\"></a>fn(x<span class=\"op\">,</span> y) { <span class=\"cf\">return</span> x <span class=\"op\">+</span> y }(<span class=\"dv\">5</span><span class=\"op\">,</span> <span class=\"dv\">5</span>)</span>\n<span id=\"cb47-2\"><a href=\"#cb47-2\"></a>(fn(x) { <span class=\"cf\">return</span> x }(<span class=\"dv\">5</span>) <span class=\"op\">+</span> <span class=\"dv\">10</span> ) <span class=\"op\">*</span> <span class=\"dv\">10</span></span></code></pre></div>\n<p>In contrast to a lot of widely used programming languages we also have “if expressions” in Monkey:</p>\n<div class=\"sourceCode\" id=\"cb48\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb48-1\"><a href=\"#cb48-1\"></a><span class=\"kw\">let</span> result <span class=\"op\">=</span> <span class=\"cf\">if</span> (<span class=\"dv\">10</span> <span class=\"op\">&gt;</span> <span class=\"dv\">5</span>) { <span class=\"kw\">true</span> } <span class=\"cf\">else</span> { <span class=\"kw\">false</span> }<span class=\"op\">;</span></span>\n<span id=\"cb48-2\"><a href=\"#cb48-2\"></a>result <span class=\"co\">// =&gt; true</span></span></code></pre></div>\n<p>Looking at all these different forms of expressions it becomes clear that we need a really good approach to parse them correctly and in an understandable and extendable way. Our old approach of deciding what to do based on the current token won’t get us very far - at least not without wanting to tear our hair out. And that is where Vaughan Pratt comes in.</p>\n</section>\n<section id=\"top-down-operator-precedence-or-pratt-parsing\" class=\"level3\" data-number=\"2.6.2\">\n<h3 data-number=\"2.6.2\">Top Down Operator Precedence (or: Pratt Parsing)</h3>\n<p>In his paper “Top Down Operator Precedence” Vaughan Pratt presents an approach to parsing expressions that, in his own words:</p>\n<blockquote>\n<p>[…] is very simple to understand, trivial to implement, easy to use, extremely efficient in practice if not in theory, yet flexible enough to meet most reasonable syntactic needs of users […]</p>\n</blockquote>\n<p>The paper was published in 1973 but in the many years since then the ideas presented by Pratt didn’t gain a huge following. Only in recent years, other programmers rediscovered Pratt’s paper, wrote about it and caused Pratt’s approach to parsing to rise in popularity. There’s Douglas Crockford’s (of “JavaScript: The Good Parts” fame) article called <a href=\"http://javascript.crockford.com/tdop/tdop.html\">“Top Down Operator Precedence”</a> that shows how to translate Pratt’s ideas to JavaScript (which Crockford did when building JSLint). And then there’s <a href=\"http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\">the highly recommended article by Bob Nystrom</a>, author of the excellent “Game Programming Patterns” book, that makes Pratt’s approach really easy to understand and to follow by providing clean example code in Java.</p>\n<p>The parsing approach described by all three, which is called Top Down Operator Precedence Parsing, or Pratt parsing, was invented as an alternative to parsers based on context-free grammars and the Backus-Naur-Form.</p>\n<p>And that is also the main difference: instead of associating parsing functions (think of our <code>parseLetStatement</code> method here) with grammar rules (defined in BNF or EBNF), Pratt associates these functions (which he calls “semantic code”) with single token types. A crucial part of this idea is that each token type can have two parsing functions associated with it, depending on the token’s position - infix or prefix.</p>\n<p>I guess that doesn’t make a lot of sense yet. We never saw how to associate parsing functions with grammar rules, so the idea of using token types instead of these rules doesn’t register as anything really novel or revelatory. To be completely honest: I was facing a chicken-and-egg problem when writing this section. Is it better to explain this algorithm in abstract terms and then show the implementation, possibly causing you to jump back and forth between pages, or to show the implementation with the explanation following, causing you to probably skip over the implementation and not getting a lot out of the explanation?</p>\n<p>The answer, I decided, is neither of these two options. What we’re going to do instead is start implementing the expression parsing part of our parser. Then we’re going to take a closer look at it and its algorithm. Afterwards we will extend and complete it so it’s able to parse all possible expressions in Monkey.</p>\n<p>And before we start writing any code, let’s just be clear on the terminology.</p>\n</section>\n<section id=\"terminology\" class=\"level3\" data-number=\"2.6.3\">\n<h3 data-number=\"2.6.3\">Terminology</h3>\n<p>A <strong>prefix operator</strong> is an operator “in front of” its operand. Example:</p>\n<div class=\"sourceCode\" id=\"cb49\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb49-1\"><a href=\"#cb49-1\"></a><span class=\"op\">--</span><span class=\"dv\">5</span></span></code></pre></div>\n<p>Here the operator is <code>--</code> (decrement), the operand is the integer literal <code>5</code> and the operator is in the prefix position.</p>\n<p>A <strong>postfix operator</strong> is an operator “after” its operand. Example:</p>\n<div class=\"sourceCode\" id=\"cb50\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb50-1\"><a href=\"#cb50-1\"></a>foobar<span class=\"op\">++</span></span></code></pre></div>\n<p>Here the operator is <code>++</code> (increment), the operand is the identifier <code>foobar</code> and the operator is in the postfix position. The Monkey interpreter we’ll build won’t have postfix operators. Not because of some technical limitations, but purely in order to keep the scope of the book limited.</p>\n<p>Now, <strong>infix operators</strong> are something we’ve all seen before. An infix operator sits between its operands, like this:</p>\n<div class=\"sourceCode\" id=\"cb51\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb51-1\"><a href=\"#cb51-1\"></a><span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">8</span></span></code></pre></div>\n<p>The <code>*</code> operator sits in the infix position between the two integer literals <code>5</code> and <code>8</code>. Infix operators appear in <strong>binary expressions</strong> - where the operator has two operands.</p>\n<p>The other term we already stumbled upon and will find again later is <strong>operator precedence</strong>. An alternative term for this is <strong>order of operations</strong>, which should make clearer what operator precedence describes: which priority do different operators have. The canonical example is this one, which we saw earlier:</p>\n<div class=\"sourceCode\" id=\"cb52\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb52-1\"><a href=\"#cb52-1\"></a><span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">10</span></span></code></pre></div>\n<p>The result of this expression is <code>55</code> and not <code>100</code>. And that’s because the <code>*</code> operator has a higher precedence, a “higher rank”. It’s “more important” than the <code>+</code> operator. It gets evaluated before the other operator. I sometimes think of operator precedence as “operator stickiness”: how much do the operands next to the operator “stick” to it.</p>\n<p>These are all basic terms: prefix, postfix, infix operator and precedence. But it’s important that we keep these simple definitions in mind later on, where we’ll use these terms in other places.</p>\n<p>But for now: let’s get typing and write some code!</p>\n</section>\n<section id=\"preparing-the-ast\" class=\"level3\" data-number=\"2.6.4\">\n<h3 data-number=\"2.6.4\">Preparing the AST</h3>\n<p>The first thing we need to do for expression parsing is to prepare our AST. As we saw before, a program in Monkey is a series of statements. Some are let statements, others return statements. We need to add a third type of statement to our AST: expression statements.</p>\n<p>This may sound confusing, after I told you that let and return statements are the only type of statements in Monkey. But an expression statement is not really a distinct statement; it’s a statement that consists solely of one expression. It’s only a wrapper. We need it because it’s totally legal in Monkey to write the following code:</p>\n<div class=\"sourceCode\" id=\"cb53\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb53-1\"><a href=\"#cb53-1\"></a><span class=\"kw\">let</span> x <span class=\"op\">=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb53-2\"><a href=\"#cb53-2\"></a>x <span class=\"op\">+</span> <span class=\"dv\">10</span><span class=\"op\">;</span></span></code></pre></div>\n<p>The first line is a let statement, the second line is an expression statement. Other languages don’t have these expression statements, but most scripting languages do. They make it possible to have one line consisting only of an expression. So let’s add this node type to our AST:</p>\n<div class=\"sourceCode\" id=\"cb54\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb54-1\"><a href=\"#cb54-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb54-2\"><a href=\"#cb54-2\"></a></span>\n<span id=\"cb54-3\"><a href=\"#cb54-3\"></a><span class=\"kw\">type</span> ExpressionStatement <span class=\"kw\">struct</span> {</span>\n<span id=\"cb54-4\"><a href=\"#cb54-4\"></a>    Token      token.Token <span class=\"co\">// the first token of the expression</span></span>\n<span id=\"cb54-5\"><a href=\"#cb54-5\"></a>    Expression Expression</span>\n<span id=\"cb54-6\"><a href=\"#cb54-6\"></a>}</span>\n<span id=\"cb54-7\"><a href=\"#cb54-7\"></a></span>\n<span id=\"cb54-8\"><a href=\"#cb54-8\"></a><span class=\"kw\">func</span> (es *ExpressionStatement) statementNode()       {}</span>\n<span id=\"cb54-9\"><a href=\"#cb54-9\"></a><span class=\"kw\">func</span> (es *ExpressionStatement) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> es.Token.Literal }</span></code></pre></div>\n<p>The <code>ast.ExpressionStatement</code> type has two fields: the <code>Token</code> field, which every node has, and the <code>Expression</code> field, which holds the expression. <code>ast.ExpressionStatement</code> fulfills the <code>ast.Statement</code> interface, which means we can add it to the <code>Statements</code> slice of <code>ast.Program</code>. And that’s the whole reason why we’re adding <code>ast.ExpressionStatement</code>.</p>\n<p>With <code>ast.ExpressionStatement</code> defined we could resume work on the parser. But instead, let’s make our lives much easier by adding a <code>String()</code> method to our AST nodes. This will allow us to print AST nodes for debugging and to compare them with other AST nodes. This is going to be really handy in tests!</p>\n<p>We’re going to make this <code>String()</code> method part of the <code>ast.Node</code> interface:</p>\n<div class=\"sourceCode\" id=\"cb55\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb55-1\"><a href=\"#cb55-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb55-2\"><a href=\"#cb55-2\"></a></span>\n<span id=\"cb55-3\"><a href=\"#cb55-3\"></a><span class=\"kw\">type</span> Node <span class=\"kw\">interface</span> {</span>\n<span id=\"cb55-4\"><a href=\"#cb55-4\"></a>    TokenLiteral() <span class=\"dt\">string</span></span>\n<span id=\"cb55-5\"><a href=\"#cb55-5\"></a>    String() <span class=\"dt\">string</span></span>\n<span id=\"cb55-6\"><a href=\"#cb55-6\"></a>}</span></code></pre></div>\n<p>Now every node type in our <code>ast</code> package has to implement this method. With that change made, our code won’t compile because the compiler complains about our AST nodes not fully implementing the updated <code>Node</code> interface. Let’s start with <code>*ast.Program</code> and add its <code>String()</code> method first:</p>\n<div class=\"sourceCode\" id=\"cb56\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb56-1\"><a href=\"#cb56-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb56-2\"><a href=\"#cb56-2\"></a></span>\n<span id=\"cb56-3\"><a href=\"#cb56-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb56-4\"><a href=\"#cb56-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb56-5\"><a href=\"#cb56-5\"></a>    <span class=\"st\">&quot;bytes&quot;</span></span>\n<span id=\"cb56-6\"><a href=\"#cb56-6\"></a>)</span>\n<span id=\"cb56-7\"><a href=\"#cb56-7\"></a></span>\n<span id=\"cb56-8\"><a href=\"#cb56-8\"></a><span class=\"kw\">func</span> (p *Program) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb56-9\"><a href=\"#cb56-9\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb56-10\"><a href=\"#cb56-10\"></a></span>\n<span id=\"cb56-11\"><a href=\"#cb56-11\"></a>    <span class=\"kw\">for</span> _, s := <span class=\"kw\">range</span> p.Statements {</span>\n<span id=\"cb56-12\"><a href=\"#cb56-12\"></a>        out.WriteString(s.String())</span>\n<span id=\"cb56-13\"><a href=\"#cb56-13\"></a>    }</span>\n<span id=\"cb56-14\"><a href=\"#cb56-14\"></a></span>\n<span id=\"cb56-15\"><a href=\"#cb56-15\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb56-16\"><a href=\"#cb56-16\"></a>}</span></code></pre></div>\n<p>This method doesn’t do much. It only creates a buffer and writes the return value of each statement’s <code>String()</code> method to it. And then it returns the buffer as a string. It delegates most of its work to the <code>Statements</code> of <code>*ast.Program</code>.</p>\n<p>The “real work” happens in the <code>String()</code> methods of our three statement types <code>ast.LetStatement</code>, <code>ast.ReturnStatement</code> and <code>ast.ExpressionStatement</code>:</p>\n<div class=\"sourceCode\" id=\"cb57\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb57-1\"><a href=\"#cb57-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb57-2\"><a href=\"#cb57-2\"></a></span>\n<span id=\"cb57-3\"><a href=\"#cb57-3\"></a><span class=\"kw\">func</span> (ls *LetStatement) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb57-4\"><a href=\"#cb57-4\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb57-5\"><a href=\"#cb57-5\"></a></span>\n<span id=\"cb57-6\"><a href=\"#cb57-6\"></a>    out.WriteString(ls.TokenLiteral() + <span class=\"st\">&quot; &quot;</span>)</span>\n<span id=\"cb57-7\"><a href=\"#cb57-7\"></a>    out.WriteString(ls.Name.String())</span>\n<span id=\"cb57-8\"><a href=\"#cb57-8\"></a>    out.WriteString(<span class=\"st\">&quot; = &quot;</span>)</span>\n<span id=\"cb57-9\"><a href=\"#cb57-9\"></a></span>\n<span id=\"cb57-10\"><a href=\"#cb57-10\"></a>    <span class=\"kw\">if</span> ls.Value != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb57-11\"><a href=\"#cb57-11\"></a>        out.WriteString(ls.Value.String())</span>\n<span id=\"cb57-12\"><a href=\"#cb57-12\"></a>    }</span>\n<span id=\"cb57-13\"><a href=\"#cb57-13\"></a></span>\n<span id=\"cb57-14\"><a href=\"#cb57-14\"></a>    out.WriteString(<span class=\"st\">&quot;;&quot;</span>)</span>\n<span id=\"cb57-15\"><a href=\"#cb57-15\"></a></span>\n<span id=\"cb57-16\"><a href=\"#cb57-16\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb57-17\"><a href=\"#cb57-17\"></a>}</span>\n<span id=\"cb57-18\"><a href=\"#cb57-18\"></a></span>\n<span id=\"cb57-19\"><a href=\"#cb57-19\"></a><span class=\"kw\">func</span> (rs *ReturnStatement) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb57-20\"><a href=\"#cb57-20\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb57-21\"><a href=\"#cb57-21\"></a></span>\n<span id=\"cb57-22\"><a href=\"#cb57-22\"></a>    out.WriteString(rs.TokenLiteral() + <span class=\"st\">&quot; &quot;</span>)</span>\n<span id=\"cb57-23\"><a href=\"#cb57-23\"></a></span>\n<span id=\"cb57-24\"><a href=\"#cb57-24\"></a>    <span class=\"kw\">if</span> rs.ReturnValue != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb57-25\"><a href=\"#cb57-25\"></a>        out.WriteString(rs.ReturnValue.String())</span>\n<span id=\"cb57-26\"><a href=\"#cb57-26\"></a>    }</span>\n<span id=\"cb57-27\"><a href=\"#cb57-27\"></a></span>\n<span id=\"cb57-28\"><a href=\"#cb57-28\"></a>    out.WriteString(<span class=\"st\">&quot;;&quot;</span>)</span>\n<span id=\"cb57-29\"><a href=\"#cb57-29\"></a></span>\n<span id=\"cb57-30\"><a href=\"#cb57-30\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb57-31\"><a href=\"#cb57-31\"></a>}</span>\n<span id=\"cb57-32\"><a href=\"#cb57-32\"></a></span>\n<span id=\"cb57-33\"><a href=\"#cb57-33\"></a><span class=\"kw\">func</span> (es *ExpressionStatement) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb57-34\"><a href=\"#cb57-34\"></a>    <span class=\"kw\">if</span> es.Expression != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb57-35\"><a href=\"#cb57-35\"></a>        <span class=\"kw\">return</span> es.Expression.String()</span>\n<span id=\"cb57-36\"><a href=\"#cb57-36\"></a>    }</span>\n<span id=\"cb57-37\"><a href=\"#cb57-37\"></a>    <span class=\"kw\">return</span> <span class=\"st\">&quot;&quot;</span></span>\n<span id=\"cb57-38\"><a href=\"#cb57-38\"></a>}</span></code></pre></div>\n<p>The nil-checks will be taken out, later on, when we can fully build expressions.</p>\n<p>Now we only need to add a last <code>String()</code> method to <code>ast.Identifier</code>:</p>\n<div class=\"sourceCode\" id=\"cb58\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb58-1\"><a href=\"#cb58-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb58-2\"><a href=\"#cb58-2\"></a></span>\n<span id=\"cb58-3\"><a href=\"#cb58-3\"></a><span class=\"kw\">func</span> (i *Identifier) String() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> i.Value }</span></code></pre></div>\n<p>With these methods in place, we can now just call <code>String()</code> on <code>*ast.Program</code> and get our whole program back as a string. That makes the structure of <code>*ast.Program</code> easily testable. Let’s use the following line of Monkey source code as an example:</p>\n<div class=\"sourceCode\" id=\"cb59\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb59-1\"><a href=\"#cb59-1\"></a><span class=\"kw\">let</span> myVar <span class=\"op\">=</span> anotherVar<span class=\"op\">;</span></span></code></pre></div>\n<p>If we construct an AST out of this, we can make an assertion about the return value of <code>String()</code> like this:</p>\n<div class=\"sourceCode\" id=\"cb60\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb60-1\"><a href=\"#cb60-1\"></a><span class=\"co\">// ast/ast_test.go</span></span>\n<span id=\"cb60-2\"><a href=\"#cb60-2\"></a></span>\n<span id=\"cb60-3\"><a href=\"#cb60-3\"></a><span class=\"kw\">package</span> ast</span>\n<span id=\"cb60-4\"><a href=\"#cb60-4\"></a></span>\n<span id=\"cb60-5\"><a href=\"#cb60-5\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb60-6\"><a href=\"#cb60-6\"></a>    <span class=\"st\">&quot;monkey/token&quot;</span></span>\n<span id=\"cb60-7\"><a href=\"#cb60-7\"></a>    <span class=\"st\">&quot;testing&quot;</span></span>\n<span id=\"cb60-8\"><a href=\"#cb60-8\"></a>)</span>\n<span id=\"cb60-9\"><a href=\"#cb60-9\"></a></span>\n<span id=\"cb60-10\"><a href=\"#cb60-10\"></a><span class=\"kw\">func</span> TestString(t *testing.T) {</span>\n<span id=\"cb60-11\"><a href=\"#cb60-11\"></a>    program := &amp;Program{</span>\n<span id=\"cb60-12\"><a href=\"#cb60-12\"></a>        Statements: []Statement{</span>\n<span id=\"cb60-13\"><a href=\"#cb60-13\"></a>            &amp;LetStatement{</span>\n<span id=\"cb60-14\"><a href=\"#cb60-14\"></a>                Token: token.Token{Type: token.LET, Literal: <span class=\"st\">&quot;let&quot;</span>},</span>\n<span id=\"cb60-15\"><a href=\"#cb60-15\"></a>                Name: &amp;Identifier{</span>\n<span id=\"cb60-16\"><a href=\"#cb60-16\"></a>                    Token: token.Token{Type: token.IDENT, Literal: <span class=\"st\">&quot;myVar&quot;</span>},</span>\n<span id=\"cb60-17\"><a href=\"#cb60-17\"></a>                    Value: <span class=\"st\">&quot;myVar&quot;</span>,</span>\n<span id=\"cb60-18\"><a href=\"#cb60-18\"></a>                },</span>\n<span id=\"cb60-19\"><a href=\"#cb60-19\"></a>                Value: &amp;Identifier{</span>\n<span id=\"cb60-20\"><a href=\"#cb60-20\"></a>                    Token: token.Token{Type: token.IDENT, Literal: <span class=\"st\">&quot;anotherVar&quot;</span>},</span>\n<span id=\"cb60-21\"><a href=\"#cb60-21\"></a>                    Value: <span class=\"st\">&quot;anotherVar&quot;</span>,</span>\n<span id=\"cb60-22\"><a href=\"#cb60-22\"></a>                },</span>\n<span id=\"cb60-23\"><a href=\"#cb60-23\"></a>            },</span>\n<span id=\"cb60-24\"><a href=\"#cb60-24\"></a>        },</span>\n<span id=\"cb60-25\"><a href=\"#cb60-25\"></a>    }</span>\n<span id=\"cb60-26\"><a href=\"#cb60-26\"></a></span>\n<span id=\"cb60-27\"><a href=\"#cb60-27\"></a>    <span class=\"kw\">if</span> program.String() != <span class=\"st\">&quot;let myVar = anotherVar;&quot;</span> {</span>\n<span id=\"cb60-28\"><a href=\"#cb60-28\"></a>        t.Errorf(<span class=\"st\">&quot;program.String() wrong. got=%q&quot;</span>, program.String())</span>\n<span id=\"cb60-29\"><a href=\"#cb60-29\"></a>    }</span>\n<span id=\"cb60-30\"><a href=\"#cb60-30\"></a>}</span></code></pre></div>\n<p>In this test we construct the AST by hand. When writing tests for the parser we don’t, of course, but make assertions about the AST the parser produces. For demonstration purposes, this test shows us how we can add another easily readable layer of tests for our parser by just comparing the parser output with strings. That’s going to be especially handy when parsing expressions.</p>\n<p>So, good news: preparation is done! It’s time to write a Pratt parser.</p>\n</section>\n<section id=\"implementing-the-pratt-parser\" class=\"level3\" data-number=\"2.6.5\">\n<h3 data-number=\"2.6.5\">Implementing the Pratt Parser</h3>\n<p>A Pratt parser’s main idea is the association of parsing functions (which Pratt calls “semantic code”) with token types. Whenever this token type is encountered, the parsing functions are called to parse the appropriate expression and return an AST node that represents it. Each token type can have up to two parsing functions associated with it, depending on whether the token is found in a prefix or an infix position.</p>\n<p>The first thing we need to do is to setup these associations. We define two types of functions: a prefix parsing function and an infix parsing function.</p>\n<div class=\"sourceCode\" id=\"cb61\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb61-1\"><a href=\"#cb61-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb61-2\"><a href=\"#cb61-2\"></a></span>\n<span id=\"cb61-3\"><a href=\"#cb61-3\"></a><span class=\"kw\">type</span> (</span>\n<span id=\"cb61-4\"><a href=\"#cb61-4\"></a>    prefixParseFn <span class=\"kw\">func</span>() ast.Expression</span>\n<span id=\"cb61-5\"><a href=\"#cb61-5\"></a>    infixParseFn  <span class=\"kw\">func</span>(ast.Expression) ast.Expression</span>\n<span id=\"cb61-6\"><a href=\"#cb61-6\"></a>)</span></code></pre></div>\n<p>Both function types return an <code>ast.Expression</code>, since that’s what we’re here to parse. But only the <code>infixParseFn</code> takes an argument: another <code>ast.Expression</code>. This argument is “left side” of the infix operator that’s being parsed. A prefix operator doesn’t have a “left side”, per definition. I know that this doesn’t make a lot of sense yet, but bear with me here, you’ll see how this works. For now, just remember that <code>prefixParseFn</code>s gets called when we encounter the associated token type in prefix position and <code>infixParseFn</code> gets called when we encounter the token type in infix position.</p>\n<p>In order for our parser to get the correct <code>prefixParseFn</code> or <code>infixParseFn</code> for the current token type, we add two maps to the <code>Parser</code> structure:</p>\n<div class=\"sourceCode\" id=\"cb62\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb62-1\"><a href=\"#cb62-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb62-2\"><a href=\"#cb62-2\"></a></span>\n<span id=\"cb62-3\"><a href=\"#cb62-3\"></a><span class=\"kw\">type</span> Parser <span class=\"kw\">struct</span> {</span>\n<span id=\"cb62-4\"><a href=\"#cb62-4\"></a>    l      *lexer.Lexer</span>\n<span id=\"cb62-5\"><a href=\"#cb62-5\"></a>    errors []<span class=\"dt\">string</span></span>\n<span id=\"cb62-6\"><a href=\"#cb62-6\"></a></span>\n<span id=\"cb62-7\"><a href=\"#cb62-7\"></a>    curToken  token.Token</span>\n<span id=\"cb62-8\"><a href=\"#cb62-8\"></a>    peekToken token.Token</span>\n<span id=\"cb62-9\"><a href=\"#cb62-9\"></a></span>\n<span id=\"cb62-10\"><a href=\"#cb62-10\"></a>    prefixParseFns <span class=\"kw\">map</span>[token.TokenType]prefixParseFn</span>\n<span id=\"cb62-11\"><a href=\"#cb62-11\"></a>    infixParseFns  <span class=\"kw\">map</span>[token.TokenType]infixParseFn</span>\n<span id=\"cb62-12\"><a href=\"#cb62-12\"></a>}</span></code></pre></div>\n<p>With these maps in place, we can just check if the appropriate map (infix or prefix) has a parsing function associated with <code>curToken.Type</code>.</p>\n<p>We also give the <code>Parser</code> two helper methods that add entries to these maps:</p>\n<div class=\"sourceCode\" id=\"cb63\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb63-1\"><a href=\"#cb63-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb63-2\"><a href=\"#cb63-2\"></a></span>\n<span id=\"cb63-3\"><a href=\"#cb63-3\"></a><span class=\"kw\">func</span> (p *Parser) registerPrefix(tokenType token.TokenType, fn prefixParseFn) {</span>\n<span id=\"cb63-4\"><a href=\"#cb63-4\"></a>    p.prefixParseFns[tokenType] = fn</span>\n<span id=\"cb63-5\"><a href=\"#cb63-5\"></a>}</span>\n<span id=\"cb63-6\"><a href=\"#cb63-6\"></a></span>\n<span id=\"cb63-7\"><a href=\"#cb63-7\"></a><span class=\"kw\">func</span> (p *Parser) registerInfix(tokenType token.TokenType, fn infixParseFn) {</span>\n<span id=\"cb63-8\"><a href=\"#cb63-8\"></a>    p.infixParseFns[tokenType] = fn</span>\n<span id=\"cb63-9\"><a href=\"#cb63-9\"></a>}</span></code></pre></div>\n<p>Now we are ready to get to the heart of the algorithm.</p>\n</section>\n<section id=\"identifiers\" class=\"level3\" data-number=\"2.6.6\">\n<h3 data-number=\"2.6.6\">Identifiers</h3>\n<p>We’re going to start with possibly the simplest expression type in the Monkey programming language: identifiers. Used in an expression statement an identifier looks like this:</p>\n<div class=\"sourceCode\" id=\"cb64\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb64-1\"><a href=\"#cb64-1\"></a>foobar<span class=\"op\">;</span></span></code></pre></div>\n<p>Of course, the <code>foobar</code> is arbitrary and identifiers are expressions in other contexts too, not just in an expression statement:</p>\n<div class=\"sourceCode\" id=\"cb65\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb65-1\"><a href=\"#cb65-1\"></a>add(foobar<span class=\"op\">,</span> barfoo)<span class=\"op\">;</span></span>\n<span id=\"cb65-2\"><a href=\"#cb65-2\"></a>foobar <span class=\"op\">+</span> barfoo<span class=\"op\">;</span></span>\n<span id=\"cb65-3\"><a href=\"#cb65-3\"></a><span class=\"cf\">if</span> (foobar) {</span>\n<span id=\"cb65-4\"><a href=\"#cb65-4\"></a>  <span class=\"co\">// [...]</span></span>\n<span id=\"cb65-5\"><a href=\"#cb65-5\"></a>}</span></code></pre></div>\n<p>Here we have identifiers as arguments in a function call, as operands in an infix expression and as a standalone expression as part of a conditional. They can be used in all of these contexts, because identifiers are expressions just like <code>1 + 2</code>. And just like any other expression identifiers produce a value: they evaluate to the value they are bound to.</p>\n<p>We start with a test:</p>\n<div class=\"sourceCode\" id=\"cb66\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb66-1\"><a href=\"#cb66-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb66-2\"><a href=\"#cb66-2\"></a></span>\n<span id=\"cb66-3\"><a href=\"#cb66-3\"></a><span class=\"kw\">func</span> TestIdentifierExpression(t *testing.T) {</span>\n<span id=\"cb66-4\"><a href=\"#cb66-4\"></a>    input := <span class=\"st\">&quot;foobar;&quot;</span></span>\n<span id=\"cb66-5\"><a href=\"#cb66-5\"></a></span>\n<span id=\"cb66-6\"><a href=\"#cb66-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb66-7\"><a href=\"#cb66-7\"></a>    p := New(l)</span>\n<span id=\"cb66-8\"><a href=\"#cb66-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb66-9\"><a href=\"#cb66-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb66-10\"><a href=\"#cb66-10\"></a></span>\n<span id=\"cb66-11\"><a href=\"#cb66-11\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(program.Statements) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb66-12\"><a href=\"#cb66-12\"></a>        t.Fatalf(<span class=\"st\">&quot;program has not enough statements. got=%d&quot;</span>,</span>\n<span id=\"cb66-13\"><a href=\"#cb66-13\"></a>            <span class=\"bu\">len</span>(program.Statements))</span>\n<span id=\"cb66-14\"><a href=\"#cb66-14\"></a>    }</span>\n<span id=\"cb66-15\"><a href=\"#cb66-15\"></a>    stmt, ok := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb66-16\"><a href=\"#cb66-16\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb66-17\"><a href=\"#cb66-17\"></a>        t.Fatalf(<span class=\"st\">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</span>\n<span id=\"cb66-18\"><a href=\"#cb66-18\"></a>            program.Statements[<span class=\"dv\">0</span>])</span>\n<span id=\"cb66-19\"><a href=\"#cb66-19\"></a>    }</span>\n<span id=\"cb66-20\"><a href=\"#cb66-20\"></a></span>\n<span id=\"cb66-21\"><a href=\"#cb66-21\"></a>    ident, ok := stmt.Expression.(*ast.Identifier)</span>\n<span id=\"cb66-22\"><a href=\"#cb66-22\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb66-23\"><a href=\"#cb66-23\"></a>        t.Fatalf(<span class=\"st\">&quot;exp not *ast.Identifier. got=%T&quot;</span>, stmt.Expression)</span>\n<span id=\"cb66-24\"><a href=\"#cb66-24\"></a>    }</span>\n<span id=\"cb66-25\"><a href=\"#cb66-25\"></a>    <span class=\"kw\">if</span> ident.Value != <span class=\"st\">&quot;foobar&quot;</span> {</span>\n<span id=\"cb66-26\"><a href=\"#cb66-26\"></a>        t.Errorf(<span class=\"st\">&quot;ident.Value not %s. got=%s&quot;</span>, <span class=\"st\">&quot;foobar&quot;</span>, ident.Value)</span>\n<span id=\"cb66-27\"><a href=\"#cb66-27\"></a>    }</span>\n<span id=\"cb66-28\"><a href=\"#cb66-28\"></a>    <span class=\"kw\">if</span> ident.TokenLiteral() != <span class=\"st\">&quot;foobar&quot;</span> {</span>\n<span id=\"cb66-29\"><a href=\"#cb66-29\"></a>        t.Errorf(<span class=\"st\">&quot;ident.TokenLiteral not %s. got=%s&quot;</span>, <span class=\"st\">&quot;foobar&quot;</span>,</span>\n<span id=\"cb66-30\"><a href=\"#cb66-30\"></a>            ident.TokenLiteral())</span>\n<span id=\"cb66-31\"><a href=\"#cb66-31\"></a>    }</span>\n<span id=\"cb66-32\"><a href=\"#cb66-32\"></a>}</span></code></pre></div>\n<p>That’s a lot of lines, but it’s mostly just grunt work. We parse our input <code>foobar;</code>, check the parser for errors, make an assertion about the number of statements in the <code>*ast.Program</code> node and then check that the only statement in <code>program.Statements</code> is an <code>*ast.ExpressionStatement</code>. Then we check that the <code>*ast.ExpressionStatement.Expression</code> is an <code>*ast.Identifier</code>. Finally we check that our identifier has the correct value of <code>\"foobar\"</code>.</p>\n<p>Of course, the parser tests fail:</p>\n<div class=\"sourceCode\" id=\"cb67\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb67-1\"><a href=\"#cb67-1\"></a>$ go test ./parser</span>\n<span id=\"cb67-2\"><a href=\"#cb67-2\"></a>--- FAIL: TestIdentifierExpression (0.00s)</span>\n<span id=\"cb67-3\"><a href=\"#cb67-3\"></a>  parser_test.go:110: program has not enough statements. got=0</span>\n<span id=\"cb67-4\"><a href=\"#cb67-4\"></a>FAIL</span>\n<span id=\"cb67-5\"><a href=\"#cb67-5\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>The parser doesn’t know anything about expressions yet. We need to write a <code>parseExpression</code> method.</p>\n<p>The first thing we need to do is to extend the <code>parseStatement()</code> method of the parser, so that it parses expression statements. Since the only two real statement types in Monkey are let and return statements, we try to parse expression statements if we don’t encounter one of the other two:</p>\n<div class=\"sourceCode\" id=\"cb68\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb68-1\"><a href=\"#cb68-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb68-2\"><a href=\"#cb68-2\"></a></span>\n<span id=\"cb68-3\"><a href=\"#cb68-3\"></a><span class=\"kw\">func</span> (p *Parser) parseStatement() ast.Statement {</span>\n<span id=\"cb68-4\"><a href=\"#cb68-4\"></a>    <span class=\"kw\">switch</span> p.curToken.Type {</span>\n<span id=\"cb68-5\"><a href=\"#cb68-5\"></a>    <span class=\"kw\">case</span> token.LET:</span>\n<span id=\"cb68-6\"><a href=\"#cb68-6\"></a>        <span class=\"kw\">return</span> p.parseLetStatement()</span>\n<span id=\"cb68-7\"><a href=\"#cb68-7\"></a>    <span class=\"kw\">case</span> token.RETURN:</span>\n<span id=\"cb68-8\"><a href=\"#cb68-8\"></a>        <span class=\"kw\">return</span> p.parseReturnStatement()</span>\n<span id=\"cb68-9\"><a href=\"#cb68-9\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb68-10\"><a href=\"#cb68-10\"></a>        <span class=\"kw\">return</span> p.parseExpressionStatement()</span>\n<span id=\"cb68-11\"><a href=\"#cb68-11\"></a>    }</span>\n<span id=\"cb68-12\"><a href=\"#cb68-12\"></a>}</span></code></pre></div>\n<p>The <code>parseExpressionStatement</code> method looks like this:</p>\n<div class=\"sourceCode\" id=\"cb69\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb69-1\"><a href=\"#cb69-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb69-2\"><a href=\"#cb69-2\"></a></span>\n<span id=\"cb69-3\"><a href=\"#cb69-3\"></a><span class=\"kw\">func</span> (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {</span>\n<span id=\"cb69-4\"><a href=\"#cb69-4\"></a>    stmt := &amp;ast.ExpressionStatement{Token: p.curToken}</span>\n<span id=\"cb69-5\"><a href=\"#cb69-5\"></a></span>\n<span id=\"cb69-6\"><a href=\"#cb69-6\"></a>    stmt.Expression = p.parseExpression(LOWEST)</span>\n<span id=\"cb69-7\"><a href=\"#cb69-7\"></a></span>\n<span id=\"cb69-8\"><a href=\"#cb69-8\"></a>    <span class=\"kw\">if</span> p.peekTokenIs(token.SEMICOLON) {</span>\n<span id=\"cb69-9\"><a href=\"#cb69-9\"></a>        p.nextToken()</span>\n<span id=\"cb69-10\"><a href=\"#cb69-10\"></a>    }</span>\n<span id=\"cb69-11\"><a href=\"#cb69-11\"></a></span>\n<span id=\"cb69-12\"><a href=\"#cb69-12\"></a>    <span class=\"kw\">return</span> stmt</span>\n<span id=\"cb69-13\"><a href=\"#cb69-13\"></a>}</span></code></pre></div>\n<p>We already know the drill: we build our AST node and then try to fill its field by calling other parsing functions. In this case there are a few differences though: we call <code>parseExpression()</code>, which doesn’t exist yet, with the constant <code>LOWEST</code>, that doesn’t exist yet, and then we check for an optional semicolon. Yes, it’s optional. If the <code>peekToken</code> is a <code>token.SEMICOLON</code>, we advance so it’s the <code>curToken</code>. If it’s not there, that’s okay too, we don’t add an error to the parser if it’s not there. That’s because we want expression statements to have optional semicolons (which makes it easier to type something like <code>5 + 5</code> into the REPL later on).</p>\n<p>If we now run the tests we can see that compilation fails, because <code>LOWEST</code> is undefined. That’s alright, let’s add it now, by defining the precedences of the Monkey programming language:</p>\n<div class=\"sourceCode\" id=\"cb70\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb70-1\"><a href=\"#cb70-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb70-2\"><a href=\"#cb70-2\"></a></span>\n<span id=\"cb70-3\"><a href=\"#cb70-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb70-4\"><a href=\"#cb70-4\"></a>    _ <span class=\"dt\">int</span> = <span class=\"ot\">iota</span></span>\n<span id=\"cb70-5\"><a href=\"#cb70-5\"></a>    LOWEST</span>\n<span id=\"cb70-6\"><a href=\"#cb70-6\"></a>    EQUALS      <span class=\"co\">// ==</span></span>\n<span id=\"cb70-7\"><a href=\"#cb70-7\"></a>    LESSGREATER <span class=\"co\">// &gt; or &lt;</span></span>\n<span id=\"cb70-8\"><a href=\"#cb70-8\"></a>    SUM         <span class=\"co\">// +</span></span>\n<span id=\"cb70-9\"><a href=\"#cb70-9\"></a>    PRODUCT     <span class=\"co\">// *</span></span>\n<span id=\"cb70-10\"><a href=\"#cb70-10\"></a>    PREFIX      <span class=\"co\">// -X or !X</span></span>\n<span id=\"cb70-11\"><a href=\"#cb70-11\"></a>    CALL        <span class=\"co\">// myFunction(X)</span></span>\n<span id=\"cb70-12\"><a href=\"#cb70-12\"></a>)</span></code></pre></div>\n<p>Here we use <code>iota</code> to give the following constants incrementing numbers as values. The blank identifier <code>_</code> takes the zero value and the following constants get assigned the values <code>1</code> to <code>7</code>. Which numbers we use doesn’t matter, but the <strong>order</strong> and the relation to each other do. What we want out of these constants is to later be able to answer: “does the <code>*</code> operator have a higher precedence than the <code>==</code> operator? Does a prefix operator have a higher precedence than a call expression?”</p>\n<p>In <code>parseExpressionStatement</code> we pass the lowest possible precedence to <code>parseExpression</code>, since we didn’t parse anything yet and we can’t compare precedences. That’s going to make more sense in a short while, I promise. Let’s write <code>parseExpression</code>:</p>\n<div class=\"sourceCode\" id=\"cb71\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb71-1\"><a href=\"#cb71-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb71-2\"><a href=\"#cb71-2\"></a></span>\n<span id=\"cb71-3\"><a href=\"#cb71-3\"></a><span class=\"kw\">func</span> (p *Parser) parseExpression(precedence <span class=\"dt\">int</span>) ast.Expression {</span>\n<span id=\"cb71-4\"><a href=\"#cb71-4\"></a>    prefix := p.prefixParseFns[p.curToken.Type]</span>\n<span id=\"cb71-5\"><a href=\"#cb71-5\"></a>    <span class=\"kw\">if</span> prefix == <span class=\"ot\">nil</span> {</span>\n<span id=\"cb71-6\"><a href=\"#cb71-6\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb71-7\"><a href=\"#cb71-7\"></a>    }</span>\n<span id=\"cb71-8\"><a href=\"#cb71-8\"></a>    leftExp := prefix()</span>\n<span id=\"cb71-9\"><a href=\"#cb71-9\"></a></span>\n<span id=\"cb71-10\"><a href=\"#cb71-10\"></a>    <span class=\"kw\">return</span> leftExp</span>\n<span id=\"cb71-11\"><a href=\"#cb71-11\"></a>}</span></code></pre></div>\n<p>That’s the first version. All it does is checking whether we have a parsing function associated with <code>p.curToken.Type</code> in the prefix position. If we do, it calls this parsing function, if not, it returns nil. Which it does at the moment, since we haven’t associated any tokens with any parsing functions yet. That’s our next step:</p>\n<div class=\"sourceCode\" id=\"cb72\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb72-1\"><a href=\"#cb72-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb72-2\"><a href=\"#cb72-2\"></a></span>\n<span id=\"cb72-3\"><a href=\"#cb72-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb72-4\"><a href=\"#cb72-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb72-5\"><a href=\"#cb72-5\"></a></span>\n<span id=\"cb72-6\"><a href=\"#cb72-6\"></a>    p.prefixParseFns = <span class=\"bu\">make</span>(<span class=\"kw\">map</span>[token.TokenType]prefixParseFn)</span>\n<span id=\"cb72-7\"><a href=\"#cb72-7\"></a>    p.registerPrefix(token.IDENT, p.parseIdentifier)</span>\n<span id=\"cb72-8\"><a href=\"#cb72-8\"></a></span>\n<span id=\"cb72-9\"><a href=\"#cb72-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb72-10\"><a href=\"#cb72-10\"></a>}</span>\n<span id=\"cb72-11\"><a href=\"#cb72-11\"></a></span>\n<span id=\"cb72-12\"><a href=\"#cb72-12\"></a><span class=\"kw\">func</span> (p *Parser) parseIdentifier() ast.Expression {</span>\n<span id=\"cb72-13\"><a href=\"#cb72-13\"></a>    <span class=\"kw\">return</span> &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</span>\n<span id=\"cb72-14\"><a href=\"#cb72-14\"></a>}</span></code></pre></div>\n<p>We modified the <code>New()</code> function to initialize the <code>prefixParseFns</code> map on <code>Parser</code> and register a parsing function: if we encounter a token of type <code>token.IDENT</code> the parsing function to call is <code>parseIdentifier</code>, a method we defined on <code>*Parser</code>.</p>\n<p>The <code>parseIdentifier</code> method doesn’t do a lot. It only returns a <code>*ast.Identifier</code> with the current token in the <code>Token</code> field and the literal value of the token in <code>Value</code>. It doesn’t advance the tokens, it doesn’t call <code>nextToken</code>. That’s important. All of our parsing functions, <code>prefixParseFn</code> or <code>infixParseFn</code>, are going to follow this protocol: start with <code>curToken</code> being the type of token you’re associated with and return with <code>curToken</code> being the last token that’s part of your expression type. Never advance the tokens too far.</p>\n<p>Believe it or not, our tests pass:</p>\n<div class=\"sourceCode\" id=\"cb73\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb73-1\"><a href=\"#cb73-1\"></a>$ go test ./parser</span>\n<span id=\"cb73-2\"><a href=\"#cb73-2\"></a>ok      monkey/parser   0.007s</span></code></pre></div>\n<p>We successfully parsed an identifier expression! Alright! But, before we get off the computer, find someone and proudly tell them, let’s keep our breath a little longer and write some more parsing functions.</p>\n</section>\n<section id=\"integer-literals\" class=\"level3\" data-number=\"2.6.7\">\n<h3 data-number=\"2.6.7\">Integer Literals</h3>\n<p>Nearly as easy to parse as identifiers are integer literals, which look like this:</p>\n<div class=\"sourceCode\" id=\"cb74\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb74-1\"><a href=\"#cb74-1\"></a><span class=\"dv\">5</span><span class=\"op\">;</span></span></code></pre></div>\n<p>Yes, that’s it. Integer literals are expressions. The value they produce is the integer itself. Again, imagine in which places integer literals can occur to understand why they are expressions:</p>\n<div class=\"sourceCode\" id=\"cb75\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb75-1\"><a href=\"#cb75-1\"></a><span class=\"kw\">let</span> x <span class=\"op\">=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb75-2\"><a href=\"#cb75-2\"></a>add(<span class=\"dv\">5</span><span class=\"op\">,</span> <span class=\"dv\">10</span>)<span class=\"op\">;</span></span>\n<span id=\"cb75-3\"><a href=\"#cb75-3\"></a><span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span></code></pre></div>\n<p>We can use any other expression instead of integer literals here and it would still be valid: identifiers, call expressions, grouped expressions, function literals and so on. All the expression types are interchangeable and integer literals are one of them.</p>\n<p>The test case for integer literals looks really similar to the one for identifiers:</p>\n<div class=\"sourceCode\" id=\"cb76\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb76-1\"><a href=\"#cb76-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb76-2\"><a href=\"#cb76-2\"></a></span>\n<span id=\"cb76-3\"><a href=\"#cb76-3\"></a><span class=\"kw\">func</span> TestIntegerLiteralExpression(t *testing.T) {</span>\n<span id=\"cb76-4\"><a href=\"#cb76-4\"></a>    input := <span class=\"st\">&quot;5;&quot;</span></span>\n<span id=\"cb76-5\"><a href=\"#cb76-5\"></a></span>\n<span id=\"cb76-6\"><a href=\"#cb76-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb76-7\"><a href=\"#cb76-7\"></a>    p := New(l)</span>\n<span id=\"cb76-8\"><a href=\"#cb76-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb76-9\"><a href=\"#cb76-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb76-10\"><a href=\"#cb76-10\"></a></span>\n<span id=\"cb76-11\"><a href=\"#cb76-11\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(program.Statements) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb76-12\"><a href=\"#cb76-12\"></a>        t.Fatalf(<span class=\"st\">&quot;program has not enough statements. got=%d&quot;</span>,</span>\n<span id=\"cb76-13\"><a href=\"#cb76-13\"></a>            <span class=\"bu\">len</span>(program.Statements))</span>\n<span id=\"cb76-14\"><a href=\"#cb76-14\"></a>    }</span>\n<span id=\"cb76-15\"><a href=\"#cb76-15\"></a>    stmt, ok := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb76-16\"><a href=\"#cb76-16\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb76-17\"><a href=\"#cb76-17\"></a>        t.Fatalf(<span class=\"st\">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</span>\n<span id=\"cb76-18\"><a href=\"#cb76-18\"></a>            program.Statements[<span class=\"dv\">0</span>])</span>\n<span id=\"cb76-19\"><a href=\"#cb76-19\"></a>    }</span>\n<span id=\"cb76-20\"><a href=\"#cb76-20\"></a></span>\n<span id=\"cb76-21\"><a href=\"#cb76-21\"></a>    literal, ok := stmt.Expression.(*ast.IntegerLiteral)</span>\n<span id=\"cb76-22\"><a href=\"#cb76-22\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb76-23\"><a href=\"#cb76-23\"></a>        t.Fatalf(<span class=\"st\">&quot;exp not *ast.IntegerLiteral. got=%T&quot;</span>, stmt.Expression)</span>\n<span id=\"cb76-24\"><a href=\"#cb76-24\"></a>    }</span>\n<span id=\"cb76-25\"><a href=\"#cb76-25\"></a>    <span class=\"kw\">if</span> literal.Value != <span class=\"dv\">5</span> {</span>\n<span id=\"cb76-26\"><a href=\"#cb76-26\"></a>        t.Errorf(<span class=\"st\">&quot;literal.Value not %d. got=%d&quot;</span>, <span class=\"dv\">5</span>, literal.Value)</span>\n<span id=\"cb76-27\"><a href=\"#cb76-27\"></a>    }</span>\n<span id=\"cb76-28\"><a href=\"#cb76-28\"></a>    <span class=\"kw\">if</span> literal.TokenLiteral() != <span class=\"st\">&quot;5&quot;</span> {</span>\n<span id=\"cb76-29\"><a href=\"#cb76-29\"></a>        t.Errorf(<span class=\"st\">&quot;literal.TokenLiteral not %s. got=%s&quot;</span>, <span class=\"st\">&quot;5&quot;</span>,</span>\n<span id=\"cb76-30\"><a href=\"#cb76-30\"></a>            literal.TokenLiteral())</span>\n<span id=\"cb76-31\"><a href=\"#cb76-31\"></a>    }</span>\n<span id=\"cb76-32\"><a href=\"#cb76-32\"></a>}</span></code></pre></div>\n<p>And as in the test case for identifiers we use a simple input, feed it to the parser and then check that the parser didn’t encounter any errors and produced the correct number of statements in <code>*ast.Program.Statements</code>. Then we add an assertion that the first statement is an <code>*ast.ExpressionStatement</code>. And finally we expect a well-formed <code>*ast.IntegerLiteral</code>.</p>\n<p>The tests do not compile, since <code>*ast.IntegerLiteral</code> doesn’t exist yet. Defining it is easy though:</p>\n<div class=\"sourceCode\" id=\"cb77\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb77-1\"><a href=\"#cb77-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb77-2\"><a href=\"#cb77-2\"></a></span>\n<span id=\"cb77-3\"><a href=\"#cb77-3\"></a><span class=\"kw\">type</span> IntegerLiteral <span class=\"kw\">struct</span> {</span>\n<span id=\"cb77-4\"><a href=\"#cb77-4\"></a>    Token token.Token</span>\n<span id=\"cb77-5\"><a href=\"#cb77-5\"></a>    Value <span class=\"dt\">int64</span></span>\n<span id=\"cb77-6\"><a href=\"#cb77-6\"></a>}</span>\n<span id=\"cb77-7\"><a href=\"#cb77-7\"></a></span>\n<span id=\"cb77-8\"><a href=\"#cb77-8\"></a><span class=\"kw\">func</span> (il *IntegerLiteral) expressionNode()      {}</span>\n<span id=\"cb77-9\"><a href=\"#cb77-9\"></a><span class=\"kw\">func</span> (il *IntegerLiteral) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> il.Token.Literal }</span>\n<span id=\"cb77-10\"><a href=\"#cb77-10\"></a><span class=\"kw\">func</span> (il *IntegerLiteral) String() <span class=\"dt\">string</span>       { <span class=\"kw\">return</span> il.Token.Literal }</span></code></pre></div>\n<p><code>*ast.IntegerLiteral</code> fulfills the <code>ast.Expression</code> interface, just like <code>*ast.Identifier</code> does, but there’s a notable difference to <code>ast.Identifier</code> in the structure itself: <code>Value</code> is an <code>int64</code> and not a <code>string</code>. This is the field that’s going to contain the actual value the integer literal represents in the source code. When we build an <code>*ast.IntegerLiteral</code> we have to convert the string in <code>*ast.IntegerLiteral.Token.Literal</code> (which is something like <code>\"5\"</code>) to an <code>int64</code>.</p>\n<p>The best place to do this is in the parsing function associated with <code>token.INT</code>, called <code>parseIntegerLiteral</code>:</p>\n<div class=\"sourceCode\" id=\"cb78\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb78-1\"><a href=\"#cb78-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb78-2\"><a href=\"#cb78-2\"></a></span>\n<span id=\"cb78-3\"><a href=\"#cb78-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb78-4\"><a href=\"#cb78-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb78-5\"><a href=\"#cb78-5\"></a>    <span class=\"st\">&quot;strconv&quot;</span></span>\n<span id=\"cb78-6\"><a href=\"#cb78-6\"></a>)</span>\n<span id=\"cb78-7\"><a href=\"#cb78-7\"></a></span>\n<span id=\"cb78-8\"><a href=\"#cb78-8\"></a><span class=\"kw\">func</span> (p *Parser) parseIntegerLiteral() ast.Expression {</span>\n<span id=\"cb78-9\"><a href=\"#cb78-9\"></a>    lit := &amp;ast.IntegerLiteral{Token: p.curToken}</span>\n<span id=\"cb78-10\"><a href=\"#cb78-10\"></a></span>\n<span id=\"cb78-11\"><a href=\"#cb78-11\"></a>    value, err := strconv.ParseInt(p.curToken.Literal, <span class=\"dv\">0</span>, <span class=\"dv\">64</span>)</span>\n<span id=\"cb78-12\"><a href=\"#cb78-12\"></a>    <span class=\"kw\">if</span> err != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb78-13\"><a href=\"#cb78-13\"></a>        msg := fmt.Sprintf(<span class=\"st\">&quot;could not parse %q as integer&quot;</span>, p.curToken.Literal)</span>\n<span id=\"cb78-14\"><a href=\"#cb78-14\"></a>        p.errors = <span class=\"bu\">append</span>(p.errors, msg)</span>\n<span id=\"cb78-15\"><a href=\"#cb78-15\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb78-16\"><a href=\"#cb78-16\"></a>    }</span>\n<span id=\"cb78-17\"><a href=\"#cb78-17\"></a></span>\n<span id=\"cb78-18\"><a href=\"#cb78-18\"></a>    lit.Value = value</span>\n<span id=\"cb78-19\"><a href=\"#cb78-19\"></a></span>\n<span id=\"cb78-20\"><a href=\"#cb78-20\"></a>    <span class=\"kw\">return</span> lit</span>\n<span id=\"cb78-21\"><a href=\"#cb78-21\"></a>}</span></code></pre></div>\n<p>Like <code>parseIdentifier</code> the method is strikingly simple. The only thing that’s really different is a call to <code>strconv.ParseInt</code>, which converts the string in <code>p.curToken.Literal</code> into an <code>int64</code>. The <code>int64</code> then gets saved to the <code>Value</code> field and we return the newly constructed <code>*ast.IntegerLiteral</code> node. If that doesn’t work, we add a new error to the parser’s <code>errors</code> field.</p>\n<p>But the tests don’t pass yet:</p>\n<div class=\"sourceCode\" id=\"cb79\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb79-1\"><a href=\"#cb79-1\"></a>$ go test ./parser</span>\n<span id=\"cb79-2\"><a href=\"#cb79-2\"></a>--- FAIL: TestIntegerLiteralExpression (0.00s)</span>\n<span id=\"cb79-3\"><a href=\"#cb79-3\"></a>  parser_test.go:162: exp not *ast.IntegerLiteral. got=&lt;nil&gt;</span>\n<span id=\"cb79-4\"><a href=\"#cb79-4\"></a>FAIL</span>\n<span id=\"cb79-5\"><a href=\"#cb79-5\"></a>FAIL    monkey/parser   0.008s</span></code></pre></div>\n<p>We have a <code>nil</code> instead of an <code>*ast.IntegerLiteral</code> in our AST. The reason is that <code>parseExpression</code> can’t find a <code>prefixParseFn</code> for a token of type <code>token.INT</code>. All we have to do to make the tests pass is to register our <code>parseIntegerLiteral</code> method:</p>\n<div class=\"sourceCode\" id=\"cb80\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb80-1\"><a href=\"#cb80-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb80-2\"><a href=\"#cb80-2\"></a></span>\n<span id=\"cb80-3\"><a href=\"#cb80-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb80-4\"><a href=\"#cb80-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb80-5\"><a href=\"#cb80-5\"></a>    p.prefixParseFns = <span class=\"bu\">make</span>(<span class=\"kw\">map</span>[token.TokenType]prefixParseFn)</span>\n<span id=\"cb80-6\"><a href=\"#cb80-6\"></a>    p.registerPrefix(token.IDENT, p.parseIdentifier)</span>\n<span id=\"cb80-7\"><a href=\"#cb80-7\"></a>    p.registerPrefix(token.INT, p.parseIntegerLiteral)</span>\n<span id=\"cb80-8\"><a href=\"#cb80-8\"></a></span>\n<span id=\"cb80-9\"><a href=\"#cb80-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb80-10\"><a href=\"#cb80-10\"></a>}</span></code></pre></div>\n<p>With <code>parseIntegerLiteral</code> registered, <code>parseExpression</code> now knows what to do with a <code>token.INT</code> token, calls <code>parseIntegerLiteral</code> and returns its return value, an <code>*ast.IntegerLiteral</code>. The tests pass:</p>\n<div class=\"sourceCode\" id=\"cb81\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb81-1\"><a href=\"#cb81-1\"></a>$ go test ./parser</span>\n<span id=\"cb81-2\"><a href=\"#cb81-2\"></a>ok      monkey/parser   0.007s</span></code></pre></div>\n<p>I think it’s time to say: we are on a roll here! Identifiers and integer literals are in the bag, let’s step it up a notch and parse prefix operators.</p>\n</section>\n<section id=\"prefix-operators\" class=\"level3\" data-number=\"2.6.8\">\n<h3 data-number=\"2.6.8\">Prefix Operators</h3>\n<p>There are two prefix operators in the Monkey programming language: <code>!</code> and <code>-</code>. Their usage is pretty much what you’d expect from other languages:</p>\n<div class=\"sourceCode\" id=\"cb82\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb82-1\"><a href=\"#cb82-1\"></a><span class=\"dv\">-5</span><span class=\"op\">;</span></span>\n<span id=\"cb82-2\"><a href=\"#cb82-2\"></a><span class=\"op\">!</span>foobar<span class=\"op\">;</span></span>\n<span id=\"cb82-3\"><a href=\"#cb82-3\"></a><span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">-10</span><span class=\"op\">;</span></span></code></pre></div>\n<p>The structure of their usage is the following:</p>\n<div class=\"sourceCode\" id=\"cb83\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb83-1\"><a href=\"#cb83-1\"></a>&lt;prefix operator&gt;&lt;expression&gt;;</span></code></pre></div>\n<p>Yes, that’s right. Any expression can follow a prefix operator as operand. These are valid:</p>\n<div class=\"sourceCode\" id=\"cb84\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb84-1\"><a href=\"#cb84-1\"></a><span class=\"op\">!</span>isGreaterThanZero(<span class=\"dv\">2</span>)<span class=\"op\">;</span></span>\n<span id=\"cb84-2\"><a href=\"#cb84-2\"></a><span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"op\">-</span>add(<span class=\"dv\">5</span><span class=\"op\">,</span> <span class=\"dv\">5</span>)<span class=\"op\">;</span></span></code></pre></div>\n<p>That means that an AST node for a prefix operator expression has to be flexible enough to point to any expression as its operand.</p>\n<p>But first things first, here is the test case for prefix operators, or “prefix expressions”:</p>\n<div class=\"sourceCode\" id=\"cb85\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb85-1\"><a href=\"#cb85-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb85-2\"><a href=\"#cb85-2\"></a></span>\n<span id=\"cb85-3\"><a href=\"#cb85-3\"></a><span class=\"kw\">func</span> TestParsingPrefixExpressions(t *testing.T) {</span>\n<span id=\"cb85-4\"><a href=\"#cb85-4\"></a>    prefixTests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb85-5\"><a href=\"#cb85-5\"></a>        input        <span class=\"dt\">string</span></span>\n<span id=\"cb85-6\"><a href=\"#cb85-6\"></a>        operator     <span class=\"dt\">string</span></span>\n<span id=\"cb85-7\"><a href=\"#cb85-7\"></a>        integerValue <span class=\"dt\">int64</span></span>\n<span id=\"cb85-8\"><a href=\"#cb85-8\"></a>    }{</span>\n<span id=\"cb85-9\"><a href=\"#cb85-9\"></a>        {<span class=\"st\">&quot;!5;&quot;</span>, <span class=\"st\">&quot;!&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb85-10\"><a href=\"#cb85-10\"></a>        {<span class=\"st\">&quot;-15;&quot;</span>, <span class=\"st\">&quot;-&quot;</span>, <span class=\"dv\">15</span>},</span>\n<span id=\"cb85-11\"><a href=\"#cb85-11\"></a>    }</span>\n<span id=\"cb85-12\"><a href=\"#cb85-12\"></a></span>\n<span id=\"cb85-13\"><a href=\"#cb85-13\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> prefixTests {</span>\n<span id=\"cb85-14\"><a href=\"#cb85-14\"></a>        l := lexer.New(tt.input)</span>\n<span id=\"cb85-15\"><a href=\"#cb85-15\"></a>        p := New(l)</span>\n<span id=\"cb85-16\"><a href=\"#cb85-16\"></a>        program := p.ParseProgram()</span>\n<span id=\"cb85-17\"><a href=\"#cb85-17\"></a>        checkParserErrors(t, p)</span>\n<span id=\"cb85-18\"><a href=\"#cb85-18\"></a></span>\n<span id=\"cb85-19\"><a href=\"#cb85-19\"></a>        <span class=\"kw\">if</span> <span class=\"bu\">len</span>(program.Statements) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb85-20\"><a href=\"#cb85-20\"></a>            t.Fatalf(<span class=\"st\">&quot;program.Statements does not contain %d statements. got=%d</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb85-21\"><a href=\"#cb85-21\"></a>                <span class=\"dv\">1</span>, <span class=\"bu\">len</span>(program.Statements))</span>\n<span id=\"cb85-22\"><a href=\"#cb85-22\"></a>        }</span>\n<span id=\"cb85-23\"><a href=\"#cb85-23\"></a></span>\n<span id=\"cb85-24\"><a href=\"#cb85-24\"></a>        stmt, ok := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb85-25\"><a href=\"#cb85-25\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb85-26\"><a href=\"#cb85-26\"></a>            t.Fatalf(<span class=\"st\">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</span>\n<span id=\"cb85-27\"><a href=\"#cb85-27\"></a>                program.Statements[<span class=\"dv\">0</span>])</span>\n<span id=\"cb85-28\"><a href=\"#cb85-28\"></a>        }</span>\n<span id=\"cb85-29\"><a href=\"#cb85-29\"></a></span>\n<span id=\"cb85-30\"><a href=\"#cb85-30\"></a>        exp, ok := stmt.Expression.(*ast.PrefixExpression)</span>\n<span id=\"cb85-31\"><a href=\"#cb85-31\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb85-32\"><a href=\"#cb85-32\"></a>            t.Fatalf(<span class=\"st\">&quot;stmt is not ast.PrefixExpression. got=%T&quot;</span>, stmt.Expression)</span>\n<span id=\"cb85-33\"><a href=\"#cb85-33\"></a>        }</span>\n<span id=\"cb85-34\"><a href=\"#cb85-34\"></a>        <span class=\"kw\">if</span> exp.Operator != tt.operator {</span>\n<span id=\"cb85-35\"><a href=\"#cb85-35\"></a>            t.Fatalf(<span class=\"st\">&quot;exp.Operator is not &#39;%s&#39;. got=%s&quot;</span>,</span>\n<span id=\"cb85-36\"><a href=\"#cb85-36\"></a>                tt.operator, exp.Operator)</span>\n<span id=\"cb85-37\"><a href=\"#cb85-37\"></a>        }</span>\n<span id=\"cb85-38\"><a href=\"#cb85-38\"></a>        <span class=\"kw\">if</span> !testIntegerLiteral(t, exp.Right, tt.integerValue) {</span>\n<span id=\"cb85-39\"><a href=\"#cb85-39\"></a>            <span class=\"kw\">return</span></span>\n<span id=\"cb85-40\"><a href=\"#cb85-40\"></a>        }</span>\n<span id=\"cb85-41\"><a href=\"#cb85-41\"></a>    }</span>\n<span id=\"cb85-42\"><a href=\"#cb85-42\"></a>}</span></code></pre></div>\n<p>This test function, again, has a lot of lines. For two reasons: manually creating error messages with <code>t.Errorf</code> takes up some space and we’re using a table-driven testing approach. The reason for this approach is that it saves us a lot of test code. Yes, it’s only two test cases, but duplicating the complete test setup for each case would mean a lot more lines. And since the logic behind the test assertions is the same, we share the test setup. Both test cases (<code>!5</code> and <code>-15</code> as input) differ only in the expected operators and integer values (which we define here in <code>prefixTests</code>).</p>\n<p>In the test function we iterate through our slice of test inputs and make assertions about the produced AST based on the values defined in the <code>prefixTests</code> slice of structs. As you can see, at the end we use a new helper function called <code>testIntegerLiteral</code> to test that the <code>Right</code> value of <code>*ast.PrefixExpression</code> is the correct integer literal. We introduce this helper function here, so the focus of the test case is on <code>*ast.PrefixExpression</code> and its fields and we will soon enough need it again. It looks like this:</p>\n<div class=\"sourceCode\" id=\"cb86\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb86-1\"><a href=\"#cb86-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb86-2\"><a href=\"#cb86-2\"></a></span>\n<span id=\"cb86-3\"><a href=\"#cb86-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb86-4\"><a href=\"#cb86-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb86-5\"><a href=\"#cb86-5\"></a>    <span class=\"st\">&quot;fmt&quot;</span></span>\n<span id=\"cb86-6\"><a href=\"#cb86-6\"></a>)</span>\n<span id=\"cb86-7\"><a href=\"#cb86-7\"></a></span>\n<span id=\"cb86-8\"><a href=\"#cb86-8\"></a><span class=\"kw\">func</span> testIntegerLiteral(t *testing.T, il ast.Expression, value <span class=\"dt\">int64</span>) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb86-9\"><a href=\"#cb86-9\"></a>    integ, ok := il.(*ast.IntegerLiteral)</span>\n<span id=\"cb86-10\"><a href=\"#cb86-10\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb86-11\"><a href=\"#cb86-11\"></a>        t.Errorf(<span class=\"st\">&quot;il not *ast.IntegerLiteral. got=%T&quot;</span>, il)</span>\n<span id=\"cb86-12\"><a href=\"#cb86-12\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb86-13\"><a href=\"#cb86-13\"></a>    }</span>\n<span id=\"cb86-14\"><a href=\"#cb86-14\"></a></span>\n<span id=\"cb86-15\"><a href=\"#cb86-15\"></a>    <span class=\"kw\">if</span> integ.Value != value {</span>\n<span id=\"cb86-16\"><a href=\"#cb86-16\"></a>        t.Errorf(<span class=\"st\">&quot;integ.Value not %d. got=%d&quot;</span>, value, integ.Value)</span>\n<span id=\"cb86-17\"><a href=\"#cb86-17\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb86-18\"><a href=\"#cb86-18\"></a>    }</span>\n<span id=\"cb86-19\"><a href=\"#cb86-19\"></a></span>\n<span id=\"cb86-20\"><a href=\"#cb86-20\"></a>    <span class=\"kw\">if</span> integ.TokenLiteral() != fmt.Sprintf(<span class=\"st\">&quot;%d&quot;</span>, value) {</span>\n<span id=\"cb86-21\"><a href=\"#cb86-21\"></a>        t.Errorf(<span class=\"st\">&quot;integ.TokenLiteral not %d. got=%s&quot;</span>, value,</span>\n<span id=\"cb86-22\"><a href=\"#cb86-22\"></a>            integ.TokenLiteral())</span>\n<span id=\"cb86-23\"><a href=\"#cb86-23\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb86-24\"><a href=\"#cb86-24\"></a>    }</span>\n<span id=\"cb86-25\"><a href=\"#cb86-25\"></a></span>\n<span id=\"cb86-26\"><a href=\"#cb86-26\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb86-27\"><a href=\"#cb86-27\"></a>}</span></code></pre></div>\n<p>There is nothing new here, we’ve seen this before in <code>TestIntegerLiteralExpression</code>. But now it’s hidden behind a small helper function that makes these new tests more readable.</p>\n<p>As expected the tests don’t even compile:</p>\n<div class=\"sourceCode\" id=\"cb87\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb87-1\"><a href=\"#cb87-1\"></a>$ go test ./parser</span>\n<span id=\"cb87-2\"><a href=\"#cb87-2\"></a># monkey/parser</span>\n<span id=\"cb87-3\"><a href=\"#cb87-3\"></a>parser/parser_test.go:210: undefined: ast.PrefixExpression</span>\n<span id=\"cb87-4\"><a href=\"#cb87-4\"></a>FAIL    monkey/parser [build failed]</span></code></pre></div>\n<p>We need to define the <code>ast.PrefixExpression</code> node:</p>\n<div class=\"sourceCode\" id=\"cb88\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb88-1\"><a href=\"#cb88-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb88-2\"><a href=\"#cb88-2\"></a></span>\n<span id=\"cb88-3\"><a href=\"#cb88-3\"></a><span class=\"kw\">type</span> PrefixExpression <span class=\"kw\">struct</span> {</span>\n<span id=\"cb88-4\"><a href=\"#cb88-4\"></a>    Token    token.Token <span class=\"co\">// The prefix token, e.g. !</span></span>\n<span id=\"cb88-5\"><a href=\"#cb88-5\"></a>    Operator <span class=\"dt\">string</span></span>\n<span id=\"cb88-6\"><a href=\"#cb88-6\"></a>    Right    Expression</span>\n<span id=\"cb88-7\"><a href=\"#cb88-7\"></a>}</span>\n<span id=\"cb88-8\"><a href=\"#cb88-8\"></a></span>\n<span id=\"cb88-9\"><a href=\"#cb88-9\"></a><span class=\"kw\">func</span> (pe *PrefixExpression) expressionNode()      {}</span>\n<span id=\"cb88-10\"><a href=\"#cb88-10\"></a><span class=\"kw\">func</span> (pe *PrefixExpression) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> pe.Token.Literal }</span>\n<span id=\"cb88-11\"><a href=\"#cb88-11\"></a><span class=\"kw\">func</span> (pe *PrefixExpression) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb88-12\"><a href=\"#cb88-12\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb88-13\"><a href=\"#cb88-13\"></a></span>\n<span id=\"cb88-14\"><a href=\"#cb88-14\"></a>    out.WriteString(<span class=\"st\">&quot;(&quot;</span>)</span>\n<span id=\"cb88-15\"><a href=\"#cb88-15\"></a>    out.WriteString(pe.Operator)</span>\n<span id=\"cb88-16\"><a href=\"#cb88-16\"></a>    out.WriteString(pe.Right.String())</span>\n<span id=\"cb88-17\"><a href=\"#cb88-17\"></a>    out.WriteString(<span class=\"st\">&quot;)&quot;</span>)</span>\n<span id=\"cb88-18\"><a href=\"#cb88-18\"></a></span>\n<span id=\"cb88-19\"><a href=\"#cb88-19\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb88-20\"><a href=\"#cb88-20\"></a>}</span></code></pre></div>\n<p>This doesn’t contain any surprises. The <code>*ast.PrefixExpression</code> node has two noteworthy fields: <code>Operator</code> and <code>Right</code>. <code>Operator</code> is a string that’s going to contain either <code>\"-\"</code> or <code>\"!\"</code>. The <code>Right</code> field contains the expression to the right of the operator.</p>\n<p>In the <code>String()</code> method we deliberately add parentheses around the operator and its operand, the expression in <code>Right</code>. That allows us to see which operands belong to which operator.</p>\n<p>With <code>*ast.PrefixExpression</code> defined, the tests now fail with a strange error message:</p>\n<div class=\"sourceCode\" id=\"cb89\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb89-1\"><a href=\"#cb89-1\"></a>$ go test ./parser</span>\n<span id=\"cb89-2\"><a href=\"#cb89-2\"></a>--- FAIL: TestParsingPrefixExpressions (0.00s)</span>\n<span id=\"cb89-3\"><a href=\"#cb89-3\"></a>  parser_test.go:198: program.Statements does not contain 1 statements. got=2</span>\n<span id=\"cb89-4\"><a href=\"#cb89-4\"></a>FAIL</span>\n<span id=\"cb89-5\"><a href=\"#cb89-5\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>Why does <code>program.Statements</code> contain two statements instead of the expected one statement? The reason is that <code>parseExpression</code> doesn’t recognize our prefix operators yet and simply returns <code>nil</code>. <code>program.Statements</code> does not contain one statement but simply two <code>nil</code>s.</p>\n<p>We can do better than this, we can extend our parser and the <code>parseExpression</code> method to give us better error messages when this happens:</p>\n<div class=\"sourceCode\" id=\"cb90\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb90-1\"><a href=\"#cb90-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb90-2\"><a href=\"#cb90-2\"></a></span>\n<span id=\"cb90-3\"><a href=\"#cb90-3\"></a><span class=\"kw\">func</span> (p *Parser) noPrefixParseFnError(t token.TokenType) {</span>\n<span id=\"cb90-4\"><a href=\"#cb90-4\"></a>    msg := fmt.Sprintf(<span class=\"st\">&quot;no prefix parse function for %s found&quot;</span>, t)</span>\n<span id=\"cb90-5\"><a href=\"#cb90-5\"></a>    p.errors = <span class=\"bu\">append</span>(p.errors, msg)</span>\n<span id=\"cb90-6\"><a href=\"#cb90-6\"></a>}</span>\n<span id=\"cb90-7\"><a href=\"#cb90-7\"></a></span>\n<span id=\"cb90-8\"><a href=\"#cb90-8\"></a><span class=\"kw\">func</span> (p *Parser) parseExpression(precedence <span class=\"dt\">int</span>) ast.Expression {</span>\n<span id=\"cb90-9\"><a href=\"#cb90-9\"></a>    prefix := p.prefixParseFns[p.curToken.Type]</span>\n<span id=\"cb90-10\"><a href=\"#cb90-10\"></a>    <span class=\"kw\">if</span> prefix == <span class=\"ot\">nil</span> {</span>\n<span id=\"cb90-11\"><a href=\"#cb90-11\"></a>        p.noPrefixParseFnError(p.curToken.Type)</span>\n<span id=\"cb90-12\"><a href=\"#cb90-12\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb90-13\"><a href=\"#cb90-13\"></a>    }</span>\n<span id=\"cb90-14\"><a href=\"#cb90-14\"></a>    leftExp := prefix()</span>\n<span id=\"cb90-15\"><a href=\"#cb90-15\"></a></span>\n<span id=\"cb90-16\"><a href=\"#cb90-16\"></a>    <span class=\"kw\">return</span> leftExp</span>\n<span id=\"cb90-17\"><a href=\"#cb90-17\"></a>}</span></code></pre></div>\n<p>The small helper method <code>noPrefixParseFnError</code> just adds a formatted error message to our parser’s <code>errors</code> field. But that’s enough to get better error messages in our failing test:</p>\n<div class=\"sourceCode\" id=\"cb91\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb91-1\"><a href=\"#cb91-1\"></a>$ go test ./parser</span>\n<span id=\"cb91-2\"><a href=\"#cb91-2\"></a>--- FAIL: TestParsingPrefixExpressions (0.00s)</span>\n<span id=\"cb91-3\"><a href=\"#cb91-3\"></a>  parser_test.go:227: parser has 1 errors</span>\n<span id=\"cb91-4\"><a href=\"#cb91-4\"></a>  parser_test.go:229: parser error: &quot;no prefix parse function for ! found&quot;</span>\n<span id=\"cb91-5\"><a href=\"#cb91-5\"></a>FAIL</span>\n<span id=\"cb91-6\"><a href=\"#cb91-6\"></a>FAIL    monkey/parser   0.010s</span></code></pre></div>\n<p>Now it’s clear what we have to do: write a parsing function for prefix expressions and register it in our parser.</p>\n<div class=\"sourceCode\" id=\"cb92\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb92-1\"><a href=\"#cb92-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb92-2\"><a href=\"#cb92-2\"></a></span>\n<span id=\"cb92-3\"><a href=\"#cb92-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb92-4\"><a href=\"#cb92-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb92-5\"><a href=\"#cb92-5\"></a>    p.registerPrefix(token.BANG, p.parsePrefixExpression)</span>\n<span id=\"cb92-6\"><a href=\"#cb92-6\"></a>    p.registerPrefix(token.MINUS, p.parsePrefixExpression)</span>\n<span id=\"cb92-7\"><a href=\"#cb92-7\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb92-8\"><a href=\"#cb92-8\"></a>}</span>\n<span id=\"cb92-9\"><a href=\"#cb92-9\"></a></span>\n<span id=\"cb92-10\"><a href=\"#cb92-10\"></a><span class=\"kw\">func</span> (p *Parser) parsePrefixExpression() ast.Expression {</span>\n<span id=\"cb92-11\"><a href=\"#cb92-11\"></a>    expression := &amp;ast.PrefixExpression{</span>\n<span id=\"cb92-12\"><a href=\"#cb92-12\"></a>        Token:    p.curToken,</span>\n<span id=\"cb92-13\"><a href=\"#cb92-13\"></a>        Operator: p.curToken.Literal,</span>\n<span id=\"cb92-14\"><a href=\"#cb92-14\"></a>    }</span>\n<span id=\"cb92-15\"><a href=\"#cb92-15\"></a></span>\n<span id=\"cb92-16\"><a href=\"#cb92-16\"></a>    p.nextToken()</span>\n<span id=\"cb92-17\"><a href=\"#cb92-17\"></a></span>\n<span id=\"cb92-18\"><a href=\"#cb92-18\"></a>    expression.Right = p.parseExpression(PREFIX)</span>\n<span id=\"cb92-19\"><a href=\"#cb92-19\"></a></span>\n<span id=\"cb92-20\"><a href=\"#cb92-20\"></a>    <span class=\"kw\">return</span> expression</span>\n<span id=\"cb92-21\"><a href=\"#cb92-21\"></a>}</span></code></pre></div>\n<p>For <code>token.BANG</code> and <code>token.MINUS</code> we register the same method as <code>prefixParseFn</code>: the newly created <code>parsePrefixExpression</code>. This method builds an AST node, in this case <code>*ast.PrefixExpression</code>, just like the parsing functions we saw before. But then it does something different: it actually advances our tokens by calling <code>p.nextToken()</code>!</p>\n<p>When <code>parsePrefixExpression</code> is called, <code>p.curToken</code> is either of type <code>token.BANG</code> or <code>token.MINUS</code>, because otherwise it wouldn’t have been called. But in order to correctly parse a prefix expression like <code>-5</code> more than one token has to be “consumed”. So after using <code>p.curToken</code> to build a <code>*ast.PrefixExpression</code> node, the method advances the tokens and calls <code>parseExpression</code> again. This time with the precedence of prefix operators as argument. It’s still unused, but we’ll shortly see what it’s good for and how to make use of it.</p>\n<p>Now, when <code>parseExpression</code> is called by <code>parsePrefixExpression</code> the tokens have been advanced and the current token is the one after the prefix operator. In the case of <code>-5</code>, when <code>parseExpression</code> is called the <code>p.curToken.Type</code> is <code>token.INT</code>. <code>parseExpression</code> then checks the registered prefix parsing functions and finds <code>parseIntegerLiteral</code>, which builds an <code>*ast.IntegerLiteral</code> node and returns it. <code>parseExpression</code> returns this newly constructed node and <code>parsePrefixExpression</code> uses it to fill the <code>Right</code> field of <code>*ast.PrefixExpression</code>.</p>\n<p>Yes, this works, our tests pass:</p>\n<div class=\"sourceCode\" id=\"cb93\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb93-1\"><a href=\"#cb93-1\"></a>$ <span class=\"kw\">go</span> test ./parser</span>\n<span id=\"cb93-2\"><a href=\"#cb93-2\"></a>ok      monkey/parser   <span class=\"dv\">0</span><span class=\"fl\">.007</span>s</span></code></pre></div>\n<p>Note how the “protocol” for our parsing functions plays out here:</p>\n<p><code>parsePrefixExpression</code> starts with <code>p.curToken</code> being the token of the prefix operator and it returns with <code>p.curToken</code> being the operand of the prefix expression, which is the last token of the expression. The tokens get advanced just enough, which works beautifully. The neat thing is how few lines of code are needed for this. The power lies in the recursive approach.</p>\n<p>Granted, the <code>precedence</code> argument in <code>parseExpression</code> is confusing, since it’s unused. But we’ve already seen something important about its usage: the value changes depending on the caller’s knowledge and its context. <code>parseExpressionStatement</code> (the top-level method that kicks off expression parsing here) knows nothing about a precedence level and just uses <code>LOWEST</code>. But <code>parsePrefixExpression</code> passes the <code>PREFIX</code> precedence to <code>parseExpression</code>, since it’s parsing a prefix expression.</p>\n<p>And now we’ll see how <code>precedence</code> in <code>parseExpression</code> is used. Because now we’re going to parse infix expressions.</p>\n</section>\n<section id=\"infix-operators\" class=\"level3\" data-number=\"2.6.9\">\n<h3 data-number=\"2.6.9\">Infix Operators</h3>\n<p>Next up we’re going to parse these eight infix operators:</p>\n<div class=\"sourceCode\" id=\"cb94\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb94-1\"><a href=\"#cb94-1\"></a><span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb94-2\"><a href=\"#cb94-2\"></a><span class=\"dv\">5</span> <span class=\"op\">-</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb94-3\"><a href=\"#cb94-3\"></a><span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb94-4\"><a href=\"#cb94-4\"></a><span class=\"dv\">5</span> <span class=\"op\">/</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb94-5\"><a href=\"#cb94-5\"></a><span class=\"dv\">5</span> <span class=\"op\">&gt;</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb94-6\"><a href=\"#cb94-6\"></a><span class=\"dv\">5</span> <span class=\"op\">&lt;</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb94-7\"><a href=\"#cb94-7\"></a><span class=\"dv\">5</span> <span class=\"op\">==</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb94-8\"><a href=\"#cb94-8\"></a><span class=\"dv\">5</span> <span class=\"op\">!=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span></code></pre></div>\n<p>Don’t be bothered by the <code>5</code> here. As with prefix operator expressions, we can use any expressions to the left and right of the operator.</p>\n<div class=\"sourceCode\" id=\"cb95\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb95-1\"><a href=\"#cb95-1\"></a>&lt;expression&gt; &lt;infix operator&gt; &lt;expression&gt;</span></code></pre></div>\n<p>Because of the two operands (left and right) these expressions are sometimes called “binary expressions” (whereas our prefix expressions would be called “unary expressions”). Even though we can use any expressions on either side of the operator, we’re going to start by writing a test that only uses integer literals as operands. As soon as we can get the test to pass, we’ll extend it to incorporate more operand types. Here it is:</p>\n<div class=\"sourceCode\" id=\"cb96\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb96-1\"><a href=\"#cb96-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb96-2\"><a href=\"#cb96-2\"></a></span>\n<span id=\"cb96-3\"><a href=\"#cb96-3\"></a><span class=\"kw\">func</span> TestParsingInfixExpressions(t *testing.T) {</span>\n<span id=\"cb96-4\"><a href=\"#cb96-4\"></a>    infixTests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb96-5\"><a href=\"#cb96-5\"></a>        input      <span class=\"dt\">string</span></span>\n<span id=\"cb96-6\"><a href=\"#cb96-6\"></a>        leftValue  <span class=\"dt\">int64</span></span>\n<span id=\"cb96-7\"><a href=\"#cb96-7\"></a>        operator   <span class=\"dt\">string</span></span>\n<span id=\"cb96-8\"><a href=\"#cb96-8\"></a>        rightValue <span class=\"dt\">int64</span></span>\n<span id=\"cb96-9\"><a href=\"#cb96-9\"></a>    }{</span>\n<span id=\"cb96-10\"><a href=\"#cb96-10\"></a>        {<span class=\"st\">&quot;5 + 5;&quot;</span>, <span class=\"dv\">5</span>, <span class=\"st\">&quot;+&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb96-11\"><a href=\"#cb96-11\"></a>        {<span class=\"st\">&quot;5 - 5;&quot;</span>, <span class=\"dv\">5</span>, <span class=\"st\">&quot;-&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb96-12\"><a href=\"#cb96-12\"></a>        {<span class=\"st\">&quot;5 * 5;&quot;</span>, <span class=\"dv\">5</span>, <span class=\"st\">&quot;*&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb96-13\"><a href=\"#cb96-13\"></a>        {<span class=\"st\">&quot;5 / 5;&quot;</span>, <span class=\"dv\">5</span>, <span class=\"st\">&quot;/&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb96-14\"><a href=\"#cb96-14\"></a>        {<span class=\"st\">&quot;5 &gt; 5;&quot;</span>, <span class=\"dv\">5</span>, <span class=\"st\">&quot;&gt;&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb96-15\"><a href=\"#cb96-15\"></a>        {<span class=\"st\">&quot;5 &lt; 5;&quot;</span>, <span class=\"dv\">5</span>, <span class=\"st\">&quot;&lt;&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb96-16\"><a href=\"#cb96-16\"></a>        {<span class=\"st\">&quot;5 == 5;&quot;</span>, <span class=\"dv\">5</span>, <span class=\"st\">&quot;==&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb96-17\"><a href=\"#cb96-17\"></a>        {<span class=\"st\">&quot;5 != 5;&quot;</span>, <span class=\"dv\">5</span>, <span class=\"st\">&quot;!=&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb96-18\"><a href=\"#cb96-18\"></a>    }</span>\n<span id=\"cb96-19\"><a href=\"#cb96-19\"></a></span>\n<span id=\"cb96-20\"><a href=\"#cb96-20\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> infixTests {</span>\n<span id=\"cb96-21\"><a href=\"#cb96-21\"></a>        l := lexer.New(tt.input)</span>\n<span id=\"cb96-22\"><a href=\"#cb96-22\"></a>        p := New(l)</span>\n<span id=\"cb96-23\"><a href=\"#cb96-23\"></a>        program := p.ParseProgram()</span>\n<span id=\"cb96-24\"><a href=\"#cb96-24\"></a>        checkParserErrors(t, p)</span>\n<span id=\"cb96-25\"><a href=\"#cb96-25\"></a></span>\n<span id=\"cb96-26\"><a href=\"#cb96-26\"></a>        <span class=\"kw\">if</span> <span class=\"bu\">len</span>(program.Statements) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb96-27\"><a href=\"#cb96-27\"></a>            t.Fatalf(<span class=\"st\">&quot;program.Statements does not contain %d statements. got=%d</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb96-28\"><a href=\"#cb96-28\"></a>                <span class=\"dv\">1</span>, <span class=\"bu\">len</span>(program.Statements))</span>\n<span id=\"cb96-29\"><a href=\"#cb96-29\"></a>        }</span>\n<span id=\"cb96-30\"><a href=\"#cb96-30\"></a></span>\n<span id=\"cb96-31\"><a href=\"#cb96-31\"></a>        stmt, ok := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb96-32\"><a href=\"#cb96-32\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb96-33\"><a href=\"#cb96-33\"></a>            t.Fatalf(<span class=\"st\">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</span>\n<span id=\"cb96-34\"><a href=\"#cb96-34\"></a>                program.Statements[<span class=\"dv\">0</span>])</span>\n<span id=\"cb96-35\"><a href=\"#cb96-35\"></a>        }</span>\n<span id=\"cb96-36\"><a href=\"#cb96-36\"></a></span>\n<span id=\"cb96-37\"><a href=\"#cb96-37\"></a>        exp, ok := stmt.Expression.(*ast.InfixExpression)</span>\n<span id=\"cb96-38\"><a href=\"#cb96-38\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb96-39\"><a href=\"#cb96-39\"></a>            t.Fatalf(<span class=\"st\">&quot;exp is not ast.InfixExpression. got=%T&quot;</span>, stmt.Expression)</span>\n<span id=\"cb96-40\"><a href=\"#cb96-40\"></a>        }</span>\n<span id=\"cb96-41\"><a href=\"#cb96-41\"></a></span>\n<span id=\"cb96-42\"><a href=\"#cb96-42\"></a>        <span class=\"kw\">if</span> !testIntegerLiteral(t, exp.Left, tt.leftValue) {</span>\n<span id=\"cb96-43\"><a href=\"#cb96-43\"></a>            <span class=\"kw\">return</span></span>\n<span id=\"cb96-44\"><a href=\"#cb96-44\"></a>        }</span>\n<span id=\"cb96-45\"><a href=\"#cb96-45\"></a></span>\n<span id=\"cb96-46\"><a href=\"#cb96-46\"></a>        <span class=\"kw\">if</span> exp.Operator != tt.operator {</span>\n<span id=\"cb96-47\"><a href=\"#cb96-47\"></a>            t.Fatalf(<span class=\"st\">&quot;exp.Operator is not &#39;%s&#39;. got=%s&quot;</span>,</span>\n<span id=\"cb96-48\"><a href=\"#cb96-48\"></a>                tt.operator, exp.Operator)</span>\n<span id=\"cb96-49\"><a href=\"#cb96-49\"></a>        }</span>\n<span id=\"cb96-50\"><a href=\"#cb96-50\"></a></span>\n<span id=\"cb96-51\"><a href=\"#cb96-51\"></a>        <span class=\"kw\">if</span> !testIntegerLiteral(t, exp.Right, tt.rightValue) {</span>\n<span id=\"cb96-52\"><a href=\"#cb96-52\"></a>            <span class=\"kw\">return</span></span>\n<span id=\"cb96-53\"><a href=\"#cb96-53\"></a>        }</span>\n<span id=\"cb96-54\"><a href=\"#cb96-54\"></a>    }</span>\n<span id=\"cb96-55\"><a href=\"#cb96-55\"></a>}</span></code></pre></div>\n<p>This test is nearly a straight copy of <code>TestParsingPrefixExpressions</code>, except that we now make assertions about the <code>Right</code> <em>and</em> <code>Left</code> fields of the resulting AST node. Here the table-driven approach gives us great leverage that we’ll soon use when we extend the test to also include identifiers.</p>\n<p>The tests fail, of course, because they can’t find a definition of <code>*ast.InfixExpression</code>. And in order to get real failing tests, we define <code>ast.InfixExpression</code>:</p>\n<div class=\"sourceCode\" id=\"cb97\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb97-1\"><a href=\"#cb97-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb97-2\"><a href=\"#cb97-2\"></a></span>\n<span id=\"cb97-3\"><a href=\"#cb97-3\"></a><span class=\"kw\">type</span> InfixExpression <span class=\"kw\">struct</span> {</span>\n<span id=\"cb97-4\"><a href=\"#cb97-4\"></a>    Token    token.Token <span class=\"co\">// The operator token, e.g. +</span></span>\n<span id=\"cb97-5\"><a href=\"#cb97-5\"></a>    Left     Expression</span>\n<span id=\"cb97-6\"><a href=\"#cb97-6\"></a>    Operator <span class=\"dt\">string</span></span>\n<span id=\"cb97-7\"><a href=\"#cb97-7\"></a>    Right    Expression</span>\n<span id=\"cb97-8\"><a href=\"#cb97-8\"></a>}</span>\n<span id=\"cb97-9\"><a href=\"#cb97-9\"></a></span>\n<span id=\"cb97-10\"><a href=\"#cb97-10\"></a><span class=\"kw\">func</span> (ie *InfixExpression) expressionNode()      {}</span>\n<span id=\"cb97-11\"><a href=\"#cb97-11\"></a><span class=\"kw\">func</span> (ie *InfixExpression) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> ie.Token.Literal }</span>\n<span id=\"cb97-12\"><a href=\"#cb97-12\"></a><span class=\"kw\">func</span> (ie *InfixExpression) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb97-13\"><a href=\"#cb97-13\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb97-14\"><a href=\"#cb97-14\"></a></span>\n<span id=\"cb97-15\"><a href=\"#cb97-15\"></a>    out.WriteString(<span class=\"st\">&quot;(&quot;</span>)</span>\n<span id=\"cb97-16\"><a href=\"#cb97-16\"></a>    out.WriteString(ie.Left.String())</span>\n<span id=\"cb97-17\"><a href=\"#cb97-17\"></a>    out.WriteString(<span class=\"st\">&quot; &quot;</span> + ie.Operator + <span class=\"st\">&quot; &quot;</span>)</span>\n<span id=\"cb97-18\"><a href=\"#cb97-18\"></a>    out.WriteString(ie.Right.String())</span>\n<span id=\"cb97-19\"><a href=\"#cb97-19\"></a>    out.WriteString(<span class=\"st\">&quot;)&quot;</span>)</span>\n<span id=\"cb97-20\"><a href=\"#cb97-20\"></a></span>\n<span id=\"cb97-21\"><a href=\"#cb97-21\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb97-22\"><a href=\"#cb97-22\"></a>}</span></code></pre></div>\n<p>Just like with <code>ast.PrefixExpression</code>, we define <code>ast.InfixExpression</code> to fulfill the <code>ast.Expression</code> and <code>ast.Node</code> interfaces, by defining the <code>expressionNode()</code>, <code>TokenLiteral()</code> and <code>String()</code> methods. The only difference to <code>ast.PrefixExpression</code> is the new field called <code>Left</code>, which can hold any expression.</p>\n<p>With that out of the way, we can build and run our tests. And the tests even return one of our own new error messages:</p>\n<div class=\"sourceCode\" id=\"cb98\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb98-1\"><a href=\"#cb98-1\"></a>$ go test ./parser</span>\n<span id=\"cb98-2\"><a href=\"#cb98-2\"></a>--- FAIL: TestParsingInfixExpressions (0.00s)</span>\n<span id=\"cb98-3\"><a href=\"#cb98-3\"></a>  parser_test.go:246: parser has 1 errors</span>\n<span id=\"cb98-4\"><a href=\"#cb98-4\"></a>  parser_test.go:248: parser error: &quot;no prefix parse function for + found&quot;</span>\n<span id=\"cb98-5\"><a href=\"#cb98-5\"></a>FAIL</span>\n<span id=\"cb98-6\"><a href=\"#cb98-6\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>But that error message is deceiving. It says “no prefix parse function for + found”. The problem is that we do not want our parser to find a prefix parse function for <code>+</code>. We want it to find an infix parse function.</p>\n<p>This is the point where we’re going from “I guess it’s neat” to “Wow, this is beautiful”, because we now need to complete our <code>parseExpression</code> method. And to do that, we first need a precedence table and a few helper methods:</p>\n<div class=\"sourceCode\" id=\"cb99\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb99-1\"><a href=\"#cb99-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb99-2\"><a href=\"#cb99-2\"></a></span>\n<span id=\"cb99-3\"><a href=\"#cb99-3\"></a><span class=\"kw\">var</span> precedences = <span class=\"kw\">map</span>[token.TokenType]<span class=\"dt\">int</span>{</span>\n<span id=\"cb99-4\"><a href=\"#cb99-4\"></a>    token.EQ:       EQUALS,</span>\n<span id=\"cb99-5\"><a href=\"#cb99-5\"></a>    token.NOT_EQ:   EQUALS,</span>\n<span id=\"cb99-6\"><a href=\"#cb99-6\"></a>    token.LT:       LESSGREATER,</span>\n<span id=\"cb99-7\"><a href=\"#cb99-7\"></a>    token.GT:       LESSGREATER,</span>\n<span id=\"cb99-8\"><a href=\"#cb99-8\"></a>    token.PLUS:     SUM,</span>\n<span id=\"cb99-9\"><a href=\"#cb99-9\"></a>    token.MINUS:    SUM,</span>\n<span id=\"cb99-10\"><a href=\"#cb99-10\"></a>    token.SLASH:    PRODUCT,</span>\n<span id=\"cb99-11\"><a href=\"#cb99-11\"></a>    token.ASTERISK: PRODUCT,</span>\n<span id=\"cb99-12\"><a href=\"#cb99-12\"></a>}</span>\n<span id=\"cb99-13\"><a href=\"#cb99-13\"></a></span>\n<span id=\"cb99-14\"><a href=\"#cb99-14\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb99-15\"><a href=\"#cb99-15\"></a></span>\n<span id=\"cb99-16\"><a href=\"#cb99-16\"></a><span class=\"kw\">func</span> (p *Parser) peekPrecedence() <span class=\"dt\">int</span> {</span>\n<span id=\"cb99-17\"><a href=\"#cb99-17\"></a>    <span class=\"kw\">if</span> p, ok := precedences[p.peekToken.Type]; ok {</span>\n<span id=\"cb99-18\"><a href=\"#cb99-18\"></a>        <span class=\"kw\">return</span> p</span>\n<span id=\"cb99-19\"><a href=\"#cb99-19\"></a>    }</span>\n<span id=\"cb99-20\"><a href=\"#cb99-20\"></a></span>\n<span id=\"cb99-21\"><a href=\"#cb99-21\"></a>    <span class=\"kw\">return</span> LOWEST</span>\n<span id=\"cb99-22\"><a href=\"#cb99-22\"></a>}</span>\n<span id=\"cb99-23\"><a href=\"#cb99-23\"></a></span>\n<span id=\"cb99-24\"><a href=\"#cb99-24\"></a><span class=\"kw\">func</span> (p *Parser) curPrecedence() <span class=\"dt\">int</span> {</span>\n<span id=\"cb99-25\"><a href=\"#cb99-25\"></a>    <span class=\"kw\">if</span> p, ok := precedences[p.curToken.Type]; ok {</span>\n<span id=\"cb99-26\"><a href=\"#cb99-26\"></a>        <span class=\"kw\">return</span> p</span>\n<span id=\"cb99-27\"><a href=\"#cb99-27\"></a>    }</span>\n<span id=\"cb99-28\"><a href=\"#cb99-28\"></a></span>\n<span id=\"cb99-29\"><a href=\"#cb99-29\"></a>    <span class=\"kw\">return</span> LOWEST</span>\n<span id=\"cb99-30\"><a href=\"#cb99-30\"></a>}</span></code></pre></div>\n<p><code>precedences</code> is our precedence table: it associates token types with their precedence. The precedence values themselves are the constants we defined earlier, the integers with increasing value. This table can now tell us that <code>+</code> (<code>token.PLUS</code>) and <code>-</code> (<code>token.MINUS</code>) have the same precedence, which is lower than the precedence of <code>*</code> (<code>token.ASTERISK</code>) and <code>/</code> (<code>token.SLASH</code>), for example.</p>\n<p>The <code>peekPrecedence</code> method returns the precedence associated with the token type of <code>p.peekToken</code>. If it doesn’t find a precedence for <code>p.peekToken</code> it defaults to <code>LOWEST</code>, the lowest possible precedence any operator can have. The <code>curPrecedence</code> method does the same thing, but for <code>p.curToken</code>.</p>\n<p>The next step is to register one infix parse function for all of our infix operators:</p>\n<div class=\"sourceCode\" id=\"cb100\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb100-1\"><a href=\"#cb100-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb100-2\"><a href=\"#cb100-2\"></a></span>\n<span id=\"cb100-3\"><a href=\"#cb100-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb100-4\"><a href=\"#cb100-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb100-5\"><a href=\"#cb100-5\"></a>    p.infixParseFns = <span class=\"bu\">make</span>(<span class=\"kw\">map</span>[token.TokenType]infixParseFn)</span>\n<span id=\"cb100-6\"><a href=\"#cb100-6\"></a>    p.registerInfix(token.PLUS, p.parseInfixExpression)</span>\n<span id=\"cb100-7\"><a href=\"#cb100-7\"></a>    p.registerInfix(token.MINUS, p.parseInfixExpression)</span>\n<span id=\"cb100-8\"><a href=\"#cb100-8\"></a>    p.registerInfix(token.SLASH, p.parseInfixExpression)</span>\n<span id=\"cb100-9\"><a href=\"#cb100-9\"></a>    p.registerInfix(token.ASTERISK, p.parseInfixExpression)</span>\n<span id=\"cb100-10\"><a href=\"#cb100-10\"></a>    p.registerInfix(token.EQ, p.parseInfixExpression)</span>\n<span id=\"cb100-11\"><a href=\"#cb100-11\"></a>    p.registerInfix(token.NOT_EQ, p.parseInfixExpression)</span>\n<span id=\"cb100-12\"><a href=\"#cb100-12\"></a>    p.registerInfix(token.LT, p.parseInfixExpression)</span>\n<span id=\"cb100-13\"><a href=\"#cb100-13\"></a>    p.registerInfix(token.GT, p.parseInfixExpression)</span>\n<span id=\"cb100-14\"><a href=\"#cb100-14\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb100-15\"><a href=\"#cb100-15\"></a>}</span></code></pre></div>\n<p>We already have the <code>registerInfix</code> method in our repertoire and now we finally use it. Every infix operator gets associated with the same parsing function called <code>parseInfixExpression</code>, which looks like this:</p>\n<div class=\"sourceCode\" id=\"cb101\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb101-1\"><a href=\"#cb101-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb101-2\"><a href=\"#cb101-2\"></a></span>\n<span id=\"cb101-3\"><a href=\"#cb101-3\"></a><span class=\"kw\">func</span> (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {</span>\n<span id=\"cb101-4\"><a href=\"#cb101-4\"></a>    expression := &amp;ast.InfixExpression{</span>\n<span id=\"cb101-5\"><a href=\"#cb101-5\"></a>        Token:    p.curToken,</span>\n<span id=\"cb101-6\"><a href=\"#cb101-6\"></a>        Operator: p.curToken.Literal,</span>\n<span id=\"cb101-7\"><a href=\"#cb101-7\"></a>        Left:     left,</span>\n<span id=\"cb101-8\"><a href=\"#cb101-8\"></a>    }</span>\n<span id=\"cb101-9\"><a href=\"#cb101-9\"></a></span>\n<span id=\"cb101-10\"><a href=\"#cb101-10\"></a>    precedence := p.curPrecedence()</span>\n<span id=\"cb101-11\"><a href=\"#cb101-11\"></a>    p.nextToken()</span>\n<span id=\"cb101-12\"><a href=\"#cb101-12\"></a>    expression.Right = p.parseExpression(precedence)</span>\n<span id=\"cb101-13\"><a href=\"#cb101-13\"></a></span>\n<span id=\"cb101-14\"><a href=\"#cb101-14\"></a>    <span class=\"kw\">return</span> expression</span>\n<span id=\"cb101-15\"><a href=\"#cb101-15\"></a>}</span></code></pre></div>\n<p>The notable difference here is that, in contrast to <code>parsePrefixExpression</code>, this new method takes an argument, an <code>ast.Expression</code> called <code>left</code>. It uses this argument to construct an <code>*ast.InfixExpression</code> node, with <code>left</code> being in the <code>Left</code> field. Then it assigns the precedence of the current token (which is the operator of the infix expression) to the local variable <code>precedence</code>, before advancing the tokens by calling <code>nextToken</code> and filling the <code>Right</code> field of the node with another call to <code>parseExpression</code> - this time passing in the precedence of the operator token.</p>\n<p>It’s time to lift the curtain. Here is the heart of our Pratt parser, here is the final version of <code>parseExpression</code>:</p>\n<div class=\"sourceCode\" id=\"cb102\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb102-1\"><a href=\"#cb102-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb102-2\"><a href=\"#cb102-2\"></a></span>\n<span id=\"cb102-3\"><a href=\"#cb102-3\"></a><span class=\"kw\">func</span> (p *Parser) parseExpression(precedence <span class=\"dt\">int</span>) ast.Expression {</span>\n<span id=\"cb102-4\"><a href=\"#cb102-4\"></a>    prefix := p.prefixParseFns[p.curToken.Type]</span>\n<span id=\"cb102-5\"><a href=\"#cb102-5\"></a>    <span class=\"kw\">if</span> prefix == <span class=\"ot\">nil</span> {</span>\n<span id=\"cb102-6\"><a href=\"#cb102-6\"></a>        p.noPrefixParseFnError(p.curToken.Type)</span>\n<span id=\"cb102-7\"><a href=\"#cb102-7\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb102-8\"><a href=\"#cb102-8\"></a>    }</span>\n<span id=\"cb102-9\"><a href=\"#cb102-9\"></a>    leftExp := prefix()</span>\n<span id=\"cb102-10\"><a href=\"#cb102-10\"></a></span>\n<span id=\"cb102-11\"><a href=\"#cb102-11\"></a>    <span class=\"kw\">for</span> !p.peekTokenIs(token.SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() {</span>\n<span id=\"cb102-12\"><a href=\"#cb102-12\"></a>        infix := p.infixParseFns[p.peekToken.Type]</span>\n<span id=\"cb102-13\"><a href=\"#cb102-13\"></a>        <span class=\"kw\">if</span> infix == <span class=\"ot\">nil</span> {</span>\n<span id=\"cb102-14\"><a href=\"#cb102-14\"></a>            <span class=\"kw\">return</span> leftExp</span>\n<span id=\"cb102-15\"><a href=\"#cb102-15\"></a>        }</span>\n<span id=\"cb102-16\"><a href=\"#cb102-16\"></a></span>\n<span id=\"cb102-17\"><a href=\"#cb102-17\"></a>        p.nextToken()</span>\n<span id=\"cb102-18\"><a href=\"#cb102-18\"></a></span>\n<span id=\"cb102-19\"><a href=\"#cb102-19\"></a>        leftExp = infix(leftExp)</span>\n<span id=\"cb102-20\"><a href=\"#cb102-20\"></a>    }</span>\n<span id=\"cb102-21\"><a href=\"#cb102-21\"></a></span>\n<span id=\"cb102-22\"><a href=\"#cb102-22\"></a>    <span class=\"kw\">return</span> leftExp</span>\n<span id=\"cb102-23\"><a href=\"#cb102-23\"></a>}</span></code></pre></div>\n<p>And, boom! Our tests pass! It’s all green, baby:</p>\n<div class=\"sourceCode\" id=\"cb103\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb103-1\"><a href=\"#cb103-1\"></a>$ go test ./parser</span>\n<span id=\"cb103-2\"><a href=\"#cb103-2\"></a>ok      monkey/parser   0.006s</span></code></pre></div>\n<p>We are now officially able to parse infix operator expressions correctly! <em>Wait, what? What the hell did just happen? How does this work?</em></p>\n<p>Obviously <code>parseExpression</code> now does a few more things. We already know how it finds an associated <code>prefixParseFn</code> with the current token and calls it. We’ve seen this work with prefix operators, identifiers and integer literals.</p>\n<p>What’s new is the loop right in the middle of <code>parseExpression</code>. In the loop’s body the method tries to find <code>infixParseFn</code>s for the next token. If it finds such a function, it calls it, passing in the expression returned by a <code>prefixParseFn</code> as an argument. And it does all this again and again until it encounters a token that has a lower precedence.</p>\n<p>This works beautifully. Look at these tests that use multiple operators with different precedences and how the AST in string form correctly represents this:</p>\n<div class=\"sourceCode\" id=\"cb104\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb104-1\"><a href=\"#cb104-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb104-2\"><a href=\"#cb104-2\"></a></span>\n<span id=\"cb104-3\"><a href=\"#cb104-3\"></a><span class=\"kw\">func</span> TestOperatorPrecedenceParsing(t *testing.T) {</span>\n<span id=\"cb104-4\"><a href=\"#cb104-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb104-5\"><a href=\"#cb104-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb104-6\"><a href=\"#cb104-6\"></a>        expected <span class=\"dt\">string</span></span>\n<span id=\"cb104-7\"><a href=\"#cb104-7\"></a>    }{</span>\n<span id=\"cb104-8\"><a href=\"#cb104-8\"></a>        {</span>\n<span id=\"cb104-9\"><a href=\"#cb104-9\"></a>            <span class=\"st\">&quot;-a * b&quot;</span>,</span>\n<span id=\"cb104-10\"><a href=\"#cb104-10\"></a>            <span class=\"st\">&quot;((-a) * b)&quot;</span>,</span>\n<span id=\"cb104-11\"><a href=\"#cb104-11\"></a>        },</span>\n<span id=\"cb104-12\"><a href=\"#cb104-12\"></a>        {</span>\n<span id=\"cb104-13\"><a href=\"#cb104-13\"></a>            <span class=\"st\">&quot;!-a&quot;</span>,</span>\n<span id=\"cb104-14\"><a href=\"#cb104-14\"></a>            <span class=\"st\">&quot;(!(-a))&quot;</span>,</span>\n<span id=\"cb104-15\"><a href=\"#cb104-15\"></a>        },</span>\n<span id=\"cb104-16\"><a href=\"#cb104-16\"></a>        {</span>\n<span id=\"cb104-17\"><a href=\"#cb104-17\"></a>            <span class=\"st\">&quot;a + b + c&quot;</span>,</span>\n<span id=\"cb104-18\"><a href=\"#cb104-18\"></a>            <span class=\"st\">&quot;((a + b) + c)&quot;</span>,</span>\n<span id=\"cb104-19\"><a href=\"#cb104-19\"></a>        },</span>\n<span id=\"cb104-20\"><a href=\"#cb104-20\"></a>        {</span>\n<span id=\"cb104-21\"><a href=\"#cb104-21\"></a>            <span class=\"st\">&quot;a + b - c&quot;</span>,</span>\n<span id=\"cb104-22\"><a href=\"#cb104-22\"></a>            <span class=\"st\">&quot;((a + b) - c)&quot;</span>,</span>\n<span id=\"cb104-23\"><a href=\"#cb104-23\"></a>        },</span>\n<span id=\"cb104-24\"><a href=\"#cb104-24\"></a>        {</span>\n<span id=\"cb104-25\"><a href=\"#cb104-25\"></a>            <span class=\"st\">&quot;a * b * c&quot;</span>,</span>\n<span id=\"cb104-26\"><a href=\"#cb104-26\"></a>            <span class=\"st\">&quot;((a * b) * c)&quot;</span>,</span>\n<span id=\"cb104-27\"><a href=\"#cb104-27\"></a>        },</span>\n<span id=\"cb104-28\"><a href=\"#cb104-28\"></a>        {</span>\n<span id=\"cb104-29\"><a href=\"#cb104-29\"></a>            <span class=\"st\">&quot;a * b / c&quot;</span>,</span>\n<span id=\"cb104-30\"><a href=\"#cb104-30\"></a>            <span class=\"st\">&quot;((a * b) / c)&quot;</span>,</span>\n<span id=\"cb104-31\"><a href=\"#cb104-31\"></a>        },</span>\n<span id=\"cb104-32\"><a href=\"#cb104-32\"></a>        {</span>\n<span id=\"cb104-33\"><a href=\"#cb104-33\"></a>            <span class=\"st\">&quot;a + b / c&quot;</span>,</span>\n<span id=\"cb104-34\"><a href=\"#cb104-34\"></a>            <span class=\"st\">&quot;(a + (b / c))&quot;</span>,</span>\n<span id=\"cb104-35\"><a href=\"#cb104-35\"></a>        },</span>\n<span id=\"cb104-36\"><a href=\"#cb104-36\"></a>        {</span>\n<span id=\"cb104-37\"><a href=\"#cb104-37\"></a>            <span class=\"st\">&quot;a + b * c + d / e - f&quot;</span>,</span>\n<span id=\"cb104-38\"><a href=\"#cb104-38\"></a>            <span class=\"st\">&quot;(((a + (b * c)) + (d / e)) - f)&quot;</span>,</span>\n<span id=\"cb104-39\"><a href=\"#cb104-39\"></a>        },</span>\n<span id=\"cb104-40\"><a href=\"#cb104-40\"></a>        {</span>\n<span id=\"cb104-41\"><a href=\"#cb104-41\"></a>            <span class=\"st\">&quot;3 + 4; -5 * 5&quot;</span>,</span>\n<span id=\"cb104-42\"><a href=\"#cb104-42\"></a>            <span class=\"st\">&quot;(3 + 4)((-5) * 5)&quot;</span>,</span>\n<span id=\"cb104-43\"><a href=\"#cb104-43\"></a>        },</span>\n<span id=\"cb104-44\"><a href=\"#cb104-44\"></a>        {</span>\n<span id=\"cb104-45\"><a href=\"#cb104-45\"></a>            <span class=\"st\">&quot;5 &gt; 4 == 3 &lt; 4&quot;</span>,</span>\n<span id=\"cb104-46\"><a href=\"#cb104-46\"></a>            <span class=\"st\">&quot;((5 &gt; 4) == (3 &lt; 4))&quot;</span>,</span>\n<span id=\"cb104-47\"><a href=\"#cb104-47\"></a>        },</span>\n<span id=\"cb104-48\"><a href=\"#cb104-48\"></a>        {</span>\n<span id=\"cb104-49\"><a href=\"#cb104-49\"></a>            <span class=\"st\">&quot;5 &lt; 4 != 3 &gt; 4&quot;</span>,</span>\n<span id=\"cb104-50\"><a href=\"#cb104-50\"></a>            <span class=\"st\">&quot;((5 &lt; 4) != (3 &gt; 4))&quot;</span>,</span>\n<span id=\"cb104-51\"><a href=\"#cb104-51\"></a>        },</span>\n<span id=\"cb104-52\"><a href=\"#cb104-52\"></a>        {</span>\n<span id=\"cb104-53\"><a href=\"#cb104-53\"></a>            <span class=\"st\">&quot;3 + 4 * 5 == 3 * 1 + 4 * 5&quot;</span>,</span>\n<span id=\"cb104-54\"><a href=\"#cb104-54\"></a>            <span class=\"st\">&quot;((3 + (4 * 5)) == ((3 * 1) + (4 * 5)))&quot;</span>,</span>\n<span id=\"cb104-55\"><a href=\"#cb104-55\"></a>        },</span>\n<span id=\"cb104-56\"><a href=\"#cb104-56\"></a>    }</span>\n<span id=\"cb104-57\"><a href=\"#cb104-57\"></a></span>\n<span id=\"cb104-58\"><a href=\"#cb104-58\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb104-59\"><a href=\"#cb104-59\"></a>        l := lexer.New(tt.input)</span>\n<span id=\"cb104-60\"><a href=\"#cb104-60\"></a>        p := New(l)</span>\n<span id=\"cb104-61\"><a href=\"#cb104-61\"></a>        program := p.ParseProgram()</span>\n<span id=\"cb104-62\"><a href=\"#cb104-62\"></a>        checkParserErrors(t, p)</span>\n<span id=\"cb104-63\"><a href=\"#cb104-63\"></a></span>\n<span id=\"cb104-64\"><a href=\"#cb104-64\"></a>        actual := program.String()</span>\n<span id=\"cb104-65\"><a href=\"#cb104-65\"></a>        <span class=\"kw\">if</span> actual != tt.expected {</span>\n<span id=\"cb104-66\"><a href=\"#cb104-66\"></a>            t.Errorf(<span class=\"st\">&quot;expected=%q, got=%q&quot;</span>, tt.expected, actual)</span>\n<span id=\"cb104-67\"><a href=\"#cb104-67\"></a>        }</span>\n<span id=\"cb104-68\"><a href=\"#cb104-68\"></a>    }</span>\n<span id=\"cb104-69\"><a href=\"#cb104-69\"></a>}</span></code></pre></div>\n<p>They’re all passing! That’s pretty amazing, isn’t it?</p>\n<p>The different <code>*ast.InfixExpression</code>s are nested correctly, which we can observe thanks to our usage of parentheses in the <code>String()</code> methods of the AST nodes.</p>\n<p>If you’re scratching your head and wondering how all of this works, don’t worry. We’re now going to take a really close look at our <code>parseExpression</code> method.</p>\n</section>\n</section>\n<section id=\"how-pratt-parsing-works\" class=\"level2\" data-number=\"2.7\">\n<h2 data-number=\"2.7\">2.7 - How Pratt Parsing Works</h2>\n<p>The algorithm behind the <code>parseExpression</code> method and its combination of parsing functions and precedences is fully described by Vaughan Pratt in his “Top Down Operator Precedence” paper. But there are differences between his and our implementation.</p>\n<p>Pratt doesn’t use a <code>Parser</code> structure and doesn’t pass around methods defined on <code>*Parser</code>. He also doesn’t use maps and, of course, he didn’t use Go. His paper predates the release of Go by 36 years. And then there are naming differences: what we call <code>prefixParseFn</code>s are “nuds” (for “null denotations”) for Pratt. <code>infixParseFns</code> are “leds” (for “left denotations”).</p>\n<p>Formulated in pseudocode though, our <code>parseExpression</code> method looks strikingly similar to the code presented in Pratt’s paper. It uses the same algorithm with barely any changes.</p>\n<p>We’re going to skip the theory that answers <em>why</em> it works and just follow <em>how</em> it works and how all the pieces (<code>parseExpression</code>, parsing functions and precedences) fit together by looking at an example. Suppose we’re parsing the following expression statement:</p>\n<div class=\"sourceCode\" id=\"cb105\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb105-1\"><a href=\"#cb105-1\"></a><span class=\"dv\">1</span> <span class=\"op\">+</span> <span class=\"dv\">2</span> <span class=\"op\">+</span> <span class=\"dv\">3</span><span class=\"op\">;</span></span></code></pre></div>\n<p>The big challenge here is not to represent every operator and operand in the resulting AST, but to nest the nodes of the AST correctly. What we want is an AST that (serialized as a string) looks like this:</p>\n<div class=\"sourceCode\" id=\"cb106\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb106-1\"><a href=\"#cb106-1\"></a>((<span class=\"dv\">1</span> <span class=\"op\">+</span> <span class=\"dv\">2</span>) <span class=\"op\">+</span> <span class=\"dv\">3</span>)</span></code></pre></div>\n<p>The AST needs to have two <code>*ast.InfixExpression</code> nodes. The <code>*ast.InfixExpression</code> higher in the tree should have the integer literal <code>3</code> as its <code>Right</code> child node and its <code>Left</code> child node needs to be the other <code>*ast.InfixExpression</code>. This second <code>*ast.InfixExpression</code> then needs to have the integer literals <code>1</code> and <code>2</code> as its <code>Left</code> and <code>Right</code> child nodes, respectively. Like this:</p>\n<figure>\n<img src=\"../media/file2.png\" width=\"400\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p>And this is exactly what our parser outputs when it parses <code>1 + 2 + 3;</code>. But how? We’ll answer that question in the following paragraphs. We’re going take a close look at what the parser does as soon as <code>parseExpressionStatement</code> is called for the first time. It’s not a mistake to have the code open while reading the following paragraphs.</p>\n<p>So here we go. Here is what happens when we parse <code>1 + 2 + 3;</code>:</p>\n<p><code>parseExpressionStatement</code> calls <code>parseExpression(LOWEST)</code>. The <code>p.curToken</code> and <code>p.peekToken</code> are the <code>1</code> and the first <code>+</code>:</p>\n<figure>\n<img src=\"../media/file3.png\" width=\"400\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p>The first thing <code>parseExpression</code> then does is to check whether there is a <code>prefixParseFn</code> associated with the current <code>p.curToken.Type</code>, which is a <code>token.INT</code>. And, yes, there is: <code>parseIntegerLiteral</code>. So it calls <code>parseIntegerLiteral</code>, which returns an <code>*ast.IntegerLiteral</code>. <code>parseExpression</code> assigns this to <code>leftExp</code>.</p>\n<p>Then comes the new for-loop in <code>parseExpression</code>. Its condition evaluates to true:</p>\n<div class=\"sourceCode\" id=\"cb107\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb107-1\"><a href=\"#cb107-1\"></a><span class=\"kw\">for</span> !p.peekTokenIs(token.SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() {</span>\n<span id=\"cb107-2\"><a href=\"#cb107-2\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb107-3\"><a href=\"#cb107-3\"></a>}</span></code></pre></div>\n<p><code>p.peekToken</code> is not a <code>token.SEMICOLON</code> and <code>peekPrecedence</code> (which returns the precedence of the <code>+</code> token) is higher than the argument passed to <code>parseExpression</code>, which is <code>LOWEST</code>. Here are our defined precedences again to refresh our memory:</p>\n<div class=\"sourceCode\" id=\"cb108\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb108-1\"><a href=\"#cb108-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb108-2\"><a href=\"#cb108-2\"></a></span>\n<span id=\"cb108-3\"><a href=\"#cb108-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb108-4\"><a href=\"#cb108-4\"></a>    _ <span class=\"dt\">int</span> = <span class=\"ot\">iota</span></span>\n<span id=\"cb108-5\"><a href=\"#cb108-5\"></a>    LOWEST</span>\n<span id=\"cb108-6\"><a href=\"#cb108-6\"></a>    EQUALS      <span class=\"co\">// ==</span></span>\n<span id=\"cb108-7\"><a href=\"#cb108-7\"></a>    LESSGREATER <span class=\"co\">// &gt; or &lt;</span></span>\n<span id=\"cb108-8\"><a href=\"#cb108-8\"></a>    SUM         <span class=\"co\">// +</span></span>\n<span id=\"cb108-9\"><a href=\"#cb108-9\"></a>    PRODUCT     <span class=\"co\">// *</span></span>\n<span id=\"cb108-10\"><a href=\"#cb108-10\"></a>    PREFIX      <span class=\"co\">// -X or !X</span></span>\n<span id=\"cb108-11\"><a href=\"#cb108-11\"></a>    CALL        <span class=\"co\">// myFunction(X)</span></span>\n<span id=\"cb108-12\"><a href=\"#cb108-12\"></a>)</span></code></pre></div>\n<p>So the condition evaluates to true and <code>parseExpression</code> executes the body of the loop, which looks like this:</p>\n<div class=\"sourceCode\" id=\"cb109\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb109-1\"><a href=\"#cb109-1\"></a>infix := p.infixParseFns[p.peekToken.Type]</span>\n<span id=\"cb109-2\"><a href=\"#cb109-2\"></a><span class=\"kw\">if</span> infix == <span class=\"ot\">nil</span> {</span>\n<span id=\"cb109-3\"><a href=\"#cb109-3\"></a>  <span class=\"kw\">return</span> leftExp</span>\n<span id=\"cb109-4\"><a href=\"#cb109-4\"></a>}</span>\n<span id=\"cb109-5\"><a href=\"#cb109-5\"></a></span>\n<span id=\"cb109-6\"><a href=\"#cb109-6\"></a>p.nextToken()</span>\n<span id=\"cb109-7\"><a href=\"#cb109-7\"></a></span>\n<span id=\"cb109-8\"><a href=\"#cb109-8\"></a>leftExp = infix(leftExp)</span></code></pre></div>\n<p>Now it fetches the <code>infixParseFn</code> for <code>p.peekToken.Type</code>, which is <code>parseInfixExpression</code> defined on <code>*Parser</code>. Before calling it and assigning its return value to <code>leftExp</code> (reusing the <code>leftExp</code> variable!) it advances the tokens so they now look like this:</p>\n<figure>\n<img src=\"../media/file4.png\" width=\"400\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p>With the tokens in this state, it calls <code>parseInfixExpression</code> and passes in the already parsed <code>*ast.IntegerLiteral</code> (assigned to <code>leftExp</code> outside the for-loop). What happens next in <code>parseInfixExpression</code> is where things get interesting. Here is the method again:</p>\n<div class=\"sourceCode\" id=\"cb110\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb110-1\"><a href=\"#cb110-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb110-2\"><a href=\"#cb110-2\"></a></span>\n<span id=\"cb110-3\"><a href=\"#cb110-3\"></a><span class=\"kw\">func</span> (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {</span>\n<span id=\"cb110-4\"><a href=\"#cb110-4\"></a>    expression := &amp;ast.InfixExpression{</span>\n<span id=\"cb110-5\"><a href=\"#cb110-5\"></a>        Token:    p.curToken,</span>\n<span id=\"cb110-6\"><a href=\"#cb110-6\"></a>        Operator: p.curToken.Literal,</span>\n<span id=\"cb110-7\"><a href=\"#cb110-7\"></a>        Left:     left,</span>\n<span id=\"cb110-8\"><a href=\"#cb110-8\"></a>    }</span>\n<span id=\"cb110-9\"><a href=\"#cb110-9\"></a></span>\n<span id=\"cb110-10\"><a href=\"#cb110-10\"></a>    precedence := p.curPrecedence()</span>\n<span id=\"cb110-11\"><a href=\"#cb110-11\"></a>    p.nextToken()</span>\n<span id=\"cb110-12\"><a href=\"#cb110-12\"></a>    expression.Right = p.parseExpression(precedence)</span>\n<span id=\"cb110-13\"><a href=\"#cb110-13\"></a></span>\n<span id=\"cb110-14\"><a href=\"#cb110-14\"></a>    <span class=\"kw\">return</span> expression</span>\n<span id=\"cb110-15\"><a href=\"#cb110-15\"></a>}</span></code></pre></div>\n<p>It’s important to note that <code>left</code> is our already parsed <code>*ast.IntegerLiteral</code> that represents the <code>1</code>.</p>\n<p><code>parseInfixExpression</code> saves the precedence of <code>p.curToken</code> (the first <code>+</code> token!), advances the tokens and calls <code>parseExpression</code> - passing in the just saved precedence. So now <code>parseExpression</code> is called the second time, with the tokens looking like this:</p>\n<figure>\n<img src=\"../media/file5.png\" width=\"400\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p>The first thing <code>parseExpression</code> does again is to look for a <code>prefixParseFn</code> for <code>p.curToken</code>. And again it’s <code>parseIntegerLiteral</code>. But now the condition of the for-loop doesn’t evaluate to true: <code>precedence</code> (the argument passed to <code>parseExpression</code>) is the precedence of the <em>first</em> <code>+</code> operator in <code>1 + 2 + 3</code>, which is <em>not</em> smaller than the precedence of <code>p.peekToken</code>, the second <code>+</code> operator. They are equal. The body of the for-loop is not executed and the <code>*ast.IntegerLiteral</code> representing the <code>2</code> is returned.</p>\n<p>Now back in <code>parseInfixExpression</code> the return-value of <code>parseExpression</code> is assigned to the <code>Right</code> field of the newly constructed <code>*ast.InfixExpression</code>. So now we have this:</p>\n<figure>\n<img src=\"../media/file6.png\" width=\"400\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p>This <code>*ast.InfixExpression</code> gets returned by <code>parseInfixExpression</code> and now we’re back in the outer-most call to <code>parseExpression</code>, where <code>precedence</code> is still <code>LOWEST</code>. We are back where we started and the condition of the for-loop is evaluated again.</p>\n<div class=\"sourceCode\" id=\"cb111\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb111-1\"><a href=\"#cb111-1\"></a><span class=\"kw\">for</span> !p.peekTokenIs(token.SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() {</span>\n<span id=\"cb111-2\"><a href=\"#cb111-2\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb111-3\"><a href=\"#cb111-3\"></a>}</span></code></pre></div>\n<p>This still evaluates to true, since <code>precedence</code> is <code>LOWEST</code> and <code>peekPrecedence</code> now returns the precedence of the second <code>+</code> in our expression, which is higher. <code>parseExpression</code> executes the body of the for-loop a second time. The difference is that now <code>leftExp</code> is not an <code>*ast.IntegerLiteral</code> representing the <code>1</code>, but the <code>*ast.InfixExpression</code> returned by <code>parseInfixExpression</code>, representing <code>1 + 2</code>.</p>\n<p>In the body of the loop <code>parseExpression</code> fetches <code>parseInfixExpression</code> as the <code>infixParseFn</code> for <code>p.peekToken.Type</code> (which is the second <code>+</code>), advances the tokens and calls <code>parseInfixExpression</code> with <code>leftExp</code> as the argument. <code>parseInfixExpression</code> in turn calls <code>parseExpression</code> again, which returns the last <code>*ast.IntegerLiteral</code> (that represents the <code>3</code> in our expression).</p>\n<p>After all this, at the end of the loop-body, <code>leftExp</code> looks like this:</p>\n<figure>\n<img src=\"../media/file2.png\" width=\"400\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p>That’s exactly what we wanted! The operators and operands are nested correctly! And our tokens look like this:</p>\n<figure>\n<img src=\"../media/file7.png\" width=\"400\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p>The condition of the for-loop evaluates to false:</p>\n<div class=\"sourceCode\" id=\"cb112\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb112-1\"><a href=\"#cb112-1\"></a><span class=\"kw\">for</span> !p.peekTokenIs(token.SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() {</span>\n<span id=\"cb112-2\"><a href=\"#cb112-2\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb112-3\"><a href=\"#cb112-3\"></a>}</span></code></pre></div>\n<p>Now <code>p.peekTokenIs(token.SEMICOLON)</code> evaluates to true, which stops the body of the loop from being executed again.</p>\n<p>(The call to <code>p.peekTokenIs(token.SEMICOLON)</code> is not strictly necessary. Our <code>peekPrecedence</code> method returns <code>LOWEST</code> as the default value if no precedence for <code>p.peekToken.Type</code> can be found - which is the case for <code>token.SEMICOLON</code> tokens. But I think it makes the behaviour of semicolons as expression-ending-delimiters more explicit and easier to understand.)</p>\n<p>And that’s it! The for-loop is done and <code>leftExp</code> is returned. We’re back in <code>parseExpressionStatement</code> and have the final and correct <code>*ast.InfixExpression</code> at hand. And that’s used as the <code>Expression</code> in <code>*ast.ExpressionStatement</code>.</p>\n<p>Now we know how our parser manages to parse <code>1 + 2 + 3</code> correctly. It’s pretty fascinating, isn’t it? I think the usage of <code>precedence</code> and <code>peekPrecedence</code> is particularly interesting.</p>\n<p>But what about “real precedence issues”? In our example every operator (the <code>+</code>) had the same precedence. What do the different precedence levels for operators accomplish? Couldn’t we just use <code>LOWEST</code> per default and something called <code>HIGHEST</code> for all operators?</p>\n<p>No, because that would give us a wrong AST. The goal is to have expressions involving operators with a higher precedence to be deeper in the tree than expressions with lower precedence operators. This is accomplished by the <code>precedence</code> value (the argument) in <code>parseExpression</code>.</p>\n<p>When <code>parseExpression</code> is called the value of <code>precedence</code> stands for the current “right-binding power” of the current <code>parseExpression</code> invocation. What does “right-binding power” mean? Well, the higher it is, the more tokens/operators/operands to the right of the current expressions (the future peek tokens) can we “bind” to it, or as I like to think, “suck in”.</p>\n<p>In case our current right-binding power is of the highest possible value, what we parsed so far (assigned to <code>leftExp</code>) is <em>never</em> passed to an <code>infixParseFn</code> associated with the next operator (or token). It will never end up as a “left” child node. Because the condition of the for-loop never evaluates to true.</p>\n<p>A counterpart to right-binding power exists and it’s called (you guessed it!) “left-binding power”. But which value signifies this left-binding power? Since the <code>precedence</code> argument in <code>parseExpression</code> stands for the current right-binding power, where does the left-binding power of the next operator come from? Simply put: from our call to <code>peekPrecedence</code>. The value this call returns stands for the left-binding power of the next operator, of <code>p.peekToken</code>.</p>\n<p>It all comes down to the <code>precedence &lt; p.peekPrecedence()</code> condition of our for-loop. This condition checks if the left-binding power of the next operator/token is higher than our current right-binding power. If it is, what we parsed so far gets “sucked in” by the next operator, from left to right, and ends up being passed to the <code>infixParseFn</code> of the next operator.</p>\n<p>An example: let’s say we’re parsing the expression statement <code>-1 + 2;</code>. What we want the AST to represent is <code>(-1) + 2</code> and not <code>-(1 + 2)</code>. The first method we end up in (after <code>parseExpressionStatement</code> and <code>parseExpression</code>) is the <code>prefixParseFn</code> we associated with <code>token.MINUS</code>: <code>parsePrefixExpression</code>. To refresh our memory of <code>parsePrefixExpression</code> here it is in its entirety:</p>\n<div class=\"sourceCode\" id=\"cb113\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb113-1\"><a href=\"#cb113-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb113-2\"><a href=\"#cb113-2\"></a></span>\n<span id=\"cb113-3\"><a href=\"#cb113-3\"></a><span class=\"kw\">func</span> (p *Parser) parsePrefixExpression() ast.Expression {</span>\n<span id=\"cb113-4\"><a href=\"#cb113-4\"></a>  expression := &amp;ast.PrefixExpression{</span>\n<span id=\"cb113-5\"><a href=\"#cb113-5\"></a>    Token:    p.curToken,</span>\n<span id=\"cb113-6\"><a href=\"#cb113-6\"></a>    Operator: p.curToken.Literal,</span>\n<span id=\"cb113-7\"><a href=\"#cb113-7\"></a>  }</span>\n<span id=\"cb113-8\"><a href=\"#cb113-8\"></a>  p.nextToken()</span>\n<span id=\"cb113-9\"><a href=\"#cb113-9\"></a>  expression.Right = p.parseExpression(PREFIX)</span>\n<span id=\"cb113-10\"><a href=\"#cb113-10\"></a>  <span class=\"kw\">return</span> expression</span>\n<span id=\"cb113-11\"><a href=\"#cb113-11\"></a>}</span></code></pre></div>\n<p>This passes <code>PREFIX</code> to <code>parseExpression</code> as <code>precedence</code>, turning <code>PREFIX</code> into the right-binding power of that <code>parseExpression</code> invocation. <code>PREFIX</code> is a really high precedence, as per our definition. The result of this is that <code>parseExpression(PREFIX)</code> is <em>never</em> going to parse the <code>1</code> in <code>-1</code> and pass it to another <code>infixParseFn</code>. The <code>precedence &lt; p.peekPrecedence()</code> will never be true in this case, meaning that no other <code>infixParseFn</code> is going to get our <code>1</code> as the left arm. Instead the <code>1</code> is returned as the “right” arm of our prefix expression. Just the <code>1</code>, not some other expression that comes after and needs to be parsed.</p>\n<p>Back in the outer call to <code>parseExpression</code> (in which we called <code>parsePrefixExpression</code> as a <code>prefixParseFn</code>), right after the first <code>leftExp := prefix()</code>, the value of <code>precedence</code> is still <code>LOWEST</code>. Since that was the value we used in the outer-most call. Our right-binding power is still <code>LOWEST</code>. The <code>p.peekToken</code> is now the <code>+</code> in <code>-1 + 2</code>.</p>\n<p>We’re now sitting on the condition of the for-loop and evaluate it to determine whether we should execute the body of the loop. And it turns out that the precedence of the <code>+</code> operator (returned by <code>p.peekPrecedence()</code>) is higher than our current right-binding power. What we parsed so far (the <code>-1</code> prefix expression) is now passed to the <code>infixParseFn</code> associated with <code>+</code>. The left-binding power of the <code>+</code> “sucks in” what we parsed so far and uses it as the “left arm” of the AST node it is constructing.</p>\n<p>The <code>infixParseFn</code> for <code>+</code> is <code>parseInfixExpression</code>, which now uses the precedence of <code>+</code> as the right-binding power in its call to <code>parseExpression</code>. It doesn’t use <code>LOWEST</code>, because that would result in another <code>+</code> having a higher left-binding power and “sucking” away our “right arm”. If it did, then an expression like <code>a + b + c</code> would result in <code>(a + (b + c))</code>, which is not what we want. We want <code>((a + b) + c)</code>.</p>\n<p>The high precedence of prefix operators worked. And it even works great for infix operators. In the classic example for operator precedences <code>1 + 2 * 3</code>, the left-binding power of <code>*</code> would be higher than the right-binding power of <code>+</code>. Parsing this would result in the <code>2</code> being passed to the <code>infixParseFn</code> associated with the <code>*</code> token.</p>\n<p>Notable is that in our parser, every token has the same right- and left-binding power. We simply use one value (in our <code>precedences</code> table) as both. What this value means changes depending on the context.</p>\n<p>If an operator should be right-associative instead of left-associative (in the case of <code>+</code> that would result in <code>(a + (b  + c))</code> instead of <code>((a + b) + c)</code>, then we must use a smaller “right-binding power” when parsing the “right arm” of the operator expression. If you think about the <code>++</code> and <code>--</code> operators in other languages, where they can be used in a pre- and a postfix position, you can see why it’s sometimes useful to have differing left- and right-binding powers for operators.</p>\n<p>Since we did not define separate right- and left-binding powers for operators, but only use one value, we can’t just change a definition to achieve this. But, as an example, to make <code>+</code> right-associate we can decrement its precedence when calling <code>parseExpression</code>:</p>\n<div class=\"sourceCode\" id=\"cb114\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb114-1\"><a href=\"#cb114-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb114-2\"><a href=\"#cb114-2\"></a></span>\n<span id=\"cb114-3\"><a href=\"#cb114-3\"></a><span class=\"kw\">func</span> (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {</span>\n<span id=\"cb114-4\"><a href=\"#cb114-4\"></a>    expression := &amp;ast.InfixExpression{</span>\n<span id=\"cb114-5\"><a href=\"#cb114-5\"></a>        Token:    p.curToken,</span>\n<span id=\"cb114-6\"><a href=\"#cb114-6\"></a>        Operator: p.curToken.Literal,</span>\n<span id=\"cb114-7\"><a href=\"#cb114-7\"></a>        Left:     left,</span>\n<span id=\"cb114-8\"><a href=\"#cb114-8\"></a>    }</span>\n<span id=\"cb114-9\"><a href=\"#cb114-9\"></a></span>\n<span id=\"cb114-10\"><a href=\"#cb114-10\"></a>    precedence := p.curPrecedence()</span>\n<span id=\"cb114-11\"><a href=\"#cb114-11\"></a>    p.nextToken()</span>\n<span id=\"cb114-12\"><a href=\"#cb114-12\"></a>    expression.Right = p.parseExpression(precedence)</span>\n<span id=\"cb114-13\"><a href=\"#cb114-13\"></a>    <span class=\"co\">//                                   ^^^ decrement here for right-associativity</span></span>\n<span id=\"cb114-14\"><a href=\"#cb114-14\"></a></span>\n<span id=\"cb114-15\"><a href=\"#cb114-15\"></a>    <span class=\"kw\">return</span> expression</span>\n<span id=\"cb114-16\"><a href=\"#cb114-16\"></a>}</span></code></pre></div>\n<p>For demonstration purposes, let’s change this method for a minute and see what happens:</p>\n<div class=\"sourceCode\" id=\"cb115\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb115-1\"><a href=\"#cb115-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb115-2\"><a href=\"#cb115-2\"></a></span>\n<span id=\"cb115-3\"><a href=\"#cb115-3\"></a><span class=\"kw\">func</span> (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {</span>\n<span id=\"cb115-4\"><a href=\"#cb115-4\"></a>    expression := &amp;ast.InfixExpression{</span>\n<span id=\"cb115-5\"><a href=\"#cb115-5\"></a>        Token:    p.curToken,</span>\n<span id=\"cb115-6\"><a href=\"#cb115-6\"></a>        Operator: p.curToken.Literal,</span>\n<span id=\"cb115-7\"><a href=\"#cb115-7\"></a>        Left:     left,</span>\n<span id=\"cb115-8\"><a href=\"#cb115-8\"></a>    }</span>\n<span id=\"cb115-9\"><a href=\"#cb115-9\"></a></span>\n<span id=\"cb115-10\"><a href=\"#cb115-10\"></a>    precedence := p.curPrecedence()</span>\n<span id=\"cb115-11\"><a href=\"#cb115-11\"></a>    p.nextToken()</span>\n<span id=\"cb115-12\"><a href=\"#cb115-12\"></a></span>\n<span id=\"cb115-13\"><a href=\"#cb115-13\"></a>    <span class=\"kw\">if</span> expression.Operator == <span class=\"st\">&quot;+&quot;</span> {</span>\n<span id=\"cb115-14\"><a href=\"#cb115-14\"></a>        expression.Right = p.parseExpression(precedence - <span class=\"dv\">1</span>)</span>\n<span id=\"cb115-15\"><a href=\"#cb115-15\"></a>    } <span class=\"kw\">else</span> {</span>\n<span id=\"cb115-16\"><a href=\"#cb115-16\"></a>        expression.Right = p.parseExpression(precedence)</span>\n<span id=\"cb115-17\"><a href=\"#cb115-17\"></a>    }</span>\n<span id=\"cb115-18\"><a href=\"#cb115-18\"></a></span>\n<span id=\"cb115-19\"><a href=\"#cb115-19\"></a>    <span class=\"kw\">return</span> expression</span>\n<span id=\"cb115-20\"><a href=\"#cb115-20\"></a>}</span></code></pre></div>\n<p>With this change made, our tests tell us that <code>+</code> is officially right-associative:</p>\n<div class=\"sourceCode\" id=\"cb116\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb116-1\"><a href=\"#cb116-1\"></a>$ go test -run TestOperatorPrecedenceParsing ./parser</span>\n<span id=\"cb116-2\"><a href=\"#cb116-2\"></a>--- FAIL: TestOperatorPrecedenceParsing (0.00s)</span>\n<span id=\"cb116-3\"><a href=\"#cb116-3\"></a>  parser_test.go:359: expected=&quot;((a + b) + c)&quot;, got=&quot;(a + (b + c))&quot;</span>\n<span id=\"cb116-4\"><a href=\"#cb116-4\"></a>  parser_test.go:359: expected=&quot;((a + b) - c)&quot;, got=&quot;(a + (b - c))&quot;</span>\n<span id=\"cb116-5\"><a href=\"#cb116-5\"></a>  parser_test.go:359: expected=&quot;(((a + (b * c)) + (d / e)) - f)&quot;,\\</span>\n<span id=\"cb116-6\"><a href=\"#cb116-6\"></a>    got=&quot;(a + ((b * c) + ((d / e) - f)))&quot;</span>\n<span id=\"cb116-7\"><a href=\"#cb116-7\"></a>FAIL</span></code></pre></div>\n<p>And that marks the end of our deep dive into the bowels of <code>parseExpression</code>. If you’re still unsure and can’t grasp how it works, don’t worry, I felt the same. What really helped though was putting tracing statements in the methods of <code>Parser</code> to see what was happening when parsing certain expressions. In the folder of code accompanying this chapter I’ve included a file called <code>./parser/parser_tracing.go</code>, which we haven’t looked at before. The file includes two function definitions that are really helpful when trying to understand what the parser does: <code>trace</code> and <code>untrace</code>. Use them like this:</p>\n<div class=\"sourceCode\" id=\"cb117\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb117-1\"><a href=\"#cb117-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb117-2\"><a href=\"#cb117-2\"></a></span>\n<span id=\"cb117-3\"><a href=\"#cb117-3\"></a><span class=\"kw\">func</span> (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {</span>\n<span id=\"cb117-4\"><a href=\"#cb117-4\"></a>    <span class=\"kw\">defer</span> untrace(trace(<span class=\"st\">&quot;parseExpressionStatement&quot;</span>))</span>\n<span id=\"cb117-5\"><a href=\"#cb117-5\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb117-6\"><a href=\"#cb117-6\"></a>}</span>\n<span id=\"cb117-7\"><a href=\"#cb117-7\"></a></span>\n<span id=\"cb117-8\"><a href=\"#cb117-8\"></a><span class=\"kw\">func</span> (p *Parser) parseExpression(precedence <span class=\"dt\">int</span>) ast.Expression {</span>\n<span id=\"cb117-9\"><a href=\"#cb117-9\"></a>    <span class=\"kw\">defer</span> untrace(trace(<span class=\"st\">&quot;parseExpression&quot;</span>))</span>\n<span id=\"cb117-10\"><a href=\"#cb117-10\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb117-11\"><a href=\"#cb117-11\"></a>}</span>\n<span id=\"cb117-12\"><a href=\"#cb117-12\"></a></span>\n<span id=\"cb117-13\"><a href=\"#cb117-13\"></a><span class=\"kw\">func</span> (p *Parser) parseIntegerLiteral() ast.Expression {</span>\n<span id=\"cb117-14\"><a href=\"#cb117-14\"></a>    <span class=\"kw\">defer</span> untrace(trace(<span class=\"st\">&quot;parseIntegerLiteral&quot;</span>))</span>\n<span id=\"cb117-15\"><a href=\"#cb117-15\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb117-16\"><a href=\"#cb117-16\"></a>}</span>\n<span id=\"cb117-17\"><a href=\"#cb117-17\"></a></span>\n<span id=\"cb117-18\"><a href=\"#cb117-18\"></a><span class=\"kw\">func</span> (p *Parser) parsePrefixExpression() ast.Expression {</span>\n<span id=\"cb117-19\"><a href=\"#cb117-19\"></a>    <span class=\"kw\">defer</span> untrace(trace(<span class=\"st\">&quot;parsePrefixExpression&quot;</span>))</span>\n<span id=\"cb117-20\"><a href=\"#cb117-20\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb117-21\"><a href=\"#cb117-21\"></a>}</span>\n<span id=\"cb117-22\"><a href=\"#cb117-22\"></a></span>\n<span id=\"cb117-23\"><a href=\"#cb117-23\"></a><span class=\"kw\">func</span> (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {</span>\n<span id=\"cb117-24\"><a href=\"#cb117-24\"></a>    <span class=\"kw\">defer</span> untrace(trace(<span class=\"st\">&quot;parseInfixExpression&quot;</span>))</span>\n<span id=\"cb117-25\"><a href=\"#cb117-25\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb117-26\"><a href=\"#cb117-26\"></a>}</span></code></pre></div>\n<p>With these tracing statements included we can now use our parser and see what it does. Here is the output when parsing the expression statement <code>-1 * 2 + 3</code> in the test suite:</p>\n<div class=\"sourceCode\" id=\"cb118\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb118-1\"><a href=\"#cb118-1\"></a>$ go test -v -run TestOperatorPrecedenceParsing ./parser</span>\n<span id=\"cb118-2\"><a href=\"#cb118-2\"></a>=== RUN   TestOperatorPrecedenceParsing</span>\n<span id=\"cb118-3\"><a href=\"#cb118-3\"></a>BEGIN parseExpressionStatement</span>\n<span id=\"cb118-4\"><a href=\"#cb118-4\"></a>        BEGIN parseExpression</span>\n<span id=\"cb118-5\"><a href=\"#cb118-5\"></a>                BEGIN parsePrefixExpression</span>\n<span id=\"cb118-6\"><a href=\"#cb118-6\"></a>                        BEGIN parseExpression</span>\n<span id=\"cb118-7\"><a href=\"#cb118-7\"></a>                                BEGIN parseIntegerLiteral</span>\n<span id=\"cb118-8\"><a href=\"#cb118-8\"></a>                                END parseIntegerLiteral</span>\n<span id=\"cb118-9\"><a href=\"#cb118-9\"></a>                        END parseExpression</span>\n<span id=\"cb118-10\"><a href=\"#cb118-10\"></a>                END parsePrefixExpression</span>\n<span id=\"cb118-11\"><a href=\"#cb118-11\"></a>                BEGIN parseInfixExpression</span>\n<span id=\"cb118-12\"><a href=\"#cb118-12\"></a>                        BEGIN parseExpression</span>\n<span id=\"cb118-13\"><a href=\"#cb118-13\"></a>                                BEGIN parseIntegerLiteral</span>\n<span id=\"cb118-14\"><a href=\"#cb118-14\"></a>                                END parseIntegerLiteral</span>\n<span id=\"cb118-15\"><a href=\"#cb118-15\"></a>                        END parseExpression</span>\n<span id=\"cb118-16\"><a href=\"#cb118-16\"></a>                END parseInfixExpression</span>\n<span id=\"cb118-17\"><a href=\"#cb118-17\"></a>                BEGIN parseInfixExpression</span>\n<span id=\"cb118-18\"><a href=\"#cb118-18\"></a>                        BEGIN parseExpression</span>\n<span id=\"cb118-19\"><a href=\"#cb118-19\"></a>                                BEGIN parseIntegerLiteral</span>\n<span id=\"cb118-20\"><a href=\"#cb118-20\"></a>                                END parseIntegerLiteral</span>\n<span id=\"cb118-21\"><a href=\"#cb118-21\"></a>                        END parseExpression</span>\n<span id=\"cb118-22\"><a href=\"#cb118-22\"></a>                END parseInfixExpression</span>\n<span id=\"cb118-23\"><a href=\"#cb118-23\"></a>        END parseExpression</span>\n<span id=\"cb118-24\"><a href=\"#cb118-24\"></a>END parseExpressionStatement</span>\n<span id=\"cb118-25\"><a href=\"#cb118-25\"></a>--- PASS: TestOperatorPrecedenceParsing (0.00s)</span>\n<span id=\"cb118-26\"><a href=\"#cb118-26\"></a>PASS</span>\n<span id=\"cb118-27\"><a href=\"#cb118-27\"></a>ok      monkey/parser   0.008s</span></code></pre></div>\n</section>\n<section id=\"extending-the-parser\" class=\"level2\" data-number=\"2.8\">\n<h2 data-number=\"2.8\">2.8 - Extending the Parser</h2>\n<p>Before we move on and extend our parser, we first need to clean up and extend our existing test suite. I won’t bore you by listing the complete changes, but I will show you a few small helper functions that make the tests easier to understand.</p>\n<p>We already have a <code>testIntegerLiteral</code> test helper. A second function called <code>testIdentifier</code> can clean up a lot of other tests:</p>\n<div class=\"sourceCode\" id=\"cb119\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb119-1\"><a href=\"#cb119-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb119-2\"><a href=\"#cb119-2\"></a></span>\n<span id=\"cb119-3\"><a href=\"#cb119-3\"></a><span class=\"kw\">func</span> testIdentifier(t *testing.T, exp ast.Expression, value <span class=\"dt\">string</span>) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb119-4\"><a href=\"#cb119-4\"></a>    ident, ok := exp.(*ast.Identifier)</span>\n<span id=\"cb119-5\"><a href=\"#cb119-5\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb119-6\"><a href=\"#cb119-6\"></a>        t.Errorf(<span class=\"st\">&quot;exp not *ast.Identifier. got=%T&quot;</span>, exp)</span>\n<span id=\"cb119-7\"><a href=\"#cb119-7\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb119-8\"><a href=\"#cb119-8\"></a>    }</span>\n<span id=\"cb119-9\"><a href=\"#cb119-9\"></a></span>\n<span id=\"cb119-10\"><a href=\"#cb119-10\"></a>    <span class=\"kw\">if</span> ident.Value != value {</span>\n<span id=\"cb119-11\"><a href=\"#cb119-11\"></a>        t.Errorf(<span class=\"st\">&quot;ident.Value not %s. got=%s&quot;</span>, value, ident.Value)</span>\n<span id=\"cb119-12\"><a href=\"#cb119-12\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb119-13\"><a href=\"#cb119-13\"></a>    }</span>\n<span id=\"cb119-14\"><a href=\"#cb119-14\"></a></span>\n<span id=\"cb119-15\"><a href=\"#cb119-15\"></a>    <span class=\"kw\">if</span> ident.TokenLiteral() != value {</span>\n<span id=\"cb119-16\"><a href=\"#cb119-16\"></a>        t.Errorf(<span class=\"st\">&quot;ident.TokenLiteral not %s. got=%s&quot;</span>, value,</span>\n<span id=\"cb119-17\"><a href=\"#cb119-17\"></a>            ident.TokenLiteral())</span>\n<span id=\"cb119-18\"><a href=\"#cb119-18\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb119-19\"><a href=\"#cb119-19\"></a>    }</span>\n<span id=\"cb119-20\"><a href=\"#cb119-20\"></a></span>\n<span id=\"cb119-21\"><a href=\"#cb119-21\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb119-22\"><a href=\"#cb119-22\"></a>}</span></code></pre></div>\n<p>The fun part is now using <code>testIntegerLiteral</code> and <code>testIdentifier</code> to build more generic helper functions:</p>\n<div class=\"sourceCode\" id=\"cb120\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb120-1\"><a href=\"#cb120-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb120-2\"><a href=\"#cb120-2\"></a></span>\n<span id=\"cb120-3\"><a href=\"#cb120-3\"></a><span class=\"kw\">func</span> testLiteralExpression(</span>\n<span id=\"cb120-4\"><a href=\"#cb120-4\"></a>    t *testing.T,</span>\n<span id=\"cb120-5\"><a href=\"#cb120-5\"></a>    exp ast.Expression,</span>\n<span id=\"cb120-6\"><a href=\"#cb120-6\"></a>    expected <span class=\"kw\">interface</span>{},</span>\n<span id=\"cb120-7\"><a href=\"#cb120-7\"></a>) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb120-8\"><a href=\"#cb120-8\"></a>    <span class=\"kw\">switch</span> v := expected.(<span class=\"kw\">type</span>) {</span>\n<span id=\"cb120-9\"><a href=\"#cb120-9\"></a>    <span class=\"kw\">case</span> <span class=\"dt\">int</span>:</span>\n<span id=\"cb120-10\"><a href=\"#cb120-10\"></a>        <span class=\"kw\">return</span> testIntegerLiteral(t, exp, <span class=\"dt\">int64</span>(v))</span>\n<span id=\"cb120-11\"><a href=\"#cb120-11\"></a>    <span class=\"kw\">case</span> <span class=\"dt\">int64</span>:</span>\n<span id=\"cb120-12\"><a href=\"#cb120-12\"></a>        <span class=\"kw\">return</span> testIntegerLiteral(t, exp, v)</span>\n<span id=\"cb120-13\"><a href=\"#cb120-13\"></a>    <span class=\"kw\">case</span> <span class=\"dt\">string</span>:</span>\n<span id=\"cb120-14\"><a href=\"#cb120-14\"></a>        <span class=\"kw\">return</span> testIdentifier(t, exp, v)</span>\n<span id=\"cb120-15\"><a href=\"#cb120-15\"></a>    }</span>\n<span id=\"cb120-16\"><a href=\"#cb120-16\"></a>    t.Errorf(<span class=\"st\">&quot;type of exp not handled. got=%T&quot;</span>, exp)</span>\n<span id=\"cb120-17\"><a href=\"#cb120-17\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb120-18\"><a href=\"#cb120-18\"></a>}</span>\n<span id=\"cb120-19\"><a href=\"#cb120-19\"></a></span>\n<span id=\"cb120-20\"><a href=\"#cb120-20\"></a><span class=\"kw\">func</span> testInfixExpression(t *testing.T, exp ast.Expression, left <span class=\"kw\">interface</span>{},</span>\n<span id=\"cb120-21\"><a href=\"#cb120-21\"></a>    operator <span class=\"dt\">string</span>, right <span class=\"kw\">interface</span>{}) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb120-22\"><a href=\"#cb120-22\"></a></span>\n<span id=\"cb120-23\"><a href=\"#cb120-23\"></a>    opExp, ok := exp.(*ast.InfixExpression)</span>\n<span id=\"cb120-24\"><a href=\"#cb120-24\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb120-25\"><a href=\"#cb120-25\"></a>        t.Errorf(<span class=\"st\">&quot;exp is not ast.InfixExpression. got=%T(%s)&quot;</span>, exp, exp)</span>\n<span id=\"cb120-26\"><a href=\"#cb120-26\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb120-27\"><a href=\"#cb120-27\"></a>    }</span>\n<span id=\"cb120-28\"><a href=\"#cb120-28\"></a></span>\n<span id=\"cb120-29\"><a href=\"#cb120-29\"></a>    <span class=\"kw\">if</span> !testLiteralExpression(t, opExp.Left, left) {</span>\n<span id=\"cb120-30\"><a href=\"#cb120-30\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb120-31\"><a href=\"#cb120-31\"></a>    }</span>\n<span id=\"cb120-32\"><a href=\"#cb120-32\"></a></span>\n<span id=\"cb120-33\"><a href=\"#cb120-33\"></a>    <span class=\"kw\">if</span> opExp.Operator != operator {</span>\n<span id=\"cb120-34\"><a href=\"#cb120-34\"></a>        t.Errorf(<span class=\"st\">&quot;exp.Operator is not &#39;%s&#39;. got=%q&quot;</span>, operator, opExp.Operator)</span>\n<span id=\"cb120-35\"><a href=\"#cb120-35\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb120-36\"><a href=\"#cb120-36\"></a>    }</span>\n<span id=\"cb120-37\"><a href=\"#cb120-37\"></a></span>\n<span id=\"cb120-38\"><a href=\"#cb120-38\"></a>    <span class=\"kw\">if</span> !testLiteralExpression(t, opExp.Right, right) {</span>\n<span id=\"cb120-39\"><a href=\"#cb120-39\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb120-40\"><a href=\"#cb120-40\"></a>    }</span>\n<span id=\"cb120-41\"><a href=\"#cb120-41\"></a></span>\n<span id=\"cb120-42\"><a href=\"#cb120-42\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb120-43\"><a href=\"#cb120-43\"></a>}</span></code></pre></div>\n<p>With these in place it’s possible to write test code like this:</p>\n<div class=\"sourceCode\" id=\"cb121\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb121-1\"><a href=\"#cb121-1\"></a>testInfixExpression(t, stmt.Expression, <span class=\"dv\">5</span>, <span class=\"st\">&quot;+&quot;</span>, <span class=\"dv\">10</span>)</span>\n<span id=\"cb121-2\"><a href=\"#cb121-2\"></a>testInfixExpression(t, stmt.Expression, <span class=\"st\">&quot;alice&quot;</span>, <span class=\"st\">&quot;*&quot;</span>, <span class=\"st\">&quot;bob&quot;</span>)</span></code></pre></div>\n<p>That makes it a lot easier to test properties of the ASTs produced by our parser. I went ahead and changed our existing parser tests to use these new test helpers. In <code>parser/parser_test.go</code> you can see the cleaned up and extended test suite.</p>\n<section id=\"boolean-literals\" class=\"level3\" data-number=\"2.8.1\">\n<h3 data-number=\"2.8.1\">Boolean Literals</h3>\n<p>There are a few things in the Monkey programming language that we still need to implement in our parser and AST. Easiest are boolean literals. In Monkey we can use booleans in place of any other expression:</p>\n<div class=\"sourceCode\" id=\"cb122\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb122-1\"><a href=\"#cb122-1\"></a><span class=\"kw\">true</span><span class=\"op\">;</span></span>\n<span id=\"cb122-2\"><a href=\"#cb122-2\"></a><span class=\"kw\">false</span><span class=\"op\">;</span></span>\n<span id=\"cb122-3\"><a href=\"#cb122-3\"></a><span class=\"kw\">let</span> foobar <span class=\"op\">=</span> <span class=\"kw\">true</span><span class=\"op\">;</span></span>\n<span id=\"cb122-4\"><a href=\"#cb122-4\"></a><span class=\"kw\">let</span> barfoo <span class=\"op\">=</span> <span class=\"kw\">false</span><span class=\"op\">;</span></span></code></pre></div>\n<p>Like identifiers and integer literals their AST representation is simple and small:</p>\n<div class=\"sourceCode\" id=\"cb123\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb123-1\"><a href=\"#cb123-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb123-2\"><a href=\"#cb123-2\"></a></span>\n<span id=\"cb123-3\"><a href=\"#cb123-3\"></a><span class=\"kw\">type</span> Boolean <span class=\"kw\">struct</span> {</span>\n<span id=\"cb123-4\"><a href=\"#cb123-4\"></a>    Token token.Token</span>\n<span id=\"cb123-5\"><a href=\"#cb123-5\"></a>    Value <span class=\"dt\">bool</span></span>\n<span id=\"cb123-6\"><a href=\"#cb123-6\"></a>}</span>\n<span id=\"cb123-7\"><a href=\"#cb123-7\"></a></span>\n<span id=\"cb123-8\"><a href=\"#cb123-8\"></a><span class=\"kw\">func</span> (b *Boolean) expressionNode()      {}</span>\n<span id=\"cb123-9\"><a href=\"#cb123-9\"></a><span class=\"kw\">func</span> (b *Boolean) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> b.Token.Literal }</span>\n<span id=\"cb123-10\"><a href=\"#cb123-10\"></a><span class=\"kw\">func</span> (b *Boolean) String() <span class=\"dt\">string</span>       { <span class=\"kw\">return</span> b.Token.Literal }</span></code></pre></div>\n<p>The <code>Value</code> field can hold values of the type <code>bool</code>, which means that we’re going to save either <code>true</code> or <code>false</code> in there (the Go <code>bool</code> values, not the Monkey literals). With the AST node defined we can now add our tests.</p>\n<p>The single <code>TestBooleanExpression</code> test function is so similar to the existing <code>TestIdentifierExpression</code> and <code>TestIntegerLiteralExpression</code> that I won’t show it here. It’s enough to show the error message which points us in the right direction as to how to implement boolean literal parsing:</p>\n<div class=\"sourceCode\" id=\"cb124\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb124-1\"><a href=\"#cb124-1\"></a>$ go test ./parser</span>\n<span id=\"cb124-2\"><a href=\"#cb124-2\"></a>--- FAIL: TestBooleanExpression (0.00s)</span>\n<span id=\"cb124-3\"><a href=\"#cb124-3\"></a>  parser_test.go:470: parser has 1 errors</span>\n<span id=\"cb124-4\"><a href=\"#cb124-4\"></a>  parser_test.go:472: parser error: &quot;no prefix parse function for TRUE found&quot;</span>\n<span id=\"cb124-5\"><a href=\"#cb124-5\"></a>FAIL</span>\n<span id=\"cb124-6\"><a href=\"#cb124-6\"></a>FAIL    monkey/parser   0.008s</span></code></pre></div>\n<p>Of course, yes. We need to register a <code>prefixParseFn</code> for <code>token.TRUE</code> and <code>token.FALSE</code> tokens.</p>\n<div class=\"sourceCode\" id=\"cb125\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb125-1\"><a href=\"#cb125-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb125-2\"><a href=\"#cb125-2\"></a></span>\n<span id=\"cb125-3\"><a href=\"#cb125-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb125-4\"><a href=\"#cb125-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb125-5\"><a href=\"#cb125-5\"></a>    p.registerPrefix(token.TRUE, p.parseBoolean)</span>\n<span id=\"cb125-6\"><a href=\"#cb125-6\"></a>    p.registerPrefix(token.FALSE, p.parseBoolean)</span>\n<span id=\"cb125-7\"><a href=\"#cb125-7\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb125-8\"><a href=\"#cb125-8\"></a>}</span></code></pre></div>\n<p>And the <code>parseBoolean</code> method is exactly what you imagine it to be:</p>\n<div class=\"sourceCode\" id=\"cb126\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb126-1\"><a href=\"#cb126-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb126-2\"><a href=\"#cb126-2\"></a></span>\n<span id=\"cb126-3\"><a href=\"#cb126-3\"></a><span class=\"kw\">func</span> (p *Parser) parseBoolean() ast.Expression {</span>\n<span id=\"cb126-4\"><a href=\"#cb126-4\"></a>    <span class=\"kw\">return</span> &amp;ast.Boolean{Token: p.curToken, Value: p.curTokenIs(token.TRUE)}</span>\n<span id=\"cb126-5\"><a href=\"#cb126-5\"></a>}</span></code></pre></div>\n<p>The only mildly interesting part about this method is the inlining of the <code>p.curTokenIs(token.TRUE)</code> call, which is not really interesting. Other than that it’s straightforward, maybe even boring. Or in other words: the structure of our parser serves us well! That actually is one of the beauties of Pratt’s approach: it’s so easy to extend.</p>\n<p>And boom! The tests are green:</p>\n<div class=\"sourceCode\" id=\"cb127\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb127-1\"><a href=\"#cb127-1\"></a>$ go test ./parser</span>\n<span id=\"cb127-2\"><a href=\"#cb127-2\"></a>ok      monkey/parser   0.006s</span></code></pre></div>\n<p>But what’s interesting is that we can now extend several tests to incorporate the newly implemented boolean literals. The first candidate is <code>TestOperatorPrecedenceParsing</code>, with its string comparison mechanism:</p>\n<div class=\"sourceCode\" id=\"cb128\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb128-1\"><a href=\"#cb128-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb128-2\"><a href=\"#cb128-2\"></a></span>\n<span id=\"cb128-3\"><a href=\"#cb128-3\"></a><span class=\"kw\">func</span> TestOperatorPrecedenceParsing(t *testing.T) {</span>\n<span id=\"cb128-4\"><a href=\"#cb128-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb128-5\"><a href=\"#cb128-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb128-6\"><a href=\"#cb128-6\"></a>        expected <span class=\"dt\">string</span></span>\n<span id=\"cb128-7\"><a href=\"#cb128-7\"></a>    }{</span>\n<span id=\"cb128-8\"><a href=\"#cb128-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb128-9\"><a href=\"#cb128-9\"></a>        {</span>\n<span id=\"cb128-10\"><a href=\"#cb128-10\"></a>            <span class=\"st\">&quot;true&quot;</span>,</span>\n<span id=\"cb128-11\"><a href=\"#cb128-11\"></a>            <span class=\"st\">&quot;true&quot;</span>,</span>\n<span id=\"cb128-12\"><a href=\"#cb128-12\"></a>        },</span>\n<span id=\"cb128-13\"><a href=\"#cb128-13\"></a>        {</span>\n<span id=\"cb128-14\"><a href=\"#cb128-14\"></a>            <span class=\"st\">&quot;false&quot;</span>,</span>\n<span id=\"cb128-15\"><a href=\"#cb128-15\"></a>            <span class=\"st\">&quot;false&quot;</span>,</span>\n<span id=\"cb128-16\"><a href=\"#cb128-16\"></a>        },</span>\n<span id=\"cb128-17\"><a href=\"#cb128-17\"></a>        {</span>\n<span id=\"cb128-18\"><a href=\"#cb128-18\"></a>            <span class=\"st\">&quot;3 &gt; 5 == false&quot;</span>,</span>\n<span id=\"cb128-19\"><a href=\"#cb128-19\"></a>            <span class=\"st\">&quot;((3 &gt; 5) == false)&quot;</span>,</span>\n<span id=\"cb128-20\"><a href=\"#cb128-20\"></a>        },</span>\n<span id=\"cb128-21\"><a href=\"#cb128-21\"></a>        {</span>\n<span id=\"cb128-22\"><a href=\"#cb128-22\"></a>            <span class=\"st\">&quot;3 &lt; 5 == true&quot;</span>,</span>\n<span id=\"cb128-23\"><a href=\"#cb128-23\"></a>            <span class=\"st\">&quot;((3 &lt; 5) == true)&quot;</span>,</span>\n<span id=\"cb128-24\"><a href=\"#cb128-24\"></a>        },</span>\n<span id=\"cb128-25\"><a href=\"#cb128-25\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb128-26\"><a href=\"#cb128-26\"></a>}</span></code></pre></div>\n<p>We can test for boolean literals in even more tests by extending our <code>testLiteralExpression</code> helper and providing a new <code>testBooleanLiteral</code> function:</p>\n<div class=\"sourceCode\" id=\"cb129\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb129-1\"><a href=\"#cb129-1\"></a><span class=\"co\">// parser_test.go</span></span>\n<span id=\"cb129-2\"><a href=\"#cb129-2\"></a></span>\n<span id=\"cb129-3\"><a href=\"#cb129-3\"></a><span class=\"kw\">func</span> testLiteralExpression(</span>\n<span id=\"cb129-4\"><a href=\"#cb129-4\"></a>    t *testing.T,</span>\n<span id=\"cb129-5\"><a href=\"#cb129-5\"></a>    exp ast.Expression,</span>\n<span id=\"cb129-6\"><a href=\"#cb129-6\"></a>    expected <span class=\"kw\">interface</span>{},</span>\n<span id=\"cb129-7\"><a href=\"#cb129-7\"></a>) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb129-8\"><a href=\"#cb129-8\"></a>    <span class=\"kw\">switch</span> v := expected.(<span class=\"kw\">type</span>) {</span>\n<span id=\"cb129-9\"><a href=\"#cb129-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb129-10\"><a href=\"#cb129-10\"></a>    <span class=\"kw\">case</span> <span class=\"dt\">bool</span>:</span>\n<span id=\"cb129-11\"><a href=\"#cb129-11\"></a>        <span class=\"kw\">return</span> testBooleanLiteral(t, exp, v)</span>\n<span id=\"cb129-12\"><a href=\"#cb129-12\"></a>    }</span>\n<span id=\"cb129-13\"><a href=\"#cb129-13\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb129-14\"><a href=\"#cb129-14\"></a>}</span>\n<span id=\"cb129-15\"><a href=\"#cb129-15\"></a></span>\n<span id=\"cb129-16\"><a href=\"#cb129-16\"></a><span class=\"kw\">func</span> testBooleanLiteral(t *testing.T, exp ast.Expression, value <span class=\"dt\">bool</span>) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb129-17\"><a href=\"#cb129-17\"></a>    bo, ok := exp.(*ast.Boolean)</span>\n<span id=\"cb129-18\"><a href=\"#cb129-18\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb129-19\"><a href=\"#cb129-19\"></a>        t.Errorf(<span class=\"st\">&quot;exp not *ast.Boolean. got=%T&quot;</span>, exp)</span>\n<span id=\"cb129-20\"><a href=\"#cb129-20\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb129-21\"><a href=\"#cb129-21\"></a>    }</span>\n<span id=\"cb129-22\"><a href=\"#cb129-22\"></a></span>\n<span id=\"cb129-23\"><a href=\"#cb129-23\"></a>    <span class=\"kw\">if</span> bo.Value != value {</span>\n<span id=\"cb129-24\"><a href=\"#cb129-24\"></a>        t.Errorf(<span class=\"st\">&quot;bo.Value not %t. got=%t&quot;</span>, value, bo.Value)</span>\n<span id=\"cb129-25\"><a href=\"#cb129-25\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb129-26\"><a href=\"#cb129-26\"></a>    }</span>\n<span id=\"cb129-27\"><a href=\"#cb129-27\"></a></span>\n<span id=\"cb129-28\"><a href=\"#cb129-28\"></a>    <span class=\"kw\">if</span> bo.TokenLiteral() != fmt.Sprintf(<span class=\"st\">&quot;%t&quot;</span>, value) {</span>\n<span id=\"cb129-29\"><a href=\"#cb129-29\"></a>        t.Errorf(<span class=\"st\">&quot;bo.TokenLiteral not %t. got=%s&quot;</span>,</span>\n<span id=\"cb129-30\"><a href=\"#cb129-30\"></a>            value, bo.TokenLiteral())</span>\n<span id=\"cb129-31\"><a href=\"#cb129-31\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb129-32\"><a href=\"#cb129-32\"></a>    }</span>\n<span id=\"cb129-33\"><a href=\"#cb129-33\"></a></span>\n<span id=\"cb129-34\"><a href=\"#cb129-34\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb129-35\"><a href=\"#cb129-35\"></a>}</span></code></pre></div>\n<p>Nothing surprising here, just another case in a switch statement and a new helper function. But with this in place, it’s easy to extend <code>TestParsingInfixExpressions</code>:</p>\n<div class=\"sourceCode\" id=\"cb130\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb130-1\"><a href=\"#cb130-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb130-2\"><a href=\"#cb130-2\"></a></span>\n<span id=\"cb130-3\"><a href=\"#cb130-3\"></a><span class=\"kw\">func</span> TestParsingInfixExpressions(t *testing.T) {</span>\n<span id=\"cb130-4\"><a href=\"#cb130-4\"></a>    infixTests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb130-5\"><a href=\"#cb130-5\"></a>        input      <span class=\"dt\">string</span></span>\n<span id=\"cb130-6\"><a href=\"#cb130-6\"></a>        leftValue  <span class=\"kw\">interface</span>{}</span>\n<span id=\"cb130-7\"><a href=\"#cb130-7\"></a>        operator   <span class=\"dt\">string</span></span>\n<span id=\"cb130-8\"><a href=\"#cb130-8\"></a>        rightValue <span class=\"kw\">interface</span>{}</span>\n<span id=\"cb130-9\"><a href=\"#cb130-9\"></a>    }{</span>\n<span id=\"cb130-10\"><a href=\"#cb130-10\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb130-11\"><a href=\"#cb130-11\"></a>        {<span class=\"st\">&quot;true == true&quot;</span>, <span class=\"ot\">true</span>, <span class=\"st\">&quot;==&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb130-12\"><a href=\"#cb130-12\"></a>        {<span class=\"st\">&quot;true != false&quot;</span>, <span class=\"ot\">true</span>, <span class=\"st\">&quot;!=&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb130-13\"><a href=\"#cb130-13\"></a>        {<span class=\"st\">&quot;false == false&quot;</span>, <span class=\"ot\">false</span>, <span class=\"st\">&quot;==&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb130-14\"><a href=\"#cb130-14\"></a>    }</span>\n<span id=\"cb130-15\"><a href=\"#cb130-15\"></a></span>\n<span id=\"cb130-16\"><a href=\"#cb130-16\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> infixTests {</span>\n<span id=\"cb130-17\"><a href=\"#cb130-17\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb130-18\"><a href=\"#cb130-18\"></a></span>\n<span id=\"cb130-19\"><a href=\"#cb130-19\"></a>        <span class=\"kw\">if</span> !testInfixExpression(t, stmt.Expression, tt.leftValue,</span>\n<span id=\"cb130-20\"><a href=\"#cb130-20\"></a>            tt.operator, tt.rightValue) {</span>\n<span id=\"cb130-21\"><a href=\"#cb130-21\"></a>            <span class=\"kw\">return</span></span>\n<span id=\"cb130-22\"><a href=\"#cb130-22\"></a>        }</span>\n<span id=\"cb130-23\"><a href=\"#cb130-23\"></a>    }</span>\n<span id=\"cb130-24\"><a href=\"#cb130-24\"></a>}</span></code></pre></div>\n<p>And also <code>TestParsingPrefixExpressions</code> is easy to extend by just adding new entries to the test table:</p>\n<div class=\"sourceCode\" id=\"cb131\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb131-1\"><a href=\"#cb131-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb131-2\"><a href=\"#cb131-2\"></a></span>\n<span id=\"cb131-3\"><a href=\"#cb131-3\"></a><span class=\"kw\">func</span> TestParsingPrefixExpressions(t *testing.T) {</span>\n<span id=\"cb131-4\"><a href=\"#cb131-4\"></a>    prefixTests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb131-5\"><a href=\"#cb131-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb131-6\"><a href=\"#cb131-6\"></a>        operator <span class=\"dt\">string</span></span>\n<span id=\"cb131-7\"><a href=\"#cb131-7\"></a>        value    <span class=\"kw\">interface</span>{}</span>\n<span id=\"cb131-8\"><a href=\"#cb131-8\"></a>    }{</span>\n<span id=\"cb131-9\"><a href=\"#cb131-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb131-10\"><a href=\"#cb131-10\"></a>        {<span class=\"st\">&quot;!true;&quot;</span>, <span class=\"st\">&quot;!&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb131-11\"><a href=\"#cb131-11\"></a>        {<span class=\"st\">&quot;!false;&quot;</span>, <span class=\"st\">&quot;!&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb131-12\"><a href=\"#cb131-12\"></a>    }</span>\n<span id=\"cb131-13\"><a href=\"#cb131-13\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb131-14\"><a href=\"#cb131-14\"></a>}</span></code></pre></div>\n<p>It’s time to pat ourselves on the back! We implemented the parsing of booleans and extended our tests in a way that gives us more test coverage now and better tools later on. Good job!</p>\n</section>\n<section id=\"grouped-expressions\" class=\"level3\" data-number=\"2.8.2\">\n<h3 data-number=\"2.8.2\">Grouped Expressions</h3>\n<p>What we’re about to see next is sometimes called “the greatest trick Vaughan Pratt ever pulled”. Actually, no, I just lied there, nobody says that. But they should! I’m talking about parsing grouped expressions, of course. In Monkey we can group expression with parentheses to influence their precedence and thus the order in which they are evaluated in their context. We’ve seen the canonical example for this before:</p>\n<div class=\"sourceCode\" id=\"cb132\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb132-1\"><a href=\"#cb132-1\"></a>(<span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">5</span>) <span class=\"op\">*</span> <span class=\"dv\">2</span><span class=\"op\">;</span></span></code></pre></div>\n<p>The parentheses group the <code>5 + 5</code> expression in order to give them a higher precedence and position them deeper in the AST, resulting in the correct evaluation order for this mathematical expression.</p>\n<p>Now you might be thinking <em>“Oh come on, not with the precedence stuff again! My head still hurts! This guy…”</em> and you contemplate whether to skip to the end of this chapter. Don’t! You have to see this!</p>\n<p>We’re not going to write a unit test for grouped expressions, since they are not represented by a separate AST node type. Yes, that’s right. We do not need to change our AST in order to parse grouped expressions correctly! What we’re going to do instead is to extend our <code>TestOperatorPrecedenceParsing</code> test function to make sure that parentheses actually group expressions and have an effect on the resulting AST.</p>\n<div class=\"sourceCode\" id=\"cb133\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb133-1\"><a href=\"#cb133-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb133-2\"><a href=\"#cb133-2\"></a></span>\n<span id=\"cb133-3\"><a href=\"#cb133-3\"></a><span class=\"kw\">func</span> TestOperatorPrecedenceParsing(t *testing.T) {</span>\n<span id=\"cb133-4\"><a href=\"#cb133-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb133-5\"><a href=\"#cb133-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb133-6\"><a href=\"#cb133-6\"></a>        expected <span class=\"dt\">string</span></span>\n<span id=\"cb133-7\"><a href=\"#cb133-7\"></a>    }{</span>\n<span id=\"cb133-8\"><a href=\"#cb133-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb133-9\"><a href=\"#cb133-9\"></a>        {</span>\n<span id=\"cb133-10\"><a href=\"#cb133-10\"></a>            <span class=\"st\">&quot;1 + (2 + 3) + 4&quot;</span>,</span>\n<span id=\"cb133-11\"><a href=\"#cb133-11\"></a>            <span class=\"st\">&quot;((1 + (2 + 3)) + 4)&quot;</span>,</span>\n<span id=\"cb133-12\"><a href=\"#cb133-12\"></a>        },</span>\n<span id=\"cb133-13\"><a href=\"#cb133-13\"></a>        {</span>\n<span id=\"cb133-14\"><a href=\"#cb133-14\"></a>            <span class=\"st\">&quot;(5 + 5) * 2&quot;</span>,</span>\n<span id=\"cb133-15\"><a href=\"#cb133-15\"></a>            <span class=\"st\">&quot;((5 + 5) * 2)&quot;</span>,</span>\n<span id=\"cb133-16\"><a href=\"#cb133-16\"></a>        },</span>\n<span id=\"cb133-17\"><a href=\"#cb133-17\"></a>        {</span>\n<span id=\"cb133-18\"><a href=\"#cb133-18\"></a>            <span class=\"st\">&quot;2 / (5 + 5)&quot;</span>,</span>\n<span id=\"cb133-19\"><a href=\"#cb133-19\"></a>            <span class=\"st\">&quot;(2 / (5 + 5))&quot;</span>,</span>\n<span id=\"cb133-20\"><a href=\"#cb133-20\"></a>        },</span>\n<span id=\"cb133-21\"><a href=\"#cb133-21\"></a>        {</span>\n<span id=\"cb133-22\"><a href=\"#cb133-22\"></a>            <span class=\"st\">&quot;-(5 + 5)&quot;</span>,</span>\n<span id=\"cb133-23\"><a href=\"#cb133-23\"></a>            <span class=\"st\">&quot;(-(5 + 5))&quot;</span>,</span>\n<span id=\"cb133-24\"><a href=\"#cb133-24\"></a>        },</span>\n<span id=\"cb133-25\"><a href=\"#cb133-25\"></a>        {</span>\n<span id=\"cb133-26\"><a href=\"#cb133-26\"></a>            <span class=\"st\">&quot;!(true == true)&quot;</span>,</span>\n<span id=\"cb133-27\"><a href=\"#cb133-27\"></a>            <span class=\"st\">&quot;(!(true == true))&quot;</span>,</span>\n<span id=\"cb133-28\"><a href=\"#cb133-28\"></a>        },</span>\n<span id=\"cb133-29\"><a href=\"#cb133-29\"></a>    }</span>\n<span id=\"cb133-30\"><a href=\"#cb133-30\"></a></span>\n<span id=\"cb133-31\"><a href=\"#cb133-31\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb133-32\"><a href=\"#cb133-32\"></a>}</span></code></pre></div>\n<p>They fail, as expected:</p>\n<div class=\"sourceCode\" id=\"cb134\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb134-1\"><a href=\"#cb134-1\"></a>$ <span class=\"kw\">go</span> test ./parser</span>\n<span id=\"cb134-2\"><a href=\"#cb134-2\"></a>--- FAIL: TestOperatorPrecedenceParsing (<span class=\"dv\">0</span><span class=\"fl\">.00</span>s)</span>\n<span id=\"cb134-3\"><a href=\"#cb134-3\"></a>  parser_test.<span class=\"kw\">go</span>:<span class=\"dv\">531</span>: parser has <span class=\"dv\">3</span> errors</span>\n<span id=\"cb134-4\"><a href=\"#cb134-4\"></a>  parser_test.<span class=\"kw\">go</span>:<span class=\"dv\">533</span>: parser <span class=\"dt\">error</span>: <span class=\"st\">&quot;no prefix parse function for ( found&quot;</span></span>\n<span id=\"cb134-5\"><a href=\"#cb134-5\"></a>  parser_test.<span class=\"kw\">go</span>:<span class=\"dv\">533</span>: parser <span class=\"dt\">error</span>: <span class=\"st\">&quot;no prefix parse function for ) found&quot;</span></span>\n<span id=\"cb134-6\"><a href=\"#cb134-6\"></a>  parser_test.<span class=\"kw\">go</span>:<span class=\"dv\">533</span>: parser <span class=\"dt\">error</span>: <span class=\"st\">&quot;no prefix parse function for + found&quot;</span></span>\n<span id=\"cb134-7\"><a href=\"#cb134-7\"></a>FAIL</span>\n<span id=\"cb134-8\"><a href=\"#cb134-8\"></a>FAIL    monkey/parser   <span class=\"dv\">0</span><span class=\"fl\">.007</span>s</span></code></pre></div>\n<p>Here comes the mind-blowing part. In order to get these tests to pass, all we need to do is add this:</p>\n<div class=\"sourceCode\" id=\"cb135\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb135-1\"><a href=\"#cb135-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb135-2\"><a href=\"#cb135-2\"></a></span>\n<span id=\"cb135-3\"><a href=\"#cb135-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb135-4\"><a href=\"#cb135-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb135-5\"><a href=\"#cb135-5\"></a>    p.registerPrefix(token.LPAREN, p.parseGroupedExpression)</span>\n<span id=\"cb135-6\"><a href=\"#cb135-6\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb135-7\"><a href=\"#cb135-7\"></a>}</span>\n<span id=\"cb135-8\"><a href=\"#cb135-8\"></a></span>\n<span id=\"cb135-9\"><a href=\"#cb135-9\"></a><span class=\"kw\">func</span> (p *Parser) parseGroupedExpression() ast.Expression {</span>\n<span id=\"cb135-10\"><a href=\"#cb135-10\"></a>    p.nextToken()</span>\n<span id=\"cb135-11\"><a href=\"#cb135-11\"></a></span>\n<span id=\"cb135-12\"><a href=\"#cb135-12\"></a>    exp := p.parseExpression(LOWEST)</span>\n<span id=\"cb135-13\"><a href=\"#cb135-13\"></a></span>\n<span id=\"cb135-14\"><a href=\"#cb135-14\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.RPAREN) {</span>\n<span id=\"cb135-15\"><a href=\"#cb135-15\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb135-16\"><a href=\"#cb135-16\"></a>    }</span>\n<span id=\"cb135-17\"><a href=\"#cb135-17\"></a></span>\n<span id=\"cb135-18\"><a href=\"#cb135-18\"></a>    <span class=\"kw\">return</span> exp</span>\n<span id=\"cb135-19\"><a href=\"#cb135-19\"></a>}</span></code></pre></div>\n<p>And that’s it! Yes, it really is. The tests pass and the parentheses work as expected by boosting the precedence of the enclosed expressions. The concept of associating token types with functions really shines here. That’s all there is to it. There is nothing happening here that we haven’t seen before.</p>\n<p>I told you, didn’t I? It’s a great trick. With that said, let’s keep some of the magic and move on.</p>\n</section>\n<section id=\"if-expressions\" class=\"level3\" data-number=\"2.8.3\">\n<h3 data-number=\"2.8.3\">If Expressions</h3>\n<p>In Monkey we can use <code>if</code> and <code>else</code> just like we did hundreds of times in other programming languages:</p>\n<div class=\"sourceCode\" id=\"cb136\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb136-1\"><a href=\"#cb136-1\"></a><span class=\"cf\">if</span> (x <span class=\"op\">&gt;</span> y) {</span>\n<span id=\"cb136-2\"><a href=\"#cb136-2\"></a>  <span class=\"cf\">return</span> x<span class=\"op\">;</span></span>\n<span id=\"cb136-3\"><a href=\"#cb136-3\"></a>} <span class=\"cf\">else</span> {</span>\n<span id=\"cb136-4\"><a href=\"#cb136-4\"></a>  <span class=\"cf\">return</span> y<span class=\"op\">;</span></span>\n<span id=\"cb136-5\"><a href=\"#cb136-5\"></a>}</span></code></pre></div>\n<p>The <code>else</code> is optional and can be left out:</p>\n<div class=\"sourceCode\" id=\"cb137\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb137-1\"><a href=\"#cb137-1\"></a><span class=\"cf\">if</span> (x <span class=\"op\">&gt;</span> y) {</span>\n<span id=\"cb137-2\"><a href=\"#cb137-2\"></a>  <span class=\"cf\">return</span> x<span class=\"op\">;</span></span>\n<span id=\"cb137-3\"><a href=\"#cb137-3\"></a>}</span></code></pre></div>\n<p>That’s all very familiar. In Monkey though, if-else-conditionals are expressions. That means that they produce a value and in the case of if expressions that’s the last evaluated line. We don’t need the return statements here:</p>\n<div class=\"sourceCode\" id=\"cb138\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb138-1\"><a href=\"#cb138-1\"></a><span class=\"kw\">let</span> foobar <span class=\"op\">=</span> <span class=\"cf\">if</span> (x <span class=\"op\">&gt;</span> y) { x } <span class=\"cf\">else</span> { y }<span class=\"op\">;</span></span></code></pre></div>\n<p>Explaining the structure of if-else-conditionals is probably not necessary, but just so we’re clear on the naming, here it is:</p>\n<div class=\"sourceCode\" id=\"cb139\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb139-1\"><a href=\"#cb139-1\"></a>if (&lt;condition&gt;) &lt;consequence&gt; else &lt;alternative&gt;</span></code></pre></div>\n<p>The braces are part of <code>consequence</code> and <code>alternative</code>, because both are block statements. Block statements are a series of statements (just like programs in Monkey) enclosed by an opening <code>{</code> and a closing <code>}</code>.</p>\n<p>So far our recipe for success has been to “define AST nodes, write tests, make tests pass by writing parsing code, celebrate, pat ourselves on the back, congratulate each other, tell everyone” and, well, there’s no reason to change it now.</p>\n<p>Here is the definition of the <code>ast.IfExpression</code> AST node:</p>\n<div class=\"sourceCode\" id=\"cb140\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb140-1\"><a href=\"#cb140-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb140-2\"><a href=\"#cb140-2\"></a></span>\n<span id=\"cb140-3\"><a href=\"#cb140-3\"></a><span class=\"kw\">type</span> IfExpression <span class=\"kw\">struct</span> {</span>\n<span id=\"cb140-4\"><a href=\"#cb140-4\"></a>    Token       token.Token <span class=\"co\">// The &#39;if&#39; token</span></span>\n<span id=\"cb140-5\"><a href=\"#cb140-5\"></a>    Condition   Expression</span>\n<span id=\"cb140-6\"><a href=\"#cb140-6\"></a>    Consequence *BlockStatement</span>\n<span id=\"cb140-7\"><a href=\"#cb140-7\"></a>    Alternative *BlockStatement</span>\n<span id=\"cb140-8\"><a href=\"#cb140-8\"></a>}</span>\n<span id=\"cb140-9\"><a href=\"#cb140-9\"></a></span>\n<span id=\"cb140-10\"><a href=\"#cb140-10\"></a><span class=\"kw\">func</span> (ie *IfExpression) expressionNode()      {}</span>\n<span id=\"cb140-11\"><a href=\"#cb140-11\"></a><span class=\"kw\">func</span> (ie *IfExpression) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> ie.Token.Literal }</span>\n<span id=\"cb140-12\"><a href=\"#cb140-12\"></a><span class=\"kw\">func</span> (ie *IfExpression) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb140-13\"><a href=\"#cb140-13\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb140-14\"><a href=\"#cb140-14\"></a></span>\n<span id=\"cb140-15\"><a href=\"#cb140-15\"></a>    out.WriteString(<span class=\"st\">&quot;if&quot;</span>)</span>\n<span id=\"cb140-16\"><a href=\"#cb140-16\"></a>    out.WriteString(ie.Condition.String())</span>\n<span id=\"cb140-17\"><a href=\"#cb140-17\"></a>    out.WriteString(<span class=\"st\">&quot; &quot;</span>)</span>\n<span id=\"cb140-18\"><a href=\"#cb140-18\"></a>    out.WriteString(ie.Consequence.String())</span>\n<span id=\"cb140-19\"><a href=\"#cb140-19\"></a></span>\n<span id=\"cb140-20\"><a href=\"#cb140-20\"></a>    <span class=\"kw\">if</span> ie.Alternative != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb140-21\"><a href=\"#cb140-21\"></a>        out.WriteString(<span class=\"st\">&quot;else &quot;</span>)</span>\n<span id=\"cb140-22\"><a href=\"#cb140-22\"></a>        out.WriteString(ie.Alternative.String())</span>\n<span id=\"cb140-23\"><a href=\"#cb140-23\"></a>    }</span>\n<span id=\"cb140-24\"><a href=\"#cb140-24\"></a></span>\n<span id=\"cb140-25\"><a href=\"#cb140-25\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb140-26\"><a href=\"#cb140-26\"></a>}</span></code></pre></div>\n<p>No surprises here. <code>ast.IfExpression</code> fulfills the <code>ast.Expression</code> interface and has three fields that can represent an if-else-conditional. <code>Condition</code> holds the condition, which can be any expression, and <code>Consequence</code> and <code>Alternative</code> point to the consequence and alternative of the conditional respectively. But they reference a new type, <code>ast.BlockStatement</code>. As we saw before, the consequence/alternative of an if-else-condition is just a series of statements. That’s exactly what <code>ast.BlockStatement</code> represents:</p>\n<div class=\"sourceCode\" id=\"cb141\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb141-1\"><a href=\"#cb141-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb141-2\"><a href=\"#cb141-2\"></a></span>\n<span id=\"cb141-3\"><a href=\"#cb141-3\"></a><span class=\"kw\">type</span> BlockStatement <span class=\"kw\">struct</span> {</span>\n<span id=\"cb141-4\"><a href=\"#cb141-4\"></a>    Token      token.Token <span class=\"co\">// the { token</span></span>\n<span id=\"cb141-5\"><a href=\"#cb141-5\"></a>    Statements []Statement</span>\n<span id=\"cb141-6\"><a href=\"#cb141-6\"></a>}</span>\n<span id=\"cb141-7\"><a href=\"#cb141-7\"></a></span>\n<span id=\"cb141-8\"><a href=\"#cb141-8\"></a><span class=\"kw\">func</span> (bs *BlockStatement) statementNode()       {}</span>\n<span id=\"cb141-9\"><a href=\"#cb141-9\"></a><span class=\"kw\">func</span> (bs *BlockStatement) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> bs.Token.Literal }</span>\n<span id=\"cb141-10\"><a href=\"#cb141-10\"></a><span class=\"kw\">func</span> (bs *BlockStatement) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb141-11\"><a href=\"#cb141-11\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb141-12\"><a href=\"#cb141-12\"></a></span>\n<span id=\"cb141-13\"><a href=\"#cb141-13\"></a>    <span class=\"kw\">for</span> _, s := <span class=\"kw\">range</span> bs.Statements {</span>\n<span id=\"cb141-14\"><a href=\"#cb141-14\"></a>        out.WriteString(s.String())</span>\n<span id=\"cb141-15\"><a href=\"#cb141-15\"></a>    }</span>\n<span id=\"cb141-16\"><a href=\"#cb141-16\"></a></span>\n<span id=\"cb141-17\"><a href=\"#cb141-17\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb141-18\"><a href=\"#cb141-18\"></a>}</span></code></pre></div>\n<p>The next step in our recipe for success is to add a test. By now, we know the drill and the test looks familiar:</p>\n<div class=\"sourceCode\" id=\"cb142\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb142-1\"><a href=\"#cb142-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb142-2\"><a href=\"#cb142-2\"></a></span>\n<span id=\"cb142-3\"><a href=\"#cb142-3\"></a><span class=\"kw\">func</span> TestIfExpression(t *testing.T) {</span>\n<span id=\"cb142-4\"><a href=\"#cb142-4\"></a>    input := <span class=\"st\">`if (x &lt; y) { x }`</span></span>\n<span id=\"cb142-5\"><a href=\"#cb142-5\"></a></span>\n<span id=\"cb142-6\"><a href=\"#cb142-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb142-7\"><a href=\"#cb142-7\"></a>    p := New(l)</span>\n<span id=\"cb142-8\"><a href=\"#cb142-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb142-9\"><a href=\"#cb142-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb142-10\"><a href=\"#cb142-10\"></a></span>\n<span id=\"cb142-11\"><a href=\"#cb142-11\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(program.Statements) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb142-12\"><a href=\"#cb142-12\"></a>        t.Fatalf(<span class=\"st\">&quot;program.Statements does not contain %d statements. got=%d</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb142-13\"><a href=\"#cb142-13\"></a>            <span class=\"dv\">1</span>, <span class=\"bu\">len</span>(program.Statements))</span>\n<span id=\"cb142-14\"><a href=\"#cb142-14\"></a>    }</span>\n<span id=\"cb142-15\"><a href=\"#cb142-15\"></a></span>\n<span id=\"cb142-16\"><a href=\"#cb142-16\"></a>    stmt, ok := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb142-17\"><a href=\"#cb142-17\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb142-18\"><a href=\"#cb142-18\"></a>        t.Fatalf(<span class=\"st\">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</span>\n<span id=\"cb142-19\"><a href=\"#cb142-19\"></a>            program.Statements[<span class=\"dv\">0</span>])</span>\n<span id=\"cb142-20\"><a href=\"#cb142-20\"></a>    }</span>\n<span id=\"cb142-21\"><a href=\"#cb142-21\"></a></span>\n<span id=\"cb142-22\"><a href=\"#cb142-22\"></a>    exp, ok := stmt.Expression.(*ast.IfExpression)</span>\n<span id=\"cb142-23\"><a href=\"#cb142-23\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb142-24\"><a href=\"#cb142-24\"></a>        t.Fatalf(<span class=\"st\">&quot;stmt.Expression is not ast.IfExpression. got=%T&quot;</span>,</span>\n<span id=\"cb142-25\"><a href=\"#cb142-25\"></a>            stmt.Expression)</span>\n<span id=\"cb142-26\"><a href=\"#cb142-26\"></a>    }</span>\n<span id=\"cb142-27\"><a href=\"#cb142-27\"></a></span>\n<span id=\"cb142-28\"><a href=\"#cb142-28\"></a>    <span class=\"kw\">if</span> !testInfixExpression(t, exp.Condition, <span class=\"st\">&quot;x&quot;</span>, <span class=\"st\">&quot;&lt;&quot;</span>, <span class=\"st\">&quot;y&quot;</span>) {</span>\n<span id=\"cb142-29\"><a href=\"#cb142-29\"></a>        <span class=\"kw\">return</span></span>\n<span id=\"cb142-30\"><a href=\"#cb142-30\"></a>    }</span>\n<span id=\"cb142-31\"><a href=\"#cb142-31\"></a></span>\n<span id=\"cb142-32\"><a href=\"#cb142-32\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(exp.Consequence.Statements) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb142-33\"><a href=\"#cb142-33\"></a>        t.Errorf(<span class=\"st\">&quot;consequence is not 1 statements. got=%d</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb142-34\"><a href=\"#cb142-34\"></a>            <span class=\"bu\">len</span>(exp.Consequence.Statements))</span>\n<span id=\"cb142-35\"><a href=\"#cb142-35\"></a>    }</span>\n<span id=\"cb142-36\"><a href=\"#cb142-36\"></a></span>\n<span id=\"cb142-37\"><a href=\"#cb142-37\"></a>    consequence, ok := exp.Consequence.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb142-38\"><a href=\"#cb142-38\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb142-39\"><a href=\"#cb142-39\"></a>        t.Fatalf(<span class=\"st\">&quot;Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</span>\n<span id=\"cb142-40\"><a href=\"#cb142-40\"></a>            exp.Consequence.Statements[<span class=\"dv\">0</span>])</span>\n<span id=\"cb142-41\"><a href=\"#cb142-41\"></a>    }</span>\n<span id=\"cb142-42\"><a href=\"#cb142-42\"></a></span>\n<span id=\"cb142-43\"><a href=\"#cb142-43\"></a>    <span class=\"kw\">if</span> !testIdentifier(t, consequence.Expression, <span class=\"st\">&quot;x&quot;</span>) {</span>\n<span id=\"cb142-44\"><a href=\"#cb142-44\"></a>        <span class=\"kw\">return</span></span>\n<span id=\"cb142-45\"><a href=\"#cb142-45\"></a>    }</span>\n<span id=\"cb142-46\"><a href=\"#cb142-46\"></a></span>\n<span id=\"cb142-47\"><a href=\"#cb142-47\"></a>    <span class=\"kw\">if</span> exp.Alternative != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb142-48\"><a href=\"#cb142-48\"></a>        t.Errorf(<span class=\"st\">&quot;exp.Alternative.Statements was not nil. got=%+v&quot;</span>, exp.Alternative)</span>\n<span id=\"cb142-49\"><a href=\"#cb142-49\"></a>    }</span>\n<span id=\"cb142-50\"><a href=\"#cb142-50\"></a>}</span></code></pre></div>\n<p>I also added a <code>TestIfElseExpression</code> test function that uses the following test input:</p>\n<div class=\"sourceCode\" id=\"cb143\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb143-1\"><a href=\"#cb143-1\"></a><span class=\"cf\">if</span> (x <span class=\"op\">&lt;</span> y) { x } <span class=\"cf\">else</span> { y }</span></code></pre></div>\n<p>In <code>TestIfElseExpression</code> there are additional assertions on the <code>Alternative</code> field of <code>*ast.IfExpression</code>. Both tests make assertions about the structure of the resulting <code>*ast.IfExpression</code> node and use the helper functions <code>testInfixExpression</code> and <code>testIdentifier</code> to keep the focus on the conditional itself but also make sure that the rest of our parser is correctly integrated.</p>\n<p>Both tests fail with a lot of error messages. But we are familiar with all of them by now:</p>\n<div class=\"sourceCode\" id=\"cb144\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb144-1\"><a href=\"#cb144-1\"></a>$ go test ./parser</span>\n<span id=\"cb144-2\"><a href=\"#cb144-2\"></a>--- FAIL: TestIfExpression (0.00s)</span>\n<span id=\"cb144-3\"><a href=\"#cb144-3\"></a>  parser_test.go:659: parser has 3 errors</span>\n<span id=\"cb144-4\"><a href=\"#cb144-4\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for IF found&quot;</span>\n<span id=\"cb144-5\"><a href=\"#cb144-5\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for { found&quot;</span>\n<span id=\"cb144-6\"><a href=\"#cb144-6\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for } found&quot;</span>\n<span id=\"cb144-7\"><a href=\"#cb144-7\"></a>--- FAIL: TestIfElseExpression (0.00s)</span>\n<span id=\"cb144-8\"><a href=\"#cb144-8\"></a>  parser_test.go:659: parser has 6 errors</span>\n<span id=\"cb144-9\"><a href=\"#cb144-9\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for IF found&quot;</span>\n<span id=\"cb144-10\"><a href=\"#cb144-10\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for { found&quot;</span>\n<span id=\"cb144-11\"><a href=\"#cb144-11\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for } found&quot;</span>\n<span id=\"cb144-12\"><a href=\"#cb144-12\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for ELSE found&quot;</span>\n<span id=\"cb144-13\"><a href=\"#cb144-13\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for { found&quot;</span>\n<span id=\"cb144-14\"><a href=\"#cb144-14\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for } found&quot;</span>\n<span id=\"cb144-15\"><a href=\"#cb144-15\"></a>FAIL</span>\n<span id=\"cb144-16\"><a href=\"#cb144-16\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>We’re going to start with the first failing test: <code>TestIfExpression</code>. Clearly, we need to register a <code>prefixParseFn</code> for <code>token.IF</code> tokens.</p>\n<div class=\"sourceCode\" id=\"cb145\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb145-1\"><a href=\"#cb145-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb145-2\"><a href=\"#cb145-2\"></a></span>\n<span id=\"cb145-3\"><a href=\"#cb145-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb145-4\"><a href=\"#cb145-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb145-5\"><a href=\"#cb145-5\"></a>    p.registerPrefix(token.IF, p.parseIfExpression)</span>\n<span id=\"cb145-6\"><a href=\"#cb145-6\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb145-7\"><a href=\"#cb145-7\"></a>}</span>\n<span id=\"cb145-8\"><a href=\"#cb145-8\"></a></span>\n<span id=\"cb145-9\"><a href=\"#cb145-9\"></a><span class=\"kw\">func</span> (p *Parser) parseIfExpression() ast.Expression {</span>\n<span id=\"cb145-10\"><a href=\"#cb145-10\"></a>    expression := &amp;ast.IfExpression{Token: p.curToken}</span>\n<span id=\"cb145-11\"><a href=\"#cb145-11\"></a></span>\n<span id=\"cb145-12\"><a href=\"#cb145-12\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.LPAREN) {</span>\n<span id=\"cb145-13\"><a href=\"#cb145-13\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb145-14\"><a href=\"#cb145-14\"></a>    }</span>\n<span id=\"cb145-15\"><a href=\"#cb145-15\"></a></span>\n<span id=\"cb145-16\"><a href=\"#cb145-16\"></a>    p.nextToken()</span>\n<span id=\"cb145-17\"><a href=\"#cb145-17\"></a>    expression.Condition = p.parseExpression(LOWEST)</span>\n<span id=\"cb145-18\"><a href=\"#cb145-18\"></a></span>\n<span id=\"cb145-19\"><a href=\"#cb145-19\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.RPAREN) {</span>\n<span id=\"cb145-20\"><a href=\"#cb145-20\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb145-21\"><a href=\"#cb145-21\"></a>    }</span>\n<span id=\"cb145-22\"><a href=\"#cb145-22\"></a></span>\n<span id=\"cb145-23\"><a href=\"#cb145-23\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.LBRACE) {</span>\n<span id=\"cb145-24\"><a href=\"#cb145-24\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb145-25\"><a href=\"#cb145-25\"></a>    }</span>\n<span id=\"cb145-26\"><a href=\"#cb145-26\"></a></span>\n<span id=\"cb145-27\"><a href=\"#cb145-27\"></a>    expression.Consequence = p.parseBlockStatement()</span>\n<span id=\"cb145-28\"><a href=\"#cb145-28\"></a></span>\n<span id=\"cb145-29\"><a href=\"#cb145-29\"></a>    <span class=\"kw\">return</span> expression</span>\n<span id=\"cb145-30\"><a href=\"#cb145-30\"></a>}</span></code></pre></div>\n<p>In no other parsing function did we use <code>expectPeek</code> so extensively. There just wasn’t a need. Here it makes sense. <code>expectPeek</code> adds an error to the parser if <code>p.peekToken</code> is not of the expected type, but if it is, then it advances the tokens by calling the <code>nextToken</code> method. That’s exactly what we need here. We need there to be a <code>(</code> right after the <code>if</code> and if it’s there we need to jump over it. The same goes for the <code>)</code> after the expression and the <code>{</code> that marks the beginning of a block statement.</p>\n<p>This method also follows our parsing function protocol: the tokens get advanced just enough so that <code>parseBlockStatement</code> sits on the <code>{</code> with <code>p.curToken</code> being of type <code>token.LBRACE</code>. Here is <code>parseBlockStatement</code>:</p>\n<div class=\"sourceCode\" id=\"cb146\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb146-1\"><a href=\"#cb146-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb146-2\"><a href=\"#cb146-2\"></a></span>\n<span id=\"cb146-3\"><a href=\"#cb146-3\"></a><span class=\"kw\">func</span> (p *Parser) parseBlockStatement() *ast.BlockStatement {</span>\n<span id=\"cb146-4\"><a href=\"#cb146-4\"></a>    block := &amp;ast.BlockStatement{Token: p.curToken}</span>\n<span id=\"cb146-5\"><a href=\"#cb146-5\"></a>    block.Statements = []ast.Statement{}</span>\n<span id=\"cb146-6\"><a href=\"#cb146-6\"></a></span>\n<span id=\"cb146-7\"><a href=\"#cb146-7\"></a>    p.nextToken()</span>\n<span id=\"cb146-8\"><a href=\"#cb146-8\"></a></span>\n<span id=\"cb146-9\"><a href=\"#cb146-9\"></a>    <span class=\"kw\">for</span> !p.curTokenIs(token.RBRACE) &amp;&amp; !p.curTokenIs(token.EOF) {</span>\n<span id=\"cb146-10\"><a href=\"#cb146-10\"></a>        stmt := p.parseStatement()</span>\n<span id=\"cb146-11\"><a href=\"#cb146-11\"></a>        <span class=\"kw\">if</span> stmt != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb146-12\"><a href=\"#cb146-12\"></a>            block.Statements = <span class=\"bu\">append</span>(block.Statements, stmt)</span>\n<span id=\"cb146-13\"><a href=\"#cb146-13\"></a>        }</span>\n<span id=\"cb146-14\"><a href=\"#cb146-14\"></a>        p.nextToken()</span>\n<span id=\"cb146-15\"><a href=\"#cb146-15\"></a>    }</span>\n<span id=\"cb146-16\"><a href=\"#cb146-16\"></a></span>\n<span id=\"cb146-17\"><a href=\"#cb146-17\"></a>    <span class=\"kw\">return</span> block</span>\n<span id=\"cb146-18\"><a href=\"#cb146-18\"></a>}</span></code></pre></div>\n<p><code>parseBlockStatement</code> calls <code>parseStatement</code> until it encounters either a <code>}</code>, which signifies the end of the block statement, or a <code>token.EOF</code>, which tells us that there’s no more tokens left to parse. In that case, we can’t successfully parse the block statement and there’s no need to keep on calling <code>parseStatement</code> in an endless loop.</p>\n<p>This looks really similar to our top-level <code>ParseProgram</code> method, where we also call <code>parseStatement</code> repeatedly until we encounter an “end token”, which in the case of <code>ParseProgram</code> is just the <code>token.EOF</code> token. The duplication of the loop doesn’t hurt though, so we leave these two methods be and instead take care of our tests:</p>\n<div class=\"sourceCode\" id=\"cb147\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb147-1\"><a href=\"#cb147-1\"></a>$ go test ./parser</span>\n<span id=\"cb147-2\"><a href=\"#cb147-2\"></a>--- FAIL: TestIfElseExpression (0.00s)</span>\n<span id=\"cb147-3\"><a href=\"#cb147-3\"></a>  parser_test.go:659: parser has 3 errors</span>\n<span id=\"cb147-4\"><a href=\"#cb147-4\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for ELSE found&quot;</span>\n<span id=\"cb147-5\"><a href=\"#cb147-5\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for { found&quot;</span>\n<span id=\"cb147-6\"><a href=\"#cb147-6\"></a>  parser_test.go:661: parser error: &quot;no prefix parse function for } found&quot;</span>\n<span id=\"cb147-7\"><a href=\"#cb147-7\"></a>FAIL</span>\n<span id=\"cb147-8\"><a href=\"#cb147-8\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p><code>TestIfExpression</code> passes and <code>TestIfElseExpression</code> does not, exactly as expected. Now, in order to support the <code>else</code> part of an if-else-condition, we need to check if it even exists and if so we need to parse the block statement that comes directly after the <code>else</code>:</p>\n<div class=\"sourceCode\" id=\"cb148\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb148-1\"><a href=\"#cb148-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb148-2\"><a href=\"#cb148-2\"></a></span>\n<span id=\"cb148-3\"><a href=\"#cb148-3\"></a><span class=\"kw\">func</span> (p *Parser) parseIfExpression() ast.Expression {</span>\n<span id=\"cb148-4\"><a href=\"#cb148-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb148-5\"><a href=\"#cb148-5\"></a>    expression.Consequence = p.parseBlockStatement()</span>\n<span id=\"cb148-6\"><a href=\"#cb148-6\"></a></span>\n<span id=\"cb148-7\"><a href=\"#cb148-7\"></a>    <span class=\"kw\">if</span> p.peekTokenIs(token.ELSE) {</span>\n<span id=\"cb148-8\"><a href=\"#cb148-8\"></a>        p.nextToken()</span>\n<span id=\"cb148-9\"><a href=\"#cb148-9\"></a></span>\n<span id=\"cb148-10\"><a href=\"#cb148-10\"></a>        <span class=\"kw\">if</span> !p.expectPeek(token.LBRACE) {</span>\n<span id=\"cb148-11\"><a href=\"#cb148-11\"></a>            <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb148-12\"><a href=\"#cb148-12\"></a>        }</span>\n<span id=\"cb148-13\"><a href=\"#cb148-13\"></a></span>\n<span id=\"cb148-14\"><a href=\"#cb148-14\"></a>        expression.Alternative = p.parseBlockStatement()</span>\n<span id=\"cb148-15\"><a href=\"#cb148-15\"></a>    }</span>\n<span id=\"cb148-16\"><a href=\"#cb148-16\"></a></span>\n<span id=\"cb148-17\"><a href=\"#cb148-17\"></a>    <span class=\"kw\">return</span> expression</span>\n<span id=\"cb148-18\"><a href=\"#cb148-18\"></a>}</span></code></pre></div>\n<p>That’s all there is to it. The whole part of this method is constructed in a way that allows an optional <code>else</code> but doesn’t add a parser error if there is none. After we parse the consequence-block-statement we check if the next token is a <code>token.ELSE</code> token. Remember, at the end of <code>parseBlockStatement</code> we’re sitting on the <code>}</code>. If we have a <code>token.ELSE</code>, we advance the tokens two times. The first time with a call to <code>nextToken</code>, since we already know that the <code>p.peekToken</code> is the <code>else</code>. Then with a call to <code>expectPeek</code> since now the next token has to be the opening brace of a block statement, otherwise the program is invalid.</p>\n<p>Yes, parsing is prone to off-by-one errors. It’s easy to forget advancing the tokens or make a wrong call to <code>nextToken</code>. Having a strict protocol that dictates how every parsing function has to advance tokens helps a lot. Luckily we also have a great test suite that lets us know everything works:</p>\n<div class=\"sourceCode\" id=\"cb149\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb149-1\"><a href=\"#cb149-1\"></a>$ go test ./parser</span>\n<span id=\"cb149-2\"><a href=\"#cb149-2\"></a>ok      monkey/parser   0.007s</span></code></pre></div>\n<p>I don’t think I have to tell you anymore: good job all around! We did it - again.</p>\n</section>\n<section id=\"function-literals\" class=\"level3\" data-number=\"2.8.4\">\n<h3 data-number=\"2.8.4\">Function Literals</h3>\n<p>You may have noticed that the <code>parseIfExpression</code> method we just added has a lot more meat to it than any of the <code>prefixParseFn</code>s or <code>infixParseFn</code>s we wrote before. The main reason is that we had to work with many different token and expression types and even optional parts. What we’re going to do next is similar in its difficulty and variety of involved token types. We’re going to parse function literals.</p>\n<p>In Monkey a function literal is how we define functions: which parameters they have and what the function does. Function literals look like this:</p>\n<div class=\"sourceCode\" id=\"cb150\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb150-1\"><a href=\"#cb150-1\"></a>fn(x<span class=\"op\">,</span> y) {</span>\n<span id=\"cb150-2\"><a href=\"#cb150-2\"></a>  <span class=\"cf\">return</span> x <span class=\"op\">+</span> y<span class=\"op\">;</span></span>\n<span id=\"cb150-3\"><a href=\"#cb150-3\"></a>}</span></code></pre></div>\n<p>It starts with the keyword <code>fn</code>, followed by a list of parameters, followed by a block statement, which is the function’s body, that gets executed when the function is called. The abstract structure of a function literal is this:</p>\n<div class=\"sourceCode\" id=\"cb151\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb151-1\"><a href=\"#cb151-1\"></a>fn &lt;parameters&gt; &lt;block statement&gt;</span></code></pre></div>\n<p>We already know what block statements are and how to parse them. The parameters are new though, but not much more difficult to parse. They are just a list of identifiers that are comma-separated and surrounded by parentheses:</p>\n<div class=\"sourceCode\" id=\"cb152\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb152-1\"><a href=\"#cb152-1\"></a>(&lt;parameter one&gt;, &lt;parameter two&gt;, &lt;parameter three&gt;, ...)</span></code></pre></div>\n<p>This list can also be empty:</p>\n<div class=\"sourceCode\" id=\"cb153\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb153-1\"><a href=\"#cb153-1\"></a>fn() {</span>\n<span id=\"cb153-2\"><a href=\"#cb153-2\"></a>  <span class=\"cf\">return</span> foobar <span class=\"op\">+</span> barfoo<span class=\"op\">;</span></span>\n<span id=\"cb153-3\"><a href=\"#cb153-3\"></a>}</span></code></pre></div>\n<p>That’s the structure of function literals. But what type of AST node are they? Expressions, of course! We can use function literals in every place where any other expression is valid. For example, here is a function literal as the expression in a let statement:</p>\n<div class=\"sourceCode\" id=\"cb154\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb154-1\"><a href=\"#cb154-1\"></a><span class=\"kw\">let</span> myFunction <span class=\"op\">=</span> fn(x<span class=\"op\">,</span> y) { <span class=\"cf\">return</span> x <span class=\"op\">+</span> y<span class=\"op\">;</span> }</span></code></pre></div>\n<p>And here is a function literal as the expression in a return statement inside another function literal:</p>\n<div class=\"sourceCode\" id=\"cb155\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb155-1\"><a href=\"#cb155-1\"></a>fn() {</span>\n<span id=\"cb155-2\"><a href=\"#cb155-2\"></a>  <span class=\"cf\">return</span> fn(x<span class=\"op\">,</span> y) { <span class=\"cf\">return</span> x <span class=\"op\">&gt;</span> y<span class=\"op\">;</span> }<span class=\"op\">;</span></span>\n<span id=\"cb155-3\"><a href=\"#cb155-3\"></a>}</span></code></pre></div>\n<p>Using a function literal as an argument when calling another function is also possible:</p>\n<div class=\"sourceCode\" id=\"cb156\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb156-1\"><a href=\"#cb156-1\"></a>myFunc(x<span class=\"op\">,</span> y<span class=\"op\">,</span> fn(x<span class=\"op\">,</span> y) { <span class=\"cf\">return</span> x <span class=\"op\">&gt;</span> y<span class=\"op\">;</span> })<span class=\"op\">;</span></span></code></pre></div>\n<p>That does sound complicated, but it’s not. One of the great things about our parser is that once we define function literals as expressions and provide a function to correctly parse them the rest works. Sounds amazing? I agree.</p>\n<p>We just saw that the two main parts of a function literal are the list of parameters and the block statement that is the function’s body. That’s all we need to keep in mind when defining the AST node:</p>\n<div class=\"sourceCode\" id=\"cb157\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb157-1\"><a href=\"#cb157-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb157-2\"><a href=\"#cb157-2\"></a></span>\n<span id=\"cb157-3\"><a href=\"#cb157-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb157-4\"><a href=\"#cb157-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb157-5\"><a href=\"#cb157-5\"></a>    <span class=\"st\">&quot;strings&quot;</span></span>\n<span id=\"cb157-6\"><a href=\"#cb157-6\"></a>)</span>\n<span id=\"cb157-7\"><a href=\"#cb157-7\"></a></span>\n<span id=\"cb157-8\"><a href=\"#cb157-8\"></a><span class=\"kw\">type</span> FunctionLiteral <span class=\"kw\">struct</span> {</span>\n<span id=\"cb157-9\"><a href=\"#cb157-9\"></a>    Token      token.Token <span class=\"co\">// The &#39;fn&#39; token</span></span>\n<span id=\"cb157-10\"><a href=\"#cb157-10\"></a>    Parameters []*Identifier</span>\n<span id=\"cb157-11\"><a href=\"#cb157-11\"></a>    Body       *BlockStatement</span>\n<span id=\"cb157-12\"><a href=\"#cb157-12\"></a>}</span>\n<span id=\"cb157-13\"><a href=\"#cb157-13\"></a></span>\n<span id=\"cb157-14\"><a href=\"#cb157-14\"></a><span class=\"kw\">func</span> (fl *FunctionLiteral) expressionNode()      {}</span>\n<span id=\"cb157-15\"><a href=\"#cb157-15\"></a><span class=\"kw\">func</span> (fl *FunctionLiteral) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> fl.Token.Literal }</span>\n<span id=\"cb157-16\"><a href=\"#cb157-16\"></a><span class=\"kw\">func</span> (fl *FunctionLiteral) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb157-17\"><a href=\"#cb157-17\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb157-18\"><a href=\"#cb157-18\"></a></span>\n<span id=\"cb157-19\"><a href=\"#cb157-19\"></a>    params := []<span class=\"dt\">string</span>{}</span>\n<span id=\"cb157-20\"><a href=\"#cb157-20\"></a>    <span class=\"kw\">for</span> _, p := <span class=\"kw\">range</span> fl.Parameters {</span>\n<span id=\"cb157-21\"><a href=\"#cb157-21\"></a>        params = <span class=\"bu\">append</span>(params, p.String())</span>\n<span id=\"cb157-22\"><a href=\"#cb157-22\"></a>    }</span>\n<span id=\"cb157-23\"><a href=\"#cb157-23\"></a></span>\n<span id=\"cb157-24\"><a href=\"#cb157-24\"></a>    out.WriteString(fl.TokenLiteral())</span>\n<span id=\"cb157-25\"><a href=\"#cb157-25\"></a>    out.WriteString(<span class=\"st\">&quot;(&quot;</span>)</span>\n<span id=\"cb157-26\"><a href=\"#cb157-26\"></a>    out.WriteString(strings.Join(params, <span class=\"st\">&quot;, &quot;</span>))</span>\n<span id=\"cb157-27\"><a href=\"#cb157-27\"></a>    out.WriteString(<span class=\"st\">&quot;) &quot;</span>)</span>\n<span id=\"cb157-28\"><a href=\"#cb157-28\"></a>    out.WriteString(fl.Body.String())</span>\n<span id=\"cb157-29\"><a href=\"#cb157-29\"></a></span>\n<span id=\"cb157-30\"><a href=\"#cb157-30\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb157-31\"><a href=\"#cb157-31\"></a>}</span></code></pre></div>\n<p>The <code>Parameters</code> field is a slice of <code>*ast.Identifiers</code>, because that’s all there is to it, and <code>Body</code> is an <code>*ast.BlockStatement</code>, which we saw and used before.</p>\n<p>Here is the test, in which we can use our helper functions <code>testLiteralExpression</code> and <code>testInfixExpression</code> again:</p>\n<div class=\"sourceCode\" id=\"cb158\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb158-1\"><a href=\"#cb158-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb158-2\"><a href=\"#cb158-2\"></a></span>\n<span id=\"cb158-3\"><a href=\"#cb158-3\"></a><span class=\"kw\">func</span> TestFunctionLiteralParsing(t *testing.T) {</span>\n<span id=\"cb158-4\"><a href=\"#cb158-4\"></a>    input := <span class=\"st\">`fn(x, y) { x + y; }`</span></span>\n<span id=\"cb158-5\"><a href=\"#cb158-5\"></a></span>\n<span id=\"cb158-6\"><a href=\"#cb158-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb158-7\"><a href=\"#cb158-7\"></a>    p := New(l)</span>\n<span id=\"cb158-8\"><a href=\"#cb158-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb158-9\"><a href=\"#cb158-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb158-10\"><a href=\"#cb158-10\"></a></span>\n<span id=\"cb158-11\"><a href=\"#cb158-11\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(program.Statements) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb158-12\"><a href=\"#cb158-12\"></a>        t.Fatalf(<span class=\"st\">&quot;program.Statements does not contain %d statements. got=%d</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb158-13\"><a href=\"#cb158-13\"></a>            <span class=\"dv\">1</span>, <span class=\"bu\">len</span>(program.Statements))</span>\n<span id=\"cb158-14\"><a href=\"#cb158-14\"></a>    }</span>\n<span id=\"cb158-15\"><a href=\"#cb158-15\"></a></span>\n<span id=\"cb158-16\"><a href=\"#cb158-16\"></a>    stmt, ok := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb158-17\"><a href=\"#cb158-17\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb158-18\"><a href=\"#cb158-18\"></a>        t.Fatalf(<span class=\"st\">&quot;program.Statements[0] is not ast.ExpressionStatement. got=%T&quot;</span>,</span>\n<span id=\"cb158-19\"><a href=\"#cb158-19\"></a>            program.Statements[<span class=\"dv\">0</span>])</span>\n<span id=\"cb158-20\"><a href=\"#cb158-20\"></a>    }</span>\n<span id=\"cb158-21\"><a href=\"#cb158-21\"></a></span>\n<span id=\"cb158-22\"><a href=\"#cb158-22\"></a>    function, ok := stmt.Expression.(*ast.FunctionLiteral)</span>\n<span id=\"cb158-23\"><a href=\"#cb158-23\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb158-24\"><a href=\"#cb158-24\"></a>        t.Fatalf(<span class=\"st\">&quot;stmt.Expression is not ast.FunctionLiteral. got=%T&quot;</span>,</span>\n<span id=\"cb158-25\"><a href=\"#cb158-25\"></a>            stmt.Expression)</span>\n<span id=\"cb158-26\"><a href=\"#cb158-26\"></a>    }</span>\n<span id=\"cb158-27\"><a href=\"#cb158-27\"></a></span>\n<span id=\"cb158-28\"><a href=\"#cb158-28\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(function.Parameters) != <span class=\"dv\">2</span> {</span>\n<span id=\"cb158-29\"><a href=\"#cb158-29\"></a>        t.Fatalf(<span class=\"st\">&quot;function literal parameters wrong. want 2, got=%d</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb158-30\"><a href=\"#cb158-30\"></a>            <span class=\"bu\">len</span>(function.Parameters))</span>\n<span id=\"cb158-31\"><a href=\"#cb158-31\"></a>    }</span>\n<span id=\"cb158-32\"><a href=\"#cb158-32\"></a></span>\n<span id=\"cb158-33\"><a href=\"#cb158-33\"></a>    testLiteralExpression(t, function.Parameters[<span class=\"dv\">0</span>], <span class=\"st\">&quot;x&quot;</span>)</span>\n<span id=\"cb158-34\"><a href=\"#cb158-34\"></a>    testLiteralExpression(t, function.Parameters[<span class=\"dv\">1</span>], <span class=\"st\">&quot;y&quot;</span>)</span>\n<span id=\"cb158-35\"><a href=\"#cb158-35\"></a></span>\n<span id=\"cb158-36\"><a href=\"#cb158-36\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(function.Body.Statements) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb158-37\"><a href=\"#cb158-37\"></a>        t.Fatalf(<span class=\"st\">&quot;function.Body.Statements has not 1 statements. got=%d</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb158-38\"><a href=\"#cb158-38\"></a>            <span class=\"bu\">len</span>(function.Body.Statements))</span>\n<span id=\"cb158-39\"><a href=\"#cb158-39\"></a>    }</span>\n<span id=\"cb158-40\"><a href=\"#cb158-40\"></a></span>\n<span id=\"cb158-41\"><a href=\"#cb158-41\"></a>    bodyStmt, ok := function.Body.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb158-42\"><a href=\"#cb158-42\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb158-43\"><a href=\"#cb158-43\"></a>        t.Fatalf(<span class=\"st\">&quot;function body stmt is not ast.ExpressionStatement. got=%T&quot;</span>,</span>\n<span id=\"cb158-44\"><a href=\"#cb158-44\"></a>            function.Body.Statements[<span class=\"dv\">0</span>])</span>\n<span id=\"cb158-45\"><a href=\"#cb158-45\"></a>    }</span>\n<span id=\"cb158-46\"><a href=\"#cb158-46\"></a></span>\n<span id=\"cb158-47\"><a href=\"#cb158-47\"></a>    testInfixExpression(t, bodyStmt.Expression, <span class=\"st\">&quot;x&quot;</span>, <span class=\"st\">&quot;+&quot;</span>, <span class=\"st\">&quot;y&quot;</span>)</span>\n<span id=\"cb158-48\"><a href=\"#cb158-48\"></a>}</span></code></pre></div>\n<p>So, the test has three main parts: check that the <code>*ast.FunctionLiteral</code> is there, check that the parameter list is correct and make sure that the function body contains the correct statements. The last part is not strictly necessary, since we already tested parsing block statements before in our tests for <code>IfExpression</code>s. But I’m okay with duplicating some test assertions here that possibly alarm us when hooking up the parsing of block statements failed.</p>\n<p>With only <code>ast.FunctionLiteral</code> defined and nothing changed in the parser, the tests fail:</p>\n<div class=\"sourceCode\" id=\"cb159\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb159-1\"><a href=\"#cb159-1\"></a>$ go test ./parser</span>\n<span id=\"cb159-2\"><a href=\"#cb159-2\"></a>--- FAIL: TestFunctionLiteralParsing (0.00s)</span>\n<span id=\"cb159-3\"><a href=\"#cb159-3\"></a>  parser_test.go:755: parser has 6 errors</span>\n<span id=\"cb159-4\"><a href=\"#cb159-4\"></a>  parser_test.go:757: parser error: &quot;no prefix parse function for FUNCTION found&quot;</span>\n<span id=\"cb159-5\"><a href=\"#cb159-5\"></a>  parser_test.go:757: parser error: &quot;expected next token to be ), got , instead&quot;</span>\n<span id=\"cb159-6\"><a href=\"#cb159-6\"></a>  parser_test.go:757: parser error: &quot;no prefix parse function for , found&quot;</span>\n<span id=\"cb159-7\"><a href=\"#cb159-7\"></a>  parser_test.go:757: parser error: &quot;no prefix parse function for ) found&quot;</span>\n<span id=\"cb159-8\"><a href=\"#cb159-8\"></a>  parser_test.go:757: parser error: &quot;no prefix parse function for { found&quot;</span>\n<span id=\"cb159-9\"><a href=\"#cb159-9\"></a>  parser_test.go:757: parser error: &quot;no prefix parse function for } found&quot;</span>\n<span id=\"cb159-10\"><a href=\"#cb159-10\"></a>FAIL</span>\n<span id=\"cb159-11\"><a href=\"#cb159-11\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>It’s clear that we need to register a new <code>prefixParseFn</code> for <code>token.FUNCTION</code> tokens.</p>\n<div class=\"sourceCode\" id=\"cb160\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb160-1\"><a href=\"#cb160-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb160-2\"><a href=\"#cb160-2\"></a></span>\n<span id=\"cb160-3\"><a href=\"#cb160-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb160-4\"><a href=\"#cb160-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb160-5\"><a href=\"#cb160-5\"></a>    p.registerPrefix(token.FUNCTION, p.parseFunctionLiteral)</span>\n<span id=\"cb160-6\"><a href=\"#cb160-6\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb160-7\"><a href=\"#cb160-7\"></a>}</span>\n<span id=\"cb160-8\"><a href=\"#cb160-8\"></a></span>\n<span id=\"cb160-9\"><a href=\"#cb160-9\"></a><span class=\"kw\">func</span> (p *Parser) parseFunctionLiteral() ast.Expression {</span>\n<span id=\"cb160-10\"><a href=\"#cb160-10\"></a>    lit := &amp;ast.FunctionLiteral{Token: p.curToken}</span>\n<span id=\"cb160-11\"><a href=\"#cb160-11\"></a></span>\n<span id=\"cb160-12\"><a href=\"#cb160-12\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.LPAREN) {</span>\n<span id=\"cb160-13\"><a href=\"#cb160-13\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb160-14\"><a href=\"#cb160-14\"></a>    }</span>\n<span id=\"cb160-15\"><a href=\"#cb160-15\"></a></span>\n<span id=\"cb160-16\"><a href=\"#cb160-16\"></a>    lit.Parameters = p.parseFunctionParameters()</span>\n<span id=\"cb160-17\"><a href=\"#cb160-17\"></a></span>\n<span id=\"cb160-18\"><a href=\"#cb160-18\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.LBRACE) {</span>\n<span id=\"cb160-19\"><a href=\"#cb160-19\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb160-20\"><a href=\"#cb160-20\"></a>    }</span>\n<span id=\"cb160-21\"><a href=\"#cb160-21\"></a></span>\n<span id=\"cb160-22\"><a href=\"#cb160-22\"></a>    lit.Body = p.parseBlockStatement()</span>\n<span id=\"cb160-23\"><a href=\"#cb160-23\"></a></span>\n<span id=\"cb160-24\"><a href=\"#cb160-24\"></a>    <span class=\"kw\">return</span> lit</span>\n<span id=\"cb160-25\"><a href=\"#cb160-25\"></a>}</span></code></pre></div>\n<p>The <code>parseFunctionParameters</code> method we use here to parse the literal’s parameters looks like this:</p>\n<div class=\"sourceCode\" id=\"cb161\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb161-1\"><a href=\"#cb161-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb161-2\"><a href=\"#cb161-2\"></a></span>\n<span id=\"cb161-3\"><a href=\"#cb161-3\"></a><span class=\"kw\">func</span> (p *Parser) parseFunctionParameters() []*ast.Identifier {</span>\n<span id=\"cb161-4\"><a href=\"#cb161-4\"></a>    identifiers := []*ast.Identifier{}</span>\n<span id=\"cb161-5\"><a href=\"#cb161-5\"></a></span>\n<span id=\"cb161-6\"><a href=\"#cb161-6\"></a>    <span class=\"kw\">if</span> p.peekTokenIs(token.RPAREN) {</span>\n<span id=\"cb161-7\"><a href=\"#cb161-7\"></a>        p.nextToken()</span>\n<span id=\"cb161-8\"><a href=\"#cb161-8\"></a>        <span class=\"kw\">return</span> identifiers</span>\n<span id=\"cb161-9\"><a href=\"#cb161-9\"></a>    }</span>\n<span id=\"cb161-10\"><a href=\"#cb161-10\"></a></span>\n<span id=\"cb161-11\"><a href=\"#cb161-11\"></a>    p.nextToken()</span>\n<span id=\"cb161-12\"><a href=\"#cb161-12\"></a></span>\n<span id=\"cb161-13\"><a href=\"#cb161-13\"></a>    ident := &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</span>\n<span id=\"cb161-14\"><a href=\"#cb161-14\"></a>    identifiers = <span class=\"bu\">append</span>(identifiers, ident)</span>\n<span id=\"cb161-15\"><a href=\"#cb161-15\"></a></span>\n<span id=\"cb161-16\"><a href=\"#cb161-16\"></a>    <span class=\"kw\">for</span> p.peekTokenIs(token.COMMA) {</span>\n<span id=\"cb161-17\"><a href=\"#cb161-17\"></a>        p.nextToken()</span>\n<span id=\"cb161-18\"><a href=\"#cb161-18\"></a>        p.nextToken()</span>\n<span id=\"cb161-19\"><a href=\"#cb161-19\"></a>        ident := &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</span>\n<span id=\"cb161-20\"><a href=\"#cb161-20\"></a>        identifiers = <span class=\"bu\">append</span>(identifiers, ident)</span>\n<span id=\"cb161-21\"><a href=\"#cb161-21\"></a>    }</span>\n<span id=\"cb161-22\"><a href=\"#cb161-22\"></a></span>\n<span id=\"cb161-23\"><a href=\"#cb161-23\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.RPAREN) {</span>\n<span id=\"cb161-24\"><a href=\"#cb161-24\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb161-25\"><a href=\"#cb161-25\"></a>    }</span>\n<span id=\"cb161-26\"><a href=\"#cb161-26\"></a></span>\n<span id=\"cb161-27\"><a href=\"#cb161-27\"></a>    <span class=\"kw\">return</span> identifiers</span>\n<span id=\"cb161-28\"><a href=\"#cb161-28\"></a>}</span></code></pre></div>\n<p>There’s the heart of the matter. <code>parseFunctionParameters</code> constructs the slice of parameters by repeatedly building identifiers from the comma separated list. It also makes an early exit if the list is empty and it carefully handles lists of varying sizes.</p>\n<p>For a method like this it really pays off to have another set of tests that check the edge cases: an empty parameter list, a list with one parameter and a list with multiple parameters.</p>\n<div class=\"sourceCode\" id=\"cb162\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb162-1\"><a href=\"#cb162-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb162-2\"><a href=\"#cb162-2\"></a></span>\n<span id=\"cb162-3\"><a href=\"#cb162-3\"></a><span class=\"kw\">func</span> TestFunctionParameterParsing(t *testing.T) {</span>\n<span id=\"cb162-4\"><a href=\"#cb162-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb162-5\"><a href=\"#cb162-5\"></a>        input          <span class=\"dt\">string</span></span>\n<span id=\"cb162-6\"><a href=\"#cb162-6\"></a>        expectedParams []<span class=\"dt\">string</span></span>\n<span id=\"cb162-7\"><a href=\"#cb162-7\"></a>    }{</span>\n<span id=\"cb162-8\"><a href=\"#cb162-8\"></a>        {input: <span class=\"st\">&quot;fn() {};&quot;</span>, expectedParams: []<span class=\"dt\">string</span>{}},</span>\n<span id=\"cb162-9\"><a href=\"#cb162-9\"></a>        {input: <span class=\"st\">&quot;fn(x) {};&quot;</span>, expectedParams: []<span class=\"dt\">string</span>{<span class=\"st\">&quot;x&quot;</span>}},</span>\n<span id=\"cb162-10\"><a href=\"#cb162-10\"></a>        {input: <span class=\"st\">&quot;fn(x, y, z) {};&quot;</span>, expectedParams: []<span class=\"dt\">string</span>{<span class=\"st\">&quot;x&quot;</span>, <span class=\"st\">&quot;y&quot;</span>, <span class=\"st\">&quot;z&quot;</span>}},</span>\n<span id=\"cb162-11\"><a href=\"#cb162-11\"></a>    }</span>\n<span id=\"cb162-12\"><a href=\"#cb162-12\"></a></span>\n<span id=\"cb162-13\"><a href=\"#cb162-13\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb162-14\"><a href=\"#cb162-14\"></a>        l := lexer.New(tt.input)</span>\n<span id=\"cb162-15\"><a href=\"#cb162-15\"></a>        p := New(l)</span>\n<span id=\"cb162-16\"><a href=\"#cb162-16\"></a>        program := p.ParseProgram()</span>\n<span id=\"cb162-17\"><a href=\"#cb162-17\"></a>        checkParserErrors(t, p)</span>\n<span id=\"cb162-18\"><a href=\"#cb162-18\"></a></span>\n<span id=\"cb162-19\"><a href=\"#cb162-19\"></a>        stmt := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb162-20\"><a href=\"#cb162-20\"></a>        function := stmt.Expression.(*ast.FunctionLiteral)</span>\n<span id=\"cb162-21\"><a href=\"#cb162-21\"></a></span>\n<span id=\"cb162-22\"><a href=\"#cb162-22\"></a>        <span class=\"kw\">if</span> <span class=\"bu\">len</span>(function.Parameters) != <span class=\"bu\">len</span>(tt.expectedParams) {</span>\n<span id=\"cb162-23\"><a href=\"#cb162-23\"></a>            t.Errorf(<span class=\"st\">&quot;length parameters wrong. want %d, got=%d</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb162-24\"><a href=\"#cb162-24\"></a>                <span class=\"bu\">len</span>(tt.expectedParams), <span class=\"bu\">len</span>(function.Parameters))</span>\n<span id=\"cb162-25\"><a href=\"#cb162-25\"></a>        }</span>\n<span id=\"cb162-26\"><a href=\"#cb162-26\"></a></span>\n<span id=\"cb162-27\"><a href=\"#cb162-27\"></a>        <span class=\"kw\">for</span> i, ident := <span class=\"kw\">range</span> tt.expectedParams {</span>\n<span id=\"cb162-28\"><a href=\"#cb162-28\"></a>            testLiteralExpression(t, function.Parameters[i], ident)</span>\n<span id=\"cb162-29\"><a href=\"#cb162-29\"></a>        }</span>\n<span id=\"cb162-30\"><a href=\"#cb162-30\"></a>    }</span>\n<span id=\"cb162-31\"><a href=\"#cb162-31\"></a>}</span></code></pre></div>\n<p>Both of these test functions now pass:</p>\n<div class=\"sourceCode\" id=\"cb163\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb163-1\"><a href=\"#cb163-1\"></a>$ go test ./parser</span>\n<span id=\"cb163-2\"><a href=\"#cb163-2\"></a>ok      monkey/parser   0.007s</span></code></pre></div>\n<p>Function literals are in the bag! Sweet! There is only one last thing to do now before we can leave the parser and start talking about the evaluation of our AST.</p>\n</section>\n<section id=\"call-expressions\" class=\"level3\" data-number=\"2.8.5\">\n<h3 data-number=\"2.8.5\">Call Expressions</h3>\n<p>Now that we know how to parse function literals the next step is to parse the calling of a function: call expressions. Here is their structure:</p>\n<div class=\"sourceCode\" id=\"cb164\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb164-1\"><a href=\"#cb164-1\"></a>&lt;expression&gt;(&lt;comma separated expressions&gt;)</span></code></pre></div>\n<p>What? Yup, that’s it, but granted, a few examples are needed. Here is the normal call expression we all know:</p>\n<div class=\"sourceCode\" id=\"cb165\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb165-1\"><a href=\"#cb165-1\"></a>add(<span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span>)</span></code></pre></div>\n<p>Now think about this: the <code>add</code> is an identifier. And identifiers are expressions. The arguments <code>2</code> and <code>3</code> are expressions too - integer literals. But they don’t have to be, the arguments are just a list of expressions:</p>\n<div class=\"sourceCode\" id=\"cb166\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb166-1\"><a href=\"#cb166-1\"></a>add(<span class=\"dv\">2</span> <span class=\"op\">+</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span> <span class=\"op\">*</span> <span class=\"dv\">3</span> <span class=\"op\">*</span> <span class=\"dv\">3</span>)</span></code></pre></div>\n<p>That’s valid, too. The first argument is the infix expression <code>2 + 2</code> and the second one is <code>3 * 3 * 3</code>. So far, so good. Now, let’s look at the function that’s being called here. In this case the function is bound to the identifier <code>add</code>. The identifier <code>add</code> returns this function when it’s evaluated. That means, we could go straight to the source, skip the identifier and replace <code>add</code> with a function literal:</p>\n<div class=\"sourceCode\" id=\"cb167\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb167-1\"><a href=\"#cb167-1\"></a>fn(x<span class=\"op\">,</span> y) { x <span class=\"op\">+</span> y<span class=\"op\">;</span> }(<span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span>)</span></code></pre></div>\n<p>Yes, that’s valid. We can also use function literals as arguments:</p>\n<div class=\"sourceCode\" id=\"cb168\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb168-1\"><a href=\"#cb168-1\"></a>callsFunction(<span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> fn(x<span class=\"op\">,</span> y) { x <span class=\"op\">+</span> y<span class=\"op\">;</span> })<span class=\"op\">;</span></span></code></pre></div>\n<p>Let’s look at the structure again:</p>\n<div class=\"sourceCode\" id=\"cb169\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb169-1\"><a href=\"#cb169-1\"></a>&lt;expression&gt;(&lt;comma separated expressions&gt;)</span></code></pre></div>\n<p>Call expressions consist of an expression that results in a function when evaluated and a list of expressions that are the arguments to this function call. As an AST node they look like this:</p>\n<div class=\"sourceCode\" id=\"cb170\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb170-1\"><a href=\"#cb170-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb170-2\"><a href=\"#cb170-2\"></a></span>\n<span id=\"cb170-3\"><a href=\"#cb170-3\"></a><span class=\"kw\">type</span> CallExpression <span class=\"kw\">struct</span> {</span>\n<span id=\"cb170-4\"><a href=\"#cb170-4\"></a>    Token     token.Token <span class=\"co\">// The &#39;(&#39; token</span></span>\n<span id=\"cb170-5\"><a href=\"#cb170-5\"></a>    Function  Expression  <span class=\"co\">// Identifier or FunctionLiteral</span></span>\n<span id=\"cb170-6\"><a href=\"#cb170-6\"></a>    Arguments []Expression</span>\n<span id=\"cb170-7\"><a href=\"#cb170-7\"></a>}</span>\n<span id=\"cb170-8\"><a href=\"#cb170-8\"></a></span>\n<span id=\"cb170-9\"><a href=\"#cb170-9\"></a><span class=\"kw\">func</span> (ce *CallExpression) expressionNode()      {}</span>\n<span id=\"cb170-10\"><a href=\"#cb170-10\"></a><span class=\"kw\">func</span> (ce *CallExpression) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> ce.Token.Literal }</span>\n<span id=\"cb170-11\"><a href=\"#cb170-11\"></a><span class=\"kw\">func</span> (ce *CallExpression) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb170-12\"><a href=\"#cb170-12\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb170-13\"><a href=\"#cb170-13\"></a></span>\n<span id=\"cb170-14\"><a href=\"#cb170-14\"></a>    args := []<span class=\"dt\">string</span>{}</span>\n<span id=\"cb170-15\"><a href=\"#cb170-15\"></a>    <span class=\"kw\">for</span> _, a := <span class=\"kw\">range</span> ce.Arguments {</span>\n<span id=\"cb170-16\"><a href=\"#cb170-16\"></a>        args = <span class=\"bu\">append</span>(args, a.String())</span>\n<span id=\"cb170-17\"><a href=\"#cb170-17\"></a>    }</span>\n<span id=\"cb170-18\"><a href=\"#cb170-18\"></a></span>\n<span id=\"cb170-19\"><a href=\"#cb170-19\"></a>    out.WriteString(ce.Function.String())</span>\n<span id=\"cb170-20\"><a href=\"#cb170-20\"></a>    out.WriteString(<span class=\"st\">&quot;(&quot;</span>)</span>\n<span id=\"cb170-21\"><a href=\"#cb170-21\"></a>    out.WriteString(strings.Join(args, <span class=\"st\">&quot;, &quot;</span>))</span>\n<span id=\"cb170-22\"><a href=\"#cb170-22\"></a>    out.WriteString(<span class=\"st\">&quot;)&quot;</span>)</span>\n<span id=\"cb170-23\"><a href=\"#cb170-23\"></a></span>\n<span id=\"cb170-24\"><a href=\"#cb170-24\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb170-25\"><a href=\"#cb170-25\"></a>}</span></code></pre></div>\n<p>The test case for call expressions is just like the rest of our test suite and makes assertions about the <code>*ast.CallExpression</code> structure:</p>\n<div class=\"sourceCode\" id=\"cb171\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb171-1\"><a href=\"#cb171-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb171-2\"><a href=\"#cb171-2\"></a></span>\n<span id=\"cb171-3\"><a href=\"#cb171-3\"></a><span class=\"kw\">func</span> TestCallExpressionParsing(t *testing.T) {</span>\n<span id=\"cb171-4\"><a href=\"#cb171-4\"></a>    input := <span class=\"st\">&quot;add(1, 2 * 3, 4 + 5);&quot;</span></span>\n<span id=\"cb171-5\"><a href=\"#cb171-5\"></a></span>\n<span id=\"cb171-6\"><a href=\"#cb171-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb171-7\"><a href=\"#cb171-7\"></a>    p := New(l)</span>\n<span id=\"cb171-8\"><a href=\"#cb171-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb171-9\"><a href=\"#cb171-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb171-10\"><a href=\"#cb171-10\"></a></span>\n<span id=\"cb171-11\"><a href=\"#cb171-11\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(program.Statements) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb171-12\"><a href=\"#cb171-12\"></a>        t.Fatalf(<span class=\"st\">&quot;program.Statements does not contain %d statements. got=%d</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb171-13\"><a href=\"#cb171-13\"></a>            <span class=\"dv\">1</span>, <span class=\"bu\">len</span>(program.Statements))</span>\n<span id=\"cb171-14\"><a href=\"#cb171-14\"></a>    }</span>\n<span id=\"cb171-15\"><a href=\"#cb171-15\"></a></span>\n<span id=\"cb171-16\"><a href=\"#cb171-16\"></a>    stmt, ok := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb171-17\"><a href=\"#cb171-17\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb171-18\"><a href=\"#cb171-18\"></a>        t.Fatalf(<span class=\"st\">&quot;stmt is not ast.ExpressionStatement. got=%T&quot;</span>,</span>\n<span id=\"cb171-19\"><a href=\"#cb171-19\"></a>            program.Statements[<span class=\"dv\">0</span>])</span>\n<span id=\"cb171-20\"><a href=\"#cb171-20\"></a>    }</span>\n<span id=\"cb171-21\"><a href=\"#cb171-21\"></a></span>\n<span id=\"cb171-22\"><a href=\"#cb171-22\"></a>    exp, ok := stmt.Expression.(*ast.CallExpression)</span>\n<span id=\"cb171-23\"><a href=\"#cb171-23\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb171-24\"><a href=\"#cb171-24\"></a>        t.Fatalf(<span class=\"st\">&quot;stmt.Expression is not ast.CallExpression. got=%T&quot;</span>,</span>\n<span id=\"cb171-25\"><a href=\"#cb171-25\"></a>            stmt.Expression)</span>\n<span id=\"cb171-26\"><a href=\"#cb171-26\"></a>    }</span>\n<span id=\"cb171-27\"><a href=\"#cb171-27\"></a></span>\n<span id=\"cb171-28\"><a href=\"#cb171-28\"></a>    <span class=\"kw\">if</span> !testIdentifier(t, exp.Function, <span class=\"st\">&quot;add&quot;</span>) {</span>\n<span id=\"cb171-29\"><a href=\"#cb171-29\"></a>        <span class=\"kw\">return</span></span>\n<span id=\"cb171-30\"><a href=\"#cb171-30\"></a>    }</span>\n<span id=\"cb171-31\"><a href=\"#cb171-31\"></a></span>\n<span id=\"cb171-32\"><a href=\"#cb171-32\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(exp.Arguments) != <span class=\"dv\">3</span> {</span>\n<span id=\"cb171-33\"><a href=\"#cb171-33\"></a>        t.Fatalf(<span class=\"st\">&quot;wrong length of arguments. got=%d&quot;</span>, <span class=\"bu\">len</span>(exp.Arguments))</span>\n<span id=\"cb171-34\"><a href=\"#cb171-34\"></a>    }</span>\n<span id=\"cb171-35\"><a href=\"#cb171-35\"></a></span>\n<span id=\"cb171-36\"><a href=\"#cb171-36\"></a>    testLiteralExpression(t, exp.Arguments[<span class=\"dv\">0</span>], <span class=\"dv\">1</span>)</span>\n<span id=\"cb171-37\"><a href=\"#cb171-37\"></a>    testInfixExpression(t, exp.Arguments[<span class=\"dv\">1</span>], <span class=\"dv\">2</span>, <span class=\"st\">&quot;*&quot;</span>, <span class=\"dv\">3</span>)</span>\n<span id=\"cb171-38\"><a href=\"#cb171-38\"></a>    testInfixExpression(t, exp.Arguments[<span class=\"dv\">2</span>], <span class=\"dv\">4</span>, <span class=\"st\">&quot;+&quot;</span>, <span class=\"dv\">5</span>)</span>\n<span id=\"cb171-39\"><a href=\"#cb171-39\"></a>}</span></code></pre></div>\n<p>As with function literals and parameter parsing it’s also a good idea to add a separate test for the argument parsing. Just to make sure that every corner case works and is covered by a test. I added a <code>TestCallExpressionParameterParsing</code> test function that does exactly this. You can see it in the code for this chapter.</p>\n<p>So far, so familiar. But now comes the twist. If we run the tests we get this error message:</p>\n<div class=\"sourceCode\" id=\"cb172\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb172-1\"><a href=\"#cb172-1\"></a>$ go test ./parser</span>\n<span id=\"cb172-2\"><a href=\"#cb172-2\"></a>--- FAIL: TestCallExpressionParsing (0.00s)</span>\n<span id=\"cb172-3\"><a href=\"#cb172-3\"></a>  parser_test.go:853: parser has 4 errors</span>\n<span id=\"cb172-4\"><a href=\"#cb172-4\"></a>  parser_test.go:855: parser error: &quot;expected next token to be ), got , instead&quot;</span>\n<span id=\"cb172-5\"><a href=\"#cb172-5\"></a>  parser_test.go:855: parser error: &quot;no prefix parse function for , found&quot;</span>\n<span id=\"cb172-6\"><a href=\"#cb172-6\"></a>  parser_test.go:855: parser error: &quot;no prefix parse function for , found&quot;</span>\n<span id=\"cb172-7\"><a href=\"#cb172-7\"></a>  parser_test.go:855: parser error: &quot;no prefix parse function for ) found&quot;</span>\n<span id=\"cb172-8\"><a href=\"#cb172-8\"></a>FAIL</span>\n<span id=\"cb172-9\"><a href=\"#cb172-9\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>Huh, that doesn’t make a lot of sense. Why is there no error message telling us to register a <code>prefixParseFn</code> for call expressions? Because there <em>are no new token types</em> in call expressions. So what do we do instead of registering a <code>prefixParseFn</code>? Take at look at this:</p>\n<div class=\"sourceCode\" id=\"cb173\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb173-1\"><a href=\"#cb173-1\"></a>add(<span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span>)<span class=\"op\">;</span></span></code></pre></div>\n<p>The <code>add</code> is an identifier that’s parsed by a <code>prefixParseFn</code>. And after the identifier comes a <code>token.LPAREN</code>, right between the identifier and the list of arguments, just in the middle, in infix position… Yes, we need to register an <code>infixParseFn</code> for <code>token.LPAREN</code>. This way we parse the expression that is the function (either an identifier, or a function literal), then check for an <code>infixParseFn</code> associated with <code>token.LPAREN</code> and call it with the already parsed expression as argument. And in this <code>infixParseFn</code> we can then parse the argument list. Perfect!</p>\n<div class=\"sourceCode\" id=\"cb174\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb174-1\"><a href=\"#cb174-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb174-2\"><a href=\"#cb174-2\"></a></span>\n<span id=\"cb174-3\"><a href=\"#cb174-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb174-4\"><a href=\"#cb174-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb174-5\"><a href=\"#cb174-5\"></a>    p.registerInfix(token.LPAREN, p.parseCallExpression)</span>\n<span id=\"cb174-6\"><a href=\"#cb174-6\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb174-7\"><a href=\"#cb174-7\"></a>}</span>\n<span id=\"cb174-8\"><a href=\"#cb174-8\"></a></span>\n<span id=\"cb174-9\"><a href=\"#cb174-9\"></a><span class=\"kw\">func</span> (p *Parser) parseCallExpression(function ast.Expression) ast.Expression {</span>\n<span id=\"cb174-10\"><a href=\"#cb174-10\"></a>    exp := &amp;ast.CallExpression{Token: p.curToken, Function: function}</span>\n<span id=\"cb174-11\"><a href=\"#cb174-11\"></a>    exp.Arguments = p.parseCallArguments()</span>\n<span id=\"cb174-12\"><a href=\"#cb174-12\"></a>    <span class=\"kw\">return</span> exp</span>\n<span id=\"cb174-13\"><a href=\"#cb174-13\"></a>}</span>\n<span id=\"cb174-14\"><a href=\"#cb174-14\"></a></span>\n<span id=\"cb174-15\"><a href=\"#cb174-15\"></a><span class=\"kw\">func</span> (p *Parser) parseCallArguments() []ast.Expression {</span>\n<span id=\"cb174-16\"><a href=\"#cb174-16\"></a>    args := []ast.Expression{}</span>\n<span id=\"cb174-17\"><a href=\"#cb174-17\"></a></span>\n<span id=\"cb174-18\"><a href=\"#cb174-18\"></a>    <span class=\"kw\">if</span> p.peekTokenIs(token.RPAREN) {</span>\n<span id=\"cb174-19\"><a href=\"#cb174-19\"></a>        p.nextToken()</span>\n<span id=\"cb174-20\"><a href=\"#cb174-20\"></a>        <span class=\"kw\">return</span> args</span>\n<span id=\"cb174-21\"><a href=\"#cb174-21\"></a>    }</span>\n<span id=\"cb174-22\"><a href=\"#cb174-22\"></a></span>\n<span id=\"cb174-23\"><a href=\"#cb174-23\"></a>    p.nextToken()</span>\n<span id=\"cb174-24\"><a href=\"#cb174-24\"></a>    args = <span class=\"bu\">append</span>(args, p.parseExpression(LOWEST))</span>\n<span id=\"cb174-25\"><a href=\"#cb174-25\"></a></span>\n<span id=\"cb174-26\"><a href=\"#cb174-26\"></a>    <span class=\"kw\">for</span> p.peekTokenIs(token.COMMA) {</span>\n<span id=\"cb174-27\"><a href=\"#cb174-27\"></a>        p.nextToken()</span>\n<span id=\"cb174-28\"><a href=\"#cb174-28\"></a>        p.nextToken()</span>\n<span id=\"cb174-29\"><a href=\"#cb174-29\"></a>        args = <span class=\"bu\">append</span>(args, p.parseExpression(LOWEST))</span>\n<span id=\"cb174-30\"><a href=\"#cb174-30\"></a>    }</span>\n<span id=\"cb174-31\"><a href=\"#cb174-31\"></a></span>\n<span id=\"cb174-32\"><a href=\"#cb174-32\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.RPAREN) {</span>\n<span id=\"cb174-33\"><a href=\"#cb174-33\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb174-34\"><a href=\"#cb174-34\"></a>    }</span>\n<span id=\"cb174-35\"><a href=\"#cb174-35\"></a></span>\n<span id=\"cb174-36\"><a href=\"#cb174-36\"></a>    <span class=\"kw\">return</span> args</span>\n<span id=\"cb174-37\"><a href=\"#cb174-37\"></a>}</span></code></pre></div>\n<p><code>parseCallExpression</code> receives the already parsed <code>function</code> as argument and uses it to construct an <code>*ast.CallExpression</code> node. To parse the argument list we call <code>parseCallArguments</code>, which looks strikingly similar to <code>parseFunctionParameters</code>, except that it’s more generic and returns a slice of <code>ast.Expression</code> and not <code>*ast.Identifier</code>.</p>\n<p>There is nothing here we haven’t seen before. All we did was register a new <code>infixParseFn</code>. The tests still fail though:</p>\n<div class=\"sourceCode\" id=\"cb175\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb175-1\"><a href=\"#cb175-1\"></a>$ go test ./parser</span>\n<span id=\"cb175-2\"><a href=\"#cb175-2\"></a>--- FAIL: TestCallExpressionParsing (0.00s)</span>\n<span id=\"cb175-3\"><a href=\"#cb175-3\"></a>  parser_test.go:853: parser has 4 errors</span>\n<span id=\"cb175-4\"><a href=\"#cb175-4\"></a>  parser_test.go:855: parser error: &quot;expected next token to be ), got , instead&quot;</span>\n<span id=\"cb175-5\"><a href=\"#cb175-5\"></a>  parser_test.go:855: parser error: &quot;no prefix parse function for , found&quot;</span>\n<span id=\"cb175-6\"><a href=\"#cb175-6\"></a>  parser_test.go:855: parser error: &quot;no prefix parse function for , found&quot;</span>\n<span id=\"cb175-7\"><a href=\"#cb175-7\"></a>  parser_test.go:855: parser error: &quot;no prefix parse function for ) found&quot;</span>\n<span id=\"cb175-8\"><a href=\"#cb175-8\"></a>FAIL</span>\n<span id=\"cb175-9\"><a href=\"#cb175-9\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>The reason that it still doesn’t work is that the <code>(</code> in <code>add(1, 2)</code> acts like an infix operator now, but we haven’t assigned a precedence to it. It doesn’t have the right “stickiness” yet, so <code>parseExpression</code> doesn’t return what we want. But call expressions have the highest precedence of all, so it’s important that we fix our precedences table:</p>\n<div class=\"sourceCode\" id=\"cb176\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb176-1\"><a href=\"#cb176-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb176-2\"><a href=\"#cb176-2\"></a></span>\n<span id=\"cb176-3\"><a href=\"#cb176-3\"></a><span class=\"kw\">var</span> precedences = <span class=\"kw\">map</span>[token.TokenType]<span class=\"dt\">int</span>{</span>\n<span id=\"cb176-4\"><a href=\"#cb176-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb176-5\"><a href=\"#cb176-5\"></a>    token.LPAREN:   CALL,</span>\n<span id=\"cb176-6\"><a href=\"#cb176-6\"></a>}</span></code></pre></div>\n<p>To make sure that call expressions really have the highest precedence we can just extend our <code>TestOperatorPrecedenceParsing</code> test function:</p>\n<div class=\"sourceCode\" id=\"cb177\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb177-1\"><a href=\"#cb177-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb177-2\"><a href=\"#cb177-2\"></a></span>\n<span id=\"cb177-3\"><a href=\"#cb177-3\"></a><span class=\"kw\">func</span> TestOperatorPrecedenceParsing(t *testing.T) {</span>\n<span id=\"cb177-4\"><a href=\"#cb177-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb177-5\"><a href=\"#cb177-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb177-6\"><a href=\"#cb177-6\"></a>        expected <span class=\"dt\">string</span></span>\n<span id=\"cb177-7\"><a href=\"#cb177-7\"></a>    }{</span>\n<span id=\"cb177-8\"><a href=\"#cb177-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb177-9\"><a href=\"#cb177-9\"></a>        {</span>\n<span id=\"cb177-10\"><a href=\"#cb177-10\"></a>            <span class=\"st\">&quot;a + add(b * c) + d&quot;</span>,</span>\n<span id=\"cb177-11\"><a href=\"#cb177-11\"></a>            <span class=\"st\">&quot;((a + add((b * c))) + d)&quot;</span>,</span>\n<span id=\"cb177-12\"><a href=\"#cb177-12\"></a>        },</span>\n<span id=\"cb177-13\"><a href=\"#cb177-13\"></a>        {</span>\n<span id=\"cb177-14\"><a href=\"#cb177-14\"></a>            <span class=\"st\">&quot;add(a, b, 1, 2 * 3, 4 + 5, add(6, 7 * 8))&quot;</span>,</span>\n<span id=\"cb177-15\"><a href=\"#cb177-15\"></a>            <span class=\"st\">&quot;add(a, b, 1, (2 * 3), (4 + 5), add(6, (7 * 8)))&quot;</span>,</span>\n<span id=\"cb177-16\"><a href=\"#cb177-16\"></a>        },</span>\n<span id=\"cb177-17\"><a href=\"#cb177-17\"></a>        {</span>\n<span id=\"cb177-18\"><a href=\"#cb177-18\"></a>            <span class=\"st\">&quot;add(a + b + c * d / f + g)&quot;</span>,</span>\n<span id=\"cb177-19\"><a href=\"#cb177-19\"></a>            <span class=\"st\">&quot;add((((a + b) + ((c * d) / f)) + g))&quot;</span>,</span>\n<span id=\"cb177-20\"><a href=\"#cb177-20\"></a>        },</span>\n<span id=\"cb177-21\"><a href=\"#cb177-21\"></a>    }</span>\n<span id=\"cb177-22\"><a href=\"#cb177-22\"></a></span>\n<span id=\"cb177-23\"><a href=\"#cb177-23\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb177-24\"><a href=\"#cb177-24\"></a>}</span></code></pre></div>\n<p>If we now run the tests again, we can see that all of them pass:</p>\n<div class=\"sourceCode\" id=\"cb178\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb178-1\"><a href=\"#cb178-1\"></a>$ go test ./parser</span>\n<span id=\"cb178-2\"><a href=\"#cb178-2\"></a>ok      monkey/parser   0.008s</span></code></pre></div>\n<p>Yes, all of them: the unit test, the test for argument parsing and the precedence tests - wow! They all pass! And if that wasn’t enough, here’s some more good news: we are done. Yes, the parser is finished. Granted, we’ll come back to it later, at the end of the book, to extend it once more. But for now: that’s it! The AST is fully defined and the parser works - it’s time to move on to the topic of evaluation.</p>\n<p>Before we do that though, let’s remove the TODOs we left in the code and extend our REPL to integrate the parser.</p>\n</section>\n<section id=\"removing-todos\" class=\"level3\" data-number=\"2.8.6\">\n<h3 data-number=\"2.8.6\">Removing TODOs</h3>\n<p>When we wrote the code that parses let and return statements we took a shortcut by skipping over the expressions:</p>\n<div class=\"sourceCode\" id=\"cb179\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb179-1\"><a href=\"#cb179-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb179-2\"><a href=\"#cb179-2\"></a></span>\n<span id=\"cb179-3\"><a href=\"#cb179-3\"></a><span class=\"kw\">func</span> (p *Parser) parseLetStatement() *ast.LetStatement {</span>\n<span id=\"cb179-4\"><a href=\"#cb179-4\"></a>    stmt := &amp;ast.LetStatement{Token: p.curToken}</span>\n<span id=\"cb179-5\"><a href=\"#cb179-5\"></a></span>\n<span id=\"cb179-6\"><a href=\"#cb179-6\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.IDENT) {</span>\n<span id=\"cb179-7\"><a href=\"#cb179-7\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb179-8\"><a href=\"#cb179-8\"></a>    }</span>\n<span id=\"cb179-9\"><a href=\"#cb179-9\"></a></span>\n<span id=\"cb179-10\"><a href=\"#cb179-10\"></a>    stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</span>\n<span id=\"cb179-11\"><a href=\"#cb179-11\"></a></span>\n<span id=\"cb179-12\"><a href=\"#cb179-12\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.ASSIGN) {</span>\n<span id=\"cb179-13\"><a href=\"#cb179-13\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb179-14\"><a href=\"#cb179-14\"></a>    }</span>\n<span id=\"cb179-15\"><a href=\"#cb179-15\"></a></span>\n<span id=\"cb179-16\"><a href=\"#cb179-16\"></a>    <span class=\"co\">// </span><span class=\"al\">TODO</span><span class=\"co\">: We&#39;re skipping the expressions until we</span></span>\n<span id=\"cb179-17\"><a href=\"#cb179-17\"></a>    <span class=\"co\">// encounter a semicolon</span></span>\n<span id=\"cb179-18\"><a href=\"#cb179-18\"></a>    <span class=\"kw\">for</span> !p.curTokenIs(token.SEMICOLON) {</span>\n<span id=\"cb179-19\"><a href=\"#cb179-19\"></a>        p.nextToken()</span>\n<span id=\"cb179-20\"><a href=\"#cb179-20\"></a>    }</span>\n<span id=\"cb179-21\"><a href=\"#cb179-21\"></a></span>\n<span id=\"cb179-22\"><a href=\"#cb179-22\"></a>    <span class=\"kw\">return</span> stmt</span>\n<span id=\"cb179-23\"><a href=\"#cb179-23\"></a>}</span></code></pre></div>\n<p>The same <code>TODO</code> sits in <code>parseReturnStatement</code>. It’s time to get rid of them. No shortcuts. First of all, we need to extend our existing tests to make sure that the expressions, that are parsed as part of a let or return statement, are actually there. We do this by using our helper functions (that don’t distract from the focus of the test) and different expression types, so we know that <code>parseExpression</code> is correctly integrated.</p>\n<p>Here is what the <code>TestLetStatement</code> function looks like:</p>\n<div class=\"sourceCode\" id=\"cb180\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb180-1\"><a href=\"#cb180-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb180-2\"><a href=\"#cb180-2\"></a></span>\n<span id=\"cb180-3\"><a href=\"#cb180-3\"></a><span class=\"kw\">func</span> TestLetStatements(t *testing.T) {</span>\n<span id=\"cb180-4\"><a href=\"#cb180-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb180-5\"><a href=\"#cb180-5\"></a>        input              <span class=\"dt\">string</span></span>\n<span id=\"cb180-6\"><a href=\"#cb180-6\"></a>        expectedIdentifier <span class=\"dt\">string</span></span>\n<span id=\"cb180-7\"><a href=\"#cb180-7\"></a>        expectedValue      <span class=\"kw\">interface</span>{}</span>\n<span id=\"cb180-8\"><a href=\"#cb180-8\"></a>    }{</span>\n<span id=\"cb180-9\"><a href=\"#cb180-9\"></a>        {<span class=\"st\">&quot;let x = 5;&quot;</span>, <span class=\"st\">&quot;x&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb180-10\"><a href=\"#cb180-10\"></a>        {<span class=\"st\">&quot;let y = true;&quot;</span>, <span class=\"st\">&quot;y&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb180-11\"><a href=\"#cb180-11\"></a>        {<span class=\"st\">&quot;let foobar = y;&quot;</span>, <span class=\"st\">&quot;foobar&quot;</span>, <span class=\"st\">&quot;y&quot;</span>},</span>\n<span id=\"cb180-12\"><a href=\"#cb180-12\"></a>    }</span>\n<span id=\"cb180-13\"><a href=\"#cb180-13\"></a></span>\n<span id=\"cb180-14\"><a href=\"#cb180-14\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb180-15\"><a href=\"#cb180-15\"></a>        l := lexer.New(tt.input)</span>\n<span id=\"cb180-16\"><a href=\"#cb180-16\"></a>        p := New(l)</span>\n<span id=\"cb180-17\"><a href=\"#cb180-17\"></a>        program := p.ParseProgram()</span>\n<span id=\"cb180-18\"><a href=\"#cb180-18\"></a>        checkParserErrors(t, p)</span>\n<span id=\"cb180-19\"><a href=\"#cb180-19\"></a></span>\n<span id=\"cb180-20\"><a href=\"#cb180-20\"></a>        <span class=\"kw\">if</span> <span class=\"bu\">len</span>(program.Statements) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb180-21\"><a href=\"#cb180-21\"></a>            t.Fatalf(<span class=\"st\">&quot;program.Statements does not contain 1 statements. got=%d&quot;</span>,</span>\n<span id=\"cb180-22\"><a href=\"#cb180-22\"></a>                <span class=\"bu\">len</span>(program.Statements))</span>\n<span id=\"cb180-23\"><a href=\"#cb180-23\"></a>        }</span>\n<span id=\"cb180-24\"><a href=\"#cb180-24\"></a></span>\n<span id=\"cb180-25\"><a href=\"#cb180-25\"></a>        stmt := program.Statements[<span class=\"dv\">0</span>]</span>\n<span id=\"cb180-26\"><a href=\"#cb180-26\"></a>        <span class=\"kw\">if</span> !testLetStatement(t, stmt, tt.expectedIdentifier) {</span>\n<span id=\"cb180-27\"><a href=\"#cb180-27\"></a>            <span class=\"kw\">return</span></span>\n<span id=\"cb180-28\"><a href=\"#cb180-28\"></a>        }</span>\n<span id=\"cb180-29\"><a href=\"#cb180-29\"></a></span>\n<span id=\"cb180-30\"><a href=\"#cb180-30\"></a>        val := stmt.(*ast.LetStatement).Value</span>\n<span id=\"cb180-31\"><a href=\"#cb180-31\"></a>        <span class=\"kw\">if</span> !testLiteralExpression(t, val, tt.expectedValue) {</span>\n<span id=\"cb180-32\"><a href=\"#cb180-32\"></a>            <span class=\"kw\">return</span></span>\n<span id=\"cb180-33\"><a href=\"#cb180-33\"></a>        }</span>\n<span id=\"cb180-34\"><a href=\"#cb180-34\"></a>    }</span>\n<span id=\"cb180-35\"><a href=\"#cb180-35\"></a>}</span></code></pre></div>\n<p>The same needs to be done for <code>TestReturnStatements</code>. And the fix is trivial, since we did such great work before. We merely need to hook up <code>parseExpression</code> in <code>parseReturnStatement</code> and <code>parseLetStatement</code>. And we also need to take care of optional semicolons, which we already know how to do from <code>parseExpressionStatement</code>. The updated, fully-working versions of <code>parseReturnStatement</code> and <code>parseLetStatement</code> look like this:</p>\n<div class=\"sourceCode\" id=\"cb181\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb181-1\"><a href=\"#cb181-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb181-2\"><a href=\"#cb181-2\"></a></span>\n<span id=\"cb181-3\"><a href=\"#cb181-3\"></a><span class=\"kw\">func</span> (p *Parser) parseReturnStatement() *ast.ReturnStatement {</span>\n<span id=\"cb181-4\"><a href=\"#cb181-4\"></a>    stmt := &amp;ast.ReturnStatement{Token: p.curToken}</span>\n<span id=\"cb181-5\"><a href=\"#cb181-5\"></a></span>\n<span id=\"cb181-6\"><a href=\"#cb181-6\"></a>    p.nextToken()</span>\n<span id=\"cb181-7\"><a href=\"#cb181-7\"></a></span>\n<span id=\"cb181-8\"><a href=\"#cb181-8\"></a>    stmt.ReturnValue = p.parseExpression(LOWEST)</span>\n<span id=\"cb181-9\"><a href=\"#cb181-9\"></a></span>\n<span id=\"cb181-10\"><a href=\"#cb181-10\"></a>    <span class=\"kw\">if</span> p.peekTokenIs(token.SEMICOLON) {</span>\n<span id=\"cb181-11\"><a href=\"#cb181-11\"></a>        p.nextToken()</span>\n<span id=\"cb181-12\"><a href=\"#cb181-12\"></a>    }</span>\n<span id=\"cb181-13\"><a href=\"#cb181-13\"></a></span>\n<span id=\"cb181-14\"><a href=\"#cb181-14\"></a>    <span class=\"kw\">return</span> stmt</span>\n<span id=\"cb181-15\"><a href=\"#cb181-15\"></a>}</span>\n<span id=\"cb181-16\"><a href=\"#cb181-16\"></a></span>\n<span id=\"cb181-17\"><a href=\"#cb181-17\"></a><span class=\"kw\">func</span> (p *Parser) parseLetStatement() *ast.LetStatement {</span>\n<span id=\"cb181-18\"><a href=\"#cb181-18\"></a>    stmt := &amp;ast.LetStatement{Token: p.curToken}</span>\n<span id=\"cb181-19\"><a href=\"#cb181-19\"></a></span>\n<span id=\"cb181-20\"><a href=\"#cb181-20\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.IDENT) {</span>\n<span id=\"cb181-21\"><a href=\"#cb181-21\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb181-22\"><a href=\"#cb181-22\"></a>    }</span>\n<span id=\"cb181-23\"><a href=\"#cb181-23\"></a></span>\n<span id=\"cb181-24\"><a href=\"#cb181-24\"></a>    stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}</span>\n<span id=\"cb181-25\"><a href=\"#cb181-25\"></a></span>\n<span id=\"cb181-26\"><a href=\"#cb181-26\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.ASSIGN) {</span>\n<span id=\"cb181-27\"><a href=\"#cb181-27\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb181-28\"><a href=\"#cb181-28\"></a>    }</span>\n<span id=\"cb181-29\"><a href=\"#cb181-29\"></a></span>\n<span id=\"cb181-30\"><a href=\"#cb181-30\"></a>    p.nextToken()</span>\n<span id=\"cb181-31\"><a href=\"#cb181-31\"></a></span>\n<span id=\"cb181-32\"><a href=\"#cb181-32\"></a>    stmt.Value = p.parseExpression(LOWEST)</span>\n<span id=\"cb181-33\"><a href=\"#cb181-33\"></a></span>\n<span id=\"cb181-34\"><a href=\"#cb181-34\"></a>    <span class=\"kw\">if</span> p.peekTokenIs(token.SEMICOLON) {</span>\n<span id=\"cb181-35\"><a href=\"#cb181-35\"></a>        p.nextToken()</span>\n<span id=\"cb181-36\"><a href=\"#cb181-36\"></a>    }</span>\n<span id=\"cb181-37\"><a href=\"#cb181-37\"></a></span>\n<span id=\"cb181-38\"><a href=\"#cb181-38\"></a>    <span class=\"kw\">return</span> stmt</span>\n<span id=\"cb181-39\"><a href=\"#cb181-39\"></a>}</span></code></pre></div>\n<p>Ah! All TODOs removed from the code. Let’s take this parser for a test drive.</p>\n</section>\n</section>\n<section id=\"read-parse-print-loop\" class=\"level2\" data-number=\"2.9\">\n<h2 data-number=\"2.9\">2.9 - Read-Parse-Print-Loop</h2>\n<p>Up until now our REPL was more of a RLPL, a read-lex-print-loop. We don’t know how to evaluate code yet, so replacing the “lex” with “evaluate” is still out of the question. But what we most certainly know by now is parsing. It’s time to replace the “lex” with “parse” and build a RPPL.</p>\n<div class=\"sourceCode\" id=\"cb182\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb182-1\"><a href=\"#cb182-1\"></a><span class=\"co\">// repl/repl.go</span></span>\n<span id=\"cb182-2\"><a href=\"#cb182-2\"></a></span>\n<span id=\"cb182-3\"><a href=\"#cb182-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb182-4\"><a href=\"#cb182-4\"></a>    <span class=\"st\">&quot;bufio&quot;</span></span>\n<span id=\"cb182-5\"><a href=\"#cb182-5\"></a>    <span class=\"st\">&quot;fmt&quot;</span></span>\n<span id=\"cb182-6\"><a href=\"#cb182-6\"></a>    <span class=\"st\">&quot;io&quot;</span></span>\n<span id=\"cb182-7\"><a href=\"#cb182-7\"></a>    <span class=\"st\">&quot;monkey/lexer&quot;</span></span>\n<span id=\"cb182-8\"><a href=\"#cb182-8\"></a>    <span class=\"st\">&quot;monkey/parser&quot;</span></span>\n<span id=\"cb182-9\"><a href=\"#cb182-9\"></a>)</span>\n<span id=\"cb182-10\"><a href=\"#cb182-10\"></a></span>\n<span id=\"cb182-11\"><a href=\"#cb182-11\"></a><span class=\"kw\">func</span> Start(in io.Reader, out io.Writer) {</span>\n<span id=\"cb182-12\"><a href=\"#cb182-12\"></a>    scanner := bufio.NewScanner(in)</span>\n<span id=\"cb182-13\"><a href=\"#cb182-13\"></a></span>\n<span id=\"cb182-14\"><a href=\"#cb182-14\"></a>    <span class=\"kw\">for</span> {</span>\n<span id=\"cb182-15\"><a href=\"#cb182-15\"></a>        fmt.Fprintf(out, PROMPT)</span>\n<span id=\"cb182-16\"><a href=\"#cb182-16\"></a>        scanned := scanner.Scan()</span>\n<span id=\"cb182-17\"><a href=\"#cb182-17\"></a>        <span class=\"kw\">if</span> !scanned {</span>\n<span id=\"cb182-18\"><a href=\"#cb182-18\"></a>            <span class=\"kw\">return</span></span>\n<span id=\"cb182-19\"><a href=\"#cb182-19\"></a>        }</span>\n<span id=\"cb182-20\"><a href=\"#cb182-20\"></a></span>\n<span id=\"cb182-21\"><a href=\"#cb182-21\"></a>        line := scanner.Text()</span>\n<span id=\"cb182-22\"><a href=\"#cb182-22\"></a>        l := lexer.New(line)</span>\n<span id=\"cb182-23\"><a href=\"#cb182-23\"></a>        p := parser.New(l)</span>\n<span id=\"cb182-24\"><a href=\"#cb182-24\"></a></span>\n<span id=\"cb182-25\"><a href=\"#cb182-25\"></a>        program := p.ParseProgram()</span>\n<span id=\"cb182-26\"><a href=\"#cb182-26\"></a>        <span class=\"kw\">if</span> <span class=\"bu\">len</span>(p.Errors()) != <span class=\"dv\">0</span> {</span>\n<span id=\"cb182-27\"><a href=\"#cb182-27\"></a>            printParserErrors(out, p.Errors())</span>\n<span id=\"cb182-28\"><a href=\"#cb182-28\"></a>            <span class=\"kw\">continue</span></span>\n<span id=\"cb182-29\"><a href=\"#cb182-29\"></a>        }</span>\n<span id=\"cb182-30\"><a href=\"#cb182-30\"></a></span>\n<span id=\"cb182-31\"><a href=\"#cb182-31\"></a>        io.WriteString(out, program.String())</span>\n<span id=\"cb182-32\"><a href=\"#cb182-32\"></a>        io.WriteString(out, <span class=\"st\">&quot;</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>)</span>\n<span id=\"cb182-33\"><a href=\"#cb182-33\"></a>    }</span>\n<span id=\"cb182-34\"><a href=\"#cb182-34\"></a>}</span>\n<span id=\"cb182-35\"><a href=\"#cb182-35\"></a></span>\n<span id=\"cb182-36\"><a href=\"#cb182-36\"></a><span class=\"kw\">func</span> printParserErrors(out io.Writer, errors []<span class=\"dt\">string</span>) {</span>\n<span id=\"cb182-37\"><a href=\"#cb182-37\"></a>    <span class=\"kw\">for</span> _, msg := <span class=\"kw\">range</span> errors {</span>\n<span id=\"cb182-38\"><a href=\"#cb182-38\"></a>        io.WriteString(out, <span class=\"st\">&quot;</span><span class=\"ch\">\\t</span><span class=\"st\">&quot;</span>+msg+<span class=\"st\">&quot;</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>)</span>\n<span id=\"cb182-39\"><a href=\"#cb182-39\"></a>    }</span>\n<span id=\"cb182-40\"><a href=\"#cb182-40\"></a>}</span></code></pre></div>\n<p>Here we extend our loop to parse the line we just entered in the REPL. The output of the parser, an <code>*ast.Program</code>, is then printed by calling its <code>String</code> method, which recursively calls the <code>String</code> method of all statements belonging to that program. Now we can take the parser for a spin - interactively on the command line:</p>\n<div class=\"sourceCode\" id=\"cb183\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb183-1\"><a href=\"#cb183-1\"></a>$ go run main.go</span>\n<span id=\"cb183-2\"><a href=\"#cb183-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb183-3\"><a href=\"#cb183-3\"></a>Feel free to type in commands</span>\n<span id=\"cb183-4\"><a href=\"#cb183-4\"></a>&gt;&gt; let x = 1 * 2 * 3 * 4 * 5</span>\n<span id=\"cb183-5\"><a href=\"#cb183-5\"></a>let x = ((((1 * 2) * 3) * 4) * 5);</span>\n<span id=\"cb183-6\"><a href=\"#cb183-6\"></a>&gt;&gt; x * y / 2 + 3 * 8 - 123</span>\n<span id=\"cb183-7\"><a href=\"#cb183-7\"></a>((((x * y) / 2) + (3 * 8)) - 123)</span>\n<span id=\"cb183-8\"><a href=\"#cb183-8\"></a>&gt;&gt; true == false</span>\n<span id=\"cb183-9\"><a href=\"#cb183-9\"></a>(true == false)</span>\n<span id=\"cb183-10\"><a href=\"#cb183-10\"></a>&gt;&gt;</span></code></pre></div>\n<p>Sweet! Now instead of calling <code>String</code> we could use any string-based representation of the AST to output here. We could add a <code>PrettyPrint</code> method that prints the type of the AST node and indents its child nodes correctly, or we could use ASCII color codes, or we could print an ASCII graph, or… The point is: the sky is the limit.</p>\n<p>But our RPPL still has a huge drawback. Here is what happens when the parser runs into an error:</p>\n<div class=\"sourceCode\" id=\"cb184\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb184-1\"><a href=\"#cb184-1\"></a>$ go run main.go</span>\n<span id=\"cb184-2\"><a href=\"#cb184-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb184-3\"><a href=\"#cb184-3\"></a>Feel free to type in commands</span>\n<span id=\"cb184-4\"><a href=\"#cb184-4\"></a>&gt;&gt; let x 12 * 3;</span>\n<span id=\"cb184-5\"><a href=\"#cb184-5\"></a>        expected next token to be =, got INT instead</span>\n<span id=\"cb184-6\"><a href=\"#cb184-6\"></a>&gt;&gt;</span></code></pre></div>\n<p>That’s not a very nice error message. I mean, it does the job, yes, but it’s not very nice, is it? The Monkey programming language deserves better. Here is a more user-friendly <code>printParseError</code> function that enhances the user-experience:</p>\n<div class=\"sourceCode\" id=\"cb185\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb185-1\"><a href=\"#cb185-1\"></a><span class=\"co\">// repl/repl.go</span></span>\n<span id=\"cb185-2\"><a href=\"#cb185-2\"></a></span>\n<span id=\"cb185-3\"><a href=\"#cb185-3\"></a><span class=\"kw\">const</span> MONKEY_FACE = <span class=\"st\">`            __,__</span></span>\n<span id=\"cb185-4\"><a href=\"#cb185-4\"></a><span class=\"st\">   .--.  .-&quot;     &quot;-.  .--.</span></span>\n<span id=\"cb185-5\"><a href=\"#cb185-5\"></a><span class=\"st\">  / .. \\/  .-. .-.  \\/ .. \\</span></span>\n<span id=\"cb185-6\"><a href=\"#cb185-6\"></a><span class=\"st\"> | |  &#39;|  /   Y   \\  |&#39;  | |</span></span>\n<span id=\"cb185-7\"><a href=\"#cb185-7\"></a><span class=\"st\"> | \\   \\  \\ 0 | 0 /  /   / |</span></span>\n<span id=\"cb185-8\"><a href=\"#cb185-8\"></a><span class=\"st\">  \\ &#39;- ,\\.-&quot;&quot;&quot;&quot;&quot;&quot;&quot;-./, -&#39; /</span></span>\n<span id=\"cb185-9\"><a href=\"#cb185-9\"></a><span class=\"st\">   &#39;&#39;-&#39; /_   ^ ^   _\\ &#39;-&#39;&#39;</span></span>\n<span id=\"cb185-10\"><a href=\"#cb185-10\"></a><span class=\"st\">       |  \\._   _./  |</span></span>\n<span id=\"cb185-11\"><a href=\"#cb185-11\"></a><span class=\"st\">       \\   \\ &#39;~&#39; /   /</span></span>\n<span id=\"cb185-12\"><a href=\"#cb185-12\"></a><span class=\"st\">        &#39;._ &#39;-=-&#39; _.&#39;</span></span>\n<span id=\"cb185-13\"><a href=\"#cb185-13\"></a><span class=\"st\">           &#39;-----&#39;</span></span>\n<span id=\"cb185-14\"><a href=\"#cb185-14\"></a><span class=\"st\">`</span></span>\n<span id=\"cb185-15\"><a href=\"#cb185-15\"></a></span>\n<span id=\"cb185-16\"><a href=\"#cb185-16\"></a><span class=\"kw\">func</span> printParserErrors(out io.Writer, errors []<span class=\"dt\">string</span>) {</span>\n<span id=\"cb185-17\"><a href=\"#cb185-17\"></a>    io.WriteString(out, MONKEY_FACE)</span>\n<span id=\"cb185-18\"><a href=\"#cb185-18\"></a>    io.WriteString(out, <span class=\"st\">&quot;Woops! We ran into some monkey business here!</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>)</span>\n<span id=\"cb185-19\"><a href=\"#cb185-19\"></a>    io.WriteString(out, <span class=\"st\">&quot; parser errors:</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>)</span>\n<span id=\"cb185-20\"><a href=\"#cb185-20\"></a>    <span class=\"kw\">for</span> _, msg := <span class=\"kw\">range</span> errors {</span>\n<span id=\"cb185-21\"><a href=\"#cb185-21\"></a>        io.WriteString(out, <span class=\"st\">&quot;</span><span class=\"ch\">\\t</span><span class=\"st\">&quot;</span>+msg+<span class=\"st\">&quot;</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>)</span>\n<span id=\"cb185-22\"><a href=\"#cb185-22\"></a>    }</span>\n<span id=\"cb185-23\"><a href=\"#cb185-23\"></a>}</span></code></pre></div>\n<p>That’s better! If we now run into any parser errors, we get to see a monkey, which, really, is more than anyone could ask for:</p>\n<div class=\"sourceCode\" id=\"cb186\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb186-1\"><a href=\"#cb186-1\"></a>$ go run main.go</span>\n<span id=\"cb186-2\"><a href=\"#cb186-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb186-3\"><a href=\"#cb186-3\"></a>Feel free to type in commands</span>\n<span id=\"cb186-4\"><a href=\"#cb186-4\"></a>&gt;&gt; let x 12 * 3</span>\n<span id=\"cb186-5\"><a href=\"#cb186-5\"></a>            __,__</span>\n<span id=\"cb186-6\"><a href=\"#cb186-6\"></a>   .--.  .-&quot;     &quot;-.  .--.</span>\n<span id=\"cb186-7\"><a href=\"#cb186-7\"></a>  / .. \\/  .-. .-.  \\/ .. \\</span>\n<span id=\"cb186-8\"><a href=\"#cb186-8\"></a> | |  &#39;|  /   Y   \\  |&#39;  | |</span>\n<span id=\"cb186-9\"><a href=\"#cb186-9\"></a> | \\   \\  \\ 0 | 0 /  /   / |</span>\n<span id=\"cb186-10\"><a href=\"#cb186-10\"></a>  \\ &#39;- ,\\.-&quot;&quot;&quot;&quot;&quot;&quot;&quot;-./, -&#39; /</span>\n<span id=\"cb186-11\"><a href=\"#cb186-11\"></a>   &#39;&#39;-&#39; /_   ^ ^   _\\ &#39;-&#39;&#39;</span>\n<span id=\"cb186-12\"><a href=\"#cb186-12\"></a>       |  \\._   _./  |</span>\n<span id=\"cb186-13\"><a href=\"#cb186-13\"></a>       \\   \\ &#39;~&#39; /   /</span>\n<span id=\"cb186-14\"><a href=\"#cb186-14\"></a>        &#39;._ &#39;-=-&#39; _.&#39;</span>\n<span id=\"cb186-15\"><a href=\"#cb186-15\"></a>           &#39;-----&#39;</span>\n<span id=\"cb186-16\"><a href=\"#cb186-16\"></a>Woops! We ran into some monkey business here!</span>\n<span id=\"cb186-17\"><a href=\"#cb186-17\"></a> parser errors:</span>\n<span id=\"cb186-18\"><a href=\"#cb186-18\"></a>        expected next token to be =, got INT instead</span>\n<span id=\"cb186-19\"><a href=\"#cb186-19\"></a>&gt;&gt;</span></code></pre></div>\n<p>On second thought… Anyway, it’s time to start evaluating our AST.</p>\n</section>\n</section>\n</body>\n</html>\n" }, Chapter { title: "Evaluation", sections: [Section { title: "Evaluation", start_line: 0, fragment_id: Some("evaluation") }, Section { title: "3.1 - Giving Meaning to Symbols", start_line: 2, fragment_id: Some("giving-meaning-to-symbols") }, Section { title: "3.2 - Strategies of Evaluation", start_line: 54, fragment_id: Some("strategies-of-evaluation") }, Section { title: "3.3 - A Tree-Walking Interpreter", start_line: 165, fragment_id: Some("a-tree-walking-interpreter") }, Section { title: "3.4 - Representing Objects", start_line: 231, fragment_id: Some("representing-objects") }, Section { title: "3.5 - Evaluating Expressions", start_line: 456, fragment_id: Some("evaluating-expressions") }, Section { title: "3.6 - Conditionals", start_line: 1346, fragment_id: Some("conditionals") }, Section { title: "3.7 - Return Statements", start_line: 1516, fragment_id: Some("return-statements") }, Section { title: "3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling", start_line: 1751, fragment_id: Some("abort-abort-theres-been-a-mistake-or-error-handling") }, Section { title: "3.9 - Bindings & The Environment", start_line: 2071, fragment_id: Some("bindings-the-environment") }, Section { title: "3.10 - Functions & Function Calls", start_line: 2328, fragment_id: Some("functions-function-calls") }, Section { title: "3.11 - Who’s taking the trash out?", start_line: 2915, fragment_id: Some("whos-taking-the-trash-out") }], content_lines: [RenderedLine { text: "Evaluation", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.1 - Giving Meaning to Symbols", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We are finally here. Evaluation. The E in REPL and the last thing an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter has to do when processing source code. This is where code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "becomes meaningful. Without evaluation an expression like 1 + 2 is just", style: Normal, search_matches: [], inline_styles: [(58, 63, Code)], syntax_colors: [] }, RenderedLine { text: "a series of characters, tokens, or a tree structure that represents this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expression. It doesn’t mean anything. Evaluated, of course, 1 + 2 becomes 3.", style: Normal, search_matches: [], inline_styles: [(62, 67, Code), (76, 77, Code)], syntax_colors: [] }, RenderedLine { text: "5 > 1 becomes true, 5 < 1 becomes false and puts(\"Hello World!\") becomes the", style: Normal, search_matches: [], inline_styles: [(0, 5, Code), (14, 18, Code), (20, 25, Code), (34, 39, Code), (44, 64, Code)], syntax_colors: [] }, RenderedLine { text: "friendly message we all know.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The evaluation process of an interpreter defines how the programming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language being interpreted works.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let num = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "if (num) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "  return a;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "} else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "  return b;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Whether this returns a or b depends on the decision of the interpreter’s", style: Normal, search_matches: [], inline_styles: [(21, 22, Code), (26, 27, Code)], syntax_colors: [] }, RenderedLine { text: "evaluation process whether the integer 5 is truthy or not. In some languages", style: Normal, search_matches: [], inline_styles: [(40, 41, Code)], syntax_colors: [] }, RenderedLine { text: "it’s truthy, in others we’d need to use an expression that produces a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "boolean like 5 != 0.", style: Normal, search_matches: [], inline_styles: [(16, 20, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Consider this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let one = fn() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "  printLine(\"one\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "  return 1;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let two = fn() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "  printLine(\"two\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "  return 2;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "add(one(), two());", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Does this first output one and then two or the other way around? It depends", style: Normal, search_matches: [], inline_styles: [(23, 26, Code), (36, 39, Code)], syntax_colors: [] }, RenderedLine { text: "on the specification of the language and ultimately on the implementation", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of its interpreter and in which order it evaluates the arguments in a call", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expression.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In this chapter there will be many more small choices like these, where we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "get to decide how Monkey is going to work and how our interpreter evaluates", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Monkey source code.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Maybe you’re skeptical, after I told you that writing a parser was fun,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "but trust me: this is the best part. This is where the Monkey programming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language comes to life, where source code quickens and starts to breathe.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.2 - Strategies of Evaluation", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Evaluation is also where interpreter implementations (regardless of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "which language they’re interpreting) diverge the most. There are a lot", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of different strategies to choose from when evaluating source code. I’ve", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "already hinted at this in the introduction of this book, where we took a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "brief look at different interpreter architectures. Now that we’re here, AST", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in hand, the question of what to do with it and how to evaluate this shiny", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tree of ours is more relevant than ever, so looking at different options", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "again is worthwhile.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Before we start, though, it’s also worth noting again that the line between", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreters and compilers is a blurry one. The notion of an interpreter", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "as something that doesn’t leave executable artifacts behind (in contrast to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a compiler, which does just that) gets fuzzy real fast when looking at the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implementations of real-world and highly-optimized programming languages.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With that said, the most obvious and classical choice of what to do with the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "AST is to just interpret it. Traverse the AST, visit each node and do what", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the node signifies: print a string, add two numbers, execute a function’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "body - all on the fly. Interpreters working this way are called “tree-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "walking interpreters” and are the archetype of interpreters. Sometimes", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "their evaluation step is preceded by small optimizations that rewrite", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the AST (e.g.\u{a0}remove unused variable bindings) or convert it into another", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "intermediate representation (IR) that’s more suitable for recursive and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "repeated evaluation.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Other interpreters also traverse the AST, but instead of interpreting the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "AST itself they first convert it to bytecode. Bytecode is another IR of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "AST and a really dense one at that. The exact format and of which opcodes", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "(the instructions that make up the bytecode) it’s composed of varies and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "depends on the guest and host programming languages. In general though, the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "opcodes are pretty similar to the mnemonics of most assembly languages; it’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a safe bet to say that most bytecode definitions contain opcodes for push", style: Normal, search_matches: [], inline_styles: [(71, 73, Code)], syntax_colors: [] }, RenderedLine { text: "and pop to do stack operations. But bytecode is not native machine code,", style: Normal, search_matches: [], inline_styles: [(0, 2, Code), (7, 10, Code)], syntax_colors: [] }, RenderedLine { text: "nor is it assembly language. It can’t and won’t be executed by the operating", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "system and the CPU of the machine the interpreter is running on. Instead", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it’s interpreted by a virtual machine, that’s part of the interpreter. Just", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "like VMWare and VirtualBox emulate real machines and CPUs, these virtual", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "machines emulate a machine that understands this particular bytecode format.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This approach can yield great performance benefits.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A variation of this strategy doesn’t involve an AST at all. Instead of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "building an AST the parser emits bytecode directly. Now, are we still", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "talking about interpreters or compilers? Isn’t emitting bytecode that gets", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "then interpreted (or should we say “executed”?) a form of compilation? I", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "told you: the line becomes blurry. And to make it even more fuzzy, consider", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this: some implementations of programming languages parse the source code,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "build an AST and convert this AST to bytecode. But instead of executing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the operations specified by the bytecode directly in a virtual machine, the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "virtual machine then compiles the bytecode to native machine code, right", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "before its executed - just in time. That’s called a JIT (for “just in time”)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter/compiler.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Others skip the compilation to bytecode. They recursively traverse the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "AST but before executing a particular branch of it the node is compiled to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "native machine code. And then executed. Again, “just in time”.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A slight variation of this is a mixed mode of interpretation where the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter recursively evaluates the AST and only after evaluating a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "particular branch of the AST multiple times does it compile the branch to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "machine code.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Amazing, isn’t it? So many different ways to go about this task of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluation, so many twists and variations.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The choice of which strategy to choose largely depends on performance and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "portability needs, the programming language that’s being interpreted and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "how far you’re willing to go. A tree-walking interpreter that recursively", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluates an AST is probably the slowest of all approaches, but easy to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "build, extend, reason about and as portable as the language it’s implemented", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "An interpreter that compiles to bytecode and uses a virtual machine to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluate said bytecode is going to be a lot faster. But more complicated and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "harder to build, too. Throw JIT compilation to machine code into the mix and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "now you also need to support multiple machine architectures if you want the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter to work on both ARM and x86 CPUs.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "All of these approaches can be found in real-world programming languages.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And most of the time the chosen approach changed with the lifetime of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language. Ruby is a great example here. Up to and including version 1.8", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the interpreter was a tree-walking interpreter, executing the AST while", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "traversing it. But with version 1.9 came the switch to a virtual machine", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "architecture. Now the Ruby interpreter parses source code, builds an AST and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "then compiles this AST into bytecode, which gets then executed in a virtual", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "machine. The increase in performance was huge.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The WebKit JavaScript engine JavaScriptCore and its interpreter named", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“Squirrelfish” also used AST walking and direct execution as its", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "approach. Then in 2008 came the switch to a virtual machine and bytecode", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpretation. Nowadays the engine has four (!) different stages of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "JIT compilation, which kick in at different times in the lifetime of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreted program – depending on which part of the program needs the best", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "performance.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Another example is Lua. The main implementation of the Lua programming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language started out as an interpreter that compiles to bytecode and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "executes the bytecode in a register-based virtual machine. 12 years after", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "its first release another implementation of the language was born: LuaJIT.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The clear goal of Mike Pall, the creator of LuaJIT, was to create the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fastest Lua implementation possible. And he did. By JIT compiling a dense", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "bytecode format to highly-optimized machine code for different architectures", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the LuaJIT implementation beats the original Lua in every benchmark. And not", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "just by a tiny bit, no; it’s sometimes 50 times faster.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So, a lot of interpreters started out small with room for improvement.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s exactly what we’re going to do. There are a lot of ways to build a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "faster interpreter, but not necessarily one that’s easier to understand. We", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "are here to learn, to understand and to be able to build upon our work.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.3 - A Tree-Walking Interpreter", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What we’re going to build is a tree-walking interpreter. We’re going to take", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the AST our parser builds for us and interpret it “on the fly”, without any", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "preprocessing or compilation step.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Our interpreter will be a lot like a classic Lisp interpreter. The design", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we’re going to use is heavily inspired by the interpreter presented in “The", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Structure and Interpretation of Computer Programs” (SICP), especially its", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "usage of environments. That doesn’t mean that we’re copying one particular", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter, no, we’re rather using a blueprint that you can see in lot of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "other interpreters too, if you squint hard enough. There are really good", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "reasons for the prevalence of this particular design: it’s the easiest way", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to get started, it’s easy to understand and to extend later on.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We only need two things really: a tree-walking evaluator and a way to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "represent Monkey values in our host language Go. Evaluator sounds mighty", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and grand, but it will be just one function called “eval”. Its job", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is to evaluate the AST. Here is a pseudocode version that illustrates", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "what “evaluating on the fly” and “tree-walking” mean in the context of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpretation:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function eval(astNode) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "  if (astNode is integerliteral) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    return astNode.integerValue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  } else if (astNode is booleanLiteral) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    return astNode.booleanValue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  } else if (astNode is infixExpression) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    leftEvaluated = eval(astNode.Left)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    rightEvaluated = eval(astNode.Right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if astNode.Operator == \"+\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "      return leftEvaluated + rightEvaluated", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else if ast.Operator == \"-\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "      return leftEvaluated - rightEvaluated", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As you can see, eval is recursive. When astNode is infixExpression is", style: Normal, search_matches: [], inline_styles: [(16, 20, Code), (40, 66, Code)], syntax_colors: [] }, RenderedLine { text: "true, eval calls itself again two times to evaluate the left and the right", style: Normal, search_matches: [], inline_styles: [(6, 10, Code)], syntax_colors: [] }, RenderedLine { text: "operands of the infix expression. This in turn may lead to the evaluation", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of another infix expression or an integer literal or a boolean literal or an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "identifier… We’ve already seen recursion at work when building and testing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the AST. The same concepts apply here, except that we’re evaluating the tree", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and not building it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Looking at this snippet of pseudocode you can probably imagine how easy", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it is to extend this function. That comes to our advantage. We’re going", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to build up our own Eval function piece by piece and add new branches and", style: Normal, search_matches: [], inline_styles: [(21, 25, Code)], syntax_colors: [] }, RenderedLine { text: "capabilities as we go along and extend our interpreter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But the most interesting lines of this snippet are the return statements.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What do they return? Here are two lines that bind the return value of a call", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to eval to names:", style: Normal, search_matches: [], inline_styles: [(3, 7, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "leftEvaluated = eval(astNode.Left)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "rightEvaluated = eval(astNode.Right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What does eval return here? Of which type are the return values? The answer", style: Normal, search_matches: [], inline_styles: [(10, 14, Code)], syntax_colors: [] }, RenderedLine { text: "to these questions is the same as the one for “what kind of internal object", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "system will our interpreter have?”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.4 - Representing Objects", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Wait, what? You never said Monkey was object oriented! Yes, I never did and", style: Normal, search_matches: [], inline_styles: [(0, 54, Italic)], syntax_colors: [] }, RenderedLine { text: "it’s not. Why do we need “a object system” then? Call it a “value system”", style: Normal, search_matches: [], inline_styles: [(12, 54, Italic)], syntax_colors: [] }, RenderedLine { text: "or “object representation” then. The point is, we need to define what our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“eval” function returns. We need a system that can represent the values our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "AST represents or values that we generate when evaluating the AST in memory.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s say we’re evaluating the following Monkey code:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let a = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "a + a;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As you can see, we’re binding the integer literal 5 to the name a. Then", style: Normal, search_matches: [], inline_styles: [(52, 53, Code), (66, 67, Code)], syntax_colors: [] }, RenderedLine { text: "things happen. It doesn’t matter what. What matters is that when we come", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "across the a + a expression later we need to access the value a is bound", style: Normal, search_matches: [], inline_styles: [(13, 18, Code), (64, 65, Code)], syntax_colors: [] }, RenderedLine { text: "to. In order to evaluate a + a we need to get to the 5. In the AST it’s", style: Normal, search_matches: [], inline_styles: [(28, 33, Code), (56, 57, Code)], syntax_colors: [] }, RenderedLine { text: "represented as an *ast.IntegerLiteral, but how are we going to keep track of", style: Normal, search_matches: [], inline_styles: [(22, 41, Code)], syntax_colors: [] }, RenderedLine { text: "and represent the 5 while we’re evaluating the rest of the AST?", style: Normal, search_matches: [], inline_styles: [(23, 24, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There are a lot of different choices when building an internal", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "representation of values in an interpreted language. And there is a lot", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of wisdom about this topic spread throughout the codebases of the world’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreters and compilers. Each interpreter has its own way to represent", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "values, always slightly differing from the solution that came before,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "adjusted for the requirements of the interpreted language.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Some use native types (integers, booleans, etc.) of the host language to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "represent values in the interpreted language, not wrapped in anything. In", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "other languages values/objects are represented only as pointers, whereas in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "some programming languages native types and pointers are mixed.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Why the variety? For one, the host languages differ. How you represent", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a string of your interpreted language depends on how a string can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "be represented in the language the interpreter is implemented in. An", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter written in Ruby can’t represent values the same way an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter written in C can.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And not only do the host languages differ, but the languages being", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreted do too. Some interpreted languages may only need representations", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of primitive data types, like integers, characters or bytes. But in others", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "you’ll have lists, dictionaries, functions or compound data types. These", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "differences lead to highly different requirements in regards to value", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "representation.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides the host language and the interpreted language, the biggest", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "influence on the design and implementation of value representations is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the resulting execution speed and the memory consumption while evaluating", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programs. If you want to build a fast interpreter you can’t get away with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a slow and bloated object system. And if you’re going to write your own", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "garbage collector, you need to think about how it’ll keep track of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "values in the system. But, on the other hand, if you don’t care about", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "performance, then it does make sense to keep things simple and easy to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "understand until further requirements arise.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The point is this: there are a lot of different ways to represent values", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of the interpreted languages in the host language. The best (and maybe the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "only) way to learn about these different representations is to actually read", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "through the source code of some popular interpreters. I heartily recommended", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the Wren source code, which includes two types of value representation,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "enabled/disabled by using a compiler flag.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides the representation of values inside the host language there is also", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the matter of how to expose these values and their representation to the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "user of the interpreted language. What does the “public API” of these values", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "look like?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Java, for example, offers both “primitive data types” (int, byte, short,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "long, float, double, boolean, char) and reference types to the user. The", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "primitive data types do not have a huge representation inside the Java", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implementation, they closely map to their native counterparts. Reference", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "types on the other hand are references to compound data structures defined", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in the host language.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In Ruby the user doesn’t have access to “primitive data types”, nothing like", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a native value type exists because everything is an object and thus wrapped", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "inside an internal representation. Internally Ruby doesn’t distinguish", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "between a byte and an instance of the class Pizza: both are the same value", style: Normal, search_matches: [], inline_styles: [(47, 52, Code)], syntax_colors: [] }, RenderedLine { text: "type, wrapping different values.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There are a myriad ways to expose data to users of programming languages.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Which one to choose depends on the language design and also, again, on", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "performance requirements. If you don’t care about performance everything", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "goes. But if you do, you need to make some smart decisions to achieve your", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "goals.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Foundation of our Object System", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Carefree as we still are about the performance of our Monkey interpreter,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we choose the easy way: we’re going to represent every value we encounter", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "when evaluating Monkey source code as an Object, an interface of our design.", style: Normal, search_matches: [], inline_styles: [(42, 48, Code)], syntax_colors: [] }, RenderedLine { text: "Every value will be wrapped inside a struct, which fulfills this Object", style: Normal, search_matches: [], inline_styles: [(67, 71, Code)], syntax_colors: [] }, RenderedLine { text: "interface.", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In a new object package we define the Object interface and the ObjectType", style: Normal, search_matches: [], inline_styles: [(9, 15, Code), (38, 44, Code), (63, 73, Code)], syntax_colors: [] }, RenderedLine { text: "type:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type ObjectType string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Object interface {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    Type() ObjectType", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Inspect() string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s pretty simple and looks a lot like what we did in the token package", style: Normal, search_matches: [], inline_styles: [(63, 68, Code)], syntax_colors: [] }, RenderedLine { text: "with the Token and TokenType types. Except that instead of being a struct", style: Normal, search_matches: [], inline_styles: [(10, 15, Code), (20, 29, Code)], syntax_colors: [] }, RenderedLine { text: "like Token the Object type is an interface. The reason is that every value", style: Normal, search_matches: [], inline_styles: [(7, 12, Code), (17, 23, Code)], syntax_colors: [] }, RenderedLine { text: "needs a different internal representation and it’s easier to define two", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "different struct types than trying to fit booleans and integers into the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "same struct field.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "At the moment we only have three data types in our Monkey interpreter:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "null, booleans and integers. Let’s start with implementing the integer", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "representation and build up our object system.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Integers", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The object.Integer type is as small as you’d expect it to be:", style: Normal, search_matches: [], inline_styles: [(4, 18, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import \"fmt\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Integer struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (i *Integer) Inspect() string { return fmt.Sprintf(\"%d\", i.Value) }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Whenever we encounter an integer literal in the source code we first turn it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "into an ast.IntegerLiteral and then, when evaluating that AST node, we turn", style: Normal, search_matches: [], inline_styles: [(8, 26, Code)], syntax_colors: [] }, RenderedLine { text: "it into an object.Integer, saving the value inside our struct and passing", style: Normal, search_matches: [], inline_styles: [(11, 25, Code)], syntax_colors: [] }, RenderedLine { text: "around a reference to this struct.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order for object.Integer to fulfill the object.Object interface, it still", style: Normal, search_matches: [], inline_styles: [(13, 27, Code), (43, 56, Code)], syntax_colors: [] }, RenderedLine { text: "needs a Type() method that returns its ObjectType. Just like we did with", style: Normal, search_matches: [], inline_styles: [(8, 14, Code), (39, 49, Code)], syntax_colors: [] }, RenderedLine { text: "token.TokenType we define constants for each ObjectType:", style: Normal, search_matches: [], inline_styles: [(0, 15, Code), (45, 55, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import \"fmt\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type ObjectType string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "    INTEGER_OBJ = \"INTEGER\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As I said, this is pretty much what we did in the token package. And with", style: Normal, search_matches: [], inline_styles: [(50, 55, Code)], syntax_colors: [] }, RenderedLine { text: "that in place we can add the Type() method to *object.Integer:", style: Normal, search_matches: [], inline_styles: [(29, 35, Code), (46, 61, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (i *Integer) Type() ObjectType { return INTEGER_OBJ }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And we’re done with Integer! Onto another data type: booleans.", style: Normal, search_matches: [], inline_styles: [(22, 29, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Booleans", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If you were expecting big things of this section, I’m sorry to disappoint.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Boolean is as tiny as it gets:", style: Normal, search_matches: [], inline_styles: [(1, 15, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    BOOLEAN_OBJ = \"BOOLEAN\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Boolean struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value bool", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (b *Boolean) Type() ObjectType { return BOOLEAN_OBJ }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "func (b *Boolean) Inspect() string  { return fmt.Sprintf(\"%t\", b.Value) }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 73, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Just a struct that wraps a single value, a bool.", style: Normal, search_matches: [], inline_styles: [(43, 47, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re close to finishing the foundation of our object system. The last", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "thing we need to do now, before we can start with our Eval function, is to", style: Normal, search_matches: [], inline_styles: [(55, 59, Code)], syntax_colors: [] }, RenderedLine { text: "represent a value that isn’t there.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Null", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Tony Hoare introduced null references to the ALGOL W language in 1965", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and called this his “billion-dollar mistake”. Since their introduction", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "countless systems have crashed because of references to “null”, a value", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that represents the absence of a value. Null (or “nil” as in some languages)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "doesn’t have the best reputation, to say the least.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I debated with myself whether Monkey should have null. On one hand, yes, the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language would be safer to use if it doesn’t allow null or null references.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But on the other, we’re not trying to reinvent the wheel, but to learn", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "something. And I found that having null at my disposal lead me to think", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "twice whenever there was a chance to use it. Kinda like having something", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "explosive in your car leads you to driving slower and more carefully.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It really made me appreciate the choices that go into the design of a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programming language. That’s something I consider worthwhile. So let’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implement the Null type and keep a close look and steady hand when using it", style: Normal, search_matches: [], inline_styles: [(19, 23, Code)], syntax_colors: [] }, RenderedLine { text: "later on.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    NULL_OBJ  = \"NULL\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Null struct{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (n *Null) Type() ObjectType { return NULL_OBJ }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "func (n *Null) Inspect() string  { return \"null\" }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Null is a struct just like object.Boolean and object.Integer, except", style: Normal, search_matches: [], inline_styles: [(0, 11, Code), (34, 48, Code), (53, 67, Code)], syntax_colors: [] }, RenderedLine { text: "that it doesn’t wrap any value. It represents the absence of any value.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With object.Null added, our object system is now capable of representing", style: Normal, search_matches: [], inline_styles: [(5, 16, Code)], syntax_colors: [] }, RenderedLine { text: "boolean, integer and null values. That’s more than enough to get started", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "with Eval.", style: Normal, search_matches: [], inline_styles: [(6, 10, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.5 - Evaluating Expressions", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Alright, here we go. Let’s start writing Eval! We have our AST and we have a", style: Normal, search_matches: [], inline_styles: [(43, 47, Code)], syntax_colors: [] }, RenderedLine { text: "new object system, that allows us to keep track of values we encounter when", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "executing Monkey source code. It’s time to finally evaluate the AST.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is what the signature of Eval will look like in its first version:", style: Normal, search_matches: [], inline_styles: [(30, 34, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Eval will take an ast.Node as input and return an object.Object. Remember", style: Normal, search_matches: [], inline_styles: [(0, 4, Code), (18, 26, Code), (50, 63, Code)], syntax_colors: [] }, RenderedLine { text: "that every node we defined in the ast package fulfills the ast.Node", style: Normal, search_matches: [], inline_styles: [(34, 37, Code), (59, 67, Code)], syntax_colors: [] }, RenderedLine { text: "interface and can thus be passed to Eval. This allows us to use Eval", style: Normal, search_matches: [], inline_styles: [(36, 40, Code), (64, 68, Code)], syntax_colors: [] }, RenderedLine { text: "recursively and call itself while evaluating a part of the AST. Each AST", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "node needs a different form of evaluation and Eval is the place where we", style: Normal, search_matches: [], inline_styles: [(46, 50, Code)], syntax_colors: [] }, RenderedLine { text: "decide what these forms look like. As an example, let’s say that we pass", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an *ast.Program node to Eval. What Eval should do then is to evaluate each", style: Normal, search_matches: [], inline_styles: [(4, 16, Code), (25, 29, Code), (36, 40, Code)], syntax_colors: [] }, RenderedLine { text: "of *ast.Program.Statements by calling itself with a single statement. The", style: Normal, search_matches: [], inline_styles: [(5, 28, Code)], syntax_colors: [] }, RenderedLine { text: "return value of the outer call to Eval is the return value of the last call.", style: Normal, search_matches: [], inline_styles: [(36, 40, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to start by implementing self-evaluating expressions. That’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "what we call literals in the land of Eval. Specifically, boolean and integer", style: Normal, search_matches: [], inline_styles: [(38, 42, Code)], syntax_colors: [] }, RenderedLine { text: "literals. They are the constructs in Monkey that are easiest to evaluate,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "because they evaluate to themselves. If I type 5 into my REPL then 5 is also", style: Normal, search_matches: [], inline_styles: [(50, 51, Code), (70, 71, Code)], syntax_colors: [] }, RenderedLine { text: "what should come out. And if I type in true then true is what I want.", style: Normal, search_matches: [], inline_styles: [(43, 47, Code), (53, 57, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Sounds easy enough? It is! So, let’s turn “type in 5, get back 5” into", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "reality.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Integer Literals", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Before writing any code though, what does this mean exactly? We’re given", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a single expression statement as input, which only contains an integer", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "literal, and want to evaluate it so that the integer itself is returned.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Translated into the language of our system, it means that, given an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "*ast.IntegerLiteral, our Eval function should return an *object.Integer", style: Normal, search_matches: [], inline_styles: [(0, 19, Code), (25, 29, Code), (56, 71, Code)], syntax_colors: [] }, RenderedLine { text: "whose Value field contains the same integer as *ast.IntegerLiteral.Value.", style: Normal, search_matches: [], inline_styles: [(6, 11, Code), (47, 72, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can easily write a test for this in our new evaluator package:", style: Normal, search_matches: [], inline_styles: [(47, 56, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/lexer\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/object\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/parser\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"testing\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestEvalIntegerExpression(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"10\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := testEval(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        testIntegerObject(t, evaluated, tt.expected)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testEval(input string) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := parser.New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return Eval(program)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testIntegerObject(t *testing.T, obj object.Object, expected int64) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 78, Rgb(192, 197, 206))] }, RenderedLine { text: "    result, ok := obj.(*object.Integer)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"object is not Integer. got=%T (%+v)\", obj, obj)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    if result.Value != expected {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"object has wrong value. got=%d, want=%d\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "            result.Value, expected)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s a lot of code for such a small test, isn’t it? As with our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser tests, we’re building up our testing infrastructure here. The", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestEvalIntegerExpression test will need to grow and its current structure", style: Normal, search_matches: [], inline_styles: [(2, 27, Code)], syntax_colors: [] }, RenderedLine { text: "makes this really easy. The testEval and testIntegerObject will also find a", style: Normal, search_matches: [], inline_styles: [(31, 39, Code), (44, 61, Code)], syntax_colors: [] }, RenderedLine { text: "lot of use.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The heart of the test is the call to Eval inside testEval. We take our", style: Normal, search_matches: [], inline_styles: [(37, 41, Code), (49, 57, Code)], syntax_colors: [] }, RenderedLine { text: "input, pass it to the lexer, pass the lexer to the parser and get back an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "AST. And then, this is new, we pass the AST to Eval. The return value of", style: Normal, search_matches: [], inline_styles: [(47, 51, Code)], syntax_colors: [] }, RenderedLine { text: "Eval is what we make assertions about. In this case, we want the return", style: Normal, search_matches: [], inline_styles: [(0, 4, Code)], syntax_colors: [] }, RenderedLine { text: "value to be an *object.Integer with the correct .Value. In other words: we", style: Normal, search_matches: [], inline_styles: [(15, 30, Code), (48, 54, Code)], syntax_colors: [] }, RenderedLine { text: "want 5 to evaluate to 5.", style: Normal, search_matches: [], inline_styles: [(5, 6, Code), (22, 23, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of course, the test fails because we haven’t defined Eval yet. But we", style: Normal, search_matches: [], inline_styles: [(55, 59, Code)], syntax_colors: [] }, RenderedLine { text: "already know that Eval should take an ast.Node as argument and return an", style: Normal, search_matches: [], inline_styles: [(19, 23, Code), (39, 47, Code)], syntax_colors: [] }, RenderedLine { text: "object.Object. And whenever it encounters an *ast.IntegerLiteral it should", style: Normal, search_matches: [], inline_styles: [(2, 15, Code), (47, 66, Code)], syntax_colors: [] }, RenderedLine { text: "return an *object.Integer with the correct .Value. Turning this into code", style: Normal, search_matches: [], inline_styles: [(12, 27, Code), (45, 51, Code)], syntax_colors: [] }, RenderedLine { text: "and defining our new Eval with this behaviour in the evaluator package, we", style: Normal, search_matches: [], inline_styles: [(23, 27, Code), (55, 64, Code)], syntax_colors: [] }, RenderedLine { text: "get this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/ast\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/object\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch node := node.(type) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.IntegerLiteral:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.Integer{Value: node.Value}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Nothing surprising here, it does just what we said it should. Except that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it doesn’t work. The test still fails because Eval returns nil instead of", style: Normal, search_matches: [], inline_styles: [(48, 52, Code), (61, 64, Code)], syntax_colors: [] }, RenderedLine { text: "an *object.Integer.", style: Normal, search_matches: [], inline_styles: [(4, 19, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestEvalIntegerExpression (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:36: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:36: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The reason for this failure is that we never encounter an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "*ast.IntegerLiteral in Eval. We don’t traverse the AST. We should always", style: Normal, search_matches: [], inline_styles: [(0, 19, Code), (23, 27, Code)], syntax_colors: [] }, RenderedLine { text: "start at the top of the tree, receiving an *ast.Program, and then traverse", style: Normal, search_matches: [], inline_styles: [(44, 56, Code)], syntax_colors: [] }, RenderedLine { text: "every node in it. And that’s exactly what we’re not doing here. We’re just", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "waiting for an *ast.IntegerLiteral. The fix is to actually traverse the tree", style: Normal, search_matches: [], inline_styles: [(18, 37, Code)], syntax_colors: [] }, RenderedLine { text: "and evaluate every statement of the *ast.Program:", style: Normal, search_matches: [], inline_styles: [(40, 49, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch node := node.(type) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // Statements", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.Program:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalStatements(node.Statements)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    case *ast.ExpressionStatement:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        return Eval(node.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // Expressions", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.IntegerLiteral:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.Integer{Value: node.Value}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalStatements(stmts []ast.Statement) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "    var result object.Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, statement := range stmts {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        result = Eval(statement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With these changes we evaluate every statement in a Monkey program. And if", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the statement is an *ast.ExpressionStatement we evaluate its expression.", style: Normal, search_matches: [], inline_styles: [(20, 44, Code)], syntax_colors: [] }, RenderedLine { text: "That mirrors the AST structure we get from a one line input like 5: a", style: Normal, search_matches: [], inline_styles: [(65, 66, Code)], syntax_colors: [] }, RenderedLine { text: "program that consists of one statement, an expression statement (not a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "return statement and not a let statement) with an integer literal as its", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expression.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Alright, the tests pass! We can evaluate integer literals! Hey everyone,", style: Normal, search_matches: [], inline_styles: [(59, 72, Italic)], syntax_colors: [] }, RenderedLine { text: "if we type in a number, a number comes out and it only took us a couple", style: Normal, search_matches: [], inline_styles: [(0, 71, Italic)], syntax_colors: [] }, RenderedLine { text: "thousand lines of code and tests to do so! Okay, granted, it doesn’t look", style: Normal, search_matches: [], inline_styles: [(0, 42, Italic)], syntax_colors: [] }, RenderedLine { text: "like much. But it’s a start. We’re beginning to see how evaluation works and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "how we can extend our evaluator. The structure of Eval won’t change, we’ll", style: Normal, search_matches: [], inline_styles: [(52, 56, Code)], syntax_colors: [] }, RenderedLine { text: "only add to and extend it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Next up on our list of self-evaluating expressions are boolean literals.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But before we do that, we should celebrate our first evaluation success and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "treat ourselves. Let’s put the E in REPL!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Completing the REPL", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Up until now the E in in our REPL was missing and we had nothing but a RPPL", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "- a Read-Parse-Print-Loop. Now that we have Eval we can build a real Read-", style: Normal, search_matches: [], inline_styles: [(44, 48, Code)], syntax_colors: [] }, RenderedLine { text: "Evaluate-Print-Loop!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Using the evaluator in the repl package is as easy as you’d think it is:", style: Normal, search_matches: [], inline_styles: [(27, 31, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// repl/repl.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/evaluator\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Start(in io.Reader, out io.Writer) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    scanner := bufio.NewScanner(in)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        fmt.Fprintf(out, PROMPT)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        scanned := scanner.Scan()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !scanned {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "            return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        line := scanner.Text()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        l := lexer.New(line)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        p := parser.New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        if len(p.Errors()) != 0 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "            printParserErrors(out, p.Errors())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "            continue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        evaluated := evaluator.Eval(program)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "        if evaluated != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "            io.WriteString(out, evaluated.Inspect())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "            io.WriteString(out, \"\\n\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Instead of printing program (the AST returned by the parser) we pass program", style: Normal, search_matches: [], inline_styles: [(20, 27, Code), (69, 76, Code)], syntax_colors: [] }, RenderedLine { text: "to Eval. If Eval returns a non-nil value, an object.Object, we print the", style: Normal, search_matches: [], inline_styles: [(3, 7, Code), (12, 16, Code), (45, 58, Code)], syntax_colors: [] }, RenderedLine { text: "output of its Inspect() method. In the case of an *object.Integer that would", style: Normal, search_matches: [], inline_styles: [(14, 23, Code), (50, 65, Code)], syntax_colors: [] }, RenderedLine { text: "be the string representation of the integer it’s wrapping.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And with that we now have a working REPL:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> 5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> 10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> 999", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "999", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: ">>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Feels good, doesn’t it? Lexing, parsing, evaluating - it’s all in there.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’ve come a long way.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Boolean Literals", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Boolean literals, just like their integer counterparts, evaluate to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "themselves. true evaluates to true and false to false. Implementing this in", style: Normal, search_matches: [], inline_styles: [(12, 16, Code), (30, 34, Code), (39, 44, Code), (48, 53, Code)], syntax_colors: [] }, RenderedLine { text: "Eval is as easy as adding support for integer literals was. The tests are", style: Normal, search_matches: [], inline_styles: [(0, 4, Code)], syntax_colors: [] }, RenderedLine { text: "equally boring:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestEvalBooleanExpression(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected bool", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"true\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"false\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := testEval(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        testBooleanObject(t, evaluated, tt.expected)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testBooleanObject(t *testing.T, obj object.Object, expected bool) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "    result, ok := obj.(*object.Boolean)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"object is not Boolean. got=%T (%+v)\", obj, obj)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    if result.Value != expected {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"object has wrong value. got=%t, want=%t\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "            result.Value, expected)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’ll extend the tests slice as soon as we support more expressions that", style: Normal, search_matches: [], inline_styles: [(19, 24, Code)], syntax_colors: [] }, RenderedLine { text: "result in booleans. For now, we only make sure that we get the correct", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "output when we enter true or false. The tests fail:", style: Normal, search_matches: [], inline_styles: [(23, 27, Code), (31, 36, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestEvalBooleanExpression (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:42: object is not Boolean. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:42: object is not Boolean. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Making this green is as easy as copying the case branch from", style: Normal, search_matches: [], inline_styles: [(44, 48, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.IntegerLiteral and changing two identifiers:", style: Normal, search_matches: [], inline_styles: [(0, 19, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.Boolean:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.Boolean{Value: node.Value}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s it! Let’s give it a spin in the REPL:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: None }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: None }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: None }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> true", style: CodeBlock { language: None }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "true", style: CodeBlock { language: None }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: ">> false", style: CodeBlock { language: None }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "false", style: CodeBlock { language: None }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: ">>", style: CodeBlock { language: None }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Pretty! But, let me ask you this: the fact that we’re creating a new", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Boolean every time we encounter a true or false is absurd, isn’t", style: Normal, search_matches: [], inline_styles: [(1, 15, Code), (42, 46, Code), (50, 55, Code)], syntax_colors: [] }, RenderedLine { text: "it? There is no difference between two trues. The same goes for false. Why", style: Normal, search_matches: [], inline_styles: [(41, 45, Code), (66, 71, Code)], syntax_colors: [] }, RenderedLine { text: "use new instances every time? There are only two possible values, so let’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "reference them instead of creating new ones.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    TRUE  = &object.Boolean{Value: true}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    FALSE = &object.Boolean{Value: false}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.Boolean:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nativeBoolToBooleanObject(node.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func nativeBoolToBooleanObject(input bool) *object.Boolean {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    if input {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        return TRUE", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    return FALSE", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now there are only two instances of object.Boolean in our package: TRUE and", style: Normal, search_matches: [], inline_styles: [(36, 50, Code), (67, 71, Code)], syntax_colors: [] }, RenderedLine { text: "FALSE and we reference them instead of allocating new object.Booleans. That", style: Normal, search_matches: [], inline_styles: [(0, 5, Code), (54, 68, Code)], syntax_colors: [] }, RenderedLine { text: "makes much more sense and is a small performance improvement we get without", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a lot of work. And while we’re at it, let’s take care of null, too.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Null", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Just as there is only one true and one false, there should only be one", style: Normal, search_matches: [], inline_styles: [(26, 30, Code), (39, 44, Code)], syntax_colors: [] }, RenderedLine { text: "reference to a null value. There are no variations of null. No kinda-but-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "not-quite-null, no half-null and no basically-the-same-as-the-other-null.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Either something is this one null, or it isn’t. So let’s create one NULL we", style: Normal, search_matches: [], inline_styles: [(72, 76, Code)], syntax_colors: [] }, RenderedLine { text: "can reference throughout our evaluator instead of creating new object.Nulls.", style: Normal, search_matches: [], inline_styles: [(63, 74, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    NULL  = &object.Null{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    TRUE  = &object.Boolean{Value: true}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    FALSE = &object.Boolean{Value: false}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s all there is to it. Now we have one NULL we can reference.", style: Normal, search_matches: [], inline_styles: [(49, 53, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With integer literals and our trio of NULL, TRUE and FALSE in place we’re", style: Normal, search_matches: [], inline_styles: [(38, 42, Code), (44, 48, Code), (53, 58, Code)], syntax_colors: [] }, RenderedLine { text: "ready to evaluate operator expressions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Prefix Expressions", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The simplest form of operator expressions Monkey supports is the prefix", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expression, or unary operator expression, where one operand follows the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operator. In our parser we treated a lot of language constructs like prefix", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions, because that’s the easiest way to parse them. But in this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "section prefix expressions are just operator expressions with one operator", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and one operand. Monkey supports two of these prefix operators: ! and -.", style: Normal, search_matches: [], inline_styles: [(66, 67, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Evaluating operator expressions (especially with a prefix operator and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "one operand) isn’t hard. We’ll do it in small steps and build up the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "desired behaviour bit by bit. But we also need to pay close attention.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What we’re about to implement has far reaching consequences. Remember: in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the evaluation process the input language receives meaning; we’re defining", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the semantics of the Monkey programming language. A small change in the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluation of operator expressions might cause something unintended in a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "part of the language that seems entirely unrelated. Tests help us to nail", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "down the desired behaviour and also act as a specification for us.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re going to start by implementing support for the ! operator. The tests", style: Normal, search_matches: [], inline_styles: [(55, 56, Code)], syntax_colors: [] }, RenderedLine { text: "show that the operator should “convert” its operand to a boolean value and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "negate it:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestBangOperator(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected bool", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"!true\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"!false\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"!5\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"!!true\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"!!false\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"!!5\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := testEval(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        testBooleanObject(t, evaluated, tt.expected)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As I said, this is where we decide how the language works. The !true and !", style: Normal, search_matches: [], inline_styles: [(63, 68, Code), (73, 74, Code)], syntax_colors: [] }, RenderedLine { text: "false expressions and their expected results seem like common sense, but", style: Normal, search_matches: [], inline_styles: [(0, 5, Code)], syntax_colors: [] }, RenderedLine { text: "the !5 may be something where other language designers feel an error should", style: Normal, search_matches: [], inline_styles: [(4, 6, Code)], syntax_colors: [] }, RenderedLine { text: "be returned. But what we’re saying here is that 5 acts as “truthy”.", style: Normal, search_matches: [], inline_styles: [(50, 51, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The tests don’t pass, of course, because Eval returns nil instead of TRUE or", style: Normal, search_matches: [], inline_styles: [(43, 47, Code), (56, 59, Code), (71, 75, Code)], syntax_colors: [] }, RenderedLine { text: "FALSE. The first step to evaluating a prefix expression is to evaluate its", style: Normal, search_matches: [], inline_styles: [(1, 6, Code)], syntax_colors: [] }, RenderedLine { text: "operand and then use the result of this evaluation with the operator:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.PrefixExpression:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        right := Eval(node.Right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalPrefixExpression(node.Operator, right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "After the first call to Eval here, right may be an *object.Integer or an", style: Normal, search_matches: [], inline_styles: [(24, 28, Code), (35, 40, Code), (51, 66, Code)], syntax_colors: [] }, RenderedLine { text: "*object.Boolean or maybe even NULL. We then take this right operand and pass", style: Normal, search_matches: [], inline_styles: [(0, 15, Code), (30, 34, Code), (54, 59, Code)], syntax_colors: [] }, RenderedLine { text: "it to evalPrefixExpression which checks if the operator is supported:", style: Normal, search_matches: [], inline_styles: [(6, 26, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalPrefixExpression(operator string, right object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch operator {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \"!\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalBangOperatorExpression(right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If the operator is not supported we return NULL. Is that the best choice?", style: Normal, search_matches: [], inline_styles: [(43, 47, Code)], syntax_colors: [] }, RenderedLine { text: "Maybe, maybe not. For now, it’s definitely the easiest choice, since we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "don’t have any error handling implemented yet.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The evalBangOperatorExpression function is where the behaviour of the !", style: Normal, search_matches: [], inline_styles: [(4, 30, Code), (70, 71, Code)], syntax_colors: [] }, RenderedLine { text: "is specified:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalBangOperatorExpression(right object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch right {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    case TRUE:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        return FALSE", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    case FALSE:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "        return TRUE", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    case NULL:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        return TRUE", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return FALSE", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And with that the tests pass!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s move on to the - prefix operator. We can extend our", style: Normal, search_matches: [], inline_styles: [(23, 24, Code)], syntax_colors: [] }, RenderedLine { text: "TestEvalIntegerExpression test function to incorporate it:", style: Normal, search_matches: [], inline_styles: [(1, 26, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestEvalIntegerExpression(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"10\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"-5\", -5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"-10\", -10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I choose to extend this test rather than writing a new test function solely", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "for the - prefix operator for two reasons. First, integers are the only", style: Normal, search_matches: [], inline_styles: [(8, 9, Code)], syntax_colors: [] }, RenderedLine { text: "supported operands of the - operator in prefix position. And second, because", style: Normal, search_matches: [], inline_styles: [(26, 27, Code)], syntax_colors: [] }, RenderedLine { text: "this test function should grow to encompass all integer arithmetic in order", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to have one place that shows the desired behaviour in a clear and neat way.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We have to extend the evalPrefixExpression function we wrote earlier in", style: Normal, search_matches: [], inline_styles: [(22, 42, Code)], syntax_colors: [] }, RenderedLine { text: "order to make the test cases pass. A new branch in the switch statement", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is needed:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalPrefixExpression(operator string, right object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch operator {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \"!\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalBangOperatorExpression(right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \"-\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalMinusPrefixOperatorExpression(right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The evalMinusPrefixOperatorExpression function looks like this:", style: Normal, search_matches: [], inline_styles: [(4, 37, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalMinusPrefixOperatorExpression(right object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "    if right.Type() != object.INTEGER_OBJ {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "        return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    value := right.(*object.Integer).Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    return &object.Integer{Value: -value}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we do here is to check if the operand is an integer.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If it isn’t, we return NULL. But if it is, we extract the value of the", style: Normal, search_matches: [], inline_styles: [(25, 29, Code)], syntax_colors: [] }, RenderedLine { text: "*object.Integer. Then we allocate a new object to wrap a negated version of", style: Normal, search_matches: [], inline_styles: [(1, 16, Code)], syntax_colors: [] }, RenderedLine { text: "this value.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That wasn’t a lot of code, was it? But still, it did the job:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Excellent! Now we can give our prefix expressions a spin in the REPL before", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "moving on to their infix friends:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> -5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "-5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> !true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: ">> !-5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: ">> !!-5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: ">> !!!!-5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: ">> -true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "null", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Amazing!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Infix Expressions", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As a refresher, here are the eight infix operators that Monkey supports:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 + 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 - 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 * 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 / 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 > 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 < 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 == 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "5 != 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "These eight operators can be separated into two groups: one group of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operators produces booleans as their result and one group doesn’t. We’ll", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "start by implementing support for the second group: +, -, *, /. And first", style: Normal, search_matches: [], inline_styles: [(53, 54, Code), (56, 57, Code), (59, 60, Code), (62, 63, Code)], syntax_colors: [] }, RenderedLine { text: "only in combination with integer operands. As soon as that works, we’ll add", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "support for booleans on either side of the operator.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The test infrastructure is already in place. We’ll just extend our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestEvalIntegerExpression test function with test cases for these new", style: Normal, search_matches: [], inline_styles: [(1, 26, Code)], syntax_colors: [] }, RenderedLine { text: "operators:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestEvalIntegerExpression(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"10\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"-5\", -5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"-10\", -10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 + 5 + 5 + 5 - 10\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"2 * 2 * 2 * 2 * 2\", 32},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"-50 + 100 + -50\", 0},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 * 2 + 10\", 20},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"5 + 2 * 10\", 25},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"20 + 2 * -10\", 0},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"50 / 2 * 2 + 10\", 60},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"2 * (5 + 10)\", 30},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"3 * 3 * 3 + 10\", 37},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"3 * (3 * 3) + 10\", 37},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"(5 + 10 * 2 + 15 / 3) * 2 + -10\", 50},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, there are probably some test cases that can be removed because", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "they duplicate another one and some add nothing new, but to be honest:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I was really trigger happy with these tests once I realized that the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implementation works and I just couldn’t believe it. “It can’t be that easy,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "can it?” Well, yes, it can.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "To get these test cases to pass, the first thing we need to do is to extend", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "our switch statement in Eval:", style: Normal, search_matches: [], inline_styles: [(24, 28, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.InfixExpression:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        left := Eval(node.Left)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        right := Eval(node.Right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalInfixExpression(node.Operator, left, right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Just as with *ast.PrefixExpression we evaluate the operands first. And", style: Normal, search_matches: [], inline_styles: [(13, 34, Code)], syntax_colors: [] }, RenderedLine { text: "now we have two: the left and the right arm of the AST node. We already", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "know that these may be any other expression - a function call, an integer", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "literal, an operator expression, etc. We don’t care. We let Eval take care", style: Normal, search_matches: [], inline_styles: [(62, 66, Code)], syntax_colors: [] }, RenderedLine { text: "of it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "After evaluating the operands we take the returned values and the operator", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and pass them to evalIntegerInfixExpressions, which looks like this:", style: Normal, search_matches: [], inline_styles: [(17, 44, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalInfixExpression(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    operator string,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    left, right object.Object,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "    case left.Type() == object.INTEGER_OBJ && right.Type() == object.INTEGER_OBJ:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 81, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalIntegerInfixExpression(operator, left, right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In case the operands aren’t both integers we return NULL, just as I", style: Normal, search_matches: [], inline_styles: [(54, 58, Code)], syntax_colors: [] }, RenderedLine { text: "promised. Of course, we’ll extend this function later on, but in order", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to get the tests to pass, this is enough. The heart of the matter lies in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evalIntegerInfixExpression, where the values wrapped by *object.Integers are", style: Normal, search_matches: [], inline_styles: [(2, 28, Code), (58, 73, Code)], syntax_colors: [] }, RenderedLine { text: "added, subtracted, multiplied and divided:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalIntegerInfixExpression(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    operator string,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    left, right object.Object,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    leftVal := left.(*object.Integer).Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    rightVal := right.(*object.Integer).Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    switch operator {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \"+\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.Integer{Value: leftVal + rightVal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \"-\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.Integer{Value: leftVal - rightVal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \"*\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.Integer{Value: leftVal * rightVal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \"/\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.Integer{Value: leftVal / rightVal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And now, believe it or not, the tests pass. Yes, really, they do:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Go on, add a few more. Knock yourself out. And then come back here so we can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "add support for the operators that result in booleans: ==, !=, < and >.", style: Normal, search_matches: [], inline_styles: [(55, 57, Code), (59, 61, Code), (63, 64, Code), (69, 70, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can extend our TestEvalBooleanExpression test function with test cases", style: Normal, search_matches: [], inline_styles: [(18, 43, Code)], syntax_colors: [] }, RenderedLine { text: "for these operators, since they all produce a boolean:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestEvalBooleanExpression(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected bool", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"true\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"false\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"1 < 2\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"1 > 2\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"1 < 1\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"1 > 1\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"1 == 1\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"1 != 1\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"1 == 2\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"1 != 2\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "A few added lines in evalIntegerInfixExpression is all that’s needed to get", style: Normal, search_matches: [], inline_styles: [(21, 47, Code)], syntax_colors: [] }, RenderedLine { text: "these tests to pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalIntegerInfixExpression(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    operator string,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    left, right object.Object,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    leftVal := left.(*object.Integer).Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    rightVal := right.(*object.Integer).Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    switch operator {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \"<\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nativeBoolToBooleanObject(leftVal < rightVal)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \">\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nativeBoolToBooleanObject(leftVal > rightVal)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \"==\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nativeBoolToBooleanObject(leftVal == rightVal)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "    case \"!=\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nativeBoolToBooleanObject(leftVal != rightVal)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The nativeBoolToBooleanObject function we already used for boolean literals", style: Normal, search_matches: [], inline_styles: [(4, 29, Code)], syntax_colors: [] }, RenderedLine { text: "now finds some reuse when we need to return either TRUE or FALSE based on", style: Normal, search_matches: [], inline_styles: [(51, 55, Code), (59, 64, Code)], syntax_colors: [] }, RenderedLine { text: "the comparison between the unwrapped values.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s it! Well, at least for integers. We now fully support the eight", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "infix operators when both operands are integers. What’s left in this section", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is adding support for boolean operands.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Monkey only supports boolean operands for the equality operators == and !=.", style: Normal, search_matches: [], inline_styles: [(65, 67, Code), (72, 74, Code)], syntax_colors: [] }, RenderedLine { text: "It doesn’t support adding, subtracting, dividing and multiplying booleans.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Checking whether true is greater than false with < or > is also unsupported.", style: Normal, search_matches: [], inline_styles: [(18, 22, Code), (39, 44, Code), (50, 51, Code), (55, 56, Code)], syntax_colors: [] }, RenderedLine { text: "That reduces our task to just adding support for two operators.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we have to do, as you know, is to add tests. And, as", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "before, we can extend an existing test function. In this case, we’ll use", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestEvalBooleanExpression and add test cases for the == and != operators:", style: Normal, search_matches: [], inline_styles: [(1, 26, Code), (54, 56, Code), (61, 63, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestEvalBooleanExpression(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected bool", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"true == true\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"false == false\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"true == false\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"true != false\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"false != true\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"(1 < 2) == true\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"(1 < 2) == false\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"(1 > 2) == true\", false},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"(1 > 2) == false\", true},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Strictly speaking, only the first five cases are necessary to test the new", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and desired behaviour. But let’s throw in the other four too to check the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "comparison between generated booleans.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So far, so good. Nothing surprising here. Just another set of of failing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tests:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestEvalBooleanExpression (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:121: object is not Boolean. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:121: object is not Boolean. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:121: object is not Boolean. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:121: object is not Boolean. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:121: object is not Boolean. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:121: object is not Boolean. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:121: object is not Boolean. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:121: object is not Boolean. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:121: object is not Boolean. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And here’s something neat to make those tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalInfixExpression(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    operator string,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    left, right object.Object,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case operator == \"==\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nativeBoolToBooleanObject(left == right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    case operator == \"!=\":", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nativeBoolToBooleanObject(left != right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, that’s right. We only add four lines to our existing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evalInfixExpression and the tests pass. We’re using pointer comparison here", style: Normal, search_matches: [], inline_styles: [(1, 20, Code)], syntax_colors: [] }, RenderedLine { text: "to check for equality between booleans. That works because we’re always", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "using pointers to our objects and in the case of booleans we only ever use", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "two: TRUE and FALSE. So, if something has the same value as TRUE (the memory", style: Normal, search_matches: [], inline_styles: [(8, 12, Code), (17, 22, Code), (63, 67, Code)], syntax_colors: [] }, RenderedLine { text: "address that is) then it’s true. This also works with NULL.", style: Normal, search_matches: [], inline_styles: [(60, 61, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This doesn’t work for integers or other data types we might add later on.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In the case of *object.Integer we’re always allocating new instances of", style: Normal, search_matches: [], inline_styles: [(16, 31, Code)], syntax_colors: [] }, RenderedLine { text: "object.Integer and thus use new pointers. We can’t compare these pointers", style: Normal, search_matches: [], inline_styles: [(2, 16, Code)], syntax_colors: [] }, RenderedLine { text: "to different instances, otherwise 5 == 5 would be false, which is not what", style: Normal, search_matches: [], inline_styles: [(37, 43, Code)], syntax_colors: [] }, RenderedLine { text: "we want. In this case we want to explicitly compare the values and not the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "objects that wrap these values.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s why the check for integer operands has to be higher up in the switch", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statement and match earlier than these newly added case branches. As long", style: Normal, search_matches: [], inline_styles: [(52, 56, Code)], syntax_colors: [] }, RenderedLine { text: "as we’re taking care of other operand types before arriving at these pointer", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "comparisons we’re fine and it works.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In ten years, when Monkey is a famous programming language and the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "discussion about research-ignoring dilettantes designing programming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "languages is still ongoing and we’re both rich and famous, someone will ask", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "on StackOverflow why integer comparison in Monkey is slower than boolean", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "comparison. The answer will be written by either you or me and one of us", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "will say that Monkey’s object system doesn’t allow pointer comparison for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "integer objects. It has to unwrap the value before a comparison can be made.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Thus the comparison between booleans is faster. We’ll add a “Source: I wrote", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it.” to the bottom of our answer and earn an unheard of amount of karma.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But I digress. To get back to topic, let me just say: Wow! We did it! I", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "know, I’m pretty lavish with my praise and can spot a cause for celebration", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "pretty easily, but if there ever was a time to pop the champagne, it’s now.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, we did it. Just look at what our interpreter can do now:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> 5 * 5 + 10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "35", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> 3 + 4 * 5 == 3 * 1 + 4 * 5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: ">> 5 * 10 > 40 + 5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: ">> (10 + 2) * 30 == 300 + 20 * 3", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: ">> (5 > 5 == true) != false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: ">> 500 / 2 != 250", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So, now we have a fully functional calculator that’s ready to do more. Let’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "give him more. Let’s make it look more like a programming language.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.6 - Conditionals", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "You’ll be amazed how easy it is to add support for conditionals in our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluator. The only hard thing about their implementation is deciding when", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to evaluate what. Because that’s the whole point of conditionals: only ever", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluate something based on a condition. Consider this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (x > 10) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "  puts(\"everything okay!\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "} else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "  puts(\"x is too low!\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "  shutdownSystem();", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When evaluating this if-else-expression the important thing is to only", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluate the correct branch. If the condition is met, we must never evaluate", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the else-branch, only the if-branch. And if it isn’t met we must only", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluate the else-branch.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In other words: we can only evaluate the else-branch of this conditional", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if the condition x > 10 is not … well, when it’s not what exactly? Should", style: Normal, search_matches: [], inline_styles: [(17, 23, Code)], syntax_colors: [] }, RenderedLine { text: "we evaluate the consequence, the \"everything okay!\" branch, only when", style: Normal, search_matches: [], inline_styles: [(34, 52, Code)], syntax_colors: [] }, RenderedLine { text: "the condition expression generates a true or when it generates something", style: Normal, search_matches: [], inline_styles: [(39, 43, Code)], syntax_colors: [] }, RenderedLine { text: "“truthy”, something that’s not false or not null?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s the tough part about this, because that’s a design decision, a", style: Normal, search_matches: [], inline_styles: [(4, 12, Italic)], syntax_colors: [] }, RenderedLine { text: "language design decision to be exact, with wide ranging consequences.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In the case of Monkey, the consequence part of the conditional will be", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluated when the condition is “truthy”. And “truthy” means: it’s not null", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and it’s not false. It doesn’t necessarily need to be true.", style: Normal, search_matches: [], inline_styles: [(59, 63, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let x = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "if (x) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "  puts(\"everything okay!\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "} else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "  puts(\"x is too high!\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "  shutdownSystem();", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In this example \"everything okay!\" should be printed. Why? Because x is", style: Normal, search_matches: [], inline_styles: [(16, 34, Code), (67, 68, Code)], syntax_colors: [] }, RenderedLine { text: "bound to 10, evaluates to 10 and 10 is not null and not false. That’s how", style: Normal, search_matches: [], inline_styles: [(9, 11, Code), (26, 28, Code), (33, 35, Code)], syntax_colors: [] }, RenderedLine { text: "conditionals are supposed to work in Monkey.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now that we’ve talked about this, we can turn this specification into a set", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of test cases:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestIfElseExpressions(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected interface{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"if (true) { 10 }\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"if (false) { 10 }\", nil},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"if (1) { 10 }\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"if (1 < 2) { 10 }\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"if (1 > 2) { 10 }\", nil},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"if (1 > 2) { 10 } else { 20 }\", 20},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"if (1 < 2) { 10 } else { 20 }\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := testEval(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        integer, ok := tt.expected.(int)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        if ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "            testIntegerObject(t, evaluated, int64(integer))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "        } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            testNullObject(t, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testNullObject(t *testing.T, obj object.Object) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "    if obj != NULL {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"object is not NULL. got=%T (%+v)\", obj, obj)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This test function also specifies behaviour we haven’t talked about yet.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When a conditional doesn’t evaluate to a value it’s supposed to return NULL,", style: Normal, search_matches: [], inline_styles: [(76, 80, Code)], syntax_colors: [] }, RenderedLine { text: "e.g.:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (false) { 10 }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The else is missing and thus the conditional should produce NULL.", style: Normal, search_matches: [], inline_styles: [(4, 8, Code), (60, 64, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We have to do a little type assertion and conversion dance to allow nil in", style: Normal, search_matches: [], inline_styles: [(68, 71, Code)], syntax_colors: [] }, RenderedLine { text: "our expected field, granted, but the tests are readable and clearly show", style: Normal, search_matches: [], inline_styles: [(4, 12, Code)], syntax_colors: [] }, RenderedLine { text: "the desired and hereby specified behaviour. They also fail, because we don’t", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "return any *object.Integers or NULL:", style: Normal, search_matches: [], inline_styles: [(12, 27, Code), (32, 36, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestIfElseExpressions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:125: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:153: object is not NULL. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:125: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:125: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:153: object is not NULL. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:125: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:125: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Earlier I told you that you’ll be amazed at how easy it is to implement", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "support for conditionals. Didn’t believe me? Well, look at this small amount", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of code necessary to make the tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.BlockStatement:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalStatements(node.Statements)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    case *ast.IfExpression:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalIfExpression(node)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalIfExpression(ie *ast.IfExpression) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "    condition := Eval(ie.Condition)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if isTruthy(condition) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        return Eval(ie.Consequence)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else if ie.Alternative != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        return Eval(ie.Alternative)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func isTruthy(obj object.Object) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch obj {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    case NULL:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    case TRUE:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    case FALSE:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "        return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As I said: the only hard thing is deciding what to evaluate. And that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "decision is encapsulated in evalIfExpression where the logic of the", style: Normal, search_matches: [], inline_styles: [(28, 44, Code)], syntax_colors: [] }, RenderedLine { text: "behaviour is pretty clear. isTruthy is equally expressive. Besides these", style: Normal, search_matches: [], inline_styles: [(27, 35, Code)], syntax_colors: [] }, RenderedLine { text: "two functions we also added the case branch for *ast.BlockStatement to", style: Normal, search_matches: [], inline_styles: [(32, 36, Code), (48, 67, Code)], syntax_colors: [] }, RenderedLine { text: "our Eval switch statement, because the .Consequence and .Alternative of", style: Normal, search_matches: [], inline_styles: [(4, 8, Code), (39, 51, Code), (56, 68, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.IfExpression are both block statements.", style: Normal, search_matches: [], inline_styles: [(0, 17, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We added two new and concise functions that show the semantics of the Monkey", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programming language in a clear way, reused another function we already had", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in place and with doing so added support for conditionals and made the tests", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "pass. Our interpreter now supports if-else-expressions! We’re now leaving", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "calculator territory and heading straight towards programming language land:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> if (5 * 5 + 10 > 34) { 99 } else { 100 }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "99", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> if ((1000 / 2) + 250 * 2 == 1000) { 9999 }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "9999", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: ">>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.7 - Return Statements", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now here’s something that you won’t find on your standard calculator: return", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statements. Monkey has them, like a lot of other languages. They can be", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "used in the bodies of functions but also as top-level statements in a Monkey", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "program. But it doesn’t really matter where they’re used, because how they", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "work doesn’t change: return statements stop the evaluation of a series of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statements and leave behind the value their expression has evaluated to.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is a top-level return statement in a Monkey program:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "5 * 5 * 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "return 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "9 * 9 * 9;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When evaluated this program should return 10. If these statements were", style: Normal, search_matches: [], inline_styles: [(42, 44, Code)], syntax_colors: [] }, RenderedLine { text: "the body of a function, calling the function should evaluate to 10. The", style: Normal, search_matches: [], inline_styles: [(64, 66, Code)], syntax_colors: [] }, RenderedLine { text: "important thing is that the last line, the 9 * 9 * 9 expression, is never", style: Normal, search_matches: [], inline_styles: [(43, 52, Code)], syntax_colors: [] }, RenderedLine { text: "going to be evaluated.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There are a few different ways to implement return statements. In some host", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "languages we could use gotos or exceptions. But in Go a “rescue” or “catch”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "are not easy to come by and we don’t really have the option of using gotos", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in a clean way. That’s why, in order to support return statements, we’ll", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "be passing a “return value” through our evaluator. Whenever we encounter a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "return we’ll wrap the value it’s supposed to return inside an object, so we", style: Normal, search_matches: [], inline_styles: [(2, 8, Code)], syntax_colors: [] }, RenderedLine { text: "can keep track of it. And we need to keep track of it so we can later decide", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "whether to stop evaluation or not.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is the implementation of said object. Here is object.ReturnValue:", style: Normal, search_matches: [], inline_styles: [(51, 69, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    RETURN_VALUE_OBJ = \"RETURN_VALUE\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type ReturnValue struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (rv *ReturnValue) Type() ObjectType { return RETURN_VALUE_OBJ }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "func (rv *ReturnValue) Inspect() string  { return rv.Value.Inspect() }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Since this is just a wrapper around another object nothing here is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "surprising. What’s interesting about object.ReturnValue is when and how", style: Normal, search_matches: [], inline_styles: [(39, 57, Code)], syntax_colors: [] }, RenderedLine { text: "it’s used.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here are the tests that demonstrate what we expect of the return statement", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in the context of a Monkey program:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestReturnStatements(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"return 10;\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"return 10; 9;\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"return 2 * 5; 9;\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"9; return 2 * 5; 9;\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := testEval(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        testIntegerObject(t, evaluated, tt.expected)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order to get these tests to pass we have to change the evalStatements", style: Normal, search_matches: [], inline_styles: [(58, 72, Code)], syntax_colors: [] }, RenderedLine { text: "function we already have and add a case branch for *ast.ReturnStatement", style: Normal, search_matches: [], inline_styles: [(35, 39, Code), (51, 71, Code)], syntax_colors: [] }, RenderedLine { text: "to Eval:", style: Normal, search_matches: [], inline_styles: [(3, 7, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.ReturnStatement:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        val := Eval(node.ReturnValue)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.ReturnValue{Value: val}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalStatements(stmts []ast.Statement) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "    var result object.Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, statement := range stmts {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        result = Eval(statement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if returnValue, ok := result.(*object.ReturnValue); ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "            return returnValue.Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first part of this change is the evaluation of *ast.ReturnValue, where", style: Normal, search_matches: [], inline_styles: [(51, 67, Code)], syntax_colors: [] }, RenderedLine { text: "we evaluate the expression associated with the return statement. We then", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "wrap the result of this call to Eval in our new object.ReturnValue so we can", style: Normal, search_matches: [], inline_styles: [(32, 36, Code), (48, 66, Code)], syntax_colors: [] }, RenderedLine { text: "keep track of it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In evalStatements, which is used by evalProgramStatements and", style: Normal, search_matches: [], inline_styles: [(3, 17, Code), (36, 57, Code)], syntax_colors: [] }, RenderedLine { text: "evalBlockStatements to evaluate a series of statements, we check if the", style: Normal, search_matches: [], inline_styles: [(0, 19, Code)], syntax_colors: [] }, RenderedLine { text: "last evaluation result is such an object.ReturnValue and if so, we stop the", style: Normal, search_matches: [], inline_styles: [(34, 52, Code)], syntax_colors: [] }, RenderedLine { text: "evaluation and return the unwrapped value. That’s important. We don’t return", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an object.ReturnValue, but only the value it’s wrapping, which is what the", style: Normal, search_matches: [], inline_styles: [(4, 22, Code)], syntax_colors: [] }, RenderedLine { text: "user expects to be returned.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There’s a problem, though. Sometimes we have to keep track of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.ReturnValues for longer and can’t unwrap their values on the first", style: Normal, search_matches: [], inline_styles: [(1, 19, Code)], syntax_colors: [] }, RenderedLine { text: "encounter. That’s the case with block statements. Take a look at this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (10 > 1) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "  if (10 > 1) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    return 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  return 1;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This program should return 10. But with our current implementation, it", style: Normal, search_matches: [], inline_styles: [(27, 29, Code)], syntax_colors: [] }, RenderedLine { text: "doesn’t and returns 1. A small test case confirms this:", style: Normal, search_matches: [], inline_styles: [(22, 23, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestReturnStatements(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "if (10 > 1) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "  if (10 > 1) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    return 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  return 1;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "            10,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This test case fails with the expected message:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestReturnStatements (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:159: object has wrong value. got=1, want=10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I bet that you’ve already figured out what the problem with our current", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implementation is. But if you want me to spell it out, here it comes: if we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "have nested block statements (which is totally legit in a Monkey program!)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we can’t unwrap the value of object.ReturnValue on first sight, because", style: Normal, search_matches: [], inline_styles: [(33, 51, Code)], syntax_colors: [] }, RenderedLine { text: "we need to further keep track of it so we can stop the execution in the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "outermost block statement.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Non-nested block statements work fine with our current implementation. But", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to get nested ones to work, the first thing we have to do is to accept that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we can’t reuse our evalStatements function for evaluating block statements.", style: Normal, search_matches: [], inline_styles: [(21, 35, Code)], syntax_colors: [] }, RenderedLine { text: "That’s why we’re going to rename it to evalProgram and make it less generic.", style: Normal, search_matches: [], inline_styles: [(44, 55, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.Program:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalProgram(node)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalProgram(program *ast.Program) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "    var result object.Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, statement := range program.Statements {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "        result = Eval(statement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if returnValue, ok := result.(*object.ReturnValue); ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "            return returnValue.Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "For evaluating an *ast.BlockStatement we introduce a new function called", style: Normal, search_matches: [], inline_styles: [(18, 37, Code)], syntax_colors: [] }, RenderedLine { text: "evalBlockStatement:", style: Normal, search_matches: [], inline_styles: [(0, 18, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.BlockStatement:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalBlockStatement(node)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalBlockStatement(block *ast.BlockStatement) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "    var result object.Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, statement := range block.Statements {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "        result = Eval(statement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if result != nil && result.Type() == object.RETURN_VALUE_OBJ {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "            return result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here we explicitly don’t unwrap the return value and only check the Type()", style: Normal, search_matches: [], inline_styles: [(70, 76, Code)], syntax_colors: [] }, RenderedLine { text: "of each evaluation result. If it’s object.RETURN_VALUE_OBJ we simply", style: Normal, search_matches: [], inline_styles: [(38, 61, Code)], syntax_colors: [] }, RenderedLine { text: "return the *object.ReturnValue, without unwrapping its .Value, so it stops", style: Normal, search_matches: [], inline_styles: [(13, 32, Code), (57, 63, Code)], syntax_colors: [] }, RenderedLine { text: "execution in a possible outer block statement and bubbles up to evalProgram,", style: Normal, search_matches: [], inline_styles: [(67, 76, Code)], syntax_colors: [] }, RenderedLine { text: "where it finally get’s unwrapped. (That last part will change when we", style: Normal, search_matches: [], inline_styles: [(0, 2, Code)], syntax_colors: [] }, RenderedLine { text: "implement the evaluation of function calls.)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And with that the tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Return statements are implemented. Now we’re definitely not building a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "calculator anymore. And since evalProgram and evalBlockStatement are still", style: Normal, search_matches: [], inline_styles: [(31, 42, Code), (47, 65, Code)], syntax_colors: [] }, RenderedLine { text: "so fresh in our mind let’s keep working on them.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Remember all the NULLs we were returning earlier and I said that you", style: Normal, search_matches: [], inline_styles: [(17, 21, Code)], syntax_colors: [] }, RenderedLine { text: "shouldn’t worry and we’ll come back to them? Here we are. It’s time to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implement some real error handling in Monkey before it’s too late and we’d", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "have to backpedal too much. Granted, we have to backpedal a little bit and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "correct previous code, but not much. We didn’t implement error handling as", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the first thing in our interpreter, because, and to be completely honest,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I thought implementing expressions first is a lot more fun than error", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "handling. But we’re now at a point where we need to add it, otherwise", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "debugging and using our interpreter becomes too cumbersome in the near", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "future.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "First of all, let’s define what I mean with “real error handling”. It is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "not user-defined exceptions. It’s internal error handling. Errors for wrong", style: Normal, search_matches: [], inline_styles: [(1, 4, Italic)], syntax_colors: [] }, RenderedLine { text: "operators, unsupported operations, and other user or internal errors that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "may arise during execution.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As for the implementation of such errors: this will probably sound weird,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "but the error handling is implemented in nearly the same way as handling", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "return statements is. The reason for this similarity is easy to find: errors", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and return statements both stop the evaluation of a series of statements.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we need is an error object:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    ERROR_OBJ = \"ERROR\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Error struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    Message string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (e *Error) Type() ObjectType { return ERROR_OBJ }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "func (e *Error) Inspect() string  { return \"ERROR: \" + e.Message }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As you can see, object.Error is really, really simple. It only wraps a", style: Normal, search_matches: [], inline_styles: [(16, 28, Code)], syntax_colors: [] }, RenderedLine { text: "string that serves as error message. In a production-ready interpreter we’d", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "want to attach a stack trace to such error objects, add the line and column", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "numbers of its origin and provide more than just a message. That’s not so", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "hard to do, provided that line and column numbers are attached to the tokens", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "by the lexer. Since our lexer doesn’t do that, to keep things simple, we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "only use an error message, which still serves us a great deal by giving us", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "some feedback and stopping execution.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We will add support for errors in a few places now. Later, with increased", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "capability of our interpreter, we’ll add more where appropriate. For now,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this test function shows what we expect the error handling to do:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestErrorHandling(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input           string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedMessage string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"5 + true;\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"type mismatch: INTEGER + BOOLEAN\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"5 + true; 5;\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"type mismatch: INTEGER + BOOLEAN\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"-true\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"unknown operator: -BOOLEAN\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"true + false;\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"unknown operator: BOOLEAN + BOOLEAN\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"5; true + false; 5\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"unknown operator: BOOLEAN + BOOLEAN\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"if (10 > 1) { true + false; }\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"unknown operator: BOOLEAN + BOOLEAN\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "if (10 > 1) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "  if (10 > 1) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    return true + false;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  return 1;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"unknown operator: BOOLEAN + BOOLEAN\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := testEval(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        errObj, ok := evaluated.(*object.Error)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Errorf(\"no error object returned. got=%T(%+v)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "                evaluated, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "            continue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if errObj.Message != tt.expectedMessage {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Errorf(\"wrong error message. expected=%q, got=%q\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "                tt.expectedMessage, errObj.Message)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When we run the tests we meet our old friend NULL again:", style: Normal, search_matches: [], inline_styles: [(45, 49, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestErrorHandling (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:193: no error object returned. got=*object.Null(&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:193: no error object returned.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Integer(&{Value:5})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:193: no error object returned. got=*object.Null(&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:193: no error object returned. got=*object.Null(&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:193: no error object returned.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Integer(&{Value:5})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:193: no error object returned. got=*object.Null(&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:193: no error object returned.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Integer(&{Value:10})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But there are also unexpected *object.Integers. That’s because these test", style: Normal, search_matches: [], inline_styles: [(30, 45, Code)], syntax_colors: [] }, RenderedLine { text: "cases actually assert two things: that errors are created for unsupported", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operations and that errors prevent any further evaluation. When the test", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fails because of an *object.Integer being returned, the evaluation didn’t", style: Normal, search_matches: [], inline_styles: [(22, 37, Code)], syntax_colors: [] }, RenderedLine { text: "stop correctly.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Creating errors and passing them around in Eval is easy. We just need a", style: Normal, search_matches: [], inline_styles: [(43, 47, Code)], syntax_colors: [] }, RenderedLine { text: "helper function to help us create new *object.Errors and return them when we", style: Normal, search_matches: [], inline_styles: [(38, 51, Code)], syntax_colors: [] }, RenderedLine { text: "think we should:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    // [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"fmt\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func newError(format string, a ...interface{}) *object.Error {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    return &object.Error{Message: fmt.Sprintf(format, a...)}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This newError function finds its use in every place where we didn’t know", style: Normal, search_matches: [], inline_styles: [(5, 13, Code)], syntax_colors: [] }, RenderedLine { text: "what to do before and returned NULL instead:", style: Normal, search_matches: [], inline_styles: [(32, 36, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalPrefixExpression(operator string, right object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch operator {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"unknown operator: %s%s\", operator, right.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 73, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalInfixExpression(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    operator string,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    left, right object.Object,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case left.Type() != right.Type():", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"type mismatch: %s %s %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "            left.Type(), operator, right.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"unknown operator: %s %s %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "            left.Type(), operator, right.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalMinusPrefixOperatorExpression(right object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "    if right.Type() != object.INTEGER_OBJ {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"unknown operator: -%s\", right.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalIntegerInfixExpression(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    operator string,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    left, right object.Object,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch operator {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"unknown operator: %s %s %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "            left.Type(), operator, right.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With these changes made the number of failing test cases has been reduced to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "just two:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestErrorHandling (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:193: no error object returned.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Integer(&{Value:5})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:193: no error object returned.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Integer(&{Value:5})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That output tells us that creating errors poses no problem but stopping the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluation still does. We already know where to look though, don’t we? Yes,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that’s right: evalProgram and evalBlockStatement. Here are both functions in", style: Normal, search_matches: [], inline_styles: [(17, 28, Code), (33, 51, Code)], syntax_colors: [] }, RenderedLine { text: "their entirety, with newly added support for error handling:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalProgram(program *ast.Program) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "    var result object.Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, statement := range program.Statements {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "        result = Eval(statement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        switch result := result.(type) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        case *object.ReturnValue:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "            return result.Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        case *object.Error:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            return result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalBlockStatement(block *ast.BlockStatement) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "    var result object.Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, statement := range block.Statements {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "        result = Eval(statement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if result != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "            rt := result.Type()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "            if rt == object.RETURN_VALUE_OBJ || rt == object.ERROR_OBJ {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "                return result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The added error handling in evalProgram is easy to spot. It takes", style: Normal, search_matches: [], inline_styles: [(28, 39, Code)], syntax_colors: [] }, RenderedLine { text: "slightly more effort to notice the added check for the type of result in", style: Normal, search_matches: [], inline_styles: [(63, 69, Code)], syntax_colors: [] }, RenderedLine { text: "evalBlockStatement.", style: Normal, search_matches: [], inline_styles: [(0, 18, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Taken together, these changes did it. Evaluation is stopped at the right", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "places and the tests now pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.010s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There’s still one last thing we need to do. We need to check for errors", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "whenever we call Eval inside of Eval, in order to stop errors from being", style: Normal, search_matches: [], inline_styles: [(18, 22, Code), (33, 37, Code)], syntax_colors: [] }, RenderedLine { text: "passed around and then bubbling up far away from their origin:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func isError(obj object.Object) bool {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    if obj != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        return obj.Type() == object.ERROR_OBJ", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    return false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch node := node.(type) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.ReturnStatement:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        val := Eval(node.ReturnValue)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(val) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "            return val", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.ReturnValue{Value: val}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.PrefixExpression:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        right := Eval(node.Right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(right) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            return right", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalPrefixExpression(node.Operator, right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    case *ast.InfixExpression:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        left := Eval(node.Left)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(left) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "            return left", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        right := Eval(node.Right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(right) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            return right", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        return evalInfixExpression(node.Operator, left, right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalIfExpression(ie *ast.IfExpression) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "    condition := Eval(ie.Condition)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    if isError(condition) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        return condition", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s it. Error handling is in place.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.9 - Bindings & The Environment", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Up next we’re going to add bindings to our interpreter by adding support", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "for let statements. But not only do we need to support let statements, no,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we need to support the evaluation of identifiers, too. Let’s say we have", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluated the following piece of code:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let x = 5 * 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Only adding support for the evaluation of this statement is not enough. We", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "also need to make sure that the x evaluates to 25 after interpreting the", style: Normal, search_matches: [], inline_styles: [(32, 33, Code), (47, 49, Code)], syntax_colors: [] }, RenderedLine { text: "line above.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So, our task in this section is to evaluate let statements and identifiers.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We evaluate let statements by evaluating their value-producing expression", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and keeping track of the produced value under the specified name. To", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluate identifiers we check if we already have a value bound to the name.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If we do, the identifier evaluates to this value, and if we don’t, we return", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an error.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Sounds like a good plan? Alright, so let’s kick this off with a few tests:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestLetStatements(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let a = 5; a;\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let a = 5 * 5; a;\", 25},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let a = 5; let b = a; b;\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let a = 5; let b = a; let c = a + b + 5; c;\", 15},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        testIntegerObject(t, testEval(tt.input), tt.expected)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The test cases assert that these two things should work: evaluating the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "value-producing expression in a let statement and evaluating an identifier", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that’s bound to a name. But we also need tests to make sure that we get an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "error when we try to evaluate an unbound identifier. And for that we can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "simply extend our existing TestErrorHandling function:", style: Normal, search_matches: [], inline_styles: [(29, 46, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestErrorHandling(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input           string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedMessage string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"foobar\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"identifier not found: foobar\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "How do we make these tests pass? Obviously the first thing we have to do is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "add a new case branch for *ast.LetStatement to Eval. And in this branch we", style: Normal, search_matches: [], inline_styles: [(10, 14, Code), (26, 43, Code), (47, 51, Code)], syntax_colors: [] }, RenderedLine { text: "need to Eval the expression of the let statement, correct? So let’s start", style: Normal, search_matches: [], inline_styles: [(8, 12, Code)], syntax_colors: [] }, RenderedLine { text: "with that:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.LetStatement:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        val := Eval(node.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(val) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "            return val", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    // Huh? Now what?", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The comment is right: now what? How do we keep track of values? We have the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "value and we also have the name we should bind it to, node.Name.Value. How", style: Normal, search_matches: [], inline_styles: [(54, 69, Code)], syntax_colors: [] }, RenderedLine { text: "do we associate one with the other?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This is where something called the environment comes into play. The", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "environment is what we use to keep track of value by associating them with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a name. The name “environment” is a classic one, used in a lot of other", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreters, especially Lispy ones. But even though the name may sound", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "sophisticated, at its heart the environment is a hash map that associates", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "strings with objects. And that’s exactly what we’re going to use for our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implementation.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’ll add a new Environment struct to the object package. And yes, for now", style: Normal, search_matches: [], inline_styles: [(18, 29, Code), (44, 50, Code)], syntax_colors: [] }, RenderedLine { text: "it really is just a thin wrapper around a map:", style: Normal, search_matches: [], inline_styles: [(43, 46, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/environment.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func NewEnvironment() *Environment {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    s := make(map[string]Object)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    return &Environment{store: s}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Environment struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    store map[string]Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (e *Environment) Get(name string) (Object, bool) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    obj, ok := e.store[name]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    return obj, ok", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (e *Environment) Set(name string, val Object) Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "    e.store[name] = val", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    return val", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let me guess what you’re thinking: Why not use a map? Why the wrapper? It’ll", style: Normal, search_matches: [], inline_styles: [(37, 72, Italic)], syntax_colors: [] }, RenderedLine { text: "all make sense as soon as we start implementing functions and function calls", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in the next section, I promise. This is the groundwork we’ll build upon", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "later.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As it is, the usage of object.Environment itself is self-explanatory.", style: Normal, search_matches: [], inline_styles: [(23, 41, Code)], syntax_colors: [] }, RenderedLine { text: "But how do we use it inside Eval? How and where do we keep track of the", style: Normal, search_matches: [], inline_styles: [(28, 32, Code)], syntax_colors: [] }, RenderedLine { text: "environment? We pass it around by making it a parameter of Eval:", style: Normal, search_matches: [], inline_styles: [(59, 63, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With that change nothing compiles anymore, because we have to change", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "every call to Eval make use of the environment. And not only the calls to", style: Normal, search_matches: [], inline_styles: [(14, 18, Code)], syntax_colors: [] }, RenderedLine { text: "Eval in Eval itself, but also the ones in functions such as evalProgram,", style: Normal, search_matches: [], inline_styles: [(0, 4, Code), (8, 12, Code), (60, 71, Code)], syntax_colors: [] }, RenderedLine { text: "evalIfExpression and so on. This requires more manual editor work than", style: Normal, search_matches: [], inline_styles: [(0, 16, Code)], syntax_colors: [] }, RenderedLine { text: "anything else, so I won’t bore you by showing the list of changes here.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The calls to Eval in our REPL and in our test suite need to use an", style: Normal, search_matches: [], inline_styles: [(13, 17, Code)], syntax_colors: [] }, RenderedLine { text: "environment too, of course. In the REPL we use a single environment:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// repl/repl.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    // [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/object\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Start(in io.Reader, out io.Writer) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    scanner := bufio.NewScanner(in)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    env := object.NewEnvironment()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := evaluator.Eval(program, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "        if evaluated != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "            io.WriteString(out, evaluated.Inspect())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "            io.WriteString(out, \"\\n\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The environment we use here, env, persists between calls to Eval. If it", style: Normal, search_matches: [], inline_styles: [(29, 32, Code), (60, 64, Code)], syntax_colors: [] }, RenderedLine { text: "didn’t, binding a value to a name in the REPL would be without any effect.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As soon as the next line is evaluated, the association wouldn’t be in the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "new environment.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s exactly what we want in our test suite, though. We don’t want to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "keep state around for each test function and each test case. Each call to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "testEval should have a fresh environment so we don’t run into weird bugs", style: Normal, search_matches: [], inline_styles: [(2, 10, Code)], syntax_colors: [] }, RenderedLine { text: "involving global state caused by the order in which tests are run. Every", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "call to Eval here gets a fresh environment:", style: Normal, search_matches: [], inline_styles: [(12, 16, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func testEval(input string) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := parser.New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    env := object.NewEnvironment()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return Eval(program, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With updated Eval calls the tests compile again and we can start making them", style: Normal, search_matches: [], inline_styles: [(13, 17, Code)], syntax_colors: [] }, RenderedLine { text: "pass, which is not too hard with *object.Environment available. In the case", style: Normal, search_matches: [], inline_styles: [(33, 52, Code), (71, 75, Code)], syntax_colors: [] }, RenderedLine { text: "branch for *ast.LetStatement we can just use the name and value we already", style: Normal, search_matches: [], inline_styles: [(11, 28, Code)], syntax_colors: [] }, RenderedLine { text: "have and save them in the current environment:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.LetStatement:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        val := Eval(node.Value, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(val) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "            return val", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        env.Set(node.Name.Value, val)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now we’re adding associations to the environment when evaluating let", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "statements. But we also need to get these values out when we’re evaluating", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "identifiers. Doing that is pretty easy, too:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.Identifier:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalIdentifier(node, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalIdentifier(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    node *ast.Identifier,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    env *object.Environment,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    val, ok := env.Get(node.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"identifier not found: \" + node.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return val", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evalIdentifier will be extended in the next section. For now it simply", style: Normal, search_matches: [], inline_styles: [(0, 14, Code)], syntax_colors: [] }, RenderedLine { text: "checks if a value has been associated with the given name in the current", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "environment. If that’s the case it returns the value, otherwise an error.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Look at this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, you’re right, that’s exactly what this means: we’re now firmly standing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in programming language land.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let a = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let b = a > 3;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let c = a * 99;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: ">> if (b) { 10 } else { 1 };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let d = if (c > a) { 99 } else { 100 };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: ">> d", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "99", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> d * c * a;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "245025", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.10 - Functions & Function Calls", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This is what we’ve been working towards. This is the third act. We’re going", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to add support for functions and function calls to our interpreter. When", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we’re done with this section, we’ll be able to do this in our REPL:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let add = fn(a, b, c, d) { return a + b + c + d };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: ">> add(1, 2, 3, 4);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let addThree = fn(x) { return x + 3 };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: ">> addThree(3);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "6", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let max = fn(x, y) { if (x > y) { x } else { y } };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: ">> max(5, 10)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "10", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let factorial = fn(n) { if (n == 0) { 1 } else { n * factorial(n - 1) } };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: ">> factorial(5)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "120", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If that doesn’t impress you then take a look at this. Passing around", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "functions, higher-order functions and closures will also work:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let callTwoTimes = fn(x, func) { func(func(x)) };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: ">> callTwoTimes(3, addThree);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "9", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> callTwoTimes(3, fn(x) { x + 1 });", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let newAdder = fn(x) { fn(n) { x + n } };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let addTwo = newAdder(2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: ">> addTwo(2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "4", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, that’s right, we will be able to do all of that.", style: Normal, search_matches: [], inline_styles: [(50, 54, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order to get from where we currently are to there we need to do two", style: Normal, search_matches: [], inline_styles: [(47, 52, Italic)], syntax_colors: [] }, RenderedLine { text: "things: define an internal representation of functions in our object system", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and add support for function calls to Eval.", style: Normal, search_matches: [], inline_styles: [(38, 42, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But don’t worry. It’s easy. The work we did in the last sections now pays", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "off. We can reuse and extend a lot of things we already built. You’ll see", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that a lot of things just start to fit together at a certain point in this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "section.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Since “one step at a time” brought us here there’s no reason to abandon this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "strategy now. The first step is to take care of the internal representation", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of functions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The need to represent functions internally comes from the fact that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "functions in Monkey are treated like any other value: we can bind them", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to names, use them in expressions, pass them to other functions, return", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "them from functions and so on. And like other values, functions need a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "representation in our object system, so we can pass around, assign and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "return them.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But how do we represent a function internally, as an object? Our definition", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of ast.FunctionLiteral gives us a starting point:", style: Normal, search_matches: [], inline_styles: [(3, 22, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type FunctionLiteral struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token      token.Token // The 'fn' token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    Parameters []*Identifier", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    Body       *BlockStatement", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We don’t need the Token field in a function object, but Parameters and", style: Normal, search_matches: [], inline_styles: [(20, 25, Code), (58, 68, Code)], syntax_colors: [] }, RenderedLine { text: "Body make sense. We can’t evaluate a function without its body and we", style: Normal, search_matches: [], inline_styles: [(1, 5, Code)], syntax_colors: [] }, RenderedLine { text: "can’t evaluate the body if we don’t know which parameters the function has.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides Parameters and Body we also need a third field in our new function", style: Normal, search_matches: [], inline_styles: [(11, 21, Code), (26, 30, Code)], syntax_colors: [] }, RenderedLine { text: "object:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"bytes\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"fmt\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/ast\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"strings\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    FUNCTION_OBJ = \"FUNCTION\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Function struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    Parameters []*ast.Identifier", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    Body       *ast.BlockStatement", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    Env        *Environment", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (f *Function) Type() ObjectType { return FUNCTION_OBJ }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "func (f *Function) Inspect() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    params := []string{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    for _, p := range f.Parameters {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        params = append(params, p.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\"fn\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\"(\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(strings.Join(params, \", \"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\") {\\n\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(f.Body.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\"\\n}\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This definition of object.Function has the Parameters and Body fields. But", style: Normal, search_matches: [], inline_styles: [(19, 34, Code), (43, 53, Code), (58, 62, Code)], syntax_colors: [] }, RenderedLine { text: "it also has Env, a field that holds a pointer to an object.Environment,", style: Normal, search_matches: [], inline_styles: [(12, 15, Code), (52, 70, Code)], syntax_colors: [] }, RenderedLine { text: "because functions in Monkey carry their own environment with them. That", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "allows for closures, which “close over” the environment they’re defined in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and can later access it. That will make more sense when we start using the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Env field. You’ll see.", style: Normal, search_matches: [], inline_styles: [(2, 5, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With that definition done, we can now write a test to assert that our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter knows how to build functions:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestFunctionObject(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := \"fn(x) { x + 2; };\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    evaluated := testEval(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    fn, ok := evaluated.(*object.Function)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"object is not Function. got=%T (%+v)\", evaluated, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 78, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(fn.Parameters) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"function has wrong parameters. Parameters=%+v\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "            fn.Parameters)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if fn.Parameters[0].String() != \"x\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"parameter is not 'x'. got=%q\", fn.Parameters[0])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    expectedBody := \"(x + 2)\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if fn.Body.String() != expectedBody {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"body is not %q. got=%q\", expectedBody, fn.Body.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This test function asserts that evaluating a function literal results in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the correct *object.Function being returned, with correct parameters and the", style: Normal, search_matches: [], inline_styles: [(12, 28, Code)], syntax_colors: [] }, RenderedLine { text: "correct body. The function’s environment will be tested later on in other", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tests, implicitly. Making this test pass takes just a few lines of code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "added to Eval in the form of a new case branch:", style: Normal, search_matches: [], inline_styles: [(11, 15, Code), (37, 41, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.FunctionLiteral:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        params := node.Parameters", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        body := node.Body", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.Function{Parameters: params, Env: env, Body: body}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 73, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Easy, right? The test passes. We just reuse the Parameters and Body fields", style: Normal, search_matches: [], inline_styles: [(48, 58, Code), (63, 67, Code)], syntax_colors: [] }, RenderedLine { text: "of the AST node. Notice how we use the current environment when building the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function object.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With that relatively low-level test passing and thus having made sure that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we build the internal representation of functions correctly, we can turn to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the topic of function application. That means, extending our interpreter so", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that we can call functions. The tests for this are much more readable and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "easier to write:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestFunctionApplication(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected int64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let identity = fn(x) { x; }; identity(5);\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let identity = fn(x) { return x; }; identity(5);\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let double = fn(x) { x * 2; }; double(5);\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let add = fn(x, y) { x + y; }; add(5, 5);\", 10},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"let add = fn(x, y) { x + y; }; add(5 + 5, add(5, 5));\", 20},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "        {\"fn(x) { x; }(5)\", 5},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        testIntegerObject(t, testEval(tt.input), tt.expected)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Each test case here does the same thing: define a function, apply it to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "arguments and then make an assertion about the produced value. But with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "their slight differences they test multiple important things: returning", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "values implicitly, returning values using return statements, using", style: Normal, search_matches: [], inline_styles: [(42, 48, Code)], syntax_colors: [] }, RenderedLine { text: "parameters in expressions, multiple parameters and evaluating arguments", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "before passing them to the function.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We are also testing two possible forms of *ast.CallExpression here. One", style: Normal, search_matches: [], inline_styles: [(42, 61, Code)], syntax_colors: [] }, RenderedLine { text: "where the function is an identifier that evaluates to a function object, and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the second one where the function is a function literal. The neat thing is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that it doesn’t really matter. We already know how to evaluate identifiers", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and function literals:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.CallExpression:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        function := Eval(node.Function, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(function) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            return function", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, we’re just using Eval to get the function we want to call. Whether", style: Normal, search_matches: [], inline_styles: [(24, 28, Code)], syntax_colors: [] }, RenderedLine { text: "that’s an *ast.Identifier or an *ast.FunctionLiteral: Eval returns an", style: Normal, search_matches: [], inline_styles: [(13, 28, Code), (35, 55, Code), (57, 61, Code)], syntax_colors: [] }, RenderedLine { text: "*object.Function (if there’s no error, of course).", style: Normal, search_matches: [], inline_styles: [(2, 18, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But how do we do call this *object.Function? The first step is to evaluate", style: Normal, search_matches: [], inline_styles: [(27, 43, Code)], syntax_colors: [] }, RenderedLine { text: "the arguments of a call expression. The reason is simple:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(x, y) { x + y };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "add(2 + 2, 5 + 5);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here we want to pass 4 and 10 to the add function as arguments and not the", style: Normal, search_matches: [], inline_styles: [(21, 22, Code), (27, 29, Code), (37, 40, Code)], syntax_colors: [] }, RenderedLine { text: "expressions 2 + 2 and 5 + 5.", style: Normal, search_matches: [], inline_styles: [(12, 17, Code), (22, 27, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Evaluating the arguments is nothing more than evaluating a list of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions and keeping track of the produced values. But we also have to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "stop the evaluation process as soon as it encounters an error. That leads us", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to this code:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.CallExpression:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        function := Eval(node.Function, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(function) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            return function", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        args := evalExpressions(node.Arguments, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "        if len(args) == 1 && isError(args[0]) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "            return args[0]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalExpressions(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    exps []ast.Expression,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    env *object.Environment,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: ") []object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    var result []object.Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, e := range exps {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := Eval(e, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(evaluated) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "            return []object.Object{evaluated}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        result = append(result, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Nothing fancy going on here. We just iterate over a list of ast.Expressions", style: Normal, search_matches: [], inline_styles: [(60, 74, Code)], syntax_colors: [] }, RenderedLine { text: "and evaluate them in the context of the current environment. If we encounter", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an error, we stop the evaluation and return the error. This is also the part", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "where we decided to evaluate the arguments from left-to-right. Hopefully", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we won’t be writing code in Monkey that makes assertions about the order of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "argument evaluation, but if we do, we’re on the conservative and safe side", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of programming language design.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So! Now that we have both the function and the list of evaluated arguments,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "how do we “call the function”? How do we apply the function to the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "arguments?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The obvious answer is that we have to evaluate the body of the function,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "which is just a block statement. We already know how to evaluate those,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "so why not just call Eval and pass it the body of the function? One word:", style: Normal, search_matches: [], inline_styles: [(21, 25, Code)], syntax_colors: [] }, RenderedLine { text: "arguments. The body of the function can contain references to the parameters", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of the function and just evaluating the body in the current environment", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "would result in references to unknown names, which would lead to errors,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "which is not what we want. Evaluating the body as it is, in the current", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "environment, does not work.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What we need to do instead is change the environment in which the function", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is evaluated, so that the references to parameters in the function’s body", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "resolve to the correct arguments. But we can’t just add these arguments", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to the current environment. That could lead to previous bindings being", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "overwritten, which is not what we want. We want this to work:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let i = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "let printNum = fn(i) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "  puts(i);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "printNum(10);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "puts(i);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With a puts function that prints lines, this should print two lines,", style: Normal, search_matches: [], inline_styles: [(7, 11, Code)], syntax_colors: [] }, RenderedLine { text: "containing 10 and 5 respectively. If we were to overwrite the current", style: Normal, search_matches: [], inline_styles: [(11, 13, Code), (18, 19, Code)], syntax_colors: [] }, RenderedLine { text: "environment before evaluating the body of printNum, the last line would also", style: Normal, search_matches: [], inline_styles: [(42, 50, Code)], syntax_colors: [] }, RenderedLine { text: "result in 10 being printed.", style: Normal, search_matches: [], inline_styles: [(10, 12, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So adding the arguments of the function call to the current environment in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "order to make them accessible in the function’s body does not work. What we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "need to do instead is to preserve previous bindings while at the same time", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "making new ones available - we’ll call that “extending the environment”.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Extending the environment means that we create a new instance of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Environment with a pointer to the environment it should extend. By", style: Normal, search_matches: [], inline_styles: [(0, 18, Code)], syntax_colors: [] }, RenderedLine { text: "doing that we enclose a fresh and empty environment with an existing one.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When the new environment’s Get method is called and it itself doesn’t have", style: Normal, search_matches: [], inline_styles: [(29, 32, Code)], syntax_colors: [] }, RenderedLine { text: "a value associated with the given name, it calls the Get of the enclosing", style: Normal, search_matches: [], inline_styles: [(54, 57, Code)], syntax_colors: [] }, RenderedLine { text: "environment. That’s the environment it’s extending. And if that enclosing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "environment can’t find the value, it calls its own enclosing environment and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "so on until there is no enclosing environment anymore and we can safely say", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that we have an “ERROR: unknown identifier: foobar”.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/environment.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func NewEnclosedEnvironment(outer *Environment) *Environment {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    env := NewEnvironment()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    env.outer = outer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    return env", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func NewEnvironment() *Environment {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    s := make(map[string]Object)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    return &Environment{store: s, outer: nil}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Environment struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    store map[string]Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    outer *Environment", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (e *Environment) Get(name string) (Object, bool) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    obj, ok := e.store[name]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok && e.outer != nil {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        obj, ok = e.outer.Get(name)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    return obj, ok", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (e *Environment) Set(name string, val Object) Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "    e.store[name] = val", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    return val", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Environment now has a new field called outer that can contain a", style: Normal, search_matches: [], inline_styles: [(0, 18, Code), (46, 51, Code)], syntax_colors: [] }, RenderedLine { text: "reference to another object.Environment, which is the enclosing environment,", style: Normal, search_matches: [], inline_styles: [(21, 39, Code)], syntax_colors: [] }, RenderedLine { text: "the one it’s extending. The NewEnclosedEnvironment function makes creating", style: Normal, search_matches: [], inline_styles: [(30, 52, Code)], syntax_colors: [] }, RenderedLine { text: "such an enclosed environment easy. The Get method has also been changed. It", style: Normal, search_matches: [], inline_styles: [(40, 43, Code)], syntax_colors: [] }, RenderedLine { text: "now checks the enclosing environment for the given name, too.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This new behaviour mirrors how we think about variable scopes. There are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an inner scope and an outer scope. If something is not found in the inner", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "scope, it’s looked up in the outer scope. The outer scope encloses the inner", style: Normal, search_matches: [], inline_styles: [(60, 68, Italic)], syntax_colors: [] }, RenderedLine { text: "scope. And the inner scope extends the outer one.", style: Normal, search_matches: [], inline_styles: [(28, 35, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With our updated object.Environment functionality we can correctly evaluate", style: Normal, search_matches: [], inline_styles: [(17, 35, Code)], syntax_colors: [] }, RenderedLine { text: "function bodies. Remember, the problem was this: possibly overwriting", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "existing bindings in a environment when binding the arguments of a function", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "call to the parameter names of the function. Now, instead of overwriting", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "bindings, we create a new environment that’s enclosed by the current", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "environment and add our bindings to this fresh and empty environment.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But we won’t use the current environment as the enclosing environment,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "no. Instead we’ll use the environment our *object.Function carries around.", style: Normal, search_matches: [], inline_styles: [(45, 61, Code)], syntax_colors: [] }, RenderedLine { text: "Remember that one? That’s the environment our function was defined in.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is the updated version of Eval that handles function calls completely", style: Normal, search_matches: [], inline_styles: [(31, 35, Code)], syntax_colors: [] }, RenderedLine { text: "and correctly:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case *ast.CallExpression:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        function := Eval(node.Function, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(function) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            return function", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        args := evalExpressions(node.Arguments, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "        if len(args) == 1 && isError(args[0]) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "            return args[0]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        return applyFunction(function, args)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func applyFunction(fn object.Object, args []object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "    function, ok := fn.(*object.Function)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"not a function: %s\", fn.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    extendedEnv := extendFunctionEnv(function, args)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    evaluated := Eval(function.Body, extendedEnv)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    return unwrapReturnValue(evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func extendFunctionEnv(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    fn *object.Function,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    args []object.Object,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: ") *object.Environment {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    env := object.NewEnclosedEnvironment(fn.Env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for paramIdx, param := range fn.Parameters {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "        env.Set(param.Value, args[paramIdx])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return env", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func unwrapReturnValue(obj object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "    if returnValue, ok := obj.(*object.ReturnValue); ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "        return returnValue.Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return obj", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In the new applyFunction function we not only check that we really", style: Normal, search_matches: [], inline_styles: [(11, 24, Code)], syntax_colors: [] }, RenderedLine { text: "have a *object.Function at hand but also convert the fn parameter to a", style: Normal, search_matches: [], inline_styles: [(7, 23, Code), (53, 55, Code)], syntax_colors: [] }, RenderedLine { text: "*object.Function reference in order to get access to the function’s .Env", style: Normal, search_matches: [], inline_styles: [(0, 16, Code), (70, 74, Code)], syntax_colors: [] }, RenderedLine { text: "and .Body fields (which object.Object doesn’t define).", style: Normal, search_matches: [], inline_styles: [(5, 10, Code), (25, 38, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The extendFunctionEnv function creates a new *object.Environment that’s", style: Normal, search_matches: [], inline_styles: [(4, 21, Code), (45, 64, Code)], syntax_colors: [] }, RenderedLine { text: "enclosed by the function’s environment. In this new, enclosed environment it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "binds the arguments of the function call to the function’s parameter names.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And this newly enclosed and updated environment is then the environment", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in which the function’s body is evaluated. The result of this evaluation", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is unwrapped if it’s an *object.ReturnValue. That’s necessary, because", style: Normal, search_matches: [], inline_styles: [(27, 46, Code)], syntax_colors: [] }, RenderedLine { text: "otherwise a return statement would bubble up through several functions and", style: Normal, search_matches: [], inline_styles: [(14, 20, Code)], syntax_colors: [] }, RenderedLine { text: "stop the evaluation in all of them. But we only want to stop the evaluation", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of the last called function’s body. That’s why we need unwrap it, so that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evalBlockStatement won’t stop evaluating statements in “outer” functions. I", style: Normal, search_matches: [], inline_styles: [(4, 22, Code)], syntax_colors: [] }, RenderedLine { text: "also added a few test cases to our previous TestReturnStatements function to", style: Normal, search_matches: [], inline_styles: [(49, 69, Code)], syntax_colors: [] }, RenderedLine { text: "make sure that this works.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Those were the last missing pieces. What? Really? Yeah! Take a look a this:", style: Normal, search_matches: [], inline_styles: [(36, 49, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let addTwo = fn(x) { x + 2; };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: ">> addTwo(2)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "4", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let multiply = fn(x, y) { x * y };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: ">> multiply(50 / 2, 1 * 2)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "50", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> fn(x) { x == 10 }(5)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: ">> fn(x) { x == 10 }(10)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Whaaat? Yes! It works! We can now finally define and call functions! There’s", style: Normal, search_matches: [], inline_styles: [(0, 7, Italic)], syntax_colors: [] }, RenderedLine { text: "a saying that goes “this is nothing to write home about”. Well, this is!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But before we put on our party hats, it’s worth taking a closer look at the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interaction between functions and their environment and what it means for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function application. Because what we’ve seen is not all we can do, there is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a lot more.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So, I bet that one question still bugs you: “Why extend the function’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "environment and not the current environment?” The short answer is this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestClosures(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "let newAdder = fn(x) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "  fn(y) { x + y };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let addTwo = newAdder(2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "addTwo(2);`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    testIntegerObject(t, testEval(input), 4)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This test passes. Yes, really:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let newAdder = fn(x) { fn(y) { x + y } };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let addTwo = newAdder(2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: ">> addTwo(3);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let addThree = newAdder(3);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ">> addThree(10);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "13", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Monkey has closures and they already work in our interpreter. How cool", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is that? Exactly. Very cool. But the connection between closures and the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "original question might not be so clear yet. Closures are functions that", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“close over” the environment they were defined in. They carry their own", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "environment around and whenever they’re called they can access it.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The two important lines from the example above are these:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let newAdder = fn(x) { fn(y) { x + y } };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "let addTwo = newAdder(2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "newAdder here is a higher-order function. Higher-order functions are", style: Normal, search_matches: [], inline_styles: [(0, 8, Code)], syntax_colors: [] }, RenderedLine { text: "functions that either return other functions or receive them as arguments.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In this case newAdder returns another function. But not just any function:", style: Normal, search_matches: [], inline_styles: [(13, 21, Code)], syntax_colors: [] }, RenderedLine { text: "a closure. addTwo is bound to the closure that’s returned when calling", style: Normal, search_matches: [], inline_styles: [(11, 17, Code)], syntax_colors: [] }, RenderedLine { text: "newAdder with 2 as the sole argument.", style: Normal, search_matches: [], inline_styles: [(1, 9, Code), (15, 16, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And what makes addTwo a closure? The bindings it has access to when called.", style: Normal, search_matches: [], inline_styles: [(15, 21, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When addTwo is called it not only has access to the arguments of the call,", style: Normal, search_matches: [], inline_styles: [(5, 11, Code)], syntax_colors: [] }, RenderedLine { text: "the y parameter, but it can also reach the value x was bound to at the time", style: Normal, search_matches: [], inline_styles: [(4, 5, Code), (49, 50, Code)], syntax_colors: [] }, RenderedLine { text: "of the newAdder(2) call, even though that binding is long out of scope and", style: Normal, search_matches: [], inline_styles: [(7, 18, Code)], syntax_colors: [] }, RenderedLine { text: "not existent in the current environment anymore:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let newAdder = fn(x) { fn(y) { x + y } };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let addTwo = newAdder(2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: ">> x", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "ERROR: identifier not found: x", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "x is not bound to a value in our top-level environment. But addTwo still has", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (60, 66, Code)], syntax_colors: [] }, RenderedLine { text: "access to it:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> addTwo(3);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In other words: the closure addTwo still has access to the environment", style: Normal, search_matches: [], inline_styles: [(28, 34, Code)], syntax_colors: [] }, RenderedLine { text: "that was the current environment at the time of its definition. Which is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "when the last line of newAdder’s body was evaluated. This last line is a", style: Normal, search_matches: [], inline_styles: [(22, 30, Code)], syntax_colors: [] }, RenderedLine { text: "function literal. Remember: when function literals are evaluated we build an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Function and keep a reference to the current environment in its .Env", style: Normal, search_matches: [], inline_styles: [(2, 17, Code), (73, 75, Code)], syntax_colors: [] }, RenderedLine { text: "field.", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When we later on evaluate the body of addTwo, we don’t evaluate it in the", style: Normal, search_matches: [], inline_styles: [(38, 44, Code)], syntax_colors: [] }, RenderedLine { text: "current environment, but instead in the function’s environment. And we do", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that by extending the function’s environment and passing it to Eval instead", style: Normal, search_matches: [], inline_styles: [(67, 71, Code)], syntax_colors: [] }, RenderedLine { text: "of the current environment. Why? So it can still access it. Why? So we can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "use closures. Why? Because they’re freaking amazing and I love them!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And since we’re talking about amazing things, it’s worth mentioning that we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "not only support returning functions from other functions but also accepting", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "functions as arguments in a function call. Yes, functions are first-class", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "citizens in Monkey and we can pass them around like any other value:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let add = fn(a, b) { a + b };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let sub = fn(a, b) { a - b };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let applyFunc = fn(a, b, func) { func(a, b) };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: ">> applyFunc(2, 2, add);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "4", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> applyFunc(10, 2, sub);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "8", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here we pass the add and sub functions as arguments to applyFunc. applyFunc", style: Normal, search_matches: [], inline_styles: [(17, 20, Code), (25, 28, Code), (55, 64, Code), (66, 75, Code)], syntax_colors: [] }, RenderedLine { text: "then calls this function without any problems: the func parameter resolves", style: Normal, search_matches: [], inline_styles: [(51, 55, Code)], syntax_colors: [] }, RenderedLine { text: "to the function object which then gets called with two arguments. There is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "not much more to it, everything works already in our interpreter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I know what you’re thinking right now and here is a template for the message", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "you want to send:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Dear NAME_OF_FRIEND, remember when I said that someday I’ll be someone and", style: Normal, search_matches: [], inline_styles: [(0, 76, Bold)], syntax_colors: [] }, RenderedLine { text: "do something great people will remember me for? Well, today’s the day. My", style: Normal, search_matches: [], inline_styles: [(0, 75, Bold)], syntax_colors: [] }, RenderedLine { text: "Monkey interpreter works and it supports functions, higher-order functions,", style: Normal, search_matches: [], inline_styles: [(0, 75, Bold)], syntax_colors: [] }, RenderedLine { text: "closures and integers and arithmetic and long story short: I’ve never been", style: Normal, search_matches: [], inline_styles: [(0, 76, Bold)], syntax_colors: [] }, RenderedLine { text: "happier in my life!", style: Normal, search_matches: [], inline_styles: [(0, 19, Bold)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We did it. We built a fully working Monkey interpreter that supports", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "functions and function calls, higher-order functions and closures. Go on,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "celebrate! I’ll be waiting here.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "3.11 - Who’s taking the trash out?", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "At the beginning of this book I promised you that we wouldn’t take any", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "shortcuts and build a fully functional interpreter with our own hands, from", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "scratch and without any third party tools. And we did! But now I have a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "small confession to make.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Consider what happens when we run this snippet of Monkey code in our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let counter = fn(x) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "  if (x > 100) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    return true;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "  } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    let foobar = 9999;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    counter(x + 1);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "  }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "counter(0);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Obviously, it would return ‘true’ after evaluating the body of counter 101", style: Normal, search_matches: [], inline_styles: [(67, 74, Code)], syntax_colors: [] }, RenderedLine { text: "times. But a lot is happening until the last of these recursive calls to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "counter returns.", style: Normal, search_matches: [], inline_styles: [(2, 9, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing is the evaluation if-else-expression condition: x > 100. If", style: Normal, search_matches: [], inline_styles: [(64, 71, Code)], syntax_colors: [] }, RenderedLine { text: "the produced value is not truthy, the alternative of the if-else-expression", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "gets evaluated. In the alternative the integer literal 9999 gets bound to", style: Normal, search_matches: [], inline_styles: [(55, 59, Code)], syntax_colors: [] }, RenderedLine { text: "the name foobar, which is never referenced again. Then x + 1 is evaluated.", style: Normal, search_matches: [], inline_styles: [(9, 15, Code), (55, 60, Code)], syntax_colors: [] }, RenderedLine { text: "The result of that call to Eval is then passed to another call to counter.", style: Normal, search_matches: [], inline_styles: [(27, 31, Code), (66, 73, Code)], syntax_colors: [] }, RenderedLine { text: "And then it all starts again, until x > 100 evaluates to TRUE.", style: Normal, search_matches: [], inline_styles: [(36, 43, Code), (57, 61, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The point is this: in each call to counter a lot of objects are allocated.", style: Normal, search_matches: [], inline_styles: [(35, 42, Code)], syntax_colors: [] }, RenderedLine { text: "Or to put it in terms of our Eval function and our object system: each", style: Normal, search_matches: [], inline_styles: [(29, 33, Code)], syntax_colors: [] }, RenderedLine { text: "evaluation of counter’s body results in a lot of object.Integer being", style: Normal, search_matches: [], inline_styles: [(14, 21, Code), (51, 65, Code)], syntax_colors: [] }, RenderedLine { text: "allocated and instantiated. The unused 9999 integer literal and the", style: Normal, search_matches: [], inline_styles: [(40, 44, Code)], syntax_colors: [] }, RenderedLine { text: "result of x + 1 are obvious. But even the literals 100 and 1 produce new", style: Normal, search_matches: [], inline_styles: [(12, 17, Code), (53, 56, Code), (61, 62, Code)], syntax_colors: [] }, RenderedLine { text: "object.Integers every time the body of counter is evaluated.", style: Normal, search_matches: [], inline_styles: [(2, 16, Code), (41, 48, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If we were to modify our Eval function to track every instance of", style: Normal, search_matches: [], inline_styles: [(25, 29, Code)], syntax_colors: [] }, RenderedLine { text: "&object.Integer{}, we’d see that running this small snippet of code results", style: Normal, search_matches: [], inline_styles: [(0, 17, Code)], syntax_colors: [] }, RenderedLine { text: "in around 400 allocated object.Integers.", style: Normal, search_matches: [], inline_styles: [(25, 39, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What’s the problem with that?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Our objects are stored in memory. The more objects we use the more memory we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "need. And even though the number of objects in the example is tiny compared", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to other programs memory is not infinite.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With each call to counter the memory usage of our interpreter process should", style: Normal, search_matches: [], inline_styles: [(18, 25, Code)], syntax_colors: [] }, RenderedLine { text: "rise until it eventually runs out of memory and the operating system kills", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it. But if we were to monitor memory usage while running the snippet above,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we’d see that it doesn’t steadily rise and never goes down. Instead it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "increases and decreases. Why?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The answer to that question is the heart of the confession I have to make:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we’re reusing Go’s garbage collector as a garbage collector for our guest", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language. We do not need to write our own.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Go’s garbage collector (GC) is the reason why we don’t run out of memory.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It manages memory for us. Even when we call the counter function from above", style: Normal, search_matches: [], inline_styles: [(49, 56, Code)], syntax_colors: [] }, RenderedLine { text: "many, many times and thus add a lot more unused integer literals and object", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "allocations, we won’t run out of memory. Because the GC keeps track of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "which object.Integer are still reachable by us and which are not. When it", style: Normal, search_matches: [], inline_styles: [(10, 24, Code)], syntax_colors: [] }, RenderedLine { text: "notices that an object is not reachable anymore it makes the object’s memory", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "available again.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The example above generates a lot of integer objects that are unreachable", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "after a call to counter: the literals 1 and 100 and the nonsense 9999 bound", style: Normal, search_matches: [], inline_styles: [(16, 23, Code), (38, 39, Code), (44, 47, Code), (65, 69, Code)], syntax_colors: [] }, RenderedLine { text: "to foobar. There is no way to access these objects after counter returns.", style: Normal, search_matches: [], inline_styles: [(3, 9, Code), (57, 64, Code)], syntax_colors: [] }, RenderedLine { text: "In the case of 1 and 100 it’s clear that they’re unreachable, since they’re", style: Normal, search_matches: [], inline_styles: [(15, 16, Code), (21, 24, Code)], syntax_colors: [] }, RenderedLine { text: "not bound to a name. But even the 9999 bound to foobar is unreachable since", style: Normal, search_matches: [], inline_styles: [(35, 39, Code), (49, 55, Code)], syntax_colors: [] }, RenderedLine { text: "foobar is out of scope when the function returns. The environment that was", style: Normal, search_matches: [], inline_styles: [(2, 8, Code)], syntax_colors: [] }, RenderedLine { text: "constructed for the evaluation of counter’s body gets destroyed (also by", style: Normal, search_matches: [], inline_styles: [(37, 44, Code)], syntax_colors: [] }, RenderedLine { text: "Go’s GC, mind you!) and with it the foobar binding.", style: Normal, search_matches: [], inline_styles: [(41, 47, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "These unreachable objects are useless and take up memory. That’s why the GC", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "collects them and frees up the memory they used.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s super handy for us! That saves us a lot of work! If we were", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to write our interpreter in a language like C, where we don’t have a GC,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we’d need to implement one ourselves to manage memory for users of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What would such a hypothetical GC need to do? In short: keep track of object", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "allocations and references to objects, make enough memory available for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "future object allocations and give memory back when it’s not needed anymore.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This last point is what garbage collection is all about. Without it the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programs would “leak” and finally run out of memory.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There are a myriad ways to accomplish all of the above, involving different", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "algorithms and implementations. For example, there’s the basic “mark and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "sweep” algorithm. In order to implement it one has to decide whether the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "GC will be a generational GC or not, or whether it’s a stop-the-world", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "GC or a concurrent GC, or how it’s organizing memory and handling memory", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fragmentation. Having decided all of that an efficient implementation is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "still a lot of hard work.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But maybe you’re asking yourself: Okay, so we have the GC of Go available.", style: Normal, search_matches: [], inline_styles: [(36, 76, Italic)], syntax_colors: [] }, RenderedLine { text: "But can’t we just write our own GC for the guest language and use that one", style: Normal, search_matches: [], inline_styles: [(0, 76, Italic)], syntax_colors: [] }, RenderedLine { text: "instead?", style: Normal, search_matches: [], inline_styles: [(0, 8, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Unfortunately, no. We’d have to disable Go’s GC and find a way to take over", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "all of its duties. That’s easier said than done. It’s a huge undertaking", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "since we would also have to take care of allocating and freeing memory", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "ourselves - in a language that per default prohibits exactly that.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s why I decided to not add a “Let’s write our own GC next to Go’s GC”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "section to this book and to instead reuse Go’s GC. Garbage collection itself", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is a huge topic and adding the dimension of working around an existing GC", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "blows it out of the scope of this book. But still, I hope that this section", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "gave you a rough idea of what a GC does and which problems it solves. Maybe", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "you even know now what to do if you were to translate the interpreter we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "built here into another host language without garbage collection.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And with that… we’re done! Our interpreter works. All that’s left for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "us is to extend it and make it more useful by adding more data types and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "functions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>ch005.xhtml</title>\n  <style>\npre > code.sourceCode { white-space: pre; position: relative; }\npre > code.sourceCode > span { display: inline-block; line-height: 1.25; }\npre > code.sourceCode > span:empty { height: 1.2em; }\ncode.sourceCode > span { color: inherit; text-decoration: inherit; }\ndiv.sourceCode { margin: 1em 0; }\npre.sourceCode { margin: 0; }\n@media screen {\ndiv.sourceCode { overflow: auto; }\n}\n@media print {\npre > code.sourceCode { white-space: pre-wrap; }\npre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }\n}\npre.numberSource code\n  { counter-reset: source-line 0; }\npre.numberSource code > span\n  { position: relative; left: -4em; counter-increment: source-line; }\npre.numberSource code > span > a:first-child::before\n  { content: counter(source-line);\n    position: relative; left: -1em; text-align: right; vertical-align: baseline;\n    border: none; display: inline-block;\n    -webkit-touch-callout: none; -webkit-user-select: none;\n    -khtml-user-select: none; -moz-user-select: none;\n    -ms-user-select: none; user-select: none;\n    padding: 0 4px; width: 4em;\n    color: #aaaaaa;\n  }\npre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\ndiv.sourceCode\n  {   }\n@media screen {\npre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }\n}\ncode span.al { color: #ff0000; font-weight: bold; } /* Alert */\ncode span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */\ncode span.at { color: #7d9029; } /* Attribute */\ncode span.bn { color: #40a070; } /* BaseN */\ncode span.bu { } /* BuiltIn */\ncode span.cf { color: #007020; font-weight: bold; } /* ControlFlow */\ncode span.ch { color: #4070a0; } /* Char */\ncode span.cn { color: #880000; } /* Constant */\ncode span.co { color: #60a0b0; font-style: italic; } /* Comment */\ncode span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */\ncode span.do { color: #ba2121; font-style: italic; } /* Documentation */\ncode span.dt { color: #902000; } /* DataType */\ncode span.dv { color: #40a070; } /* DecVal */\ncode span.er { color: #ff0000; font-weight: bold; } /* Error */\ncode span.ex { } /* Extension */\ncode span.fl { color: #40a070; } /* Float */\ncode span.fu { color: #06287e; } /* Function */\ncode span.im { } /* Import */\ncode span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */\ncode span.kw { color: #007020; font-weight: bold; } /* Keyword */\ncode span.op { color: #666666; } /* Operator */\ncode span.ot { color: #007020; } /* Other */\ncode span.pp { color: #bc7a00; } /* Preprocessor */\ncode span.sc { color: #4070a0; } /* SpecialChar */\ncode span.ss { color: #bb6688; } /* SpecialString */\ncode span.st { color: #4070a0; } /* String */\ncode span.va { color: #19177c; } /* Variable */\ncode span.vs { color: #4070a0; } /* VerbatimString */\ncode span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */\n/* Apple Books 2.4+ doesn't like overflow:auto on syntax highlighting generated by skylighting */\n@media screen {\n  div.sourceCode { overflow: visible !important; }\n  p, span, pre, code, blockquote { overflow: visible !important; }\n}\n  </style>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"bodymatter\">\n<section id=\"evaluation\" class=\"level1\" data-number=\"3\">\n<h1 data-number=\"3\">Evaluation</h1>\n<section id=\"giving-meaning-to-symbols\" class=\"level2\" data-number=\"3.1\">\n<h2 data-number=\"3.1\">3.1 - Giving Meaning to Symbols</h2>\n<p>We are finally here. Evaluation. The E in REPL and the last thing an interpreter has to do when processing source code. This is where code becomes meaningful. Without evaluation an expression like <code>1 + 2</code> is just a series of characters, tokens, or a tree structure that represents this expression. It doesn’t mean anything. Evaluated, of course, <code>1 + 2</code> becomes <code>3</code>. <code>5 &gt; 1</code> becomes <code>true</code>, <code>5 &lt; 1</code> becomes <code>false</code> and <code>puts(\"Hello World!\")</code> becomes the friendly message we all know.</p>\n<p>The evaluation process of an interpreter defines how the programming language being interpreted works.</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb1-1\"><a href=\"#cb1-1\"></a><span class=\"kw\">let</span> num <span class=\"op\">=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\"></a><span class=\"cf\">if</span> (num) {</span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\"></a>  <span class=\"cf\">return</span> a<span class=\"op\">;</span></span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\"></a>} <span class=\"cf\">else</span> {</span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\"></a>  <span class=\"cf\">return</span> b<span class=\"op\">;</span></span>\n<span id=\"cb1-6\"><a href=\"#cb1-6\"></a>}</span></code></pre></div>\n<p>Whether this returns <code>a</code> or <code>b</code> depends on the decision of the interpreter’s evaluation process whether the integer <code>5</code> is truthy or not. In some languages it’s truthy, in others we’d need to use an expression that produces a boolean like <code>5 != 0</code>.</p>\n<p>Consider this:</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb2-1\"><a href=\"#cb2-1\"></a><span class=\"kw\">let</span> one <span class=\"op\">=</span> fn() {</span>\n<span id=\"cb2-2\"><a href=\"#cb2-2\"></a>  printLine(<span class=\"st\">&quot;one&quot;</span>)<span class=\"op\">;</span></span>\n<span id=\"cb2-3\"><a href=\"#cb2-3\"></a>  <span class=\"cf\">return</span> <span class=\"dv\">1</span><span class=\"op\">;</span></span>\n<span id=\"cb2-4\"><a href=\"#cb2-4\"></a>}<span class=\"op\">;</span></span>\n<span id=\"cb2-5\"><a href=\"#cb2-5\"></a></span>\n<span id=\"cb2-6\"><a href=\"#cb2-6\"></a><span class=\"kw\">let</span> two <span class=\"op\">=</span> fn() {</span>\n<span id=\"cb2-7\"><a href=\"#cb2-7\"></a>  printLine(<span class=\"st\">&quot;two&quot;</span>)<span class=\"op\">;</span></span>\n<span id=\"cb2-8\"><a href=\"#cb2-8\"></a>  <span class=\"cf\">return</span> <span class=\"dv\">2</span><span class=\"op\">;</span></span>\n<span id=\"cb2-9\"><a href=\"#cb2-9\"></a>}<span class=\"op\">;</span></span>\n<span id=\"cb2-10\"><a href=\"#cb2-10\"></a></span>\n<span id=\"cb2-11\"><a href=\"#cb2-11\"></a>add(one()<span class=\"op\">,</span> two())<span class=\"op\">;</span></span></code></pre></div>\n<p>Does this first output <code>one</code> and then <code>two</code> or the other way around? It depends on the specification of the language and ultimately on the implementation of its interpreter and in which order it evaluates the arguments in a call expression.</p>\n<p>In this chapter there will be many more small choices like these, where we get to decide how Monkey is going to work and how our interpreter evaluates Monkey source code.</p>\n<p>Maybe you’re skeptical, after I told you that writing a parser was fun, but trust me: this is the best part. This is where the Monkey programming language comes to life, where source code quickens and starts to breathe.</p>\n</section>\n<section id=\"strategies-of-evaluation\" class=\"level2\" data-number=\"3.2\">\n<h2 data-number=\"3.2\">3.2 - Strategies of Evaluation</h2>\n<p>Evaluation is also where interpreter implementations (regardless of which language they’re interpreting) diverge the most. There are a lot of different strategies to choose from when evaluating source code. I’ve already hinted at this in the introduction of this book, where we took a brief look at different interpreter architectures. Now that we’re here, AST in hand, the question of what to do with it and how to evaluate this shiny tree of ours is more relevant than ever, so looking at different options again is worthwhile.</p>\n<p>Before we start, though, it’s also worth noting again that the line between interpreters and compilers is a blurry one. The notion of an interpreter as something that doesn’t leave executable artifacts behind (in contrast to a compiler, which does just that) gets fuzzy real fast when looking at the implementations of real-world and highly-optimized programming languages.</p>\n<p>With that said, the most obvious and classical choice of what to do with the AST is to just interpret it. Traverse the AST, visit each node and do what the node signifies: print a string, add two numbers, execute a function’s body - all on the fly. Interpreters working this way are called “tree-walking interpreters” and are the archetype of interpreters. Sometimes their evaluation step is preceded by small optimizations that rewrite the AST (e.g.\u{a0}remove unused variable bindings) or convert it into another intermediate representation (IR) that’s more suitable for recursive and repeated evaluation.</p>\n<p>Other interpreters also traverse the AST, but instead of interpreting the AST itself they first convert it to bytecode. Bytecode is another IR of the AST and a really dense one at that. The exact format and of which opcodes (the instructions that make up the bytecode) it’s composed of varies and depends on the guest and host programming languages. In general though, the opcodes are pretty similar to the mnemonics of most assembly languages; it’s a safe bet to say that most bytecode definitions contain opcodes for <code>push</code> and <code>pop</code> to do stack operations. But bytecode is not native machine code, nor is it assembly language. It can’t and won’t be executed by the operating system and the CPU of the machine the interpreter is running on. Instead it’s interpreted by a virtual machine, that’s part of the interpreter. Just like VMWare and VirtualBox emulate real machines and CPUs, these virtual machines emulate a machine that understands this particular bytecode format. This approach can yield great performance benefits.</p>\n<p>A variation of this strategy doesn’t involve an AST at all. Instead of building an AST the parser emits bytecode directly. Now, are we still talking about interpreters or compilers? Isn’t emitting bytecode that gets then interpreted (or should we say “executed”?) a form of compilation? I told you: the line becomes blurry. And to make it even more fuzzy, consider this: some implementations of programming languages parse the source code, build an AST and convert this AST to bytecode. But instead of executing the operations specified by the bytecode directly in a virtual machine, the virtual machine then compiles the bytecode to native machine code, right before its executed - just in time. That’s called a JIT (for “just in time”) interpreter/compiler.</p>\n<p>Others skip the compilation to bytecode. They recursively traverse the AST but before executing a particular branch of it the node is compiled to native machine code. And then executed. Again, “just in time”.</p>\n<p>A slight variation of this is a mixed mode of interpretation where the interpreter recursively evaluates the AST and only after evaluating a particular branch of the AST multiple times does it compile the branch to machine code.</p>\n<p>Amazing, isn’t it? So many different ways to go about this task of evaluation, so many twists and variations.</p>\n<p>The choice of which strategy to choose largely depends on performance and portability needs, the programming language that’s being interpreted and how far you’re willing to go. A tree-walking interpreter that recursively evaluates an AST is probably the slowest of all approaches, but easy to build, extend, reason about and as portable as the language it’s implemented in.</p>\n<p>An interpreter that compiles to bytecode and uses a virtual machine to evaluate said bytecode is going to be a lot faster. But more complicated and harder to build, too. Throw JIT compilation to machine code into the mix and now you also need to support multiple machine architectures if you want the interpreter to work on both ARM and x86 CPUs.</p>\n<p>All of these approaches can be found in real-world programming languages. And most of the time the chosen approach changed with the lifetime of the language. Ruby is a great example here. Up to and including version 1.8 the interpreter was a tree-walking interpreter, executing the AST while traversing it. But with version 1.9 came the switch to a virtual machine architecture. Now the Ruby interpreter parses source code, builds an AST and then compiles this AST into bytecode, which gets then executed in a virtual machine. The increase in performance was huge.</p>\n<p>The WebKit JavaScript engine JavaScriptCore and its interpreter named “Squirrelfish” also used AST walking and direct execution as its approach. Then in 2008 came the switch to a virtual machine and bytecode interpretation. Nowadays the engine has four (!) different stages of JIT compilation, which kick in at different times in the lifetime of the interpreted program – depending on which part of the program needs the best performance.</p>\n<p>Another example is Lua. The main implementation of the Lua programming language started out as an interpreter that compiles to bytecode and executes the bytecode in a register-based virtual machine. 12 years after its first release another implementation of the language was born: LuaJIT. The clear goal of Mike Pall, the creator of LuaJIT, was to create the fastest Lua implementation possible. And he did. By JIT compiling a dense bytecode format to highly-optimized machine code for different architectures the LuaJIT implementation beats the original Lua in every benchmark. And not just by a tiny bit, no; it’s sometimes 50 times faster.</p>\n<p>So, a lot of interpreters started out small with room for improvement. That’s exactly what we’re going to do. There are a lot of ways to build a faster interpreter, but not necessarily one that’s easier to understand. We are here to learn, to understand and to be able to build upon our work.</p>\n</section>\n<section id=\"a-tree-walking-interpreter\" class=\"level2\" data-number=\"3.3\">\n<h2 data-number=\"3.3\">3.3 - A Tree-Walking Interpreter</h2>\n<p>What we’re going to build is a tree-walking interpreter. We’re going to take the AST our parser builds for us and interpret it “on the fly”, without any preprocessing or compilation step.</p>\n<p>Our interpreter will be a lot like a classic Lisp interpreter. The design we’re going to use is heavily inspired by the interpreter presented in “The Structure and Interpretation of Computer Programs” (SICP), especially its usage of environments. That doesn’t mean that we’re copying one particular interpreter, no, we’re rather using a blueprint that you can see in lot of other interpreters too, if you squint hard enough. There are really good reasons for the prevalence of this particular design: it’s the easiest way to get started, it’s easy to understand and to extend later on.</p>\n<p>We only need two things really: a tree-walking evaluator and a way to represent Monkey values in our host language Go. Evaluator sounds mighty and grand, but it will be just one function called “eval”. Its job is to evaluate the AST. Here is a pseudocode version that illustrates what “evaluating on the fly” and “tree-walking” mean in the context of interpretation:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb3-1\"><a href=\"#cb3-1\"></a><span class=\"kw\">function</span> <span class=\"fu\">eval</span>(astNode) {</span>\n<span id=\"cb3-2\"><a href=\"#cb3-2\"></a>  <span class=\"cf\">if</span> (astNode is integerliteral) {</span>\n<span id=\"cb3-3\"><a href=\"#cb3-3\"></a>    <span class=\"cf\">return</span> astNode<span class=\"op\">.</span><span class=\"at\">integerValue</span></span>\n<span id=\"cb3-4\"><a href=\"#cb3-4\"></a></span>\n<span id=\"cb3-5\"><a href=\"#cb3-5\"></a>  } <span class=\"cf\">else</span> <span class=\"cf\">if</span> (astNode is booleanLiteral) {</span>\n<span id=\"cb3-6\"><a href=\"#cb3-6\"></a>    <span class=\"cf\">return</span> astNode<span class=\"op\">.</span><span class=\"at\">booleanValue</span></span>\n<span id=\"cb3-7\"><a href=\"#cb3-7\"></a></span>\n<span id=\"cb3-8\"><a href=\"#cb3-8\"></a>  } <span class=\"cf\">else</span> <span class=\"cf\">if</span> (astNode is infixExpression) {</span>\n<span id=\"cb3-9\"><a href=\"#cb3-9\"></a></span>\n<span id=\"cb3-10\"><a href=\"#cb3-10\"></a>    leftEvaluated <span class=\"op\">=</span> <span class=\"pp\">eval</span>(astNode<span class=\"op\">.</span><span class=\"at\">Left</span>)</span>\n<span id=\"cb3-11\"><a href=\"#cb3-11\"></a>    rightEvaluated <span class=\"op\">=</span> <span class=\"pp\">eval</span>(astNode<span class=\"op\">.</span><span class=\"at\">Right</span>)</span>\n<span id=\"cb3-12\"><a href=\"#cb3-12\"></a></span>\n<span id=\"cb3-13\"><a href=\"#cb3-13\"></a>    <span class=\"cf\">if</span> astNode<span class=\"op\">.</span><span class=\"at\">Operator</span> <span class=\"op\">==</span> <span class=\"st\">&quot;+&quot;</span> {</span>\n<span id=\"cb3-14\"><a href=\"#cb3-14\"></a>      <span class=\"cf\">return</span> leftEvaluated <span class=\"op\">+</span> rightEvaluated</span>\n<span id=\"cb3-15\"><a href=\"#cb3-15\"></a>    } <span class=\"cf\">else</span> <span class=\"cf\">if</span> ast<span class=\"op\">.</span><span class=\"at\">Operator</span> <span class=\"op\">==</span> <span class=\"st\">&quot;-&quot;</span> {</span>\n<span id=\"cb3-16\"><a href=\"#cb3-16\"></a>      <span class=\"cf\">return</span> leftEvaluated <span class=\"op\">-</span> rightEvaluated</span>\n<span id=\"cb3-17\"><a href=\"#cb3-17\"></a>    }</span>\n<span id=\"cb3-18\"><a href=\"#cb3-18\"></a>  }</span>\n<span id=\"cb3-19\"><a href=\"#cb3-19\"></a>}</span></code></pre></div>\n<p>As you can see, <code>eval</code> is recursive. When <code>astNode is infixExpression</code> is true, <code>eval</code> calls itself again two times to evaluate the left and the right operands of the infix expression. This in turn may lead to the evaluation of another infix expression or an integer literal or a boolean literal or an identifier… We’ve already seen recursion at work when building and testing the AST. The same concepts apply here, except that we’re evaluating the tree and not building it.</p>\n<p>Looking at this snippet of pseudocode you can probably imagine how easy it is to extend this function. That comes to our advantage. We’re going to build up our own <code>Eval</code> function piece by piece and add new branches and capabilities as we go along and extend our interpreter.</p>\n<p>But the most interesting lines of this snippet are the return statements. What do they return? Here are two lines that bind the return value of a call to <code>eval</code> to names:</p>\n<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb4-1\"><a href=\"#cb4-1\"></a>leftEvaluated = eval(astNode.Left)</span>\n<span id=\"cb4-2\"><a href=\"#cb4-2\"></a>rightEvaluated = eval(astNode.Right)</span></code></pre></div>\n<p>What does <code>eval</code> return here? Of which type are the return values? The answer to these questions is the same as the one for “what kind of internal object system will our interpreter have?”</p>\n</section>\n<section id=\"representing-objects\" class=\"level2\" data-number=\"3.4\">\n<h2 data-number=\"3.4\">3.4 - Representing Objects</h2>\n<p><em>Wait, what? You never said Monkey was object oriented!</em> Yes, I never did and it’s not. <em>Why do we need “a object system” then?</em> Call it a “value system” or “object representation” then. The point is, we need to define what our “eval” function returns. We need a system that can represent the values our AST represents or values that we generate when evaluating the AST in memory.</p>\n<p>Let’s say we’re evaluating the following Monkey code:</p>\n<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb5-1\"><a href=\"#cb5-1\"></a><span class=\"kw\">let</span> a <span class=\"op\">=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb5-2\"><a href=\"#cb5-2\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb5-3\"><a href=\"#cb5-3\"></a>a <span class=\"op\">+</span> a<span class=\"op\">;</span></span></code></pre></div>\n<p>As you can see, we’re binding the integer literal <code>5</code> to the name <code>a</code>. Then things happen. It doesn’t matter what. What matters is that when we come across the <code>a + a</code> expression later we need to access the value <code>a</code> is bound to. In order to evaluate <code>a + a</code> we need to get to the <code>5</code>. In the AST it’s represented as an <code>*ast.IntegerLiteral</code>, but how are we going to keep track of and represent the <code>5</code> while we’re evaluating the rest of the AST?</p>\n<p>There are a lot of different choices when building an internal representation of values in an interpreted language. And there is a lot of wisdom about this topic spread throughout the codebases of the world’s interpreters and compilers. Each interpreter has its own way to represent values, always slightly differing from the solution that came before, adjusted for the requirements of the interpreted language.</p>\n<p>Some use native types (integers, booleans, etc.) of the host language to represent values in the interpreted language, not wrapped in anything. In other languages values/objects are represented only as pointers, whereas in some programming languages native types and pointers are mixed.</p>\n<p>Why the variety? For one, the host languages differ. How you represent a string of your interpreted language depends on how a string can be represented in the language the interpreter is implemented in. An interpreter written in Ruby can’t represent values the same way an interpreter written in C can.</p>\n<p>And not only do the host languages differ, but the languages being interpreted do too. Some interpreted languages may only need representations of primitive data types, like integers, characters or bytes. But in others you’ll have lists, dictionaries, functions or compound data types. These differences lead to highly different requirements in regards to value representation.</p>\n<p>Besides the host language and the interpreted language, the biggest influence on the design and implementation of value representations is the resulting execution speed and the memory consumption while evaluating programs. If you want to build a fast interpreter you can’t get away with a slow and bloated object system. And if you’re going to write your own garbage collector, you need to think about how it’ll keep track of the values in the system. But, on the other hand, if you don’t care about performance, then it does make sense to keep things simple and easy to understand until further requirements arise.</p>\n<p>The point is this: there are a lot of different ways to represent values of the interpreted languages in the host language. The best (and maybe the only) way to learn about these different representations is to actually read through the source code of some popular interpreters. I heartily recommended the <a href=\"https://github.com/munificent/wren\">Wren source code</a>, which includes two types of value representation, enabled/disabled by using a compiler flag.</p>\n<p>Besides the representation of values inside the host language there is also the matter of how to expose these values and their representation to the user of the interpreted language. What does the “public API” of these values look like?</p>\n<p>Java, for example, offers both “primitive data types” (int, byte, short, long, float, double, boolean, char) and reference types to the user. The primitive data types do not have a huge representation inside the Java implementation, they closely map to their native counterparts. Reference types on the other hand are references to compound data structures defined in the host language.</p>\n<p>In Ruby the user doesn’t have access to “primitive data types”, nothing like a native value type exists because everything is an object and thus wrapped inside an internal representation. Internally Ruby doesn’t distinguish between a byte and an instance of the class <code>Pizza</code>: both are the same value type, wrapping different values.</p>\n<p>There are a myriad ways to expose data to users of programming languages. Which one to choose depends on the language design and also, again, on performance requirements. If you don’t care about performance everything goes. But if you do, you need to make some smart decisions to achieve your goals.</p>\n<section id=\"foundation-of-our-object-system\" class=\"level3\" data-number=\"3.4.1\">\n<h3 data-number=\"3.4.1\">Foundation of our Object System</h3>\n<p>Carefree as we still are about the performance of our Monkey interpreter, we choose the easy way: we’re going to represent every value we encounter when evaluating Monkey source code as an <code>Object</code>, an interface of our design. Every value will be wrapped inside a struct, which fulfills this <code>Object</code> interface.</p>\n<p>In a new <code>object</code> package we define the <code>Object</code> interface and the <code>ObjectType</code> type:</p>\n<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb6-1\"><a href=\"#cb6-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb6-2\"><a href=\"#cb6-2\"></a></span>\n<span id=\"cb6-3\"><a href=\"#cb6-3\"></a><span class=\"kw\">package</span> object</span>\n<span id=\"cb6-4\"><a href=\"#cb6-4\"></a></span>\n<span id=\"cb6-5\"><a href=\"#cb6-5\"></a><span class=\"kw\">type</span> ObjectType <span class=\"dt\">string</span></span>\n<span id=\"cb6-6\"><a href=\"#cb6-6\"></a></span>\n<span id=\"cb6-7\"><a href=\"#cb6-7\"></a><span class=\"kw\">type</span> Object <span class=\"kw\">interface</span> {</span>\n<span id=\"cb6-8\"><a href=\"#cb6-8\"></a>    Type() ObjectType</span>\n<span id=\"cb6-9\"><a href=\"#cb6-9\"></a>    Inspect() <span class=\"dt\">string</span></span>\n<span id=\"cb6-10\"><a href=\"#cb6-10\"></a>}</span></code></pre></div>\n<p>That’s pretty simple and looks a lot like what we did in the <code>token</code> package with the <code>Token</code> and <code>TokenType</code> types. Except that instead of being a struct like <code>Token</code> the <code>Object</code> type is an interface. The reason is that every value needs a different internal representation and it’s easier to define two different struct types than trying to fit booleans and integers into the same struct field.</p>\n<p>At the moment we only have three data types in our Monkey interpreter: null, booleans and integers. Let’s start with implementing the integer representation and build up our object system.</p>\n</section>\n<section id=\"integers\" class=\"level3\" data-number=\"3.4.2\">\n<h3 data-number=\"3.4.2\">Integers</h3>\n<p>The <code>object.Integer</code> type is as small as you’d expect it to be:</p>\n<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb7-1\"><a href=\"#cb7-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb7-2\"><a href=\"#cb7-2\"></a></span>\n<span id=\"cb7-3\"><a href=\"#cb7-3\"></a><span class=\"kw\">import</span> <span class=\"st\">&quot;fmt&quot;</span></span>\n<span id=\"cb7-4\"><a href=\"#cb7-4\"></a></span>\n<span id=\"cb7-5\"><a href=\"#cb7-5\"></a><span class=\"kw\">type</span> Integer <span class=\"kw\">struct</span> {</span>\n<span id=\"cb7-6\"><a href=\"#cb7-6\"></a>    Value <span class=\"dt\">int64</span></span>\n<span id=\"cb7-7\"><a href=\"#cb7-7\"></a>}</span>\n<span id=\"cb7-8\"><a href=\"#cb7-8\"></a></span>\n<span id=\"cb7-9\"><a href=\"#cb7-9\"></a><span class=\"kw\">func</span> (i *Integer) Inspect() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> fmt.Sprintf(<span class=\"st\">&quot;%d&quot;</span>, i.Value) }</span></code></pre></div>\n<p>Whenever we encounter an integer literal in the source code we first turn it into an <code>ast.IntegerLiteral</code> and then, when evaluating that AST node, we turn it into an <code>object.Integer</code>, saving the value inside our struct and passing around a reference to this struct.</p>\n<p>In order for <code>object.Integer</code> to fulfill the <code>object.Object</code> interface, it still needs a <code>Type()</code> method that returns its <code>ObjectType</code>. Just like we did with <code>token.TokenType</code> we define constants for each <code>ObjectType</code>:</p>\n<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb8-1\"><a href=\"#cb8-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb8-2\"><a href=\"#cb8-2\"></a></span>\n<span id=\"cb8-3\"><a href=\"#cb8-3\"></a><span class=\"kw\">import</span> <span class=\"st\">&quot;fmt&quot;</span></span>\n<span id=\"cb8-4\"><a href=\"#cb8-4\"></a></span>\n<span id=\"cb8-5\"><a href=\"#cb8-5\"></a><span class=\"kw\">type</span> ObjectType <span class=\"dt\">string</span></span>\n<span id=\"cb8-6\"><a href=\"#cb8-6\"></a></span>\n<span id=\"cb8-7\"><a href=\"#cb8-7\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb8-8\"><a href=\"#cb8-8\"></a>    INTEGER_OBJ = <span class=\"st\">&quot;INTEGER&quot;</span></span>\n<span id=\"cb8-9\"><a href=\"#cb8-9\"></a>)</span></code></pre></div>\n<p>As I said, this is pretty much what we did in the <code>token</code> package. And with that in place we can add the <code>Type()</code> method to <code>*object.Integer</code>:</p>\n<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb9-1\"><a href=\"#cb9-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb9-2\"><a href=\"#cb9-2\"></a></span>\n<span id=\"cb9-3\"><a href=\"#cb9-3\"></a><span class=\"kw\">func</span> (i *Integer) Type() ObjectType { <span class=\"kw\">return</span> INTEGER_OBJ }</span></code></pre></div>\n<p>And we’re done with <code>Integer</code>! Onto another data type: booleans.</p>\n</section>\n<section id=\"booleans\" class=\"level3\" data-number=\"3.4.3\">\n<h3 data-number=\"3.4.3\">Booleans</h3>\n<p>If you were expecting big things of this section, I’m sorry to disappoint. <code>object.Boolean</code> is as tiny as it gets:</p>\n<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb10-1\"><a href=\"#cb10-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb10-2\"><a href=\"#cb10-2\"></a></span>\n<span id=\"cb10-3\"><a href=\"#cb10-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb10-4\"><a href=\"#cb10-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb10-5\"><a href=\"#cb10-5\"></a>    BOOLEAN_OBJ = <span class=\"st\">&quot;BOOLEAN&quot;</span></span>\n<span id=\"cb10-6\"><a href=\"#cb10-6\"></a>)</span>\n<span id=\"cb10-7\"><a href=\"#cb10-7\"></a></span>\n<span id=\"cb10-8\"><a href=\"#cb10-8\"></a><span class=\"kw\">type</span> Boolean <span class=\"kw\">struct</span> {</span>\n<span id=\"cb10-9\"><a href=\"#cb10-9\"></a>    Value <span class=\"dt\">bool</span></span>\n<span id=\"cb10-10\"><a href=\"#cb10-10\"></a>}</span>\n<span id=\"cb10-11\"><a href=\"#cb10-11\"></a></span>\n<span id=\"cb10-12\"><a href=\"#cb10-12\"></a><span class=\"kw\">func</span> (b *Boolean) Type() ObjectType { <span class=\"kw\">return</span> BOOLEAN_OBJ }</span>\n<span id=\"cb10-13\"><a href=\"#cb10-13\"></a><span class=\"kw\">func</span> (b *Boolean) Inspect() <span class=\"dt\">string</span>  { <span class=\"kw\">return</span> fmt.Sprintf(<span class=\"st\">&quot;%t&quot;</span>, b.Value) }</span></code></pre></div>\n<p>Just a struct that wraps a single value, a <code>bool</code>.</p>\n<p>We’re close to finishing the foundation of our object system. The last thing we need to do now, before we can start with our <code>Eval</code> function, is to represent a value that isn’t there.</p>\n</section>\n<section id=\"null\" class=\"level3\" data-number=\"3.4.4\">\n<h3 data-number=\"3.4.4\">Null</h3>\n<p>Tony Hoare introduced null references to the ALGOL W language in 1965 and called this his <a href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare\">“billion-dollar mistake”</a>. Since their introduction countless systems have crashed because of references to “null”, a value that represents the absence of a value. Null (or “nil” as in some languages) doesn’t have the best reputation, to say the least.</p>\n<p>I debated with myself whether Monkey should have null. On one hand, yes, the language would be safer to use if it doesn’t allow null or null references. But on the other, we’re not trying to reinvent the wheel, but to learn something. And I found that having null at my disposal lead me to think twice whenever there was a chance to use it. Kinda like having something explosive in your car leads you to driving slower and more carefully. It really made me appreciate the choices that go into the design of a programming language. That’s something I consider worthwhile. So let’s implement the <code>Null</code> type and keep a close look and steady hand when using it later on.</p>\n<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb11-1\"><a href=\"#cb11-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb11-2\"><a href=\"#cb11-2\"></a></span>\n<span id=\"cb11-3\"><a href=\"#cb11-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb11-4\"><a href=\"#cb11-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb11-5\"><a href=\"#cb11-5\"></a>    NULL_OBJ  = <span class=\"st\">&quot;NULL&quot;</span></span>\n<span id=\"cb11-6\"><a href=\"#cb11-6\"></a>)</span>\n<span id=\"cb11-7\"><a href=\"#cb11-7\"></a></span>\n<span id=\"cb11-8\"><a href=\"#cb11-8\"></a><span class=\"kw\">type</span> Null <span class=\"kw\">struct</span>{}</span>\n<span id=\"cb11-9\"><a href=\"#cb11-9\"></a></span>\n<span id=\"cb11-10\"><a href=\"#cb11-10\"></a><span class=\"kw\">func</span> (n *Null) Type() ObjectType { <span class=\"kw\">return</span> NULL_OBJ }</span>\n<span id=\"cb11-11\"><a href=\"#cb11-11\"></a><span class=\"kw\">func</span> (n *Null) Inspect() <span class=\"dt\">string</span>  { <span class=\"kw\">return</span> <span class=\"st\">&quot;null&quot;</span> }</span></code></pre></div>\n<p><code>object.Null</code> is a struct just like <code>object.Boolean</code> and <code>object.Integer</code>, except that it doesn’t wrap any value. It represents the absence of any value.</p>\n<p>With <code>object.Null</code> added, our object system is now capable of representing boolean, integer and null values. That’s more than enough to get started with <code>Eval</code>.</p>\n</section>\n</section>\n<section id=\"evaluating-expressions\" class=\"level2\" data-number=\"3.5\">\n<h2 data-number=\"3.5\">3.5 - Evaluating Expressions</h2>\n<p>Alright, here we go. Let’s start writing <code>Eval</code>! We have our AST and we have a new object system, that allows us to keep track of values we encounter when executing Monkey source code. It’s time to finally evaluate the AST.</p>\n<p>Here is what the signature of <code>Eval</code> will look like in its first version:</p>\n<div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb12-1\"><a href=\"#cb12-1\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object</span></code></pre></div>\n<p><code>Eval</code> will take an <code>ast.Node</code> as input and return an <code>object.Object</code>. Remember that every node we defined in the <code>ast</code> package fulfills the <code>ast.Node</code> interface and can thus be passed to <code>Eval</code>. This allows us to use <code>Eval</code> recursively and call itself while evaluating a part of the AST. Each AST node needs a different form of evaluation and <code>Eval</code> is the place where we decide what these forms look like. As an example, let’s say that we pass an <code>*ast.Program</code> node to <code>Eval</code>. What <code>Eval</code> should do then is to evaluate each of <code>*ast.Program.Statements</code> by calling itself with a single statement. The return value of the outer call to <code>Eval</code> is the return value of the last call.</p>\n<p>We’re going to start by implementing self-evaluating expressions. That’s what we call literals in the land of <code>Eval</code>. Specifically, boolean and integer literals. They are the constructs in Monkey that are easiest to evaluate, because they evaluate to themselves. If I type <code>5</code> into my REPL then <code>5</code> is also what should come out. And if I type in <code>true</code> then <code>true</code> is what I want.</p>\n<p>Sounds easy enough? It is! So, let’s turn “type in 5, get back 5” into reality.</p>\n<section id=\"integer-literals-1\" class=\"level3\" data-number=\"3.5.1\">\n<h3 data-number=\"3.5.1\">Integer Literals</h3>\n<p>Before writing any code though, what does this mean exactly? We’re given a single expression statement as input, which only contains an integer literal, and want to evaluate it so that the integer itself is returned.</p>\n<p>Translated into the language of our system, it means that, given an <code>*ast.IntegerLiteral</code>, our <code>Eval</code> function should return an <code>*object.Integer</code> whose <code>Value</code> field contains the same integer as <code>*ast.IntegerLiteral.Value</code>.</p>\n<p>We can easily write a test for this in our new <code>evaluator</code> package:</p>\n<div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb13-1\"><a href=\"#cb13-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb13-2\"><a href=\"#cb13-2\"></a></span>\n<span id=\"cb13-3\"><a href=\"#cb13-3\"></a><span class=\"kw\">package</span> evaluator</span>\n<span id=\"cb13-4\"><a href=\"#cb13-4\"></a></span>\n<span id=\"cb13-5\"><a href=\"#cb13-5\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb13-6\"><a href=\"#cb13-6\"></a>    <span class=\"st\">&quot;monkey/lexer&quot;</span></span>\n<span id=\"cb13-7\"><a href=\"#cb13-7\"></a>    <span class=\"st\">&quot;monkey/object&quot;</span></span>\n<span id=\"cb13-8\"><a href=\"#cb13-8\"></a>    <span class=\"st\">&quot;monkey/parser&quot;</span></span>\n<span id=\"cb13-9\"><a href=\"#cb13-9\"></a>    <span class=\"st\">&quot;testing&quot;</span></span>\n<span id=\"cb13-10\"><a href=\"#cb13-10\"></a>)</span>\n<span id=\"cb13-11\"><a href=\"#cb13-11\"></a></span>\n<span id=\"cb13-12\"><a href=\"#cb13-12\"></a><span class=\"kw\">func</span> TestEvalIntegerExpression(t *testing.T) {</span>\n<span id=\"cb13-13\"><a href=\"#cb13-13\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb13-14\"><a href=\"#cb13-14\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb13-15\"><a href=\"#cb13-15\"></a>        expected <span class=\"dt\">int64</span></span>\n<span id=\"cb13-16\"><a href=\"#cb13-16\"></a>    }{</span>\n<span id=\"cb13-17\"><a href=\"#cb13-17\"></a>        {<span class=\"st\">&quot;5&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb13-18\"><a href=\"#cb13-18\"></a>        {<span class=\"st\">&quot;10&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb13-19\"><a href=\"#cb13-19\"></a>    }</span>\n<span id=\"cb13-20\"><a href=\"#cb13-20\"></a></span>\n<span id=\"cb13-21\"><a href=\"#cb13-21\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb13-22\"><a href=\"#cb13-22\"></a>        evaluated := testEval(tt.input)</span>\n<span id=\"cb13-23\"><a href=\"#cb13-23\"></a>        testIntegerObject(t, evaluated, tt.expected)</span>\n<span id=\"cb13-24\"><a href=\"#cb13-24\"></a>    }</span>\n<span id=\"cb13-25\"><a href=\"#cb13-25\"></a>}</span>\n<span id=\"cb13-26\"><a href=\"#cb13-26\"></a></span>\n<span id=\"cb13-27\"><a href=\"#cb13-27\"></a><span class=\"kw\">func</span> testEval(input <span class=\"dt\">string</span>) object.Object {</span>\n<span id=\"cb13-28\"><a href=\"#cb13-28\"></a>    l := lexer.New(input)</span>\n<span id=\"cb13-29\"><a href=\"#cb13-29\"></a>    p := parser.New(l)</span>\n<span id=\"cb13-30\"><a href=\"#cb13-30\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb13-31\"><a href=\"#cb13-31\"></a></span>\n<span id=\"cb13-32\"><a href=\"#cb13-32\"></a>    <span class=\"kw\">return</span> Eval(program)</span>\n<span id=\"cb13-33\"><a href=\"#cb13-33\"></a>}</span>\n<span id=\"cb13-34\"><a href=\"#cb13-34\"></a></span>\n<span id=\"cb13-35\"><a href=\"#cb13-35\"></a><span class=\"kw\">func</span> testIntegerObject(t *testing.T, obj object.Object, expected <span class=\"dt\">int64</span>) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb13-36\"><a href=\"#cb13-36\"></a>    result, ok := obj.(*object.Integer)</span>\n<span id=\"cb13-37\"><a href=\"#cb13-37\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb13-38\"><a href=\"#cb13-38\"></a>        t.Errorf(<span class=\"st\">&quot;object is not Integer. got=%T (%+v)&quot;</span>, obj, obj)</span>\n<span id=\"cb13-39\"><a href=\"#cb13-39\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb13-40\"><a href=\"#cb13-40\"></a>    }</span>\n<span id=\"cb13-41\"><a href=\"#cb13-41\"></a>    <span class=\"kw\">if</span> result.Value != expected {</span>\n<span id=\"cb13-42\"><a href=\"#cb13-42\"></a>        t.Errorf(<span class=\"st\">&quot;object has wrong value. got=%d, want=%d&quot;</span>,</span>\n<span id=\"cb13-43\"><a href=\"#cb13-43\"></a>            result.Value, expected)</span>\n<span id=\"cb13-44\"><a href=\"#cb13-44\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb13-45\"><a href=\"#cb13-45\"></a>    }</span>\n<span id=\"cb13-46\"><a href=\"#cb13-46\"></a></span>\n<span id=\"cb13-47\"><a href=\"#cb13-47\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb13-48\"><a href=\"#cb13-48\"></a>}</span></code></pre></div>\n<p>That’s a lot of code for such a small test, isn’t it? As with our parser tests, we’re building up our testing infrastructure here. The <code>TestEvalIntegerExpression</code> test will need to grow and its current structure makes this really easy. The <code>testEval</code> and <code>testIntegerObject</code> will also find a lot of use.</p>\n<p>The heart of the test is the call to <code>Eval</code> inside <code>testEval</code>. We take our input, pass it to the lexer, pass the lexer to the parser and get back an AST. And then, this is new, we pass the AST to <code>Eval</code>. The return value of <code>Eval</code> is what we make assertions about. In this case, we want the return value to be an <code>*object.Integer</code> with the correct <code>.Value</code>. In other words: we want <code>5</code> to evaluate to <code>5</code>.</p>\n<p>Of course, the test fails because we haven’t defined <code>Eval</code> yet. But we already know that <code>Eval</code> should take an <code>ast.Node</code> as argument and return an <code>object.Object</code>. And whenever it encounters an <code>*ast.IntegerLiteral</code> it should return an <code>*object.Integer</code> with the correct <code>.Value</code>. Turning this into code and defining our new <code>Eval</code> with this behaviour in the <code>evaluator</code> package, we get this:</p>\n<div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb14-1\"><a href=\"#cb14-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb14-2\"><a href=\"#cb14-2\"></a></span>\n<span id=\"cb14-3\"><a href=\"#cb14-3\"></a><span class=\"kw\">package</span> evaluator</span>\n<span id=\"cb14-4\"><a href=\"#cb14-4\"></a></span>\n<span id=\"cb14-5\"><a href=\"#cb14-5\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb14-6\"><a href=\"#cb14-6\"></a>    <span class=\"st\">&quot;monkey/ast&quot;</span></span>\n<span id=\"cb14-7\"><a href=\"#cb14-7\"></a>    <span class=\"st\">&quot;monkey/object&quot;</span></span>\n<span id=\"cb14-8\"><a href=\"#cb14-8\"></a>)</span>\n<span id=\"cb14-9\"><a href=\"#cb14-9\"></a></span>\n<span id=\"cb14-10\"><a href=\"#cb14-10\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb14-11\"><a href=\"#cb14-11\"></a>    <span class=\"kw\">switch</span> node := node.(<span class=\"kw\">type</span>) {</span>\n<span id=\"cb14-12\"><a href=\"#cb14-12\"></a>    <span class=\"kw\">case</span> *ast.IntegerLiteral:</span>\n<span id=\"cb14-13\"><a href=\"#cb14-13\"></a>        <span class=\"kw\">return</span> &amp;object.Integer{Value: node.Value}</span>\n<span id=\"cb14-14\"><a href=\"#cb14-14\"></a>    }</span>\n<span id=\"cb14-15\"><a href=\"#cb14-15\"></a></span>\n<span id=\"cb14-16\"><a href=\"#cb14-16\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb14-17\"><a href=\"#cb14-17\"></a>}</span></code></pre></div>\n<p>Nothing surprising here, it does just what we said it should. Except that it doesn’t work. The test still fails because <code>Eval</code> returns <code>nil</code> instead of an <code>*object.Integer</code>.</p>\n<div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb15-1\"><a href=\"#cb15-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb15-2\"><a href=\"#cb15-2\"></a>--- FAIL: TestEvalIntegerExpression (0.00s)</span>\n<span id=\"cb15-3\"><a href=\"#cb15-3\"></a>  evaluator_test.go:36: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb15-4\"><a href=\"#cb15-4\"></a>  evaluator_test.go:36: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb15-5\"><a href=\"#cb15-5\"></a>FAIL</span>\n<span id=\"cb15-6\"><a href=\"#cb15-6\"></a>FAIL    monkey/evaluator        0.006s</span></code></pre></div>\n<p>The reason for this failure is that we never encounter an <code>*ast.IntegerLiteral</code> in <code>Eval</code>. We don’t traverse the AST. We should always start at the top of the tree, receiving an <code>*ast.Program</code>, and then traverse every node in it. And that’s exactly what we’re not doing here. We’re just waiting for an <code>*ast.IntegerLiteral</code>. The fix is to actually traverse the tree and evaluate every statement of the <code>*ast.Program</code>:</p>\n<div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb16-1\"><a href=\"#cb16-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb16-2\"><a href=\"#cb16-2\"></a></span>\n<span id=\"cb16-3\"><a href=\"#cb16-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb16-4\"><a href=\"#cb16-4\"></a>    <span class=\"kw\">switch</span> node := node.(<span class=\"kw\">type</span>) {</span>\n<span id=\"cb16-5\"><a href=\"#cb16-5\"></a></span>\n<span id=\"cb16-6\"><a href=\"#cb16-6\"></a>    <span class=\"co\">// Statements</span></span>\n<span id=\"cb16-7\"><a href=\"#cb16-7\"></a>    <span class=\"kw\">case</span> *ast.Program:</span>\n<span id=\"cb16-8\"><a href=\"#cb16-8\"></a>        <span class=\"kw\">return</span> evalStatements(node.Statements)</span>\n<span id=\"cb16-9\"><a href=\"#cb16-9\"></a></span>\n<span id=\"cb16-10\"><a href=\"#cb16-10\"></a>    <span class=\"kw\">case</span> *ast.ExpressionStatement:</span>\n<span id=\"cb16-11\"><a href=\"#cb16-11\"></a>        <span class=\"kw\">return</span> Eval(node.Expression)</span>\n<span id=\"cb16-12\"><a href=\"#cb16-12\"></a></span>\n<span id=\"cb16-13\"><a href=\"#cb16-13\"></a>    <span class=\"co\">// Expressions</span></span>\n<span id=\"cb16-14\"><a href=\"#cb16-14\"></a>    <span class=\"kw\">case</span> *ast.IntegerLiteral:</span>\n<span id=\"cb16-15\"><a href=\"#cb16-15\"></a>        <span class=\"kw\">return</span> &amp;object.Integer{Value: node.Value}</span>\n<span id=\"cb16-16\"><a href=\"#cb16-16\"></a>    }</span>\n<span id=\"cb16-17\"><a href=\"#cb16-17\"></a></span>\n<span id=\"cb16-18\"><a href=\"#cb16-18\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb16-19\"><a href=\"#cb16-19\"></a>}</span>\n<span id=\"cb16-20\"><a href=\"#cb16-20\"></a></span>\n<span id=\"cb16-21\"><a href=\"#cb16-21\"></a><span class=\"kw\">func</span> evalStatements(stmts []ast.Statement) object.Object {</span>\n<span id=\"cb16-22\"><a href=\"#cb16-22\"></a>    <span class=\"kw\">var</span> result object.Object</span>\n<span id=\"cb16-23\"><a href=\"#cb16-23\"></a></span>\n<span id=\"cb16-24\"><a href=\"#cb16-24\"></a>    <span class=\"kw\">for</span> _, statement := <span class=\"kw\">range</span> stmts {</span>\n<span id=\"cb16-25\"><a href=\"#cb16-25\"></a>        result = Eval(statement)</span>\n<span id=\"cb16-26\"><a href=\"#cb16-26\"></a>    }</span>\n<span id=\"cb16-27\"><a href=\"#cb16-27\"></a></span>\n<span id=\"cb16-28\"><a href=\"#cb16-28\"></a>    <span class=\"kw\">return</span> result</span>\n<span id=\"cb16-29\"><a href=\"#cb16-29\"></a>}</span></code></pre></div>\n<p>With these changes we evaluate every statement in a Monkey program. And if the statement is an <code>*ast.ExpressionStatement</code> we evaluate its expression. That mirrors the AST structure we get from a one line input like <code>5</code>: a program that consists of one statement, an expression statement (not a return statement and not a let statement) with an integer literal as its expression.</p>\n<div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb17-1\"><a href=\"#cb17-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb17-2\"><a href=\"#cb17-2\"></a>ok      monkey/evaluator        0.006s</span></code></pre></div>\n<p>Alright, the tests pass! We can evaluate integer literals! <em>Hey everyone, if we type in a number, a number comes out and it only took us a couple thousand lines of code and tests to do so!</em> Okay, granted, it doesn’t look like much. But it’s a start. We’re beginning to see how evaluation works and how we can extend our evaluator. The structure of <code>Eval</code> won’t change, we’ll only add to and extend it.</p>\n<p>Next up on our list of self-evaluating expressions are boolean literals. But before we do that, we should celebrate our first evaluation success and treat ourselves. Let’s put the E in REPL!</p>\n</section>\n<section id=\"completing-the-repl\" class=\"level3\" data-number=\"3.5.2\">\n<h3 data-number=\"3.5.2\">Completing the REPL</h3>\n<p>Up until now the E in in our REPL was missing and we had nothing but a RPPL - a Read-Parse-Print-Loop. Now that we have <code>Eval</code> we can build a real Read-Evaluate-Print-Loop!</p>\n<p>Using the evaluator in the <code>repl</code> package is as easy as you’d think it is:</p>\n<div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb18-1\"><a href=\"#cb18-1\"></a><span class=\"co\">// repl/repl.go</span></span>\n<span id=\"cb18-2\"><a href=\"#cb18-2\"></a></span>\n<span id=\"cb18-3\"><a href=\"#cb18-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb18-4\"><a href=\"#cb18-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb18-5\"><a href=\"#cb18-5\"></a>    <span class=\"st\">&quot;monkey/evaluator&quot;</span></span>\n<span id=\"cb18-6\"><a href=\"#cb18-6\"></a>)</span>\n<span id=\"cb18-7\"><a href=\"#cb18-7\"></a></span>\n<span id=\"cb18-8\"><a href=\"#cb18-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb18-9\"><a href=\"#cb18-9\"></a></span>\n<span id=\"cb18-10\"><a href=\"#cb18-10\"></a><span class=\"kw\">func</span> Start(in io.Reader, out io.Writer) {</span>\n<span id=\"cb18-11\"><a href=\"#cb18-11\"></a>    scanner := bufio.NewScanner(in)</span>\n<span id=\"cb18-12\"><a href=\"#cb18-12\"></a></span>\n<span id=\"cb18-13\"><a href=\"#cb18-13\"></a>    <span class=\"kw\">for</span> {</span>\n<span id=\"cb18-14\"><a href=\"#cb18-14\"></a>        fmt.Fprintf(out, PROMPT)</span>\n<span id=\"cb18-15\"><a href=\"#cb18-15\"></a>        scanned := scanner.Scan()</span>\n<span id=\"cb18-16\"><a href=\"#cb18-16\"></a>        <span class=\"kw\">if</span> !scanned {</span>\n<span id=\"cb18-17\"><a href=\"#cb18-17\"></a>            <span class=\"kw\">return</span></span>\n<span id=\"cb18-18\"><a href=\"#cb18-18\"></a>        }</span>\n<span id=\"cb18-19\"><a href=\"#cb18-19\"></a></span>\n<span id=\"cb18-20\"><a href=\"#cb18-20\"></a>        line := scanner.Text()</span>\n<span id=\"cb18-21\"><a href=\"#cb18-21\"></a>        l := lexer.New(line)</span>\n<span id=\"cb18-22\"><a href=\"#cb18-22\"></a>        p := parser.New(l)</span>\n<span id=\"cb18-23\"><a href=\"#cb18-23\"></a></span>\n<span id=\"cb18-24\"><a href=\"#cb18-24\"></a>        program := p.ParseProgram()</span>\n<span id=\"cb18-25\"><a href=\"#cb18-25\"></a>        <span class=\"kw\">if</span> <span class=\"bu\">len</span>(p.Errors()) != <span class=\"dv\">0</span> {</span>\n<span id=\"cb18-26\"><a href=\"#cb18-26\"></a>            printParserErrors(out, p.Errors())</span>\n<span id=\"cb18-27\"><a href=\"#cb18-27\"></a>            <span class=\"kw\">continue</span></span>\n<span id=\"cb18-28\"><a href=\"#cb18-28\"></a>        }</span>\n<span id=\"cb18-29\"><a href=\"#cb18-29\"></a></span>\n<span id=\"cb18-30\"><a href=\"#cb18-30\"></a>        evaluated := evaluator.Eval(program)</span>\n<span id=\"cb18-31\"><a href=\"#cb18-31\"></a>        <span class=\"kw\">if</span> evaluated != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb18-32\"><a href=\"#cb18-32\"></a>            io.WriteString(out, evaluated.Inspect())</span>\n<span id=\"cb18-33\"><a href=\"#cb18-33\"></a>            io.WriteString(out, <span class=\"st\">&quot;</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>)</span>\n<span id=\"cb18-34\"><a href=\"#cb18-34\"></a>        }</span>\n<span id=\"cb18-35\"><a href=\"#cb18-35\"></a>    }</span>\n<span id=\"cb18-36\"><a href=\"#cb18-36\"></a>}</span></code></pre></div>\n<p>Instead of printing <code>program</code> (the AST returned by the parser) we pass <code>program</code> to <code>Eval</code>. If <code>Eval</code> returns a non-nil value, an <code>object.Object</code>, we print the output of its <code>Inspect()</code> method. In the case of an <code>*object.Integer</code> that would be the string representation of the integer it’s wrapping.</p>\n<p>And with that we now have a working REPL:</p>\n<div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb19-1\"><a href=\"#cb19-1\"></a>$ go run main.go</span>\n<span id=\"cb19-2\"><a href=\"#cb19-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb19-3\"><a href=\"#cb19-3\"></a>Feel free to type in commands</span>\n<span id=\"cb19-4\"><a href=\"#cb19-4\"></a>&gt;&gt; 5</span>\n<span id=\"cb19-5\"><a href=\"#cb19-5\"></a>5</span>\n<span id=\"cb19-6\"><a href=\"#cb19-6\"></a>&gt;&gt; 10</span>\n<span id=\"cb19-7\"><a href=\"#cb19-7\"></a>10</span>\n<span id=\"cb19-8\"><a href=\"#cb19-8\"></a>&gt;&gt; 999</span>\n<span id=\"cb19-9\"><a href=\"#cb19-9\"></a>999</span>\n<span id=\"cb19-10\"><a href=\"#cb19-10\"></a>&gt;&gt;</span></code></pre></div>\n<p>Feels good, doesn’t it? Lexing, parsing, evaluating - it’s all in there. We’ve come a long way.</p>\n</section>\n<section id=\"boolean-literals-1\" class=\"level3\" data-number=\"3.5.3\">\n<h3 data-number=\"3.5.3\">Boolean Literals</h3>\n<p>Boolean literals, just like their integer counterparts, evaluate to themselves. <code>true</code> evaluates to <code>true</code> and <code>false</code> to <code>false</code>. Implementing this in <code>Eval</code> is as easy as adding support for integer literals was. The tests are equally boring:</p>\n<div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb20-1\"><a href=\"#cb20-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb20-2\"><a href=\"#cb20-2\"></a></span>\n<span id=\"cb20-3\"><a href=\"#cb20-3\"></a><span class=\"kw\">func</span> TestEvalBooleanExpression(t *testing.T) {</span>\n<span id=\"cb20-4\"><a href=\"#cb20-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb20-5\"><a href=\"#cb20-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb20-6\"><a href=\"#cb20-6\"></a>        expected <span class=\"dt\">bool</span></span>\n<span id=\"cb20-7\"><a href=\"#cb20-7\"></a>    }{</span>\n<span id=\"cb20-8\"><a href=\"#cb20-8\"></a>        {<span class=\"st\">&quot;true&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb20-9\"><a href=\"#cb20-9\"></a>        {<span class=\"st\">&quot;false&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb20-10\"><a href=\"#cb20-10\"></a>    }</span>\n<span id=\"cb20-11\"><a href=\"#cb20-11\"></a></span>\n<span id=\"cb20-12\"><a href=\"#cb20-12\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb20-13\"><a href=\"#cb20-13\"></a>        evaluated := testEval(tt.input)</span>\n<span id=\"cb20-14\"><a href=\"#cb20-14\"></a>        testBooleanObject(t, evaluated, tt.expected)</span>\n<span id=\"cb20-15\"><a href=\"#cb20-15\"></a>    }</span>\n<span id=\"cb20-16\"><a href=\"#cb20-16\"></a>}</span>\n<span id=\"cb20-17\"><a href=\"#cb20-17\"></a></span>\n<span id=\"cb20-18\"><a href=\"#cb20-18\"></a><span class=\"kw\">func</span> testBooleanObject(t *testing.T, obj object.Object, expected <span class=\"dt\">bool</span>) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb20-19\"><a href=\"#cb20-19\"></a>    result, ok := obj.(*object.Boolean)</span>\n<span id=\"cb20-20\"><a href=\"#cb20-20\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb20-21\"><a href=\"#cb20-21\"></a>        t.Errorf(<span class=\"st\">&quot;object is not Boolean. got=%T (%+v)&quot;</span>, obj, obj)</span>\n<span id=\"cb20-22\"><a href=\"#cb20-22\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb20-23\"><a href=\"#cb20-23\"></a>    }</span>\n<span id=\"cb20-24\"><a href=\"#cb20-24\"></a>    <span class=\"kw\">if</span> result.Value != expected {</span>\n<span id=\"cb20-25\"><a href=\"#cb20-25\"></a>        t.Errorf(<span class=\"st\">&quot;object has wrong value. got=%t, want=%t&quot;</span>,</span>\n<span id=\"cb20-26\"><a href=\"#cb20-26\"></a>            result.Value, expected)</span>\n<span id=\"cb20-27\"><a href=\"#cb20-27\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb20-28\"><a href=\"#cb20-28\"></a>    }</span>\n<span id=\"cb20-29\"><a href=\"#cb20-29\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb20-30\"><a href=\"#cb20-30\"></a>}</span></code></pre></div>\n<p>We’ll extend the <code>tests</code> slice as soon as we support more expressions that result in booleans. For now, we only make sure that we get the correct output when we enter <code>true</code> or <code>false</code>. The tests fail:</p>\n<div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb21-1\"><a href=\"#cb21-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb21-2\"><a href=\"#cb21-2\"></a>--- FAIL: TestEvalBooleanExpression (0.00s)</span>\n<span id=\"cb21-3\"><a href=\"#cb21-3\"></a>  evaluator_test.go:42: object is not Boolean. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb21-4\"><a href=\"#cb21-4\"></a>  evaluator_test.go:42: object is not Boolean. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb21-5\"><a href=\"#cb21-5\"></a>FAIL</span>\n<span id=\"cb21-6\"><a href=\"#cb21-6\"></a>FAIL    monkey/evaluator        0.006s</span></code></pre></div>\n<p>Making this green is as easy as copying the <code>case</code> branch from <code>*ast.IntegerLiteral</code> and changing two identifiers:</p>\n<div class=\"sourceCode\" id=\"cb22\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb22-1\"><a href=\"#cb22-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb22-2\"><a href=\"#cb22-2\"></a></span>\n<span id=\"cb22-3\"><a href=\"#cb22-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb22-4\"><a href=\"#cb22-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb22-5\"><a href=\"#cb22-5\"></a>    <span class=\"kw\">case</span> *ast.Boolean:</span>\n<span id=\"cb22-6\"><a href=\"#cb22-6\"></a>        <span class=\"kw\">return</span> &amp;object.Boolean{Value: node.Value}</span>\n<span id=\"cb22-7\"><a href=\"#cb22-7\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb22-8\"><a href=\"#cb22-8\"></a>}</span></code></pre></div>\n<p>That’s it! Let’s give it a spin in the REPL:</p>\n<pre><code>$ go run main.go\nHello mrnugget! This is the Monkey programming language!\nFeel free to type in commands\n&gt;&gt; true\ntrue\n&gt;&gt; false\nfalse\n&gt;&gt;</code></pre>\n<p>Pretty! But, let me ask you this: the fact that we’re creating a new <code>object.Boolean</code> every time we encounter a <code>true</code> or <code>false</code> is absurd, isn’t it? There is no difference between two <code>true</code>s. The same goes for <code>false</code>. Why use new instances every time? There are only two possible values, so let’s reference them instead of creating new ones.</p>\n<div class=\"sourceCode\" id=\"cb24\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb24-1\"><a href=\"#cb24-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb24-2\"><a href=\"#cb24-2\"></a></span>\n<span id=\"cb24-3\"><a href=\"#cb24-3\"></a><span class=\"kw\">var</span> (</span>\n<span id=\"cb24-4\"><a href=\"#cb24-4\"></a>    TRUE  = &amp;object.Boolean{Value: <span class=\"ot\">true</span>}</span>\n<span id=\"cb24-5\"><a href=\"#cb24-5\"></a>    FALSE = &amp;object.Boolean{Value: <span class=\"ot\">false</span>}</span>\n<span id=\"cb24-6\"><a href=\"#cb24-6\"></a>)</span>\n<span id=\"cb24-7\"><a href=\"#cb24-7\"></a></span>\n<span id=\"cb24-8\"><a href=\"#cb24-8\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb24-9\"><a href=\"#cb24-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb24-10\"><a href=\"#cb24-10\"></a>    <span class=\"kw\">case</span> *ast.Boolean:</span>\n<span id=\"cb24-11\"><a href=\"#cb24-11\"></a>        <span class=\"kw\">return</span> nativeBoolToBooleanObject(node.Value)</span>\n<span id=\"cb24-12\"><a href=\"#cb24-12\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb24-13\"><a href=\"#cb24-13\"></a>}</span>\n<span id=\"cb24-14\"><a href=\"#cb24-14\"></a></span>\n<span id=\"cb24-15\"><a href=\"#cb24-15\"></a><span class=\"kw\">func</span> nativeBoolToBooleanObject(input <span class=\"dt\">bool</span>) *object.Boolean {</span>\n<span id=\"cb24-16\"><a href=\"#cb24-16\"></a>    <span class=\"kw\">if</span> input {</span>\n<span id=\"cb24-17\"><a href=\"#cb24-17\"></a>        <span class=\"kw\">return</span> TRUE</span>\n<span id=\"cb24-18\"><a href=\"#cb24-18\"></a>    }</span>\n<span id=\"cb24-19\"><a href=\"#cb24-19\"></a>    <span class=\"kw\">return</span> FALSE</span>\n<span id=\"cb24-20\"><a href=\"#cb24-20\"></a>}</span></code></pre></div>\n<p>Now there are only two instances of <code>object.Boolean</code> in our package: <code>TRUE</code> and <code>FALSE</code> and we reference them instead of allocating new <code>object.Boolean</code>s. That makes much more sense and is a small performance improvement we get without a lot of work. And while we’re at it, let’s take care of null, too.</p>\n</section>\n<section id=\"null-1\" class=\"level3\" data-number=\"3.5.4\">\n<h3 data-number=\"3.5.4\">Null</h3>\n<p>Just as there is only one <code>true</code> and one <code>false</code>, there should only be one reference to a null value. There are no variations of null. No kinda-but-not-quite-null, no half-null and no basically-the-same-as-the-other-null. Either something is this one null, or it isn’t. So let’s create one <code>NULL</code> we can reference throughout our evaluator instead of creating new <code>object.Null</code>s.</p>\n<div class=\"sourceCode\" id=\"cb25\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb25-1\"><a href=\"#cb25-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb25-2\"><a href=\"#cb25-2\"></a></span>\n<span id=\"cb25-3\"><a href=\"#cb25-3\"></a><span class=\"kw\">var</span> (</span>\n<span id=\"cb25-4\"><a href=\"#cb25-4\"></a>    NULL  = &amp;object.Null{}</span>\n<span id=\"cb25-5\"><a href=\"#cb25-5\"></a>    TRUE  = &amp;object.Boolean{Value: <span class=\"ot\">true</span>}</span>\n<span id=\"cb25-6\"><a href=\"#cb25-6\"></a>    FALSE = &amp;object.Boolean{Value: <span class=\"ot\">false</span>}</span>\n<span id=\"cb25-7\"><a href=\"#cb25-7\"></a>)</span></code></pre></div>\n<p>And that’s all there is to it. Now we have one <code>NULL</code> we can reference.</p>\n<p>With integer literals and our trio of <code>NULL</code>, <code>TRUE</code> and <code>FALSE</code> in place we’re ready to evaluate operator expressions.</p>\n</section>\n<section id=\"prefix-expressions\" class=\"level3\" data-number=\"3.5.5\">\n<h3 data-number=\"3.5.5\">Prefix Expressions</h3>\n<p>The simplest form of operator expressions Monkey supports is the prefix expression, or unary operator expression, where one operand follows the operator. In our parser we treated a lot of language constructs like prefix expressions, because that’s the easiest way to parse them. But in this section prefix expressions are just operator expressions with one operator and one operand. Monkey supports two of these prefix operators: <code>!</code> and <code>-</code>.</p>\n<p>Evaluating operator expressions (especially with a prefix operator and one operand) isn’t hard. We’ll do it in small steps and build up the desired behaviour bit by bit. But we also need to pay close attention. What we’re about to implement has far reaching consequences. Remember: in the evaluation process the input language receives meaning; we’re defining the semantics of the Monkey programming language. A small change in the evaluation of operator expressions might cause something unintended in a part of the language that seems entirely unrelated. Tests help us to nail down the desired behaviour and also act as a specification for us.</p>\n<p>We’re going to start by implementing support for the <code>!</code> operator. The tests show that the operator should “convert” its operand to a boolean value and negate it:</p>\n<div class=\"sourceCode\" id=\"cb26\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb26-1\"><a href=\"#cb26-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb26-2\"><a href=\"#cb26-2\"></a></span>\n<span id=\"cb26-3\"><a href=\"#cb26-3\"></a><span class=\"kw\">func</span> TestBangOperator(t *testing.T) {</span>\n<span id=\"cb26-4\"><a href=\"#cb26-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb26-5\"><a href=\"#cb26-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb26-6\"><a href=\"#cb26-6\"></a>        expected <span class=\"dt\">bool</span></span>\n<span id=\"cb26-7\"><a href=\"#cb26-7\"></a>    }{</span>\n<span id=\"cb26-8\"><a href=\"#cb26-8\"></a>        {<span class=\"st\">&quot;!true&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb26-9\"><a href=\"#cb26-9\"></a>        {<span class=\"st\">&quot;!false&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb26-10\"><a href=\"#cb26-10\"></a>        {<span class=\"st\">&quot;!5&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb26-11\"><a href=\"#cb26-11\"></a>        {<span class=\"st\">&quot;!!true&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb26-12\"><a href=\"#cb26-12\"></a>        {<span class=\"st\">&quot;!!false&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb26-13\"><a href=\"#cb26-13\"></a>        {<span class=\"st\">&quot;!!5&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb26-14\"><a href=\"#cb26-14\"></a>    }</span>\n<span id=\"cb26-15\"><a href=\"#cb26-15\"></a></span>\n<span id=\"cb26-16\"><a href=\"#cb26-16\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb26-17\"><a href=\"#cb26-17\"></a>        evaluated := testEval(tt.input)</span>\n<span id=\"cb26-18\"><a href=\"#cb26-18\"></a>        testBooleanObject(t, evaluated, tt.expected)</span>\n<span id=\"cb26-19\"><a href=\"#cb26-19\"></a>    }</span>\n<span id=\"cb26-20\"><a href=\"#cb26-20\"></a>}</span></code></pre></div>\n<p>As I said, this is where we decide how the language works. The <code>!true</code> and <code>!false</code> expressions and their expected results seem like common sense, but the <code>!5</code> may be something where other language designers feel an error should be returned. But what we’re saying here is that <code>5</code> acts as “truthy”.</p>\n<p>The tests don’t pass, of course, because <code>Eval</code> returns <code>nil</code> instead of <code>TRUE</code> or <code>FALSE</code>. The first step to evaluating a prefix expression is to evaluate its operand and then use the result of this evaluation with the operator:</p>\n<div class=\"sourceCode\" id=\"cb27\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb27-1\"><a href=\"#cb27-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb27-2\"><a href=\"#cb27-2\"></a></span>\n<span id=\"cb27-3\"><a href=\"#cb27-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb27-4\"><a href=\"#cb27-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb27-5\"><a href=\"#cb27-5\"></a>    <span class=\"kw\">case</span> *ast.PrefixExpression:</span>\n<span id=\"cb27-6\"><a href=\"#cb27-6\"></a>        right := Eval(node.Right)</span>\n<span id=\"cb27-7\"><a href=\"#cb27-7\"></a>        <span class=\"kw\">return</span> evalPrefixExpression(node.Operator, right)</span>\n<span id=\"cb27-8\"><a href=\"#cb27-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb27-9\"><a href=\"#cb27-9\"></a>}</span></code></pre></div>\n<p>After the first call to <code>Eval</code> here, <code>right</code> may be an <code>*object.Integer</code> or an <code>*object.Boolean</code> or maybe even <code>NULL</code>. We then take this <code>right</code> operand and pass it to <code>evalPrefixExpression</code> which checks if the operator is supported:</p>\n<div class=\"sourceCode\" id=\"cb28\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb28-1\"><a href=\"#cb28-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb28-2\"><a href=\"#cb28-2\"></a></span>\n<span id=\"cb28-3\"><a href=\"#cb28-3\"></a><span class=\"kw\">func</span> evalPrefixExpression(operator <span class=\"dt\">string</span>, right object.Object) object.Object {</span>\n<span id=\"cb28-4\"><a href=\"#cb28-4\"></a>    <span class=\"kw\">switch</span> operator {</span>\n<span id=\"cb28-5\"><a href=\"#cb28-5\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;!&quot;</span>:</span>\n<span id=\"cb28-6\"><a href=\"#cb28-6\"></a>        <span class=\"kw\">return</span> evalBangOperatorExpression(right)</span>\n<span id=\"cb28-7\"><a href=\"#cb28-7\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb28-8\"><a href=\"#cb28-8\"></a>        <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb28-9\"><a href=\"#cb28-9\"></a>    }</span>\n<span id=\"cb28-10\"><a href=\"#cb28-10\"></a>}</span></code></pre></div>\n<p>If the operator is not supported we return <code>NULL</code>. Is that the best choice? Maybe, maybe not. For now, it’s definitely the easiest choice, since we don’t have any error handling implemented yet.</p>\n<p>The <code>evalBangOperatorExpression</code> function is where the behaviour of the <code>!</code> is specified:</p>\n<div class=\"sourceCode\" id=\"cb29\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb29-1\"><a href=\"#cb29-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb29-2\"><a href=\"#cb29-2\"></a></span>\n<span id=\"cb29-3\"><a href=\"#cb29-3\"></a><span class=\"kw\">func</span> evalBangOperatorExpression(right object.Object) object.Object {</span>\n<span id=\"cb29-4\"><a href=\"#cb29-4\"></a>    <span class=\"kw\">switch</span> right {</span>\n<span id=\"cb29-5\"><a href=\"#cb29-5\"></a>    <span class=\"kw\">case</span> TRUE:</span>\n<span id=\"cb29-6\"><a href=\"#cb29-6\"></a>        <span class=\"kw\">return</span> FALSE</span>\n<span id=\"cb29-7\"><a href=\"#cb29-7\"></a>    <span class=\"kw\">case</span> FALSE:</span>\n<span id=\"cb29-8\"><a href=\"#cb29-8\"></a>        <span class=\"kw\">return</span> TRUE</span>\n<span id=\"cb29-9\"><a href=\"#cb29-9\"></a>    <span class=\"kw\">case</span> NULL:</span>\n<span id=\"cb29-10\"><a href=\"#cb29-10\"></a>        <span class=\"kw\">return</span> TRUE</span>\n<span id=\"cb29-11\"><a href=\"#cb29-11\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb29-12\"><a href=\"#cb29-12\"></a>        <span class=\"kw\">return</span> FALSE</span>\n<span id=\"cb29-13\"><a href=\"#cb29-13\"></a>    }</span>\n<span id=\"cb29-14\"><a href=\"#cb29-14\"></a>}</span></code></pre></div>\n<p>And with that the tests pass!</p>\n<div class=\"sourceCode\" id=\"cb30\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb30-1\"><a href=\"#cb30-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb30-2\"><a href=\"#cb30-2\"></a>ok      monkey/evaluator        0.007s</span></code></pre></div>\n<p>Let’s move on to the <code>-</code> prefix operator. We can extend our <code>TestEvalIntegerExpression</code> test function to incorporate it:</p>\n<div class=\"sourceCode\" id=\"cb31\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb31-1\"><a href=\"#cb31-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb31-2\"><a href=\"#cb31-2\"></a></span>\n<span id=\"cb31-3\"><a href=\"#cb31-3\"></a><span class=\"kw\">func</span> TestEvalIntegerExpression(t *testing.T) {</span>\n<span id=\"cb31-4\"><a href=\"#cb31-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb31-5\"><a href=\"#cb31-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb31-6\"><a href=\"#cb31-6\"></a>        expected <span class=\"dt\">int64</span></span>\n<span id=\"cb31-7\"><a href=\"#cb31-7\"></a>    }{</span>\n<span id=\"cb31-8\"><a href=\"#cb31-8\"></a>        {<span class=\"st\">&quot;5&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb31-9\"><a href=\"#cb31-9\"></a>        {<span class=\"st\">&quot;10&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb31-10\"><a href=\"#cb31-10\"></a>        {<span class=\"st\">&quot;-5&quot;</span>, <span class=\"dv\">-5</span>},</span>\n<span id=\"cb31-11\"><a href=\"#cb31-11\"></a>        {<span class=\"st\">&quot;-10&quot;</span>, <span class=\"dv\">-10</span>},</span>\n<span id=\"cb31-12\"><a href=\"#cb31-12\"></a>    }</span>\n<span id=\"cb31-13\"><a href=\"#cb31-13\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb31-14\"><a href=\"#cb31-14\"></a>}</span></code></pre></div>\n<p>I choose to extend this test rather than writing a new test function solely for the <code>-</code> prefix operator for two reasons. First, integers are the only supported operands of the <code>-</code> operator in prefix position. And second, because this test function should grow to encompass all integer arithmetic in order to have one place that shows the desired behaviour in a clear and neat way.</p>\n<p>We have to extend the <code>evalPrefixExpression</code> function we wrote earlier in order to make the test cases pass. A new branch in the switch statement is needed:</p>\n<div class=\"sourceCode\" id=\"cb32\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb32-1\"><a href=\"#cb32-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb32-2\"><a href=\"#cb32-2\"></a></span>\n<span id=\"cb32-3\"><a href=\"#cb32-3\"></a><span class=\"kw\">func</span> evalPrefixExpression(operator <span class=\"dt\">string</span>, right object.Object) object.Object {</span>\n<span id=\"cb32-4\"><a href=\"#cb32-4\"></a>    <span class=\"kw\">switch</span> operator {</span>\n<span id=\"cb32-5\"><a href=\"#cb32-5\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;!&quot;</span>:</span>\n<span id=\"cb32-6\"><a href=\"#cb32-6\"></a>        <span class=\"kw\">return</span> evalBangOperatorExpression(right)</span>\n<span id=\"cb32-7\"><a href=\"#cb32-7\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;-&quot;</span>:</span>\n<span id=\"cb32-8\"><a href=\"#cb32-8\"></a>        <span class=\"kw\">return</span> evalMinusPrefixOperatorExpression(right)</span>\n<span id=\"cb32-9\"><a href=\"#cb32-9\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb32-10\"><a href=\"#cb32-10\"></a>        <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb32-11\"><a href=\"#cb32-11\"></a>    }</span>\n<span id=\"cb32-12\"><a href=\"#cb32-12\"></a>}</span></code></pre></div>\n<p>The <code>evalMinusPrefixOperatorExpression</code> function looks like this:</p>\n<div class=\"sourceCode\" id=\"cb33\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb33-1\"><a href=\"#cb33-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb33-2\"><a href=\"#cb33-2\"></a></span>\n<span id=\"cb33-3\"><a href=\"#cb33-3\"></a><span class=\"kw\">func</span> evalMinusPrefixOperatorExpression(right object.Object) object.Object {</span>\n<span id=\"cb33-4\"><a href=\"#cb33-4\"></a>    <span class=\"kw\">if</span> right.Type() != object.INTEGER_OBJ {</span>\n<span id=\"cb33-5\"><a href=\"#cb33-5\"></a>        <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb33-6\"><a href=\"#cb33-6\"></a>    }</span>\n<span id=\"cb33-7\"><a href=\"#cb33-7\"></a></span>\n<span id=\"cb33-8\"><a href=\"#cb33-8\"></a>    value := right.(*object.Integer).Value</span>\n<span id=\"cb33-9\"><a href=\"#cb33-9\"></a>    <span class=\"kw\">return</span> &amp;object.Integer{Value: -value}</span>\n<span id=\"cb33-10\"><a href=\"#cb33-10\"></a>}</span></code></pre></div>\n<p>The first thing we do here is to check if the operand is an integer. If it isn’t, we return <code>NULL</code>. But if it is, we extract the value of the <code>*object.Integer</code>. Then we allocate a new object to wrap a negated version of this value.</p>\n<p>That wasn’t a lot of code, was it? But still, it did the job:</p>\n<div class=\"sourceCode\" id=\"cb34\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb34-1\"><a href=\"#cb34-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb34-2\"><a href=\"#cb34-2\"></a>ok      monkey/evaluator        0.007s</span></code></pre></div>\n<p>Excellent! Now we can give our prefix expressions a spin in the REPL before moving on to their infix friends:</p>\n<div class=\"sourceCode\" id=\"cb35\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb35-1\"><a href=\"#cb35-1\"></a>$ go run main.go</span>\n<span id=\"cb35-2\"><a href=\"#cb35-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb35-3\"><a href=\"#cb35-3\"></a>Feel free to type in commands</span>\n<span id=\"cb35-4\"><a href=\"#cb35-4\"></a>&gt;&gt; -5</span>\n<span id=\"cb35-5\"><a href=\"#cb35-5\"></a>-5</span>\n<span id=\"cb35-6\"><a href=\"#cb35-6\"></a>&gt;&gt; !true</span>\n<span id=\"cb35-7\"><a href=\"#cb35-7\"></a>false</span>\n<span id=\"cb35-8\"><a href=\"#cb35-8\"></a>&gt;&gt; !-5</span>\n<span id=\"cb35-9\"><a href=\"#cb35-9\"></a>false</span>\n<span id=\"cb35-10\"><a href=\"#cb35-10\"></a>&gt;&gt; !!-5</span>\n<span id=\"cb35-11\"><a href=\"#cb35-11\"></a>true</span>\n<span id=\"cb35-12\"><a href=\"#cb35-12\"></a>&gt;&gt; !!!!-5</span>\n<span id=\"cb35-13\"><a href=\"#cb35-13\"></a>true</span>\n<span id=\"cb35-14\"><a href=\"#cb35-14\"></a>&gt;&gt; -true</span>\n<span id=\"cb35-15\"><a href=\"#cb35-15\"></a>null</span></code></pre></div>\n<p>Amazing!</p>\n</section>\n<section id=\"infix-expressions\" class=\"level3\" data-number=\"3.5.6\">\n<h3 data-number=\"3.5.6\">Infix Expressions</h3>\n<p>As a refresher, here are the eight infix operators that Monkey supports:</p>\n<div class=\"sourceCode\" id=\"cb36\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb36-1\"><a href=\"#cb36-1\"></a><span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb36-2\"><a href=\"#cb36-2\"></a><span class=\"dv\">5</span> <span class=\"op\">-</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb36-3\"><a href=\"#cb36-3\"></a><span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb36-4\"><a href=\"#cb36-4\"></a><span class=\"dv\">5</span> <span class=\"op\">/</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb36-5\"><a href=\"#cb36-5\"></a></span>\n<span id=\"cb36-6\"><a href=\"#cb36-6\"></a><span class=\"dv\">5</span> <span class=\"op\">&gt;</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb36-7\"><a href=\"#cb36-7\"></a><span class=\"dv\">5</span> <span class=\"op\">&lt;</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb36-8\"><a href=\"#cb36-8\"></a><span class=\"dv\">5</span> <span class=\"op\">==</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb36-9\"><a href=\"#cb36-9\"></a><span class=\"dv\">5</span> <span class=\"op\">!=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span></code></pre></div>\n<p>These eight operators can be separated into two groups: one group of operators produces booleans as their result and one group doesn’t. We’ll start by implementing support for the second group: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. And first only in combination with integer operands. As soon as that works, we’ll add support for booleans on either side of the operator.</p>\n<p>The test infrastructure is already in place. We’ll just extend our <code>TestEvalIntegerExpression</code> test function with test cases for these new operators:</p>\n<div class=\"sourceCode\" id=\"cb37\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb37-1\"><a href=\"#cb37-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb37-2\"><a href=\"#cb37-2\"></a></span>\n<span id=\"cb37-3\"><a href=\"#cb37-3\"></a><span class=\"kw\">func</span> TestEvalIntegerExpression(t *testing.T) {</span>\n<span id=\"cb37-4\"><a href=\"#cb37-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb37-5\"><a href=\"#cb37-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb37-6\"><a href=\"#cb37-6\"></a>        expected <span class=\"dt\">int64</span></span>\n<span id=\"cb37-7\"><a href=\"#cb37-7\"></a>    }{</span>\n<span id=\"cb37-8\"><a href=\"#cb37-8\"></a>        {<span class=\"st\">&quot;5&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb37-9\"><a href=\"#cb37-9\"></a>        {<span class=\"st\">&quot;10&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb37-10\"><a href=\"#cb37-10\"></a>        {<span class=\"st\">&quot;-5&quot;</span>, <span class=\"dv\">-5</span>},</span>\n<span id=\"cb37-11\"><a href=\"#cb37-11\"></a>        {<span class=\"st\">&quot;-10&quot;</span>, <span class=\"dv\">-10</span>},</span>\n<span id=\"cb37-12\"><a href=\"#cb37-12\"></a>        {<span class=\"st\">&quot;5 + 5 + 5 + 5 - 10&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb37-13\"><a href=\"#cb37-13\"></a>        {<span class=\"st\">&quot;2 * 2 * 2 * 2 * 2&quot;</span>, <span class=\"dv\">32</span>},</span>\n<span id=\"cb37-14\"><a href=\"#cb37-14\"></a>        {<span class=\"st\">&quot;-50 + 100 + -50&quot;</span>, <span class=\"dv\">0</span>},</span>\n<span id=\"cb37-15\"><a href=\"#cb37-15\"></a>        {<span class=\"st\">&quot;5 * 2 + 10&quot;</span>, <span class=\"dv\">20</span>},</span>\n<span id=\"cb37-16\"><a href=\"#cb37-16\"></a>        {<span class=\"st\">&quot;5 + 2 * 10&quot;</span>, <span class=\"dv\">25</span>},</span>\n<span id=\"cb37-17\"><a href=\"#cb37-17\"></a>        {<span class=\"st\">&quot;20 + 2 * -10&quot;</span>, <span class=\"dv\">0</span>},</span>\n<span id=\"cb37-18\"><a href=\"#cb37-18\"></a>        {<span class=\"st\">&quot;50 / 2 * 2 + 10&quot;</span>, <span class=\"dv\">60</span>},</span>\n<span id=\"cb37-19\"><a href=\"#cb37-19\"></a>        {<span class=\"st\">&quot;2 * (5 + 10)&quot;</span>, <span class=\"dv\">30</span>},</span>\n<span id=\"cb37-20\"><a href=\"#cb37-20\"></a>        {<span class=\"st\">&quot;3 * 3 * 3 + 10&quot;</span>, <span class=\"dv\">37</span>},</span>\n<span id=\"cb37-21\"><a href=\"#cb37-21\"></a>        {<span class=\"st\">&quot;3 * (3 * 3) + 10&quot;</span>, <span class=\"dv\">37</span>},</span>\n<span id=\"cb37-22\"><a href=\"#cb37-22\"></a>        {<span class=\"st\">&quot;(5 + 10 * 2 + 15 / 3) * 2 + -10&quot;</span>, <span class=\"dv\">50</span>},</span>\n<span id=\"cb37-23\"><a href=\"#cb37-23\"></a>    }</span>\n<span id=\"cb37-24\"><a href=\"#cb37-24\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb37-25\"><a href=\"#cb37-25\"></a>}</span></code></pre></div>\n<p>Yes, there are probably some test cases that can be removed because they duplicate another one and some add nothing new, but to be honest: I was really trigger happy with these tests once I realized that the implementation works and I just couldn’t believe it. “It can’t be that easy, can it?” Well, yes, it can.</p>\n<p>To get these test cases to pass, the first thing we need to do is to extend our switch statement in <code>Eval</code>:</p>\n<div class=\"sourceCode\" id=\"cb38\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb38-1\"><a href=\"#cb38-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb38-2\"><a href=\"#cb38-2\"></a></span>\n<span id=\"cb38-3\"><a href=\"#cb38-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb38-4\"><a href=\"#cb38-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb38-5\"><a href=\"#cb38-5\"></a>    <span class=\"kw\">case</span> *ast.InfixExpression:</span>\n<span id=\"cb38-6\"><a href=\"#cb38-6\"></a>        left := Eval(node.Left)</span>\n<span id=\"cb38-7\"><a href=\"#cb38-7\"></a>        right := Eval(node.Right)</span>\n<span id=\"cb38-8\"><a href=\"#cb38-8\"></a>        <span class=\"kw\">return</span> evalInfixExpression(node.Operator, left, right)</span>\n<span id=\"cb38-9\"><a href=\"#cb38-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb38-10\"><a href=\"#cb38-10\"></a>}</span></code></pre></div>\n<p>Just as with <code>*ast.PrefixExpression</code> we evaluate the operands first. And now we have two: the left and the right arm of the AST node. We already know that these may be any other expression - a function call, an integer literal, an operator expression, etc. We don’t care. We let <code>Eval</code> take care of it.</p>\n<p>After evaluating the operands we take the returned values and the operator and pass them to <code>evalIntegerInfixExpressions</code>, which looks like this:</p>\n<div class=\"sourceCode\" id=\"cb39\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb39-1\"><a href=\"#cb39-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb39-2\"><a href=\"#cb39-2\"></a></span>\n<span id=\"cb39-3\"><a href=\"#cb39-3\"></a><span class=\"kw\">func</span> evalInfixExpression(</span>\n<span id=\"cb39-4\"><a href=\"#cb39-4\"></a>    operator <span class=\"dt\">string</span>,</span>\n<span id=\"cb39-5\"><a href=\"#cb39-5\"></a>    left, right object.Object,</span>\n<span id=\"cb39-6\"><a href=\"#cb39-6\"></a>) object.Object {</span>\n<span id=\"cb39-7\"><a href=\"#cb39-7\"></a>    <span class=\"kw\">switch</span> {</span>\n<span id=\"cb39-8\"><a href=\"#cb39-8\"></a>    <span class=\"kw\">case</span> left.Type() == object.INTEGER_OBJ &amp;&amp; right.Type() == object.INTEGER_OBJ:</span>\n<span id=\"cb39-9\"><a href=\"#cb39-9\"></a>        <span class=\"kw\">return</span> evalIntegerInfixExpression(operator, left, right)</span>\n<span id=\"cb39-10\"><a href=\"#cb39-10\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb39-11\"><a href=\"#cb39-11\"></a>        <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb39-12\"><a href=\"#cb39-12\"></a>    }</span>\n<span id=\"cb39-13\"><a href=\"#cb39-13\"></a>}</span></code></pre></div>\n<p>In case the operands aren’t both integers we return <code>NULL</code>, just as I promised. Of course, we’ll extend this function later on, but in order to get the tests to pass, this is enough. The heart of the matter lies in <code>evalIntegerInfixExpression</code>, where the values wrapped by <code>*object.Integer</code>s are added, subtracted, multiplied and divided:</p>\n<div class=\"sourceCode\" id=\"cb40\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb40-1\"><a href=\"#cb40-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb40-2\"><a href=\"#cb40-2\"></a></span>\n<span id=\"cb40-3\"><a href=\"#cb40-3\"></a><span class=\"kw\">func</span> evalIntegerInfixExpression(</span>\n<span id=\"cb40-4\"><a href=\"#cb40-4\"></a>    operator <span class=\"dt\">string</span>,</span>\n<span id=\"cb40-5\"><a href=\"#cb40-5\"></a>    left, right object.Object,</span>\n<span id=\"cb40-6\"><a href=\"#cb40-6\"></a>) object.Object {</span>\n<span id=\"cb40-7\"><a href=\"#cb40-7\"></a>    leftVal := left.(*object.Integer).Value</span>\n<span id=\"cb40-8\"><a href=\"#cb40-8\"></a>    rightVal := right.(*object.Integer).Value</span>\n<span id=\"cb40-9\"><a href=\"#cb40-9\"></a></span>\n<span id=\"cb40-10\"><a href=\"#cb40-10\"></a>    <span class=\"kw\">switch</span> operator {</span>\n<span id=\"cb40-11\"><a href=\"#cb40-11\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;+&quot;</span>:</span>\n<span id=\"cb40-12\"><a href=\"#cb40-12\"></a>        <span class=\"kw\">return</span> &amp;object.Integer{Value: leftVal + rightVal}</span>\n<span id=\"cb40-13\"><a href=\"#cb40-13\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;-&quot;</span>:</span>\n<span id=\"cb40-14\"><a href=\"#cb40-14\"></a>        <span class=\"kw\">return</span> &amp;object.Integer{Value: leftVal - rightVal}</span>\n<span id=\"cb40-15\"><a href=\"#cb40-15\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;*&quot;</span>:</span>\n<span id=\"cb40-16\"><a href=\"#cb40-16\"></a>        <span class=\"kw\">return</span> &amp;object.Integer{Value: leftVal * rightVal}</span>\n<span id=\"cb40-17\"><a href=\"#cb40-17\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;/&quot;</span>:</span>\n<span id=\"cb40-18\"><a href=\"#cb40-18\"></a>        <span class=\"kw\">return</span> &amp;object.Integer{Value: leftVal / rightVal}</span>\n<span id=\"cb40-19\"><a href=\"#cb40-19\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb40-20\"><a href=\"#cb40-20\"></a>        <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb40-21\"><a href=\"#cb40-21\"></a>    }</span>\n<span id=\"cb40-22\"><a href=\"#cb40-22\"></a>}</span></code></pre></div>\n<p>And now, believe it or not, the tests pass. Yes, really, they do:</p>\n<div class=\"sourceCode\" id=\"cb41\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb41-1\"><a href=\"#cb41-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb41-2\"><a href=\"#cb41-2\"></a>ok      monkey/evaluator        0.007s</span></code></pre></div>\n<p>Go on, add a few more. Knock yourself out. And then come back here so we can add support for the operators that result in booleans: <code>==</code>, <code>!=</code>, <code>&lt;</code> and <code>&gt;</code>.</p>\n<p>We can extend our <code>TestEvalBooleanExpression</code> test function with test cases for these operators, since they all produce a boolean:</p>\n<div class=\"sourceCode\" id=\"cb42\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb42-1\"><a href=\"#cb42-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb42-2\"><a href=\"#cb42-2\"></a></span>\n<span id=\"cb42-3\"><a href=\"#cb42-3\"></a><span class=\"kw\">func</span> TestEvalBooleanExpression(t *testing.T) {</span>\n<span id=\"cb42-4\"><a href=\"#cb42-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb42-5\"><a href=\"#cb42-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb42-6\"><a href=\"#cb42-6\"></a>        expected <span class=\"dt\">bool</span></span>\n<span id=\"cb42-7\"><a href=\"#cb42-7\"></a>    }{</span>\n<span id=\"cb42-8\"><a href=\"#cb42-8\"></a>        {<span class=\"st\">&quot;true&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb42-9\"><a href=\"#cb42-9\"></a>        {<span class=\"st\">&quot;false&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb42-10\"><a href=\"#cb42-10\"></a>        {<span class=\"st\">&quot;1 &lt; 2&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb42-11\"><a href=\"#cb42-11\"></a>        {<span class=\"st\">&quot;1 &gt; 2&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb42-12\"><a href=\"#cb42-12\"></a>        {<span class=\"st\">&quot;1 &lt; 1&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb42-13\"><a href=\"#cb42-13\"></a>        {<span class=\"st\">&quot;1 &gt; 1&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb42-14\"><a href=\"#cb42-14\"></a>        {<span class=\"st\">&quot;1 == 1&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb42-15\"><a href=\"#cb42-15\"></a>        {<span class=\"st\">&quot;1 != 1&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb42-16\"><a href=\"#cb42-16\"></a>        {<span class=\"st\">&quot;1 == 2&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb42-17\"><a href=\"#cb42-17\"></a>        {<span class=\"st\">&quot;1 != 2&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb42-18\"><a href=\"#cb42-18\"></a>    }</span>\n<span id=\"cb42-19\"><a href=\"#cb42-19\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb42-20\"><a href=\"#cb42-20\"></a>}</span></code></pre></div>\n<p>A few added lines in <code>evalIntegerInfixExpression</code> is all that’s needed to get these tests to pass:</p>\n<div class=\"sourceCode\" id=\"cb43\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb43-1\"><a href=\"#cb43-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb43-2\"><a href=\"#cb43-2\"></a></span>\n<span id=\"cb43-3\"><a href=\"#cb43-3\"></a><span class=\"kw\">func</span> evalIntegerInfixExpression(</span>\n<span id=\"cb43-4\"><a href=\"#cb43-4\"></a>    operator <span class=\"dt\">string</span>,</span>\n<span id=\"cb43-5\"><a href=\"#cb43-5\"></a>    left, right object.Object,</span>\n<span id=\"cb43-6\"><a href=\"#cb43-6\"></a>) object.Object {</span>\n<span id=\"cb43-7\"><a href=\"#cb43-7\"></a>    leftVal := left.(*object.Integer).Value</span>\n<span id=\"cb43-8\"><a href=\"#cb43-8\"></a>    rightVal := right.(*object.Integer).Value</span>\n<span id=\"cb43-9\"><a href=\"#cb43-9\"></a></span>\n<span id=\"cb43-10\"><a href=\"#cb43-10\"></a>    <span class=\"kw\">switch</span> operator {</span>\n<span id=\"cb43-11\"><a href=\"#cb43-11\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb43-12\"><a href=\"#cb43-12\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;&lt;&quot;</span>:</span>\n<span id=\"cb43-13\"><a href=\"#cb43-13\"></a>        <span class=\"kw\">return</span> nativeBoolToBooleanObject(leftVal &lt; rightVal)</span>\n<span id=\"cb43-14\"><a href=\"#cb43-14\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;&gt;&quot;</span>:</span>\n<span id=\"cb43-15\"><a href=\"#cb43-15\"></a>        <span class=\"kw\">return</span> nativeBoolToBooleanObject(leftVal &gt; rightVal)</span>\n<span id=\"cb43-16\"><a href=\"#cb43-16\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;==&quot;</span>:</span>\n<span id=\"cb43-17\"><a href=\"#cb43-17\"></a>        <span class=\"kw\">return</span> nativeBoolToBooleanObject(leftVal == rightVal)</span>\n<span id=\"cb43-18\"><a href=\"#cb43-18\"></a>    <span class=\"kw\">case</span> <span class=\"st\">&quot;!=&quot;</span>:</span>\n<span id=\"cb43-19\"><a href=\"#cb43-19\"></a>        <span class=\"kw\">return</span> nativeBoolToBooleanObject(leftVal != rightVal)</span>\n<span id=\"cb43-20\"><a href=\"#cb43-20\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb43-21\"><a href=\"#cb43-21\"></a>        <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb43-22\"><a href=\"#cb43-22\"></a>    }</span>\n<span id=\"cb43-23\"><a href=\"#cb43-23\"></a>}</span></code></pre></div>\n<p>The <code>nativeBoolToBooleanObject</code> function we already used for boolean literals now finds some reuse when we need to return either <code>TRUE</code> or <code>FALSE</code> based on the comparison between the unwrapped values.</p>\n<p>And that’s it! Well, at least for integers. We now fully support the eight infix operators when both operands are integers. What’s left in this section is adding support for boolean operands.</p>\n<p>Monkey only supports boolean operands for the equality operators <code>==</code> and <code>!=</code>. It doesn’t support adding, subtracting, dividing and multiplying booleans. Checking whether <code>true</code> is greater than <code>false</code> with <code>&lt;</code> or <code>&gt;</code> is also unsupported. That reduces our task to just adding support for two operators.</p>\n<p>The first thing we have to do, as you know, is to add tests. And, as before, we can extend an existing test function. In this case, we’ll use <code>TestEvalBooleanExpression</code> and add test cases for the <code>==</code> and <code>!=</code> operators:</p>\n<div class=\"sourceCode\" id=\"cb44\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb44-1\"><a href=\"#cb44-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb44-2\"><a href=\"#cb44-2\"></a></span>\n<span id=\"cb44-3\"><a href=\"#cb44-3\"></a><span class=\"kw\">func</span> TestEvalBooleanExpression(t *testing.T) {</span>\n<span id=\"cb44-4\"><a href=\"#cb44-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb44-5\"><a href=\"#cb44-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb44-6\"><a href=\"#cb44-6\"></a>        expected <span class=\"dt\">bool</span></span>\n<span id=\"cb44-7\"><a href=\"#cb44-7\"></a>    }{</span>\n<span id=\"cb44-8\"><a href=\"#cb44-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb44-9\"><a href=\"#cb44-9\"></a>        {<span class=\"st\">&quot;true == true&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb44-10\"><a href=\"#cb44-10\"></a>        {<span class=\"st\">&quot;false == false&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb44-11\"><a href=\"#cb44-11\"></a>        {<span class=\"st\">&quot;true == false&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb44-12\"><a href=\"#cb44-12\"></a>        {<span class=\"st\">&quot;true != false&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb44-13\"><a href=\"#cb44-13\"></a>        {<span class=\"st\">&quot;false != true&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb44-14\"><a href=\"#cb44-14\"></a>        {<span class=\"st\">&quot;(1 &lt; 2) == true&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb44-15\"><a href=\"#cb44-15\"></a>        {<span class=\"st\">&quot;(1 &lt; 2) == false&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb44-16\"><a href=\"#cb44-16\"></a>        {<span class=\"st\">&quot;(1 &gt; 2) == true&quot;</span>, <span class=\"ot\">false</span>},</span>\n<span id=\"cb44-17\"><a href=\"#cb44-17\"></a>        {<span class=\"st\">&quot;(1 &gt; 2) == false&quot;</span>, <span class=\"ot\">true</span>},</span>\n<span id=\"cb44-18\"><a href=\"#cb44-18\"></a>    }</span>\n<span id=\"cb44-19\"><a href=\"#cb44-19\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb44-20\"><a href=\"#cb44-20\"></a>}</span></code></pre></div>\n<p>Strictly speaking, only the first five cases are necessary to test the new and desired behaviour. But let’s throw in the other four too to check the comparison between generated booleans.</p>\n<p>So far, so good. Nothing surprising here. Just another set of of failing tests:</p>\n<div class=\"sourceCode\" id=\"cb45\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb45-1\"><a href=\"#cb45-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb45-2\"><a href=\"#cb45-2\"></a>--- FAIL: TestEvalBooleanExpression (0.00s)</span>\n<span id=\"cb45-3\"><a href=\"#cb45-3\"></a>  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</span>\n<span id=\"cb45-4\"><a href=\"#cb45-4\"></a>  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</span>\n<span id=\"cb45-5\"><a href=\"#cb45-5\"></a>  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</span>\n<span id=\"cb45-6\"><a href=\"#cb45-6\"></a>  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</span>\n<span id=\"cb45-7\"><a href=\"#cb45-7\"></a>  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</span>\n<span id=\"cb45-8\"><a href=\"#cb45-8\"></a>  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</span>\n<span id=\"cb45-9\"><a href=\"#cb45-9\"></a>  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</span>\n<span id=\"cb45-10\"><a href=\"#cb45-10\"></a>  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</span>\n<span id=\"cb45-11\"><a href=\"#cb45-11\"></a>  evaluator_test.go:121: object is not Boolean. got=*object.Null (&amp;{})</span>\n<span id=\"cb45-12\"><a href=\"#cb45-12\"></a>FAIL</span>\n<span id=\"cb45-13\"><a href=\"#cb45-13\"></a>FAIL    monkey/evaluator        0.007s</span></code></pre></div>\n<p>And here’s something neat to make those tests pass:</p>\n<div class=\"sourceCode\" id=\"cb46\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb46-1\"><a href=\"#cb46-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb46-2\"><a href=\"#cb46-2\"></a></span>\n<span id=\"cb46-3\"><a href=\"#cb46-3\"></a><span class=\"kw\">func</span> evalInfixExpression(</span>\n<span id=\"cb46-4\"><a href=\"#cb46-4\"></a>    operator <span class=\"dt\">string</span>,</span>\n<span id=\"cb46-5\"><a href=\"#cb46-5\"></a>    left, right object.Object,</span>\n<span id=\"cb46-6\"><a href=\"#cb46-6\"></a>) object.Object {</span>\n<span id=\"cb46-7\"><a href=\"#cb46-7\"></a>    <span class=\"kw\">switch</span> {</span>\n<span id=\"cb46-8\"><a href=\"#cb46-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb46-9\"><a href=\"#cb46-9\"></a>    <span class=\"kw\">case</span> operator == <span class=\"st\">&quot;==&quot;</span>:</span>\n<span id=\"cb46-10\"><a href=\"#cb46-10\"></a>        <span class=\"kw\">return</span> nativeBoolToBooleanObject(left == right)</span>\n<span id=\"cb46-11\"><a href=\"#cb46-11\"></a>    <span class=\"kw\">case</span> operator == <span class=\"st\">&quot;!=&quot;</span>:</span>\n<span id=\"cb46-12\"><a href=\"#cb46-12\"></a>        <span class=\"kw\">return</span> nativeBoolToBooleanObject(left != right)</span>\n<span id=\"cb46-13\"><a href=\"#cb46-13\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb46-14\"><a href=\"#cb46-14\"></a>        <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb46-15\"><a href=\"#cb46-15\"></a>    }</span>\n<span id=\"cb46-16\"><a href=\"#cb46-16\"></a>}</span></code></pre></div>\n<p>Yes, that’s right. We only add four lines to our existing <code>evalInfixExpression</code> and the tests pass. We’re using pointer comparison here to check for equality between booleans. That works because we’re always using pointers to our objects and in the case of booleans we only ever use two: <code>TRUE</code> and <code>FALSE</code>. So, if something has the same value as <code>TRUE</code> (the memory address that is) then it’s true. This also works with <code>NULL</code>.</p>\n<p>This doesn’t work for integers or other data types we might add later on. In the case of <code>*object.Integer</code> we’re always allocating new instances of <code>object.Integer</code> and thus use new pointers. We can’t compare these pointers to different instances, otherwise <code>5 == 5</code> would be false, which is not what we want. In this case we want to explicitly compare the values and not the objects that wrap these values.</p>\n<p>That’s why the check for integer operands has to be higher up in the switch statement and match earlier than these newly added <code>case</code> branches. As long as we’re taking care of other operand types before arriving at these pointer comparisons we’re fine and it works.</p>\n<p>In ten years, when Monkey is a famous programming language and the discussion about research-ignoring dilettantes designing programming languages is still ongoing and we’re both rich and famous, someone will ask on StackOverflow why integer comparison in Monkey is slower than boolean comparison. The answer will be written by either you or me and one of us will say that Monkey’s object system doesn’t allow pointer comparison for integer objects. It has to unwrap the value before a comparison can be made. Thus the comparison between booleans is faster. We’ll add a “Source: I wrote it.” to the bottom of our answer and earn an unheard of amount of karma.</p>\n<p>But I digress. To get back to topic, let me just say: Wow! We did it! I know, I’m pretty lavish with my praise and can spot a cause for celebration pretty easily, but if there ever was a time to pop the champagne, it’s now. Yes, we did it. Just look at what our interpreter can do now:</p>\n<div class=\"sourceCode\" id=\"cb47\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb47-1\"><a href=\"#cb47-1\"></a>$ go run main.go</span>\n<span id=\"cb47-2\"><a href=\"#cb47-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb47-3\"><a href=\"#cb47-3\"></a>Feel free to type in commands</span>\n<span id=\"cb47-4\"><a href=\"#cb47-4\"></a>&gt;&gt; 5 * 5 + 10</span>\n<span id=\"cb47-5\"><a href=\"#cb47-5\"></a>35</span>\n<span id=\"cb47-6\"><a href=\"#cb47-6\"></a>&gt;&gt; 3 + 4 * 5 == 3 * 1 + 4 * 5</span>\n<span id=\"cb47-7\"><a href=\"#cb47-7\"></a>true</span>\n<span id=\"cb47-8\"><a href=\"#cb47-8\"></a>&gt;&gt; 5 * 10 &gt; 40 + 5</span>\n<span id=\"cb47-9\"><a href=\"#cb47-9\"></a>true</span>\n<span id=\"cb47-10\"><a href=\"#cb47-10\"></a>&gt;&gt; (10 + 2) * 30 == 300 + 20 * 3</span>\n<span id=\"cb47-11\"><a href=\"#cb47-11\"></a>true</span>\n<span id=\"cb47-12\"><a href=\"#cb47-12\"></a>&gt;&gt; (5 &gt; 5 == true) != false</span>\n<span id=\"cb47-13\"><a href=\"#cb47-13\"></a>false</span>\n<span id=\"cb47-14\"><a href=\"#cb47-14\"></a>&gt;&gt; 500 / 2 != 250</span>\n<span id=\"cb47-15\"><a href=\"#cb47-15\"></a>false</span></code></pre></div>\n<p>So, now we have a fully functional calculator that’s ready to do more. Let’s give him more. Let’s make it look more like a programming language.</p>\n</section>\n</section>\n<section id=\"conditionals\" class=\"level2\" data-number=\"3.6\">\n<h2 data-number=\"3.6\">3.6 - Conditionals</h2>\n<p>You’ll be amazed how easy it is to add support for conditionals in our evaluator. The only hard thing about their implementation is deciding when to evaluate what. Because that’s the whole point of conditionals: only ever evaluate something based on a condition. Consider this:</p>\n<div class=\"sourceCode\" id=\"cb48\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb48-1\"><a href=\"#cb48-1\"></a><span class=\"cf\">if</span> (x <span class=\"op\">&gt;</span> <span class=\"dv\">10</span>) {</span>\n<span id=\"cb48-2\"><a href=\"#cb48-2\"></a>  puts(<span class=\"st\">&quot;everything okay!&quot;</span>)<span class=\"op\">;</span></span>\n<span id=\"cb48-3\"><a href=\"#cb48-3\"></a>} <span class=\"cf\">else</span> {</span>\n<span id=\"cb48-4\"><a href=\"#cb48-4\"></a>  puts(<span class=\"st\">&quot;x is too low!&quot;</span>)<span class=\"op\">;</span></span>\n<span id=\"cb48-5\"><a href=\"#cb48-5\"></a>  shutdownSystem()<span class=\"op\">;</span></span>\n<span id=\"cb48-6\"><a href=\"#cb48-6\"></a>}</span></code></pre></div>\n<p>When evaluating this if-else-expression the important thing is to only evaluate the correct branch. If the condition is met, we must never evaluate the else-branch, only the if-branch. And if it isn’t met we must only evaluate the else-branch.</p>\n<p>In other words: we can only evaluate the else-branch of this conditional if the condition <code>x &gt; 10</code> is not … well, when it’s not what exactly? Should we evaluate the consequence, the <code>\"everything okay!\"</code> branch, only when the condition expression generates a <code>true</code> or when it generates something “truthy”, something that’s not false or not null?</p>\n<p>And <em>that’s</em> the tough part about this, because that’s a design decision, a language design decision to be exact, with wide ranging consequences.</p>\n<p>In the case of Monkey, the consequence part of the conditional will be evaluated when the condition is “truthy”. And “truthy” means: it’s not null and it’s not false. It doesn’t necessarily need to be <code>true</code>.</p>\n<div class=\"sourceCode\" id=\"cb49\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb49-1\"><a href=\"#cb49-1\"></a><span class=\"kw\">let</span> x <span class=\"op\">=</span> <span class=\"dv\">10</span><span class=\"op\">;</span></span>\n<span id=\"cb49-2\"><a href=\"#cb49-2\"></a><span class=\"cf\">if</span> (x) {</span>\n<span id=\"cb49-3\"><a href=\"#cb49-3\"></a>  puts(<span class=\"st\">&quot;everything okay!&quot;</span>)<span class=\"op\">;</span></span>\n<span id=\"cb49-4\"><a href=\"#cb49-4\"></a>} <span class=\"cf\">else</span> {</span>\n<span id=\"cb49-5\"><a href=\"#cb49-5\"></a>  puts(<span class=\"st\">&quot;x is too high!&quot;</span>)<span class=\"op\">;</span></span>\n<span id=\"cb49-6\"><a href=\"#cb49-6\"></a>  shutdownSystem()<span class=\"op\">;</span></span>\n<span id=\"cb49-7\"><a href=\"#cb49-7\"></a>}</span></code></pre></div>\n<p>In this example <code>\"everything okay!\"</code> should be printed. Why? Because <code>x</code> is bound to <code>10</code>, evaluates to <code>10</code> and <code>10</code> is not null and not false. That’s how conditionals are supposed to work in Monkey.</p>\n<p>Now that we’ve talked about this, we can turn this specification into a set of test cases:</p>\n<div class=\"sourceCode\" id=\"cb50\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb50-1\"><a href=\"#cb50-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb50-2\"><a href=\"#cb50-2\"></a></span>\n<span id=\"cb50-3\"><a href=\"#cb50-3\"></a><span class=\"kw\">func</span> TestIfElseExpressions(t *testing.T) {</span>\n<span id=\"cb50-4\"><a href=\"#cb50-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb50-5\"><a href=\"#cb50-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb50-6\"><a href=\"#cb50-6\"></a>        expected <span class=\"kw\">interface</span>{}</span>\n<span id=\"cb50-7\"><a href=\"#cb50-7\"></a>    }{</span>\n<span id=\"cb50-8\"><a href=\"#cb50-8\"></a>        {<span class=\"st\">&quot;if (true) { 10 }&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb50-9\"><a href=\"#cb50-9\"></a>        {<span class=\"st\">&quot;if (false) { 10 }&quot;</span>, <span class=\"ot\">nil</span>},</span>\n<span id=\"cb50-10\"><a href=\"#cb50-10\"></a>        {<span class=\"st\">&quot;if (1) { 10 }&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb50-11\"><a href=\"#cb50-11\"></a>        {<span class=\"st\">&quot;if (1 &lt; 2) { 10 }&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb50-12\"><a href=\"#cb50-12\"></a>        {<span class=\"st\">&quot;if (1 &gt; 2) { 10 }&quot;</span>, <span class=\"ot\">nil</span>},</span>\n<span id=\"cb50-13\"><a href=\"#cb50-13\"></a>        {<span class=\"st\">&quot;if (1 &gt; 2) { 10 } else { 20 }&quot;</span>, <span class=\"dv\">20</span>},</span>\n<span id=\"cb50-14\"><a href=\"#cb50-14\"></a>        {<span class=\"st\">&quot;if (1 &lt; 2) { 10 } else { 20 }&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb50-15\"><a href=\"#cb50-15\"></a>    }</span>\n<span id=\"cb50-16\"><a href=\"#cb50-16\"></a></span>\n<span id=\"cb50-17\"><a href=\"#cb50-17\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb50-18\"><a href=\"#cb50-18\"></a>        evaluated := testEval(tt.input)</span>\n<span id=\"cb50-19\"><a href=\"#cb50-19\"></a>        integer, ok := tt.expected.(<span class=\"dt\">int</span>)</span>\n<span id=\"cb50-20\"><a href=\"#cb50-20\"></a>        <span class=\"kw\">if</span> ok {</span>\n<span id=\"cb50-21\"><a href=\"#cb50-21\"></a>            testIntegerObject(t, evaluated, <span class=\"dt\">int64</span>(integer))</span>\n<span id=\"cb50-22\"><a href=\"#cb50-22\"></a>        } <span class=\"kw\">else</span> {</span>\n<span id=\"cb50-23\"><a href=\"#cb50-23\"></a>            testNullObject(t, evaluated)</span>\n<span id=\"cb50-24\"><a href=\"#cb50-24\"></a>        }</span>\n<span id=\"cb50-25\"><a href=\"#cb50-25\"></a>    }</span>\n<span id=\"cb50-26\"><a href=\"#cb50-26\"></a>}</span>\n<span id=\"cb50-27\"><a href=\"#cb50-27\"></a></span>\n<span id=\"cb50-28\"><a href=\"#cb50-28\"></a><span class=\"kw\">func</span> testNullObject(t *testing.T, obj object.Object) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb50-29\"><a href=\"#cb50-29\"></a>    <span class=\"kw\">if</span> obj != NULL {</span>\n<span id=\"cb50-30\"><a href=\"#cb50-30\"></a>        t.Errorf(<span class=\"st\">&quot;object is not NULL. got=%T (%+v)&quot;</span>, obj, obj)</span>\n<span id=\"cb50-31\"><a href=\"#cb50-31\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb50-32\"><a href=\"#cb50-32\"></a>    }</span>\n<span id=\"cb50-33\"><a href=\"#cb50-33\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb50-34\"><a href=\"#cb50-34\"></a>}</span></code></pre></div>\n<p>This test function also specifies behaviour we haven’t talked about yet. When a conditional doesn’t evaluate to a value it’s supposed to return <code>NULL</code>, e.g.:</p>\n<div class=\"sourceCode\" id=\"cb51\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb51-1\"><a href=\"#cb51-1\"></a><span class=\"cf\">if</span> (<span class=\"kw\">false</span>) { <span class=\"dv\">10</span> }</span></code></pre></div>\n<p>The <code>else</code> is missing and thus the conditional should produce <code>NULL</code>.</p>\n<p>We have to do a little type assertion and conversion dance to allow <code>nil</code> in our <code>expected</code> field, granted, but the tests are readable and clearly show the desired and hereby specified behaviour. They also fail, because we don’t return any <code>*object.Integer</code>s or <code>NULL</code>:</p>\n<div class=\"sourceCode\" id=\"cb52\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb52-1\"><a href=\"#cb52-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb52-2\"><a href=\"#cb52-2\"></a>--- FAIL: TestIfElseExpressions (0.00s)</span>\n<span id=\"cb52-3\"><a href=\"#cb52-3\"></a>  evaluator_test.go:125: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb52-4\"><a href=\"#cb52-4\"></a>  evaluator_test.go:153: object is not NULL. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb52-5\"><a href=\"#cb52-5\"></a>  evaluator_test.go:125: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb52-6\"><a href=\"#cb52-6\"></a>  evaluator_test.go:125: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb52-7\"><a href=\"#cb52-7\"></a>  evaluator_test.go:153: object is not NULL. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb52-8\"><a href=\"#cb52-8\"></a>  evaluator_test.go:125: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb52-9\"><a href=\"#cb52-9\"></a>  evaluator_test.go:125: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb52-10\"><a href=\"#cb52-10\"></a>FAIL</span>\n<span id=\"cb52-11\"><a href=\"#cb52-11\"></a>FAIL    monkey/evaluator        0.007s</span></code></pre></div>\n<p>Earlier I told you that you’ll be amazed at how easy it is to implement support for conditionals. Didn’t believe me? Well, look at this small amount of code necessary to make the tests pass:</p>\n<div class=\"sourceCode\" id=\"cb53\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb53-1\"><a href=\"#cb53-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb53-2\"><a href=\"#cb53-2\"></a></span>\n<span id=\"cb53-3\"><a href=\"#cb53-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb53-4\"><a href=\"#cb53-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb53-5\"><a href=\"#cb53-5\"></a>    <span class=\"kw\">case</span> *ast.BlockStatement:</span>\n<span id=\"cb53-6\"><a href=\"#cb53-6\"></a>        <span class=\"kw\">return</span> evalStatements(node.Statements)</span>\n<span id=\"cb53-7\"><a href=\"#cb53-7\"></a></span>\n<span id=\"cb53-8\"><a href=\"#cb53-8\"></a>    <span class=\"kw\">case</span> *ast.IfExpression:</span>\n<span id=\"cb53-9\"><a href=\"#cb53-9\"></a>        <span class=\"kw\">return</span> evalIfExpression(node)</span>\n<span id=\"cb53-10\"><a href=\"#cb53-10\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb53-11\"><a href=\"#cb53-11\"></a>}</span>\n<span id=\"cb53-12\"><a href=\"#cb53-12\"></a></span>\n<span id=\"cb53-13\"><a href=\"#cb53-13\"></a><span class=\"kw\">func</span> evalIfExpression(ie *ast.IfExpression) object.Object {</span>\n<span id=\"cb53-14\"><a href=\"#cb53-14\"></a>    condition := Eval(ie.Condition)</span>\n<span id=\"cb53-15\"><a href=\"#cb53-15\"></a></span>\n<span id=\"cb53-16\"><a href=\"#cb53-16\"></a>    <span class=\"kw\">if</span> isTruthy(condition) {</span>\n<span id=\"cb53-17\"><a href=\"#cb53-17\"></a>        <span class=\"kw\">return</span> Eval(ie.Consequence)</span>\n<span id=\"cb53-18\"><a href=\"#cb53-18\"></a>    } <span class=\"kw\">else</span> <span class=\"kw\">if</span> ie.Alternative != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb53-19\"><a href=\"#cb53-19\"></a>        <span class=\"kw\">return</span> Eval(ie.Alternative)</span>\n<span id=\"cb53-20\"><a href=\"#cb53-20\"></a>    } <span class=\"kw\">else</span> {</span>\n<span id=\"cb53-21\"><a href=\"#cb53-21\"></a>        <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb53-22\"><a href=\"#cb53-22\"></a>    }</span>\n<span id=\"cb53-23\"><a href=\"#cb53-23\"></a>}</span>\n<span id=\"cb53-24\"><a href=\"#cb53-24\"></a></span>\n<span id=\"cb53-25\"><a href=\"#cb53-25\"></a><span class=\"kw\">func</span> isTruthy(obj object.Object) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb53-26\"><a href=\"#cb53-26\"></a>    <span class=\"kw\">switch</span> obj {</span>\n<span id=\"cb53-27\"><a href=\"#cb53-27\"></a>    <span class=\"kw\">case</span> NULL:</span>\n<span id=\"cb53-28\"><a href=\"#cb53-28\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb53-29\"><a href=\"#cb53-29\"></a>    <span class=\"kw\">case</span> TRUE:</span>\n<span id=\"cb53-30\"><a href=\"#cb53-30\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb53-31\"><a href=\"#cb53-31\"></a>    <span class=\"kw\">case</span> FALSE:</span>\n<span id=\"cb53-32\"><a href=\"#cb53-32\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb53-33\"><a href=\"#cb53-33\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb53-34\"><a href=\"#cb53-34\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">true</span></span>\n<span id=\"cb53-35\"><a href=\"#cb53-35\"></a>    }</span>\n<span id=\"cb53-36\"><a href=\"#cb53-36\"></a>}</span></code></pre></div>\n<p>As I said: the only hard thing is deciding what to evaluate. And that decision is encapsulated in <code>evalIfExpression</code> where the logic of the behaviour is pretty clear. <code>isTruthy</code> is equally expressive. Besides these two functions we also added the <code>case</code> branch for <code>*ast.BlockStatement</code> to our <code>Eval</code> switch statement, because the <code>.Consequence</code> and <code>.Alternative</code> of <code>*ast.IfExpression</code> are both block statements.</p>\n<p>We added two new and concise functions that show the semantics of the Monkey programming language in a clear way, reused another function we already had in place and with doing so added support for conditionals and made the tests pass. Our interpreter now supports if-else-expressions! We’re now leaving calculator territory and heading straight towards programming language land:</p>\n<div class=\"sourceCode\" id=\"cb54\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb54-1\"><a href=\"#cb54-1\"></a>$ go run main.go</span>\n<span id=\"cb54-2\"><a href=\"#cb54-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb54-3\"><a href=\"#cb54-3\"></a>Feel free to type in commands</span>\n<span id=\"cb54-4\"><a href=\"#cb54-4\"></a>&gt;&gt; if (5 * 5 + 10 &gt; 34) { 99 } else { 100 }</span>\n<span id=\"cb54-5\"><a href=\"#cb54-5\"></a>99</span>\n<span id=\"cb54-6\"><a href=\"#cb54-6\"></a>&gt;&gt; if ((1000 / 2) + 250 * 2 == 1000) { 9999 }</span>\n<span id=\"cb54-7\"><a href=\"#cb54-7\"></a>9999</span>\n<span id=\"cb54-8\"><a href=\"#cb54-8\"></a>&gt;&gt;</span></code></pre></div>\n</section>\n<section id=\"return-statements\" class=\"level2\" data-number=\"3.7\">\n<h2 data-number=\"3.7\">3.7 - Return Statements</h2>\n<p>Now here’s something that you won’t find on your standard calculator: return statements. Monkey has them, like a lot of other languages. They can be used in the bodies of functions but also as top-level statements in a Monkey program. But it doesn’t really matter where they’re used, because how they work doesn’t change: return statements stop the evaluation of a series of statements and leave behind the value their expression has evaluated to.</p>\n<p>Here is a top-level return statement in a Monkey program:</p>\n<div class=\"sourceCode\" id=\"cb55\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb55-1\"><a href=\"#cb55-1\"></a><span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb55-2\"><a href=\"#cb55-2\"></a><span class=\"cf\">return</span> <span class=\"dv\">10</span><span class=\"op\">;</span></span>\n<span id=\"cb55-3\"><a href=\"#cb55-3\"></a><span class=\"dv\">9</span> <span class=\"op\">*</span> <span class=\"dv\">9</span> <span class=\"op\">*</span> <span class=\"dv\">9</span><span class=\"op\">;</span></span></code></pre></div>\n<p>When evaluated this program should return <code>10</code>. If these statements were the body of a function, calling the function should evaluate to <code>10</code>. The important thing is that the last line, the <code>9 * 9 * 9</code> expression, is never going to be evaluated.</p>\n<p>There are a few different ways to implement return statements. In some host languages we could use gotos or exceptions. But in Go a “rescue” or “catch” are not easy to come by and we don’t really have the option of using gotos in a clean way. That’s why, in order to support return statements, we’ll be passing a “return value” through our evaluator. Whenever we encounter a <code>return</code> we’ll wrap the value it’s supposed to return inside an object, so we can keep track of it. And we need to keep track of it so we can later decide whether to stop evaluation or not.</p>\n<p>Here is the implementation of said object. Here is <code>object.ReturnValue</code>:</p>\n<div class=\"sourceCode\" id=\"cb56\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb56-1\"><a href=\"#cb56-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb56-2\"><a href=\"#cb56-2\"></a></span>\n<span id=\"cb56-3\"><a href=\"#cb56-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb56-4\"><a href=\"#cb56-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb56-5\"><a href=\"#cb56-5\"></a>    RETURN_VALUE_OBJ = <span class=\"st\">&quot;RETURN_VALUE&quot;</span></span>\n<span id=\"cb56-6\"><a href=\"#cb56-6\"></a>)</span>\n<span id=\"cb56-7\"><a href=\"#cb56-7\"></a></span>\n<span id=\"cb56-8\"><a href=\"#cb56-8\"></a><span class=\"kw\">type</span> ReturnValue <span class=\"kw\">struct</span> {</span>\n<span id=\"cb56-9\"><a href=\"#cb56-9\"></a>    Value Object</span>\n<span id=\"cb56-10\"><a href=\"#cb56-10\"></a>}</span>\n<span id=\"cb56-11\"><a href=\"#cb56-11\"></a></span>\n<span id=\"cb56-12\"><a href=\"#cb56-12\"></a><span class=\"kw\">func</span> (rv *ReturnValue) Type() ObjectType { <span class=\"kw\">return</span> RETURN_VALUE_OBJ }</span>\n<span id=\"cb56-13\"><a href=\"#cb56-13\"></a><span class=\"kw\">func</span> (rv *ReturnValue) Inspect() <span class=\"dt\">string</span>  { <span class=\"kw\">return</span> rv.Value.Inspect() }</span></code></pre></div>\n<p>Since this is just a wrapper around another object nothing here is surprising. What’s interesting about <code>object.ReturnValue</code> is when and how it’s used.</p>\n<p>Here are the tests that demonstrate what we expect of the return statement in the context of a Monkey program:</p>\n<div class=\"sourceCode\" id=\"cb57\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb57-1\"><a href=\"#cb57-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb57-2\"><a href=\"#cb57-2\"></a></span>\n<span id=\"cb57-3\"><a href=\"#cb57-3\"></a><span class=\"kw\">func</span> TestReturnStatements(t *testing.T) {</span>\n<span id=\"cb57-4\"><a href=\"#cb57-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb57-5\"><a href=\"#cb57-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb57-6\"><a href=\"#cb57-6\"></a>        expected <span class=\"dt\">int64</span></span>\n<span id=\"cb57-7\"><a href=\"#cb57-7\"></a>    }{</span>\n<span id=\"cb57-8\"><a href=\"#cb57-8\"></a>        {<span class=\"st\">&quot;return 10;&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb57-9\"><a href=\"#cb57-9\"></a>        {<span class=\"st\">&quot;return 10; 9;&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb57-10\"><a href=\"#cb57-10\"></a>        {<span class=\"st\">&quot;return 2 * 5; 9;&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb57-11\"><a href=\"#cb57-11\"></a>        {<span class=\"st\">&quot;9; return 2 * 5; 9;&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb57-12\"><a href=\"#cb57-12\"></a>    }</span>\n<span id=\"cb57-13\"><a href=\"#cb57-13\"></a></span>\n<span id=\"cb57-14\"><a href=\"#cb57-14\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb57-15\"><a href=\"#cb57-15\"></a>        evaluated := testEval(tt.input)</span>\n<span id=\"cb57-16\"><a href=\"#cb57-16\"></a>        testIntegerObject(t, evaluated, tt.expected)</span>\n<span id=\"cb57-17\"><a href=\"#cb57-17\"></a>    }</span>\n<span id=\"cb57-18\"><a href=\"#cb57-18\"></a>}</span></code></pre></div>\n<p>In order to get these tests to pass we have to change the <code>evalStatements</code> function we already have and add a <code>case</code> branch for <code>*ast.ReturnStatement</code> to <code>Eval</code>:</p>\n<div class=\"sourceCode\" id=\"cb58\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb58-1\"><a href=\"#cb58-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb58-2\"><a href=\"#cb58-2\"></a></span>\n<span id=\"cb58-3\"><a href=\"#cb58-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb58-4\"><a href=\"#cb58-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb58-5\"><a href=\"#cb58-5\"></a>    <span class=\"kw\">case</span> *ast.ReturnStatement:</span>\n<span id=\"cb58-6\"><a href=\"#cb58-6\"></a>        val := Eval(node.ReturnValue)</span>\n<span id=\"cb58-7\"><a href=\"#cb58-7\"></a>        <span class=\"kw\">return</span> &amp;object.ReturnValue{Value: val}</span>\n<span id=\"cb58-8\"><a href=\"#cb58-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb58-9\"><a href=\"#cb58-9\"></a>}</span>\n<span id=\"cb58-10\"><a href=\"#cb58-10\"></a></span>\n<span id=\"cb58-11\"><a href=\"#cb58-11\"></a><span class=\"kw\">func</span> evalStatements(stmts []ast.Statement) object.Object {</span>\n<span id=\"cb58-12\"><a href=\"#cb58-12\"></a>    <span class=\"kw\">var</span> result object.Object</span>\n<span id=\"cb58-13\"><a href=\"#cb58-13\"></a></span>\n<span id=\"cb58-14\"><a href=\"#cb58-14\"></a>    <span class=\"kw\">for</span> _, statement := <span class=\"kw\">range</span> stmts {</span>\n<span id=\"cb58-15\"><a href=\"#cb58-15\"></a>        result = Eval(statement)</span>\n<span id=\"cb58-16\"><a href=\"#cb58-16\"></a></span>\n<span id=\"cb58-17\"><a href=\"#cb58-17\"></a>        <span class=\"kw\">if</span> returnValue, ok := result.(*object.ReturnValue); ok {</span>\n<span id=\"cb58-18\"><a href=\"#cb58-18\"></a>            <span class=\"kw\">return</span> returnValue.Value</span>\n<span id=\"cb58-19\"><a href=\"#cb58-19\"></a>        }</span>\n<span id=\"cb58-20\"><a href=\"#cb58-20\"></a>    }</span>\n<span id=\"cb58-21\"><a href=\"#cb58-21\"></a></span>\n<span id=\"cb58-22\"><a href=\"#cb58-22\"></a>    <span class=\"kw\">return</span> result</span>\n<span id=\"cb58-23\"><a href=\"#cb58-23\"></a>}</span></code></pre></div>\n<p>The first part of this change is the evaluation of <code>*ast.ReturnValue</code>, where we evaluate the expression associated with the return statement. We then wrap the result of this call to <code>Eval</code> in our new <code>object.ReturnValue</code> so we can keep track of it.</p>\n<p>In <code>evalStatements</code>, which is used by <code>evalProgramStatements</code> and <code>evalBlockStatements</code> to evaluate a series of statements, we check if the last evaluation result is such an <code>object.ReturnValue</code> and if so, we stop the evaluation and return the unwrapped value. That’s important. We don’t return an <code>object.ReturnValue</code>, but only the value it’s wrapping, which is what the user expects to be returned.</p>\n<p>There’s a problem, though. Sometimes we have to keep track of <code>object.ReturnValue</code>s for longer and can’t unwrap their values on the first encounter. That’s the case with block statements. Take a look at this:</p>\n<div class=\"sourceCode\" id=\"cb59\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb59-1\"><a href=\"#cb59-1\"></a><span class=\"cf\">if</span> (<span class=\"dv\">10</span> <span class=\"op\">&gt;</span> <span class=\"dv\">1</span>) {</span>\n<span id=\"cb59-2\"><a href=\"#cb59-2\"></a>  <span class=\"cf\">if</span> (<span class=\"dv\">10</span> <span class=\"op\">&gt;</span> <span class=\"dv\">1</span>) {</span>\n<span id=\"cb59-3\"><a href=\"#cb59-3\"></a>    <span class=\"cf\">return</span> <span class=\"dv\">10</span><span class=\"op\">;</span></span>\n<span id=\"cb59-4\"><a href=\"#cb59-4\"></a>  }</span>\n<span id=\"cb59-5\"><a href=\"#cb59-5\"></a></span>\n<span id=\"cb59-6\"><a href=\"#cb59-6\"></a>  <span class=\"cf\">return</span> <span class=\"dv\">1</span><span class=\"op\">;</span></span>\n<span id=\"cb59-7\"><a href=\"#cb59-7\"></a>}</span></code></pre></div>\n<p>This program should return <code>10</code>. But with our current implementation, it doesn’t and returns <code>1</code>. A small test case confirms this:</p>\n<div class=\"sourceCode\" id=\"cb60\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb60-1\"><a href=\"#cb60-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb60-2\"><a href=\"#cb60-2\"></a></span>\n<span id=\"cb60-3\"><a href=\"#cb60-3\"></a><span class=\"kw\">func</span> TestReturnStatements(t *testing.T) {</span>\n<span id=\"cb60-4\"><a href=\"#cb60-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb60-5\"><a href=\"#cb60-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb60-6\"><a href=\"#cb60-6\"></a>        expected <span class=\"dt\">int64</span></span>\n<span id=\"cb60-7\"><a href=\"#cb60-7\"></a>    }{</span>\n<span id=\"cb60-8\"><a href=\"#cb60-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb60-9\"><a href=\"#cb60-9\"></a>        {</span>\n<span id=\"cb60-10\"><a href=\"#cb60-10\"></a>            <span class=\"st\">`</span></span>\n<span id=\"cb60-11\"><a href=\"#cb60-11\"></a><span class=\"st\">if (10 &gt; 1) {</span></span>\n<span id=\"cb60-12\"><a href=\"#cb60-12\"></a><span class=\"st\">  if (10 &gt; 1) {</span></span>\n<span id=\"cb60-13\"><a href=\"#cb60-13\"></a><span class=\"st\">    return 10;</span></span>\n<span id=\"cb60-14\"><a href=\"#cb60-14\"></a><span class=\"st\">  }</span></span>\n<span id=\"cb60-15\"><a href=\"#cb60-15\"></a></span>\n<span id=\"cb60-16\"><a href=\"#cb60-16\"></a><span class=\"st\">  return 1;</span></span>\n<span id=\"cb60-17\"><a href=\"#cb60-17\"></a><span class=\"st\">}</span></span>\n<span id=\"cb60-18\"><a href=\"#cb60-18\"></a><span class=\"st\">`</span>,</span>\n<span id=\"cb60-19\"><a href=\"#cb60-19\"></a>            <span class=\"dv\">10</span>,</span>\n<span id=\"cb60-20\"><a href=\"#cb60-20\"></a>        },</span>\n<span id=\"cb60-21\"><a href=\"#cb60-21\"></a>    }</span>\n<span id=\"cb60-22\"><a href=\"#cb60-22\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb60-23\"><a href=\"#cb60-23\"></a>}</span></code></pre></div>\n<p>This test case fails with the expected message:</p>\n<div class=\"sourceCode\" id=\"cb61\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb61-1\"><a href=\"#cb61-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb61-2\"><a href=\"#cb61-2\"></a>--- FAIL: TestReturnStatements (0.00s)</span>\n<span id=\"cb61-3\"><a href=\"#cb61-3\"></a>  evaluator_test.go:159: object has wrong value. got=1, want=10</span>\n<span id=\"cb61-4\"><a href=\"#cb61-4\"></a>FAIL</span>\n<span id=\"cb61-5\"><a href=\"#cb61-5\"></a>FAIL    monkey/evaluator        0.007s</span></code></pre></div>\n<p>I bet that you’ve already figured out what the problem with our current implementation is. But if you want me to spell it out, here it comes: if we have nested block statements (which is totally legit in a Monkey program!) we can’t unwrap the value of <code>object.ReturnValue</code> on first sight, because we need to further keep track of it so we can stop the execution in the outermost block statement.</p>\n<p>Non-nested block statements work fine with our current implementation. But to get nested ones to work, the first thing we have to do is to accept that we can’t reuse our <code>evalStatements</code> function for evaluating block statements. That’s why we’re going to rename it to <code>evalProgram</code> and make it less generic.</p>\n<div class=\"sourceCode\" id=\"cb62\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb62-1\"><a href=\"#cb62-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb62-2\"><a href=\"#cb62-2\"></a></span>\n<span id=\"cb62-3\"><a href=\"#cb62-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb62-4\"><a href=\"#cb62-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb62-5\"><a href=\"#cb62-5\"></a>    <span class=\"kw\">case</span> *ast.Program:</span>\n<span id=\"cb62-6\"><a href=\"#cb62-6\"></a>        <span class=\"kw\">return</span> evalProgram(node)</span>\n<span id=\"cb62-7\"><a href=\"#cb62-7\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb62-8\"><a href=\"#cb62-8\"></a>}</span>\n<span id=\"cb62-9\"><a href=\"#cb62-9\"></a></span>\n<span id=\"cb62-10\"><a href=\"#cb62-10\"></a><span class=\"kw\">func</span> evalProgram(program *ast.Program) object.Object {</span>\n<span id=\"cb62-11\"><a href=\"#cb62-11\"></a>    <span class=\"kw\">var</span> result object.Object</span>\n<span id=\"cb62-12\"><a href=\"#cb62-12\"></a></span>\n<span id=\"cb62-13\"><a href=\"#cb62-13\"></a>    <span class=\"kw\">for</span> _, statement := <span class=\"kw\">range</span> program.Statements {</span>\n<span id=\"cb62-14\"><a href=\"#cb62-14\"></a>        result = Eval(statement)</span>\n<span id=\"cb62-15\"><a href=\"#cb62-15\"></a></span>\n<span id=\"cb62-16\"><a href=\"#cb62-16\"></a>        <span class=\"kw\">if</span> returnValue, ok := result.(*object.ReturnValue); ok {</span>\n<span id=\"cb62-17\"><a href=\"#cb62-17\"></a>            <span class=\"kw\">return</span> returnValue.Value</span>\n<span id=\"cb62-18\"><a href=\"#cb62-18\"></a>        }</span>\n<span id=\"cb62-19\"><a href=\"#cb62-19\"></a>    }</span>\n<span id=\"cb62-20\"><a href=\"#cb62-20\"></a></span>\n<span id=\"cb62-21\"><a href=\"#cb62-21\"></a>    <span class=\"kw\">return</span> result</span>\n<span id=\"cb62-22\"><a href=\"#cb62-22\"></a>}</span></code></pre></div>\n<p>For evaluating an <code>*ast.BlockStatement</code> we introduce a new function called <code>evalBlockStatement</code>:</p>\n<div class=\"sourceCode\" id=\"cb63\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb63-1\"><a href=\"#cb63-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb63-2\"><a href=\"#cb63-2\"></a></span>\n<span id=\"cb63-3\"><a href=\"#cb63-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb63-4\"><a href=\"#cb63-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb63-5\"><a href=\"#cb63-5\"></a>    <span class=\"kw\">case</span> *ast.BlockStatement:</span>\n<span id=\"cb63-6\"><a href=\"#cb63-6\"></a>        <span class=\"kw\">return</span> evalBlockStatement(node)</span>\n<span id=\"cb63-7\"><a href=\"#cb63-7\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb63-8\"><a href=\"#cb63-8\"></a>}</span>\n<span id=\"cb63-9\"><a href=\"#cb63-9\"></a></span>\n<span id=\"cb63-10\"><a href=\"#cb63-10\"></a><span class=\"kw\">func</span> evalBlockStatement(block *ast.BlockStatement) object.Object {</span>\n<span id=\"cb63-11\"><a href=\"#cb63-11\"></a>    <span class=\"kw\">var</span> result object.Object</span>\n<span id=\"cb63-12\"><a href=\"#cb63-12\"></a></span>\n<span id=\"cb63-13\"><a href=\"#cb63-13\"></a>    <span class=\"kw\">for</span> _, statement := <span class=\"kw\">range</span> block.Statements {</span>\n<span id=\"cb63-14\"><a href=\"#cb63-14\"></a>        result = Eval(statement)</span>\n<span id=\"cb63-15\"><a href=\"#cb63-15\"></a></span>\n<span id=\"cb63-16\"><a href=\"#cb63-16\"></a>        <span class=\"kw\">if</span> result != <span class=\"ot\">nil</span> &amp;&amp; result.Type() == object.RETURN_VALUE_OBJ {</span>\n<span id=\"cb63-17\"><a href=\"#cb63-17\"></a>            <span class=\"kw\">return</span> result</span>\n<span id=\"cb63-18\"><a href=\"#cb63-18\"></a>        }</span>\n<span id=\"cb63-19\"><a href=\"#cb63-19\"></a>    }</span>\n<span id=\"cb63-20\"><a href=\"#cb63-20\"></a></span>\n<span id=\"cb63-21\"><a href=\"#cb63-21\"></a>    <span class=\"kw\">return</span> result</span>\n<span id=\"cb63-22\"><a href=\"#cb63-22\"></a>}</span></code></pre></div>\n<p>Here we explicitly don’t unwrap the return value and only check the <code>Type()</code> of each evaluation result. If it’s <code>object.RETURN_VALUE_OBJ</code> we simply return the <code>*object.ReturnValue</code>, without unwrapping its <code>.Value</code>, so it stops execution in a possible outer block statement and bubbles up to <code>evalProgram</code>, where it finally get’s unwrapped. (That last part will change when we implement the evaluation of function calls.)</p>\n<p>And with that the tests pass:</p>\n<div class=\"sourceCode\" id=\"cb64\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb64-1\"><a href=\"#cb64-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb64-2\"><a href=\"#cb64-2\"></a>ok      monkey/evaluator        0.007s</span></code></pre></div>\n<p>Return statements are implemented. Now we’re definitely not building a calculator anymore. And since <code>evalProgram</code> and <code>evalBlockStatement</code> are still so fresh in our mind let’s keep working on them.</p>\n</section>\n<section id=\"abort-abort-theres-been-a-mistake-or-error-handling\" class=\"level2\" data-number=\"3.8\">\n<h2 data-number=\"3.8\">3.8 - Abort! Abort! There’s been a mistake!, or: Error Handling</h2>\n<p>Remember all the <code>NULL</code>s we were returning earlier and I said that you shouldn’t worry and we’ll come back to them? Here we are. It’s time to implement some real error handling in Monkey before it’s too late and we’d have to backpedal too much. Granted, we have to backpedal a little bit and correct previous code, but not much. We didn’t implement error handling as the first thing in our interpreter, because, and to be completely honest, I thought implementing expressions first is a lot more fun than error handling. But we’re now at a point where we need to add it, otherwise debugging and using our interpreter becomes too cumbersome in the near future.</p>\n<p>First of all, let’s define what I mean with “real error handling”. It is <em>not</em> user-defined exceptions. It’s internal error handling. Errors for wrong operators, unsupported operations, and other user or internal errors that may arise during execution.</p>\n<p>As for the implementation of such errors: this will probably sound weird, but the error handling is implemented in nearly the same way as handling return statements is. The reason for this similarity is easy to find: errors and return statements both stop the evaluation of a series of statements.</p>\n<p>The first thing we need is an error object:</p>\n<div class=\"sourceCode\" id=\"cb65\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb65-1\"><a href=\"#cb65-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb65-2\"><a href=\"#cb65-2\"></a></span>\n<span id=\"cb65-3\"><a href=\"#cb65-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb65-4\"><a href=\"#cb65-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb65-5\"><a href=\"#cb65-5\"></a>    ERROR_OBJ = <span class=\"st\">&quot;ERROR&quot;</span></span>\n<span id=\"cb65-6\"><a href=\"#cb65-6\"></a>)</span>\n<span id=\"cb65-7\"><a href=\"#cb65-7\"></a></span>\n<span id=\"cb65-8\"><a href=\"#cb65-8\"></a><span class=\"kw\">type</span> Error <span class=\"kw\">struct</span> {</span>\n<span id=\"cb65-9\"><a href=\"#cb65-9\"></a>    Message <span class=\"dt\">string</span></span>\n<span id=\"cb65-10\"><a href=\"#cb65-10\"></a>}</span>\n<span id=\"cb65-11\"><a href=\"#cb65-11\"></a></span>\n<span id=\"cb65-12\"><a href=\"#cb65-12\"></a><span class=\"kw\">func</span> (e *Error) Type() ObjectType { <span class=\"kw\">return</span> ERROR_OBJ }</span>\n<span id=\"cb65-13\"><a href=\"#cb65-13\"></a><span class=\"kw\">func</span> (e *Error) Inspect() <span class=\"dt\">string</span>  { <span class=\"kw\">return</span> <span class=\"st\">&quot;ERROR: &quot;</span> + e.Message }</span></code></pre></div>\n<p>As you can see, <code>object.Error</code> is really, really simple. It only wraps a string that serves as error message. In a production-ready interpreter we’d want to attach a stack trace to such error objects, add the line and column numbers of its origin and provide more than just a message. That’s not so hard to do, provided that line and column numbers are attached to the tokens by the lexer. Since our lexer doesn’t do that, to keep things simple, we only use an error message, which still serves us a great deal by giving us some feedback and stopping execution.</p>\n<p>We will add support for errors in a few places now. Later, with increased capability of our interpreter, we’ll add more where appropriate. For now, this test function shows what we expect the error handling to do:</p>\n<div class=\"sourceCode\" id=\"cb66\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb66-1\"><a href=\"#cb66-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb66-2\"><a href=\"#cb66-2\"></a></span>\n<span id=\"cb66-3\"><a href=\"#cb66-3\"></a><span class=\"kw\">func</span> TestErrorHandling(t *testing.T) {</span>\n<span id=\"cb66-4\"><a href=\"#cb66-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb66-5\"><a href=\"#cb66-5\"></a>        input           <span class=\"dt\">string</span></span>\n<span id=\"cb66-6\"><a href=\"#cb66-6\"></a>        expectedMessage <span class=\"dt\">string</span></span>\n<span id=\"cb66-7\"><a href=\"#cb66-7\"></a>    }{</span>\n<span id=\"cb66-8\"><a href=\"#cb66-8\"></a>        {</span>\n<span id=\"cb66-9\"><a href=\"#cb66-9\"></a>            <span class=\"st\">&quot;5 + true;&quot;</span>,</span>\n<span id=\"cb66-10\"><a href=\"#cb66-10\"></a>            <span class=\"st\">&quot;type mismatch: INTEGER + BOOLEAN&quot;</span>,</span>\n<span id=\"cb66-11\"><a href=\"#cb66-11\"></a>        },</span>\n<span id=\"cb66-12\"><a href=\"#cb66-12\"></a>        {</span>\n<span id=\"cb66-13\"><a href=\"#cb66-13\"></a>            <span class=\"st\">&quot;5 + true; 5;&quot;</span>,</span>\n<span id=\"cb66-14\"><a href=\"#cb66-14\"></a>            <span class=\"st\">&quot;type mismatch: INTEGER + BOOLEAN&quot;</span>,</span>\n<span id=\"cb66-15\"><a href=\"#cb66-15\"></a>        },</span>\n<span id=\"cb66-16\"><a href=\"#cb66-16\"></a>        {</span>\n<span id=\"cb66-17\"><a href=\"#cb66-17\"></a>            <span class=\"st\">&quot;-true&quot;</span>,</span>\n<span id=\"cb66-18\"><a href=\"#cb66-18\"></a>            <span class=\"st\">&quot;unknown operator: -BOOLEAN&quot;</span>,</span>\n<span id=\"cb66-19\"><a href=\"#cb66-19\"></a>        },</span>\n<span id=\"cb66-20\"><a href=\"#cb66-20\"></a>        {</span>\n<span id=\"cb66-21\"><a href=\"#cb66-21\"></a>            <span class=\"st\">&quot;true + false;&quot;</span>,</span>\n<span id=\"cb66-22\"><a href=\"#cb66-22\"></a>            <span class=\"st\">&quot;unknown operator: BOOLEAN + BOOLEAN&quot;</span>,</span>\n<span id=\"cb66-23\"><a href=\"#cb66-23\"></a>        },</span>\n<span id=\"cb66-24\"><a href=\"#cb66-24\"></a>        {</span>\n<span id=\"cb66-25\"><a href=\"#cb66-25\"></a>            <span class=\"st\">&quot;5; true + false; 5&quot;</span>,</span>\n<span id=\"cb66-26\"><a href=\"#cb66-26\"></a>            <span class=\"st\">&quot;unknown operator: BOOLEAN + BOOLEAN&quot;</span>,</span>\n<span id=\"cb66-27\"><a href=\"#cb66-27\"></a>        },</span>\n<span id=\"cb66-28\"><a href=\"#cb66-28\"></a>        {</span>\n<span id=\"cb66-29\"><a href=\"#cb66-29\"></a>            <span class=\"st\">&quot;if (10 &gt; 1) { true + false; }&quot;</span>,</span>\n<span id=\"cb66-30\"><a href=\"#cb66-30\"></a>            <span class=\"st\">&quot;unknown operator: BOOLEAN + BOOLEAN&quot;</span>,</span>\n<span id=\"cb66-31\"><a href=\"#cb66-31\"></a>        },</span>\n<span id=\"cb66-32\"><a href=\"#cb66-32\"></a>        {</span>\n<span id=\"cb66-33\"><a href=\"#cb66-33\"></a>            <span class=\"st\">`</span></span>\n<span id=\"cb66-34\"><a href=\"#cb66-34\"></a><span class=\"st\">if (10 &gt; 1) {</span></span>\n<span id=\"cb66-35\"><a href=\"#cb66-35\"></a><span class=\"st\">  if (10 &gt; 1) {</span></span>\n<span id=\"cb66-36\"><a href=\"#cb66-36\"></a><span class=\"st\">    return true + false;</span></span>\n<span id=\"cb66-37\"><a href=\"#cb66-37\"></a><span class=\"st\">  }</span></span>\n<span id=\"cb66-38\"><a href=\"#cb66-38\"></a></span>\n<span id=\"cb66-39\"><a href=\"#cb66-39\"></a><span class=\"st\">  return 1;</span></span>\n<span id=\"cb66-40\"><a href=\"#cb66-40\"></a><span class=\"st\">}</span></span>\n<span id=\"cb66-41\"><a href=\"#cb66-41\"></a><span class=\"st\">`</span>,</span>\n<span id=\"cb66-42\"><a href=\"#cb66-42\"></a>            <span class=\"st\">&quot;unknown operator: BOOLEAN + BOOLEAN&quot;</span>,</span>\n<span id=\"cb66-43\"><a href=\"#cb66-43\"></a>        },</span>\n<span id=\"cb66-44\"><a href=\"#cb66-44\"></a>    }</span>\n<span id=\"cb66-45\"><a href=\"#cb66-45\"></a></span>\n<span id=\"cb66-46\"><a href=\"#cb66-46\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb66-47\"><a href=\"#cb66-47\"></a>        evaluated := testEval(tt.input)</span>\n<span id=\"cb66-48\"><a href=\"#cb66-48\"></a></span>\n<span id=\"cb66-49\"><a href=\"#cb66-49\"></a>        errObj, ok := evaluated.(*object.Error)</span>\n<span id=\"cb66-50\"><a href=\"#cb66-50\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb66-51\"><a href=\"#cb66-51\"></a>            t.Errorf(<span class=\"st\">&quot;no error object returned. got=%T(%+v)&quot;</span>,</span>\n<span id=\"cb66-52\"><a href=\"#cb66-52\"></a>                evaluated, evaluated)</span>\n<span id=\"cb66-53\"><a href=\"#cb66-53\"></a>            <span class=\"kw\">continue</span></span>\n<span id=\"cb66-54\"><a href=\"#cb66-54\"></a>        }</span>\n<span id=\"cb66-55\"><a href=\"#cb66-55\"></a></span>\n<span id=\"cb66-56\"><a href=\"#cb66-56\"></a>        <span class=\"kw\">if</span> errObj.Message != tt.expectedMessage {</span>\n<span id=\"cb66-57\"><a href=\"#cb66-57\"></a>            t.Errorf(<span class=\"st\">&quot;wrong error message. expected=%q, got=%q&quot;</span>,</span>\n<span id=\"cb66-58\"><a href=\"#cb66-58\"></a>                tt.expectedMessage, errObj.Message)</span>\n<span id=\"cb66-59\"><a href=\"#cb66-59\"></a>        }</span>\n<span id=\"cb66-60\"><a href=\"#cb66-60\"></a>    }</span>\n<span id=\"cb66-61\"><a href=\"#cb66-61\"></a>}</span></code></pre></div>\n<p>When we run the tests we meet our old friend <code>NULL</code> again:</p>\n<div class=\"sourceCode\" id=\"cb67\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb67-1\"><a href=\"#cb67-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb67-2\"><a href=\"#cb67-2\"></a>--- FAIL: TestErrorHandling (0.00s)</span>\n<span id=\"cb67-3\"><a href=\"#cb67-3\"></a>  evaluator_test.go:193: no error object returned. got=*object.Null(&amp;{})</span>\n<span id=\"cb67-4\"><a href=\"#cb67-4\"></a>  evaluator_test.go:193: no error object returned.\\</span>\n<span id=\"cb67-5\"><a href=\"#cb67-5\"></a>    got=*object.Integer(&amp;{Value:5})</span>\n<span id=\"cb67-6\"><a href=\"#cb67-6\"></a>  evaluator_test.go:193: no error object returned. got=*object.Null(&amp;{})</span>\n<span id=\"cb67-7\"><a href=\"#cb67-7\"></a>  evaluator_test.go:193: no error object returned. got=*object.Null(&amp;{})</span>\n<span id=\"cb67-8\"><a href=\"#cb67-8\"></a>  evaluator_test.go:193: no error object returned.\\</span>\n<span id=\"cb67-9\"><a href=\"#cb67-9\"></a>    got=*object.Integer(&amp;{Value:5})</span>\n<span id=\"cb67-10\"><a href=\"#cb67-10\"></a>  evaluator_test.go:193: no error object returned. got=*object.Null(&amp;{})</span>\n<span id=\"cb67-11\"><a href=\"#cb67-11\"></a>  evaluator_test.go:193: no error object returned.\\</span>\n<span id=\"cb67-12\"><a href=\"#cb67-12\"></a>    got=*object.Integer(&amp;{Value:10})</span>\n<span id=\"cb67-13\"><a href=\"#cb67-13\"></a>FAIL</span>\n<span id=\"cb67-14\"><a href=\"#cb67-14\"></a>FAIL    monkey/evaluator        0.007s</span></code></pre></div>\n<p>But there are also unexpected <code>*object.Integer</code>s. That’s because these test cases actually assert two things: that errors are created for unsupported operations and that errors prevent any further evaluation. When the test fails because of an <code>*object.Integer</code> being returned, the evaluation didn’t stop correctly.</p>\n<p>Creating errors and passing them around in <code>Eval</code> is easy. We just need a helper function to help us create new <code>*object.Error</code>s and return them when we think we should:</p>\n<div class=\"sourceCode\" id=\"cb68\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb68-1\"><a href=\"#cb68-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb68-2\"><a href=\"#cb68-2\"></a></span>\n<span id=\"cb68-3\"><a href=\"#cb68-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb68-4\"><a href=\"#cb68-4\"></a>    <span class=\"co\">// [...]</span></span>\n<span id=\"cb68-5\"><a href=\"#cb68-5\"></a>    <span class=\"st\">&quot;fmt&quot;</span></span>\n<span id=\"cb68-6\"><a href=\"#cb68-6\"></a>)</span>\n<span id=\"cb68-7\"><a href=\"#cb68-7\"></a></span>\n<span id=\"cb68-8\"><a href=\"#cb68-8\"></a><span class=\"kw\">func</span> newError(format <span class=\"dt\">string</span>, a ...<span class=\"kw\">interface</span>{}) *object.Error {</span>\n<span id=\"cb68-9\"><a href=\"#cb68-9\"></a>    <span class=\"kw\">return</span> &amp;object.Error{Message: fmt.Sprintf(format, a...)}</span>\n<span id=\"cb68-10\"><a href=\"#cb68-10\"></a>}</span></code></pre></div>\n<p>This <code>newError</code> function finds its use in every place where we didn’t know what to do before and returned <code>NULL</code> instead:</p>\n<div class=\"sourceCode\" id=\"cb69\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb69-1\"><a href=\"#cb69-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb69-2\"><a href=\"#cb69-2\"></a></span>\n<span id=\"cb69-3\"><a href=\"#cb69-3\"></a><span class=\"kw\">func</span> evalPrefixExpression(operator <span class=\"dt\">string</span>, right object.Object) object.Object {</span>\n<span id=\"cb69-4\"><a href=\"#cb69-4\"></a>    <span class=\"kw\">switch</span> operator {</span>\n<span id=\"cb69-5\"><a href=\"#cb69-5\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb69-6\"><a href=\"#cb69-6\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb69-7\"><a href=\"#cb69-7\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;unknown operator: %s%s&quot;</span>, operator, right.Type())</span>\n<span id=\"cb69-8\"><a href=\"#cb69-8\"></a>    }</span>\n<span id=\"cb69-9\"><a href=\"#cb69-9\"></a>}</span>\n<span id=\"cb69-10\"><a href=\"#cb69-10\"></a></span>\n<span id=\"cb69-11\"><a href=\"#cb69-11\"></a><span class=\"kw\">func</span> evalInfixExpression(</span>\n<span id=\"cb69-12\"><a href=\"#cb69-12\"></a>    operator <span class=\"dt\">string</span>,</span>\n<span id=\"cb69-13\"><a href=\"#cb69-13\"></a>    left, right object.Object,</span>\n<span id=\"cb69-14\"><a href=\"#cb69-14\"></a>) object.Object {</span>\n<span id=\"cb69-15\"><a href=\"#cb69-15\"></a>    <span class=\"kw\">switch</span> {</span>\n<span id=\"cb69-16\"><a href=\"#cb69-16\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb69-17\"><a href=\"#cb69-17\"></a>    <span class=\"kw\">case</span> left.Type() != right.Type():</span>\n<span id=\"cb69-18\"><a href=\"#cb69-18\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;type mismatch: %s %s %s&quot;</span>,</span>\n<span id=\"cb69-19\"><a href=\"#cb69-19\"></a>            left.Type(), operator, right.Type())</span>\n<span id=\"cb69-20\"><a href=\"#cb69-20\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb69-21\"><a href=\"#cb69-21\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;unknown operator: %s %s %s&quot;</span>,</span>\n<span id=\"cb69-22\"><a href=\"#cb69-22\"></a>            left.Type(), operator, right.Type())</span>\n<span id=\"cb69-23\"><a href=\"#cb69-23\"></a>    }</span>\n<span id=\"cb69-24\"><a href=\"#cb69-24\"></a>}</span>\n<span id=\"cb69-25\"><a href=\"#cb69-25\"></a></span>\n<span id=\"cb69-26\"><a href=\"#cb69-26\"></a><span class=\"kw\">func</span> evalMinusPrefixOperatorExpression(right object.Object) object.Object {</span>\n<span id=\"cb69-27\"><a href=\"#cb69-27\"></a>    <span class=\"kw\">if</span> right.Type() != object.INTEGER_OBJ {</span>\n<span id=\"cb69-28\"><a href=\"#cb69-28\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;unknown operator: -%s&quot;</span>, right.Type())</span>\n<span id=\"cb69-29\"><a href=\"#cb69-29\"></a>    }</span>\n<span id=\"cb69-30\"><a href=\"#cb69-30\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb69-31\"><a href=\"#cb69-31\"></a>}</span>\n<span id=\"cb69-32\"><a href=\"#cb69-32\"></a></span>\n<span id=\"cb69-33\"><a href=\"#cb69-33\"></a><span class=\"kw\">func</span> evalIntegerInfixExpression(</span>\n<span id=\"cb69-34\"><a href=\"#cb69-34\"></a>    operator <span class=\"dt\">string</span>,</span>\n<span id=\"cb69-35\"><a href=\"#cb69-35\"></a>    left, right object.Object,</span>\n<span id=\"cb69-36\"><a href=\"#cb69-36\"></a>) object.Object {</span>\n<span id=\"cb69-37\"><a href=\"#cb69-37\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb69-38\"><a href=\"#cb69-38\"></a>    <span class=\"kw\">switch</span> operator {</span>\n<span id=\"cb69-39\"><a href=\"#cb69-39\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb69-40\"><a href=\"#cb69-40\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb69-41\"><a href=\"#cb69-41\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;unknown operator: %s %s %s&quot;</span>,</span>\n<span id=\"cb69-42\"><a href=\"#cb69-42\"></a>            left.Type(), operator, right.Type())</span>\n<span id=\"cb69-43\"><a href=\"#cb69-43\"></a>    }</span>\n<span id=\"cb69-44\"><a href=\"#cb69-44\"></a>}</span></code></pre></div>\n<p>With these changes made the number of failing test cases has been reduced to just two:</p>\n<div class=\"sourceCode\" id=\"cb70\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb70-1\"><a href=\"#cb70-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb70-2\"><a href=\"#cb70-2\"></a>--- FAIL: TestErrorHandling (0.00s)</span>\n<span id=\"cb70-3\"><a href=\"#cb70-3\"></a>  evaluator_test.go:193: no error object returned.\\</span>\n<span id=\"cb70-4\"><a href=\"#cb70-4\"></a>    got=*object.Integer(&amp;{Value:5})</span>\n<span id=\"cb70-5\"><a href=\"#cb70-5\"></a>  evaluator_test.go:193: no error object returned.\\</span>\n<span id=\"cb70-6\"><a href=\"#cb70-6\"></a>    got=*object.Integer(&amp;{Value:5})</span>\n<span id=\"cb70-7\"><a href=\"#cb70-7\"></a>FAIL</span>\n<span id=\"cb70-8\"><a href=\"#cb70-8\"></a>FAIL    monkey/evaluator        0.007s</span></code></pre></div>\n<p>That output tells us that creating errors poses no problem but stopping the evaluation still does. We already know where to look though, don’t we? Yes, that’s right: <code>evalProgram</code> and <code>evalBlockStatement</code>. Here are both functions in their entirety, with newly added support for error handling:</p>\n<div class=\"sourceCode\" id=\"cb71\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb71-1\"><a href=\"#cb71-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb71-2\"><a href=\"#cb71-2\"></a></span>\n<span id=\"cb71-3\"><a href=\"#cb71-3\"></a><span class=\"kw\">func</span> evalProgram(program *ast.Program) object.Object {</span>\n<span id=\"cb71-4\"><a href=\"#cb71-4\"></a>    <span class=\"kw\">var</span> result object.Object</span>\n<span id=\"cb71-5\"><a href=\"#cb71-5\"></a></span>\n<span id=\"cb71-6\"><a href=\"#cb71-6\"></a>    <span class=\"kw\">for</span> _, statement := <span class=\"kw\">range</span> program.Statements {</span>\n<span id=\"cb71-7\"><a href=\"#cb71-7\"></a>        result = Eval(statement)</span>\n<span id=\"cb71-8\"><a href=\"#cb71-8\"></a></span>\n<span id=\"cb71-9\"><a href=\"#cb71-9\"></a>        <span class=\"kw\">switch</span> result := result.(<span class=\"kw\">type</span>) {</span>\n<span id=\"cb71-10\"><a href=\"#cb71-10\"></a>        <span class=\"kw\">case</span> *object.ReturnValue:</span>\n<span id=\"cb71-11\"><a href=\"#cb71-11\"></a>            <span class=\"kw\">return</span> result.Value</span>\n<span id=\"cb71-12\"><a href=\"#cb71-12\"></a>        <span class=\"kw\">case</span> *object.Error:</span>\n<span id=\"cb71-13\"><a href=\"#cb71-13\"></a>            <span class=\"kw\">return</span> result</span>\n<span id=\"cb71-14\"><a href=\"#cb71-14\"></a>        }</span>\n<span id=\"cb71-15\"><a href=\"#cb71-15\"></a>    }</span>\n<span id=\"cb71-16\"><a href=\"#cb71-16\"></a></span>\n<span id=\"cb71-17\"><a href=\"#cb71-17\"></a>    <span class=\"kw\">return</span> result</span>\n<span id=\"cb71-18\"><a href=\"#cb71-18\"></a>}</span>\n<span id=\"cb71-19\"><a href=\"#cb71-19\"></a></span>\n<span id=\"cb71-20\"><a href=\"#cb71-20\"></a><span class=\"kw\">func</span> evalBlockStatement(block *ast.BlockStatement) object.Object {</span>\n<span id=\"cb71-21\"><a href=\"#cb71-21\"></a>    <span class=\"kw\">var</span> result object.Object</span>\n<span id=\"cb71-22\"><a href=\"#cb71-22\"></a></span>\n<span id=\"cb71-23\"><a href=\"#cb71-23\"></a>    <span class=\"kw\">for</span> _, statement := <span class=\"kw\">range</span> block.Statements {</span>\n<span id=\"cb71-24\"><a href=\"#cb71-24\"></a>        result = Eval(statement)</span>\n<span id=\"cb71-25\"><a href=\"#cb71-25\"></a></span>\n<span id=\"cb71-26\"><a href=\"#cb71-26\"></a>        <span class=\"kw\">if</span> result != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb71-27\"><a href=\"#cb71-27\"></a>            rt := result.Type()</span>\n<span id=\"cb71-28\"><a href=\"#cb71-28\"></a>            <span class=\"kw\">if</span> rt == object.RETURN_VALUE_OBJ || rt == object.ERROR_OBJ {</span>\n<span id=\"cb71-29\"><a href=\"#cb71-29\"></a>                <span class=\"kw\">return</span> result</span>\n<span id=\"cb71-30\"><a href=\"#cb71-30\"></a>            }</span>\n<span id=\"cb71-31\"><a href=\"#cb71-31\"></a>        }</span>\n<span id=\"cb71-32\"><a href=\"#cb71-32\"></a>    }</span>\n<span id=\"cb71-33\"><a href=\"#cb71-33\"></a></span>\n<span id=\"cb71-34\"><a href=\"#cb71-34\"></a>    <span class=\"kw\">return</span> result</span>\n<span id=\"cb71-35\"><a href=\"#cb71-35\"></a>}</span></code></pre></div>\n<p>The added error handling in <code>evalProgram</code> is easy to spot. It takes slightly more effort to notice the added check for the type of <code>result</code> in <code>evalBlockStatement</code>.</p>\n<p>Taken together, these changes did it. Evaluation is stopped at the right places and the tests now pass:</p>\n<div class=\"sourceCode\" id=\"cb72\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb72-1\"><a href=\"#cb72-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb72-2\"><a href=\"#cb72-2\"></a>ok      monkey/evaluator        0.010s</span></code></pre></div>\n<p>There’s still one last thing we need to do. We need to check for errors whenever we call <code>Eval</code> inside of <code>Eval</code>, in order to stop errors from being passed around and then bubbling up far away from their origin:</p>\n<div class=\"sourceCode\" id=\"cb73\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb73-1\"><a href=\"#cb73-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb73-2\"><a href=\"#cb73-2\"></a></span>\n<span id=\"cb73-3\"><a href=\"#cb73-3\"></a><span class=\"kw\">func</span> isError(obj object.Object) <span class=\"dt\">bool</span> {</span>\n<span id=\"cb73-4\"><a href=\"#cb73-4\"></a>    <span class=\"kw\">if</span> obj != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb73-5\"><a href=\"#cb73-5\"></a>        <span class=\"kw\">return</span> obj.Type() == object.ERROR_OBJ</span>\n<span id=\"cb73-6\"><a href=\"#cb73-6\"></a>    }</span>\n<span id=\"cb73-7\"><a href=\"#cb73-7\"></a>    <span class=\"kw\">return</span> <span class=\"ot\">false</span></span>\n<span id=\"cb73-8\"><a href=\"#cb73-8\"></a>}</span>\n<span id=\"cb73-9\"><a href=\"#cb73-9\"></a></span>\n<span id=\"cb73-10\"><a href=\"#cb73-10\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb73-11\"><a href=\"#cb73-11\"></a>    <span class=\"kw\">switch</span> node := node.(<span class=\"kw\">type</span>) {</span>\n<span id=\"cb73-12\"><a href=\"#cb73-12\"></a></span>\n<span id=\"cb73-13\"><a href=\"#cb73-13\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb73-14\"><a href=\"#cb73-14\"></a>    <span class=\"kw\">case</span> *ast.ReturnStatement:</span>\n<span id=\"cb73-15\"><a href=\"#cb73-15\"></a>        val := Eval(node.ReturnValue)</span>\n<span id=\"cb73-16\"><a href=\"#cb73-16\"></a>        <span class=\"kw\">if</span> isError(val) {</span>\n<span id=\"cb73-17\"><a href=\"#cb73-17\"></a>            <span class=\"kw\">return</span> val</span>\n<span id=\"cb73-18\"><a href=\"#cb73-18\"></a>        }</span>\n<span id=\"cb73-19\"><a href=\"#cb73-19\"></a>        <span class=\"kw\">return</span> &amp;object.ReturnValue{Value: val}</span>\n<span id=\"cb73-20\"><a href=\"#cb73-20\"></a></span>\n<span id=\"cb73-21\"><a href=\"#cb73-21\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb73-22\"><a href=\"#cb73-22\"></a>    <span class=\"kw\">case</span> *ast.PrefixExpression:</span>\n<span id=\"cb73-23\"><a href=\"#cb73-23\"></a>        right := Eval(node.Right)</span>\n<span id=\"cb73-24\"><a href=\"#cb73-24\"></a>        <span class=\"kw\">if</span> isError(right) {</span>\n<span id=\"cb73-25\"><a href=\"#cb73-25\"></a>            <span class=\"kw\">return</span> right</span>\n<span id=\"cb73-26\"><a href=\"#cb73-26\"></a>        }</span>\n<span id=\"cb73-27\"><a href=\"#cb73-27\"></a>        <span class=\"kw\">return</span> evalPrefixExpression(node.Operator, right)</span>\n<span id=\"cb73-28\"><a href=\"#cb73-28\"></a></span>\n<span id=\"cb73-29\"><a href=\"#cb73-29\"></a>    <span class=\"kw\">case</span> *ast.InfixExpression:</span>\n<span id=\"cb73-30\"><a href=\"#cb73-30\"></a>        left := Eval(node.Left)</span>\n<span id=\"cb73-31\"><a href=\"#cb73-31\"></a>        <span class=\"kw\">if</span> isError(left) {</span>\n<span id=\"cb73-32\"><a href=\"#cb73-32\"></a>            <span class=\"kw\">return</span> left</span>\n<span id=\"cb73-33\"><a href=\"#cb73-33\"></a>        }</span>\n<span id=\"cb73-34\"><a href=\"#cb73-34\"></a></span>\n<span id=\"cb73-35\"><a href=\"#cb73-35\"></a>        right := Eval(node.Right)</span>\n<span id=\"cb73-36\"><a href=\"#cb73-36\"></a>        <span class=\"kw\">if</span> isError(right) {</span>\n<span id=\"cb73-37\"><a href=\"#cb73-37\"></a>            <span class=\"kw\">return</span> right</span>\n<span id=\"cb73-38\"><a href=\"#cb73-38\"></a>        }</span>\n<span id=\"cb73-39\"><a href=\"#cb73-39\"></a></span>\n<span id=\"cb73-40\"><a href=\"#cb73-40\"></a>        <span class=\"kw\">return</span> evalInfixExpression(node.Operator, left, right)</span>\n<span id=\"cb73-41\"><a href=\"#cb73-41\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb73-42\"><a href=\"#cb73-42\"></a>}</span>\n<span id=\"cb73-43\"><a href=\"#cb73-43\"></a></span>\n<span id=\"cb73-44\"><a href=\"#cb73-44\"></a><span class=\"kw\">func</span> evalIfExpression(ie *ast.IfExpression) object.Object {</span>\n<span id=\"cb73-45\"><a href=\"#cb73-45\"></a>    condition := Eval(ie.Condition)</span>\n<span id=\"cb73-46\"><a href=\"#cb73-46\"></a>    <span class=\"kw\">if</span> isError(condition) {</span>\n<span id=\"cb73-47\"><a href=\"#cb73-47\"></a>        <span class=\"kw\">return</span> condition</span>\n<span id=\"cb73-48\"><a href=\"#cb73-48\"></a>    }</span>\n<span id=\"cb73-49\"><a href=\"#cb73-49\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb73-50\"><a href=\"#cb73-50\"></a>}</span></code></pre></div>\n<p>And that’s it. Error handling is in place.</p>\n</section>\n<section id=\"bindings-the-environment\" class=\"level2\" data-number=\"3.9\">\n<h2 data-number=\"3.9\">3.9 - Bindings &amp; The Environment</h2>\n<p>Up next we’re going to add bindings to our interpreter by adding support for let statements. But not only do we need to support let statements, no, we need to support the evaluation of identifiers, too. Let’s say we have evaluated the following piece of code:</p>\n<div class=\"sourceCode\" id=\"cb74\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb74-1\"><a href=\"#cb74-1\"></a><span class=\"kw\">let</span> x <span class=\"op\">=</span> <span class=\"dv\">5</span> <span class=\"op\">*</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span></code></pre></div>\n<p>Only adding support for the evaluation of this statement is not enough. We also need to make sure that the <code>x</code> evaluates to <code>25</code> after interpreting the line above.</p>\n<p>So, our task in this section is to evaluate let statements and identifiers. We evaluate let statements by evaluating their value-producing expression and keeping track of the produced value under the specified name. To evaluate identifiers we check if we already have a value bound to the name. If we do, the identifier evaluates to this value, and if we don’t, we return an error.</p>\n<p>Sounds like a good plan? Alright, so let’s kick this off with a few tests:</p>\n<div class=\"sourceCode\" id=\"cb75\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb75-1\"><a href=\"#cb75-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb75-2\"><a href=\"#cb75-2\"></a></span>\n<span id=\"cb75-3\"><a href=\"#cb75-3\"></a><span class=\"kw\">func</span> TestLetStatements(t *testing.T) {</span>\n<span id=\"cb75-4\"><a href=\"#cb75-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb75-5\"><a href=\"#cb75-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb75-6\"><a href=\"#cb75-6\"></a>        expected <span class=\"dt\">int64</span></span>\n<span id=\"cb75-7\"><a href=\"#cb75-7\"></a>    }{</span>\n<span id=\"cb75-8\"><a href=\"#cb75-8\"></a>        {<span class=\"st\">&quot;let a = 5; a;&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb75-9\"><a href=\"#cb75-9\"></a>        {<span class=\"st\">&quot;let a = 5 * 5; a;&quot;</span>, <span class=\"dv\">25</span>},</span>\n<span id=\"cb75-10\"><a href=\"#cb75-10\"></a>        {<span class=\"st\">&quot;let a = 5; let b = a; b;&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb75-11\"><a href=\"#cb75-11\"></a>        {<span class=\"st\">&quot;let a = 5; let b = a; let c = a + b + 5; c;&quot;</span>, <span class=\"dv\">15</span>},</span>\n<span id=\"cb75-12\"><a href=\"#cb75-12\"></a>    }</span>\n<span id=\"cb75-13\"><a href=\"#cb75-13\"></a></span>\n<span id=\"cb75-14\"><a href=\"#cb75-14\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb75-15\"><a href=\"#cb75-15\"></a>        testIntegerObject(t, testEval(tt.input), tt.expected)</span>\n<span id=\"cb75-16\"><a href=\"#cb75-16\"></a>    }</span>\n<span id=\"cb75-17\"><a href=\"#cb75-17\"></a>}</span></code></pre></div>\n<p>The test cases assert that these two things should work: evaluating the value-producing expression in a let statement and evaluating an identifier that’s bound to a name. But we also need tests to make sure that we get an error when we try to evaluate an unbound identifier. And for that we can simply extend our existing <code>TestErrorHandling</code> function:</p>\n<div class=\"sourceCode\" id=\"cb76\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb76-1\"><a href=\"#cb76-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb76-2\"><a href=\"#cb76-2\"></a></span>\n<span id=\"cb76-3\"><a href=\"#cb76-3\"></a><span class=\"kw\">func</span> TestErrorHandling(t *testing.T) {</span>\n<span id=\"cb76-4\"><a href=\"#cb76-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb76-5\"><a href=\"#cb76-5\"></a>        input           <span class=\"dt\">string</span></span>\n<span id=\"cb76-6\"><a href=\"#cb76-6\"></a>        expectedMessage <span class=\"dt\">string</span></span>\n<span id=\"cb76-7\"><a href=\"#cb76-7\"></a>    }{</span>\n<span id=\"cb76-8\"><a href=\"#cb76-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb76-9\"><a href=\"#cb76-9\"></a>        {</span>\n<span id=\"cb76-10\"><a href=\"#cb76-10\"></a>            <span class=\"st\">&quot;foobar&quot;</span>,</span>\n<span id=\"cb76-11\"><a href=\"#cb76-11\"></a>            <span class=\"st\">&quot;identifier not found: foobar&quot;</span>,</span>\n<span id=\"cb76-12\"><a href=\"#cb76-12\"></a>        },</span>\n<span id=\"cb76-13\"><a href=\"#cb76-13\"></a>    }</span>\n<span id=\"cb76-14\"><a href=\"#cb76-14\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb76-15\"><a href=\"#cb76-15\"></a>}</span></code></pre></div>\n<p>How do we make these tests pass? Obviously the first thing we have to do is add a new <code>case</code> branch for <code>*ast.LetStatement</code> to <code>Eval</code>. And in this branch we need to <code>Eval</code> the expression of the let statement, correct? So let’s start with that:</p>\n<div class=\"sourceCode\" id=\"cb77\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb77-1\"><a href=\"#cb77-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb77-2\"><a href=\"#cb77-2\"></a></span>\n<span id=\"cb77-3\"><a href=\"#cb77-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node) object.Object {</span>\n<span id=\"cb77-4\"><a href=\"#cb77-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb77-5\"><a href=\"#cb77-5\"></a>    <span class=\"kw\">case</span> *ast.LetStatement:</span>\n<span id=\"cb77-6\"><a href=\"#cb77-6\"></a>        val := Eval(node.Value)</span>\n<span id=\"cb77-7\"><a href=\"#cb77-7\"></a>        <span class=\"kw\">if</span> isError(val) {</span>\n<span id=\"cb77-8\"><a href=\"#cb77-8\"></a>            <span class=\"kw\">return</span> val</span>\n<span id=\"cb77-9\"><a href=\"#cb77-9\"></a>        }</span>\n<span id=\"cb77-10\"><a href=\"#cb77-10\"></a></span>\n<span id=\"cb77-11\"><a href=\"#cb77-11\"></a>    <span class=\"co\">// Huh? Now what?</span></span>\n<span id=\"cb77-12\"><a href=\"#cb77-12\"></a></span>\n<span id=\"cb77-13\"><a href=\"#cb77-13\"></a></span>\n<span id=\"cb77-14\"><a href=\"#cb77-14\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb77-15\"><a href=\"#cb77-15\"></a>}</span></code></pre></div>\n<p>The comment is right: now what? How do we keep track of values? We have the value and we also have the name we should bind it to, <code>node.Name.Value</code>. How do we associate one with the other?</p>\n<p>This is where something called the environment comes into play. The environment is what we use to keep track of value by associating them with a name. The name “environment” is a classic one, used in a lot of other interpreters, especially Lispy ones. But even though the name may sound sophisticated, at its heart the environment is a hash map that associates strings with objects. And that’s exactly what we’re going to use for our implementation.</p>\n<p>We’ll add a new <code>Environment</code> struct to the <code>object</code> package. And yes, for now it really is just a thin wrapper around a <code>map</code>:</p>\n<div class=\"sourceCode\" id=\"cb78\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb78-1\"><a href=\"#cb78-1\"></a><span class=\"co\">// object/environment.go</span></span>\n<span id=\"cb78-2\"><a href=\"#cb78-2\"></a></span>\n<span id=\"cb78-3\"><a href=\"#cb78-3\"></a><span class=\"kw\">package</span> object</span>\n<span id=\"cb78-4\"><a href=\"#cb78-4\"></a></span>\n<span id=\"cb78-5\"><a href=\"#cb78-5\"></a><span class=\"kw\">func</span> NewEnvironment() *Environment {</span>\n<span id=\"cb78-6\"><a href=\"#cb78-6\"></a>    s := <span class=\"bu\">make</span>(<span class=\"kw\">map</span>[<span class=\"dt\">string</span>]Object)</span>\n<span id=\"cb78-7\"><a href=\"#cb78-7\"></a>    <span class=\"kw\">return</span> &amp;Environment{store: s}</span>\n<span id=\"cb78-8\"><a href=\"#cb78-8\"></a>}</span>\n<span id=\"cb78-9\"><a href=\"#cb78-9\"></a></span>\n<span id=\"cb78-10\"><a href=\"#cb78-10\"></a><span class=\"kw\">type</span> Environment <span class=\"kw\">struct</span> {</span>\n<span id=\"cb78-11\"><a href=\"#cb78-11\"></a>    store <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]Object</span>\n<span id=\"cb78-12\"><a href=\"#cb78-12\"></a>}</span>\n<span id=\"cb78-13\"><a href=\"#cb78-13\"></a></span>\n<span id=\"cb78-14\"><a href=\"#cb78-14\"></a><span class=\"kw\">func</span> (e *Environment) Get(name <span class=\"dt\">string</span>) (Object, <span class=\"dt\">bool</span>) {</span>\n<span id=\"cb78-15\"><a href=\"#cb78-15\"></a>    obj, ok := e.store[name]</span>\n<span id=\"cb78-16\"><a href=\"#cb78-16\"></a>    <span class=\"kw\">return</span> obj, ok</span>\n<span id=\"cb78-17\"><a href=\"#cb78-17\"></a>}</span>\n<span id=\"cb78-18\"><a href=\"#cb78-18\"></a></span>\n<span id=\"cb78-19\"><a href=\"#cb78-19\"></a><span class=\"kw\">func</span> (e *Environment) Set(name <span class=\"dt\">string</span>, val Object) Object {</span>\n<span id=\"cb78-20\"><a href=\"#cb78-20\"></a>    e.store[name] = val</span>\n<span id=\"cb78-21\"><a href=\"#cb78-21\"></a>    <span class=\"kw\">return</span> val</span>\n<span id=\"cb78-22\"><a href=\"#cb78-22\"></a>}</span></code></pre></div>\n<p>Let me guess what you’re thinking: <em>Why not use a map? Why the wrapper?</em> It’ll all make sense as soon as we start implementing functions and function calls in the next section, I promise. This is the groundwork we’ll build upon later.</p>\n<p>As it is, the usage of <code>object.Environment</code> itself is self-explanatory. But how do we use it inside <code>Eval</code>? How and where do we keep track of the environment? We pass it around by making it a parameter of <code>Eval</code>:</p>\n<div class=\"sourceCode\" id=\"cb79\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb79-1\"><a href=\"#cb79-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb79-2\"><a href=\"#cb79-2\"></a></span>\n<span id=\"cb79-3\"><a href=\"#cb79-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb79-4\"><a href=\"#cb79-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb79-5\"><a href=\"#cb79-5\"></a>}</span></code></pre></div>\n<p>With that change nothing compiles anymore, because we have to change every call to <code>Eval</code> make use of the environment. And not only the calls to <code>Eval</code> in <code>Eval</code> itself, but also the ones in functions such as <code>evalProgram</code>, <code>evalIfExpression</code> and so on. This requires more manual editor work than anything else, so I won’t bore you by showing the list of changes here.</p>\n<p>The calls to <code>Eval</code> in our REPL and in our test suite need to use an environment too, of course. In the REPL we use a single environment:</p>\n<div class=\"sourceCode\" id=\"cb80\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb80-1\"><a href=\"#cb80-1\"></a><span class=\"co\">// repl/repl.go</span></span>\n<span id=\"cb80-2\"><a href=\"#cb80-2\"></a></span>\n<span id=\"cb80-3\"><a href=\"#cb80-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb80-4\"><a href=\"#cb80-4\"></a>    <span class=\"co\">// [...]</span></span>\n<span id=\"cb80-5\"><a href=\"#cb80-5\"></a>    <span class=\"st\">&quot;monkey/object&quot;</span></span>\n<span id=\"cb80-6\"><a href=\"#cb80-6\"></a>)</span>\n<span id=\"cb80-7\"><a href=\"#cb80-7\"></a></span>\n<span id=\"cb80-8\"><a href=\"#cb80-8\"></a><span class=\"kw\">func</span> Start(in io.Reader, out io.Writer) {</span>\n<span id=\"cb80-9\"><a href=\"#cb80-9\"></a>    scanner := bufio.NewScanner(in)</span>\n<span id=\"cb80-10\"><a href=\"#cb80-10\"></a>    env := object.NewEnvironment()</span>\n<span id=\"cb80-11\"><a href=\"#cb80-11\"></a></span>\n<span id=\"cb80-12\"><a href=\"#cb80-12\"></a>    <span class=\"kw\">for</span> {</span>\n<span id=\"cb80-13\"><a href=\"#cb80-13\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb80-14\"><a href=\"#cb80-14\"></a>        evaluated := evaluator.Eval(program, env)</span>\n<span id=\"cb80-15\"><a href=\"#cb80-15\"></a>        <span class=\"kw\">if</span> evaluated != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb80-16\"><a href=\"#cb80-16\"></a>            io.WriteString(out, evaluated.Inspect())</span>\n<span id=\"cb80-17\"><a href=\"#cb80-17\"></a>            io.WriteString(out, <span class=\"st\">&quot;</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>)</span>\n<span id=\"cb80-18\"><a href=\"#cb80-18\"></a>        }</span>\n<span id=\"cb80-19\"><a href=\"#cb80-19\"></a>    }</span>\n<span id=\"cb80-20\"><a href=\"#cb80-20\"></a>}</span></code></pre></div>\n<p>The environment we use here, <code>env</code>, persists between calls to <code>Eval</code>. If it didn’t, binding a value to a name in the REPL would be without any effect. As soon as the next line is evaluated, the association wouldn’t be in the new environment.</p>\n<p>That’s exactly what we want in our test suite, though. We don’t want to keep state around for each test function and each test case. Each call to <code>testEval</code> should have a fresh environment so we don’t run into weird bugs involving global state caused by the order in which tests are run. Every call to <code>Eval</code> here gets a fresh environment:</p>\n<div class=\"sourceCode\" id=\"cb81\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb81-1\"><a href=\"#cb81-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb81-2\"><a href=\"#cb81-2\"></a></span>\n<span id=\"cb81-3\"><a href=\"#cb81-3\"></a><span class=\"kw\">func</span> testEval(input <span class=\"dt\">string</span>) object.Object {</span>\n<span id=\"cb81-4\"><a href=\"#cb81-4\"></a>    l := lexer.New(input)</span>\n<span id=\"cb81-5\"><a href=\"#cb81-5\"></a>    p := parser.New(l)</span>\n<span id=\"cb81-6\"><a href=\"#cb81-6\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb81-7\"><a href=\"#cb81-7\"></a>    env := object.NewEnvironment()</span>\n<span id=\"cb81-8\"><a href=\"#cb81-8\"></a></span>\n<span id=\"cb81-9\"><a href=\"#cb81-9\"></a>    <span class=\"kw\">return</span> Eval(program, env)</span>\n<span id=\"cb81-10\"><a href=\"#cb81-10\"></a>}</span></code></pre></div>\n<p>With updated <code>Eval</code> calls the tests compile again and we can start making them pass, which is not too hard with <code>*object.Environment</code> available. In the <code>case</code> branch for <code>*ast.LetStatement</code> we can just use the name and value we already have and save them in the current environment:</p>\n<div class=\"sourceCode\" id=\"cb82\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb82-1\"><a href=\"#cb82-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb82-2\"><a href=\"#cb82-2\"></a></span>\n<span id=\"cb82-3\"><a href=\"#cb82-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb82-4\"><a href=\"#cb82-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb82-5\"><a href=\"#cb82-5\"></a>    <span class=\"kw\">case</span> *ast.LetStatement:</span>\n<span id=\"cb82-6\"><a href=\"#cb82-6\"></a>        val := Eval(node.Value, env)</span>\n<span id=\"cb82-7\"><a href=\"#cb82-7\"></a>        <span class=\"kw\">if</span> isError(val) {</span>\n<span id=\"cb82-8\"><a href=\"#cb82-8\"></a>            <span class=\"kw\">return</span> val</span>\n<span id=\"cb82-9\"><a href=\"#cb82-9\"></a>        }</span>\n<span id=\"cb82-10\"><a href=\"#cb82-10\"></a>        env.Set(node.Name.Value, val)</span>\n<span id=\"cb82-11\"><a href=\"#cb82-11\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb82-12\"><a href=\"#cb82-12\"></a>}</span></code></pre></div>\n<p>Now we’re adding associations to the environment when evaluating let statements. But we also need to get these values out when we’re evaluating identifiers. Doing that is pretty easy, too:</p>\n<div class=\"sourceCode\" id=\"cb83\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb83-1\"><a href=\"#cb83-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb83-2\"><a href=\"#cb83-2\"></a></span>\n<span id=\"cb83-3\"><a href=\"#cb83-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb83-4\"><a href=\"#cb83-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb83-5\"><a href=\"#cb83-5\"></a>    <span class=\"kw\">case</span> *ast.Identifier:</span>\n<span id=\"cb83-6\"><a href=\"#cb83-6\"></a>        <span class=\"kw\">return</span> evalIdentifier(node, env)</span>\n<span id=\"cb83-7\"><a href=\"#cb83-7\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb83-8\"><a href=\"#cb83-8\"></a>}</span>\n<span id=\"cb83-9\"><a href=\"#cb83-9\"></a></span>\n<span id=\"cb83-10\"><a href=\"#cb83-10\"></a><span class=\"kw\">func</span> evalIdentifier(</span>\n<span id=\"cb83-11\"><a href=\"#cb83-11\"></a>    node *ast.Identifier,</span>\n<span id=\"cb83-12\"><a href=\"#cb83-12\"></a>    env *object.Environment,</span>\n<span id=\"cb83-13\"><a href=\"#cb83-13\"></a>) object.Object {</span>\n<span id=\"cb83-14\"><a href=\"#cb83-14\"></a>    val, ok := env.Get(node.Value)</span>\n<span id=\"cb83-15\"><a href=\"#cb83-15\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb83-16\"><a href=\"#cb83-16\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;identifier not found: &quot;</span> + node.Value)</span>\n<span id=\"cb83-17\"><a href=\"#cb83-17\"></a>    }</span>\n<span id=\"cb83-18\"><a href=\"#cb83-18\"></a></span>\n<span id=\"cb83-19\"><a href=\"#cb83-19\"></a>    <span class=\"kw\">return</span> val</span>\n<span id=\"cb83-20\"><a href=\"#cb83-20\"></a>}</span></code></pre></div>\n<p><code>evalIdentifier</code> will be extended in the next section. For now it simply checks if a value has been associated with the given name in the current environment. If that’s the case it returns the value, otherwise an error.</p>\n<p>Look at this:</p>\n<div class=\"sourceCode\" id=\"cb84\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb84-1\"><a href=\"#cb84-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb84-2\"><a href=\"#cb84-2\"></a>ok      monkey/evaluator        0.007s</span></code></pre></div>\n<p>Yes, you’re right, that’s exactly what this means: we’re now firmly standing in programming language land.</p>\n<div class=\"sourceCode\" id=\"cb85\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb85-1\"><a href=\"#cb85-1\"></a>$ go run main.go</span>\n<span id=\"cb85-2\"><a href=\"#cb85-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb85-3\"><a href=\"#cb85-3\"></a>Feel free to type in commands</span>\n<span id=\"cb85-4\"><a href=\"#cb85-4\"></a>&gt;&gt; let a = 5;</span>\n<span id=\"cb85-5\"><a href=\"#cb85-5\"></a>&gt;&gt; let b = a &gt; 3;</span>\n<span id=\"cb85-6\"><a href=\"#cb85-6\"></a>&gt;&gt; let c = a * 99;</span>\n<span id=\"cb85-7\"><a href=\"#cb85-7\"></a>&gt;&gt; if (b) { 10 } else { 1 };</span>\n<span id=\"cb85-8\"><a href=\"#cb85-8\"></a>10</span>\n<span id=\"cb85-9\"><a href=\"#cb85-9\"></a>&gt;&gt; let d = if (c &gt; a) { 99 } else { 100 };</span>\n<span id=\"cb85-10\"><a href=\"#cb85-10\"></a>&gt;&gt; d</span>\n<span id=\"cb85-11\"><a href=\"#cb85-11\"></a>99</span>\n<span id=\"cb85-12\"><a href=\"#cb85-12\"></a>&gt;&gt; d * c * a;</span>\n<span id=\"cb85-13\"><a href=\"#cb85-13\"></a>245025</span></code></pre></div>\n</section>\n<section id=\"functions-function-calls\" class=\"level2\" data-number=\"3.10\">\n<h2 data-number=\"3.10\">3.10 - Functions &amp; Function Calls</h2>\n<p>This is what we’ve been working towards. This is the third act. We’re going to add support for functions and function calls to our interpreter. When we’re done with this section, we’ll be able to do this in our REPL:</p>\n<div class=\"sourceCode\" id=\"cb86\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb86-1\"><a href=\"#cb86-1\"></a>&gt;&gt; let add = fn(a, b, c, d) { return a + b + c + d };</span>\n<span id=\"cb86-2\"><a href=\"#cb86-2\"></a>&gt;&gt; add(1, 2, 3, 4);</span>\n<span id=\"cb86-3\"><a href=\"#cb86-3\"></a>10</span>\n<span id=\"cb86-4\"><a href=\"#cb86-4\"></a>&gt;&gt; let addThree = fn(x) { return x + 3 };</span>\n<span id=\"cb86-5\"><a href=\"#cb86-5\"></a>&gt;&gt; addThree(3);</span>\n<span id=\"cb86-6\"><a href=\"#cb86-6\"></a>6</span>\n<span id=\"cb86-7\"><a href=\"#cb86-7\"></a>&gt;&gt; let max = fn(x, y) { if (x &gt; y) { x } else { y } };</span>\n<span id=\"cb86-8\"><a href=\"#cb86-8\"></a>&gt;&gt; max(5, 10)</span>\n<span id=\"cb86-9\"><a href=\"#cb86-9\"></a>10</span>\n<span id=\"cb86-10\"><a href=\"#cb86-10\"></a>&gt;&gt; let factorial = fn(n) { if (n == 0) { 1 } else { n * factorial(n - 1) } };</span>\n<span id=\"cb86-11\"><a href=\"#cb86-11\"></a>&gt;&gt; factorial(5)</span>\n<span id=\"cb86-12\"><a href=\"#cb86-12\"></a>120</span></code></pre></div>\n<p>If that doesn’t impress you then take a look at this. Passing around functions, higher-order functions and closures will also work:</p>\n<div class=\"sourceCode\" id=\"cb87\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb87-1\"><a href=\"#cb87-1\"></a>&gt;&gt; let callTwoTimes = fn(x, func) { func(func(x)) };</span>\n<span id=\"cb87-2\"><a href=\"#cb87-2\"></a>&gt;&gt; callTwoTimes(3, addThree);</span>\n<span id=\"cb87-3\"><a href=\"#cb87-3\"></a>9</span>\n<span id=\"cb87-4\"><a href=\"#cb87-4\"></a>&gt;&gt; callTwoTimes(3, fn(x) { x + 1 });</span>\n<span id=\"cb87-5\"><a href=\"#cb87-5\"></a>5</span>\n<span id=\"cb87-6\"><a href=\"#cb87-6\"></a>&gt;&gt; let newAdder = fn(x) { fn(n) { x + n } };</span>\n<span id=\"cb87-7\"><a href=\"#cb87-7\"></a>&gt;&gt; let addTwo = newAdder(2);</span>\n<span id=\"cb87-8\"><a href=\"#cb87-8\"></a>&gt;&gt; addTwo(2);</span>\n<span id=\"cb87-9\"><a href=\"#cb87-9\"></a>4</span></code></pre></div>\n<p>Yes, that’s right, we will be able to do all of <em>that</em>.</p>\n<p>In order to get from where we currently are to <em>there</em> we need to do two things: define an internal representation of functions in our object system and add support for function calls to <code>Eval</code>.</p>\n<p>But don’t worry. It’s easy. The work we did in the last sections now pays off. We can reuse and extend a lot of things we already built. You’ll see that a lot of things just start to fit together at a certain point in this section.</p>\n<p>Since “one step at a time” brought us here there’s no reason to abandon this strategy now. The first step is to take care of the internal representation of functions.</p>\n<p>The need to represent functions internally comes from the fact that functions in Monkey are treated like any other value: we can bind them to names, use them in expressions, pass them to other functions, return them from functions and so on. And like other values, functions need a representation in our object system, so we can pass around, assign and return them.</p>\n<p>But how do we represent a function internally, as an object? Our definition of <code>ast.FunctionLiteral</code> gives us a starting point:</p>\n<div class=\"sourceCode\" id=\"cb88\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb88-1\"><a href=\"#cb88-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb88-2\"><a href=\"#cb88-2\"></a></span>\n<span id=\"cb88-3\"><a href=\"#cb88-3\"></a><span class=\"kw\">type</span> FunctionLiteral <span class=\"kw\">struct</span> {</span>\n<span id=\"cb88-4\"><a href=\"#cb88-4\"></a>    Token      token.Token <span class=\"co\">// The &#39;fn&#39; token</span></span>\n<span id=\"cb88-5\"><a href=\"#cb88-5\"></a>    Parameters []*Identifier</span>\n<span id=\"cb88-6\"><a href=\"#cb88-6\"></a>    Body       *BlockStatement</span>\n<span id=\"cb88-7\"><a href=\"#cb88-7\"></a>}</span></code></pre></div>\n<p>We don’t need the <code>Token</code> field in a function object, but <code>Parameters</code> and <code>Body</code> make sense. We can’t evaluate a function without its body and we can’t evaluate the body if we don’t know which parameters the function has. Besides <code>Parameters</code> and <code>Body</code> we also need a third field in our new function object:</p>\n<div class=\"sourceCode\" id=\"cb89\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb89-1\"><a href=\"#cb89-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb89-2\"><a href=\"#cb89-2\"></a></span>\n<span id=\"cb89-3\"><a href=\"#cb89-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb89-4\"><a href=\"#cb89-4\"></a>    <span class=\"st\">&quot;bytes&quot;</span></span>\n<span id=\"cb89-5\"><a href=\"#cb89-5\"></a>    <span class=\"st\">&quot;fmt&quot;</span></span>\n<span id=\"cb89-6\"><a href=\"#cb89-6\"></a>    <span class=\"st\">&quot;monkey/ast&quot;</span></span>\n<span id=\"cb89-7\"><a href=\"#cb89-7\"></a>    <span class=\"st\">&quot;strings&quot;</span></span>\n<span id=\"cb89-8\"><a href=\"#cb89-8\"></a>)</span>\n<span id=\"cb89-9\"><a href=\"#cb89-9\"></a></span>\n<span id=\"cb89-10\"><a href=\"#cb89-10\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb89-11\"><a href=\"#cb89-11\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb89-12\"><a href=\"#cb89-12\"></a>    FUNCTION_OBJ = <span class=\"st\">&quot;FUNCTION&quot;</span></span>\n<span id=\"cb89-13\"><a href=\"#cb89-13\"></a>)</span>\n<span id=\"cb89-14\"><a href=\"#cb89-14\"></a></span>\n<span id=\"cb89-15\"><a href=\"#cb89-15\"></a><span class=\"kw\">type</span> Function <span class=\"kw\">struct</span> {</span>\n<span id=\"cb89-16\"><a href=\"#cb89-16\"></a>    Parameters []*ast.Identifier</span>\n<span id=\"cb89-17\"><a href=\"#cb89-17\"></a>    Body       *ast.BlockStatement</span>\n<span id=\"cb89-18\"><a href=\"#cb89-18\"></a>    Env        *Environment</span>\n<span id=\"cb89-19\"><a href=\"#cb89-19\"></a>}</span>\n<span id=\"cb89-20\"><a href=\"#cb89-20\"></a></span>\n<span id=\"cb89-21\"><a href=\"#cb89-21\"></a><span class=\"kw\">func</span> (f *Function) Type() ObjectType { <span class=\"kw\">return</span> FUNCTION_OBJ }</span>\n<span id=\"cb89-22\"><a href=\"#cb89-22\"></a><span class=\"kw\">func</span> (f *Function) Inspect() <span class=\"dt\">string</span> {</span>\n<span id=\"cb89-23\"><a href=\"#cb89-23\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb89-24\"><a href=\"#cb89-24\"></a></span>\n<span id=\"cb89-25\"><a href=\"#cb89-25\"></a>    params := []<span class=\"dt\">string</span>{}</span>\n<span id=\"cb89-26\"><a href=\"#cb89-26\"></a>    <span class=\"kw\">for</span> _, p := <span class=\"kw\">range</span> f.Parameters {</span>\n<span id=\"cb89-27\"><a href=\"#cb89-27\"></a>        params = <span class=\"bu\">append</span>(params, p.String())</span>\n<span id=\"cb89-28\"><a href=\"#cb89-28\"></a>    }</span>\n<span id=\"cb89-29\"><a href=\"#cb89-29\"></a></span>\n<span id=\"cb89-30\"><a href=\"#cb89-30\"></a>    out.WriteString(<span class=\"st\">&quot;fn&quot;</span>)</span>\n<span id=\"cb89-31\"><a href=\"#cb89-31\"></a>    out.WriteString(<span class=\"st\">&quot;(&quot;</span>)</span>\n<span id=\"cb89-32\"><a href=\"#cb89-32\"></a>    out.WriteString(strings.Join(params, <span class=\"st\">&quot;, &quot;</span>))</span>\n<span id=\"cb89-33\"><a href=\"#cb89-33\"></a>    out.WriteString(<span class=\"st\">&quot;) {</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>)</span>\n<span id=\"cb89-34\"><a href=\"#cb89-34\"></a>    out.WriteString(f.Body.String())</span>\n<span id=\"cb89-35\"><a href=\"#cb89-35\"></a>    out.WriteString(<span class=\"st\">&quot;</span><span class=\"ch\">\\n</span><span class=\"st\">}&quot;</span>)</span>\n<span id=\"cb89-36\"><a href=\"#cb89-36\"></a></span>\n<span id=\"cb89-37\"><a href=\"#cb89-37\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb89-38\"><a href=\"#cb89-38\"></a>}</span></code></pre></div>\n<p>This definition of <code>object.Function</code> has the <code>Parameters</code> and <code>Body</code> fields. But it also has <code>Env</code>, a field that holds a pointer to an <code>object.Environment</code>, because functions in Monkey carry their own environment with them. That allows for closures, which “close over” the environment they’re defined in and can later access it. That will make more sense when we start using the <code>Env</code> field. You’ll see.</p>\n<p>With that definition done, we can now write a test to assert that our interpreter knows how to build functions:</p>\n<div class=\"sourceCode\" id=\"cb90\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb90-1\"><a href=\"#cb90-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb90-2\"><a href=\"#cb90-2\"></a></span>\n<span id=\"cb90-3\"><a href=\"#cb90-3\"></a><span class=\"kw\">func</span> TestFunctionObject(t *testing.T) {</span>\n<span id=\"cb90-4\"><a href=\"#cb90-4\"></a>    input := <span class=\"st\">&quot;fn(x) { x + 2; };&quot;</span></span>\n<span id=\"cb90-5\"><a href=\"#cb90-5\"></a></span>\n<span id=\"cb90-6\"><a href=\"#cb90-6\"></a>    evaluated := testEval(input)</span>\n<span id=\"cb90-7\"><a href=\"#cb90-7\"></a>    fn, ok := evaluated.(*object.Function)</span>\n<span id=\"cb90-8\"><a href=\"#cb90-8\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb90-9\"><a href=\"#cb90-9\"></a>        t.Fatalf(<span class=\"st\">&quot;object is not Function. got=%T (%+v)&quot;</span>, evaluated, evaluated)</span>\n<span id=\"cb90-10\"><a href=\"#cb90-10\"></a>    }</span>\n<span id=\"cb90-11\"><a href=\"#cb90-11\"></a></span>\n<span id=\"cb90-12\"><a href=\"#cb90-12\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(fn.Parameters) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb90-13\"><a href=\"#cb90-13\"></a>        t.Fatalf(<span class=\"st\">&quot;function has wrong parameters. Parameters=%+v&quot;</span>,</span>\n<span id=\"cb90-14\"><a href=\"#cb90-14\"></a>            fn.Parameters)</span>\n<span id=\"cb90-15\"><a href=\"#cb90-15\"></a>    }</span>\n<span id=\"cb90-16\"><a href=\"#cb90-16\"></a></span>\n<span id=\"cb90-17\"><a href=\"#cb90-17\"></a>    <span class=\"kw\">if</span> fn.Parameters[<span class=\"dv\">0</span>].String() != <span class=\"st\">&quot;x&quot;</span> {</span>\n<span id=\"cb90-18\"><a href=\"#cb90-18\"></a>        t.Fatalf(<span class=\"st\">&quot;parameter is not &#39;x&#39;. got=%q&quot;</span>, fn.Parameters[<span class=\"dv\">0</span>])</span>\n<span id=\"cb90-19\"><a href=\"#cb90-19\"></a>    }</span>\n<span id=\"cb90-20\"><a href=\"#cb90-20\"></a></span>\n<span id=\"cb90-21\"><a href=\"#cb90-21\"></a>    expectedBody := <span class=\"st\">&quot;(x + 2)&quot;</span></span>\n<span id=\"cb90-22\"><a href=\"#cb90-22\"></a></span>\n<span id=\"cb90-23\"><a href=\"#cb90-23\"></a>    <span class=\"kw\">if</span> fn.Body.String() != expectedBody {</span>\n<span id=\"cb90-24\"><a href=\"#cb90-24\"></a>        t.Fatalf(<span class=\"st\">&quot;body is not %q. got=%q&quot;</span>, expectedBody, fn.Body.String())</span>\n<span id=\"cb90-25\"><a href=\"#cb90-25\"></a>    }</span>\n<span id=\"cb90-26\"><a href=\"#cb90-26\"></a>}</span></code></pre></div>\n<p>This test function asserts that evaluating a function literal results in the correct <code>*object.Function</code> being returned, with correct parameters and the correct body. The function’s environment will be tested later on in other tests, implicitly. Making this test pass takes just a few lines of code added to <code>Eval</code> in the form of a new <code>case</code> branch:</p>\n<div class=\"sourceCode\" id=\"cb91\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb91-1\"><a href=\"#cb91-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb91-2\"><a href=\"#cb91-2\"></a></span>\n<span id=\"cb91-3\"><a href=\"#cb91-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb91-4\"><a href=\"#cb91-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb91-5\"><a href=\"#cb91-5\"></a>    <span class=\"kw\">case</span> *ast.FunctionLiteral:</span>\n<span id=\"cb91-6\"><a href=\"#cb91-6\"></a>        params := node.Parameters</span>\n<span id=\"cb91-7\"><a href=\"#cb91-7\"></a>        body := node.Body</span>\n<span id=\"cb91-8\"><a href=\"#cb91-8\"></a>        <span class=\"kw\">return</span> &amp;object.Function{Parameters: params, Env: env, Body: body}</span>\n<span id=\"cb91-9\"><a href=\"#cb91-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb91-10\"><a href=\"#cb91-10\"></a>}</span></code></pre></div>\n<p>Easy, right? The test passes. We just reuse the <code>Parameters</code> and <code>Body</code> fields of the AST node. Notice how we use the current environment when building the function object.</p>\n<p>With that relatively low-level test passing and thus having made sure that we build the internal representation of functions correctly, we can turn to the topic of function application. That means, extending our interpreter so that we can call functions. The tests for this are much more readable and easier to write:</p>\n<div class=\"sourceCode\" id=\"cb92\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb92-1\"><a href=\"#cb92-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb92-2\"><a href=\"#cb92-2\"></a></span>\n<span id=\"cb92-3\"><a href=\"#cb92-3\"></a><span class=\"kw\">func</span> TestFunctionApplication(t *testing.T) {</span>\n<span id=\"cb92-4\"><a href=\"#cb92-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb92-5\"><a href=\"#cb92-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb92-6\"><a href=\"#cb92-6\"></a>        expected <span class=\"dt\">int64</span></span>\n<span id=\"cb92-7\"><a href=\"#cb92-7\"></a>    }{</span>\n<span id=\"cb92-8\"><a href=\"#cb92-8\"></a>        {<span class=\"st\">&quot;let identity = fn(x) { x; }; identity(5);&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb92-9\"><a href=\"#cb92-9\"></a>        {<span class=\"st\">&quot;let identity = fn(x) { return x; }; identity(5);&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb92-10\"><a href=\"#cb92-10\"></a>        {<span class=\"st\">&quot;let double = fn(x) { x * 2; }; double(5);&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb92-11\"><a href=\"#cb92-11\"></a>        {<span class=\"st\">&quot;let add = fn(x, y) { x + y; }; add(5, 5);&quot;</span>, <span class=\"dv\">10</span>},</span>\n<span id=\"cb92-12\"><a href=\"#cb92-12\"></a>        {<span class=\"st\">&quot;let add = fn(x, y) { x + y; }; add(5 + 5, add(5, 5));&quot;</span>, <span class=\"dv\">20</span>},</span>\n<span id=\"cb92-13\"><a href=\"#cb92-13\"></a>        {<span class=\"st\">&quot;fn(x) { x; }(5)&quot;</span>, <span class=\"dv\">5</span>},</span>\n<span id=\"cb92-14\"><a href=\"#cb92-14\"></a>    }</span>\n<span id=\"cb92-15\"><a href=\"#cb92-15\"></a></span>\n<span id=\"cb92-16\"><a href=\"#cb92-16\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb92-17\"><a href=\"#cb92-17\"></a>        testIntegerObject(t, testEval(tt.input), tt.expected)</span>\n<span id=\"cb92-18\"><a href=\"#cb92-18\"></a>    }</span>\n<span id=\"cb92-19\"><a href=\"#cb92-19\"></a>}</span></code></pre></div>\n<p>Each test case here does the same thing: define a function, apply it to arguments and then make an assertion about the produced value. But with their slight differences they test multiple important things: returning values implicitly, returning values using <code>return</code> statements, using parameters in expressions, multiple parameters and evaluating arguments before passing them to the function.</p>\n<p>We are also testing two possible forms of <code>*ast.CallExpression</code> here. One where the function is an identifier that evaluates to a function object, and the second one where the function is a function literal. The neat thing is that it doesn’t really matter. We already know how to evaluate identifiers and function literals:</p>\n<div class=\"sourceCode\" id=\"cb93\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb93-1\"><a href=\"#cb93-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb93-2\"><a href=\"#cb93-2\"></a></span>\n<span id=\"cb93-3\"><a href=\"#cb93-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb93-4\"><a href=\"#cb93-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb93-5\"><a href=\"#cb93-5\"></a>    <span class=\"kw\">case</span> *ast.CallExpression:</span>\n<span id=\"cb93-6\"><a href=\"#cb93-6\"></a>        function := Eval(node.Function, env)</span>\n<span id=\"cb93-7\"><a href=\"#cb93-7\"></a>        <span class=\"kw\">if</span> isError(function) {</span>\n<span id=\"cb93-8\"><a href=\"#cb93-8\"></a>            <span class=\"kw\">return</span> function</span>\n<span id=\"cb93-9\"><a href=\"#cb93-9\"></a>        }</span>\n<span id=\"cb93-10\"><a href=\"#cb93-10\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb93-11\"><a href=\"#cb93-11\"></a>}</span></code></pre></div>\n<p>Yes, we’re just using <code>Eval</code> to get the function we want to call. Whether that’s an <code>*ast.Identifier</code> or an <code>*ast.FunctionLiteral</code>: <code>Eval</code> returns an <code>*object.Function</code> (if there’s no error, of course).</p>\n<p>But how do we do call this <code>*object.Function</code>? The first step is to evaluate the arguments of a call expression. The reason is simple:</p>\n<div class=\"sourceCode\" id=\"cb94\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb94-1\"><a href=\"#cb94-1\"></a><span class=\"kw\">let</span> add <span class=\"op\">=</span> fn(x<span class=\"op\">,</span> y) { x <span class=\"op\">+</span> y }<span class=\"op\">;</span></span>\n<span id=\"cb94-2\"><a href=\"#cb94-2\"></a>add(<span class=\"dv\">2</span> <span class=\"op\">+</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">5</span> <span class=\"op\">+</span> <span class=\"dv\">5</span>)<span class=\"op\">;</span></span></code></pre></div>\n<p>Here we want to pass <code>4</code> and <code>10</code> to the <code>add</code> function as arguments and not the expressions <code>2 + 2</code> and <code>5 + 5</code>.</p>\n<p>Evaluating the arguments is nothing more than evaluating a list of expressions and keeping track of the produced values. But we also have to stop the evaluation process as soon as it encounters an error. That leads us to this code:</p>\n<div class=\"sourceCode\" id=\"cb95\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb95-1\"><a href=\"#cb95-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb95-2\"><a href=\"#cb95-2\"></a></span>\n<span id=\"cb95-3\"><a href=\"#cb95-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb95-4\"><a href=\"#cb95-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb95-5\"><a href=\"#cb95-5\"></a>    <span class=\"kw\">case</span> *ast.CallExpression:</span>\n<span id=\"cb95-6\"><a href=\"#cb95-6\"></a>        function := Eval(node.Function, env)</span>\n<span id=\"cb95-7\"><a href=\"#cb95-7\"></a>        <span class=\"kw\">if</span> isError(function) {</span>\n<span id=\"cb95-8\"><a href=\"#cb95-8\"></a>            <span class=\"kw\">return</span> function</span>\n<span id=\"cb95-9\"><a href=\"#cb95-9\"></a>        }</span>\n<span id=\"cb95-10\"><a href=\"#cb95-10\"></a>        args := evalExpressions(node.Arguments, env)</span>\n<span id=\"cb95-11\"><a href=\"#cb95-11\"></a>        <span class=\"kw\">if</span> <span class=\"bu\">len</span>(args) == <span class=\"dv\">1</span> &amp;&amp; isError(args[<span class=\"dv\">0</span>]) {</span>\n<span id=\"cb95-12\"><a href=\"#cb95-12\"></a>            <span class=\"kw\">return</span> args[<span class=\"dv\">0</span>]</span>\n<span id=\"cb95-13\"><a href=\"#cb95-13\"></a>        }</span>\n<span id=\"cb95-14\"><a href=\"#cb95-14\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb95-15\"><a href=\"#cb95-15\"></a>}</span>\n<span id=\"cb95-16\"><a href=\"#cb95-16\"></a></span>\n<span id=\"cb95-17\"><a href=\"#cb95-17\"></a><span class=\"kw\">func</span> evalExpressions(</span>\n<span id=\"cb95-18\"><a href=\"#cb95-18\"></a>    exps []ast.Expression,</span>\n<span id=\"cb95-19\"><a href=\"#cb95-19\"></a>    env *object.Environment,</span>\n<span id=\"cb95-20\"><a href=\"#cb95-20\"></a>) []object.Object {</span>\n<span id=\"cb95-21\"><a href=\"#cb95-21\"></a>    <span class=\"kw\">var</span> result []object.Object</span>\n<span id=\"cb95-22\"><a href=\"#cb95-22\"></a></span>\n<span id=\"cb95-23\"><a href=\"#cb95-23\"></a>    <span class=\"kw\">for</span> _, e := <span class=\"kw\">range</span> exps {</span>\n<span id=\"cb95-24\"><a href=\"#cb95-24\"></a>        evaluated := Eval(e, env)</span>\n<span id=\"cb95-25\"><a href=\"#cb95-25\"></a>        <span class=\"kw\">if</span> isError(evaluated) {</span>\n<span id=\"cb95-26\"><a href=\"#cb95-26\"></a>            <span class=\"kw\">return</span> []object.Object{evaluated}</span>\n<span id=\"cb95-27\"><a href=\"#cb95-27\"></a>        }</span>\n<span id=\"cb95-28\"><a href=\"#cb95-28\"></a>        result = <span class=\"bu\">append</span>(result, evaluated)</span>\n<span id=\"cb95-29\"><a href=\"#cb95-29\"></a>    }</span>\n<span id=\"cb95-30\"><a href=\"#cb95-30\"></a></span>\n<span id=\"cb95-31\"><a href=\"#cb95-31\"></a>    <span class=\"kw\">return</span> result</span>\n<span id=\"cb95-32\"><a href=\"#cb95-32\"></a>}</span></code></pre></div>\n<p>Nothing fancy going on here. We just iterate over a list of <code>ast.Expression</code>s and evaluate them in the context of the current environment. If we encounter an error, we stop the evaluation and return the error. This is also the part where we decided to evaluate the arguments from left-to-right. Hopefully we won’t be writing code in Monkey that makes assertions about the order of argument evaluation, but if we do, we’re on the conservative and safe side of programming language design.</p>\n<p>So! Now that we have both the function and the list of evaluated arguments, how do we “call the function”? How do we apply the function to the arguments?</p>\n<p>The obvious answer is that we have to evaluate the body of the function, which is just a block statement. We already know how to evaluate those, so why not just call <code>Eval</code> and pass it the body of the function? One word: arguments. The body of the function can contain references to the parameters of the function and just evaluating the body in the current environment would result in references to unknown names, which would lead to errors, which is not what we want. Evaluating the body as it is, in the current environment, does not work.</p>\n<p>What we need to do instead is change the environment in which the function is evaluated, so that the references to parameters in the function’s body resolve to the correct arguments. But we can’t just add these arguments to the current environment. That could lead to previous bindings being overwritten, which is not what we want. We want this to work:</p>\n<div class=\"sourceCode\" id=\"cb96\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb96-1\"><a href=\"#cb96-1\"></a><span class=\"kw\">let</span> i <span class=\"op\">=</span> <span class=\"dv\">5</span><span class=\"op\">;</span></span>\n<span id=\"cb96-2\"><a href=\"#cb96-2\"></a><span class=\"kw\">let</span> printNum <span class=\"op\">=</span> fn(i) {</span>\n<span id=\"cb96-3\"><a href=\"#cb96-3\"></a>  puts(i)<span class=\"op\">;</span></span>\n<span id=\"cb96-4\"><a href=\"#cb96-4\"></a>}<span class=\"op\">;</span></span>\n<span id=\"cb96-5\"><a href=\"#cb96-5\"></a></span>\n<span id=\"cb96-6\"><a href=\"#cb96-6\"></a>printNum(<span class=\"dv\">10</span>)<span class=\"op\">;</span></span>\n<span id=\"cb96-7\"><a href=\"#cb96-7\"></a>puts(i)<span class=\"op\">;</span></span></code></pre></div>\n<p>With a <code>puts</code> function that prints lines, this should print two lines, containing <code>10</code> and <code>5</code> respectively. If we were to overwrite the current environment before evaluating the body of <code>printNum</code>, the last line would also result in <code>10</code> being printed.</p>\n<p>So adding the arguments of the function call to the current environment in order to make them accessible in the function’s body does not work. What we need to do instead is to preserve previous bindings while at the same time making new ones available - we’ll call that “extending the environment”.</p>\n<p>Extending the environment means that we create a new instance of <code>object.Environment</code> with a pointer to the environment it should extend. By doing that we enclose a fresh and empty environment with an existing one.</p>\n<p>When the new environment’s <code>Get</code> method is called and it itself doesn’t have a value associated with the given name, it calls the <code>Get</code> of the enclosing environment. That’s the environment it’s extending. And if that enclosing environment can’t find the value, it calls its own enclosing environment and so on until there is no enclosing environment anymore and we can safely say that we have an “ERROR: unknown identifier: foobar”.</p>\n<div class=\"sourceCode\" id=\"cb97\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb97-1\"><a href=\"#cb97-1\"></a><span class=\"co\">// object/environment.go</span></span>\n<span id=\"cb97-2\"><a href=\"#cb97-2\"></a></span>\n<span id=\"cb97-3\"><a href=\"#cb97-3\"></a><span class=\"kw\">package</span> object</span>\n<span id=\"cb97-4\"><a href=\"#cb97-4\"></a></span>\n<span id=\"cb97-5\"><a href=\"#cb97-5\"></a><span class=\"kw\">func</span> NewEnclosedEnvironment(outer *Environment) *Environment {</span>\n<span id=\"cb97-6\"><a href=\"#cb97-6\"></a>    env := NewEnvironment()</span>\n<span id=\"cb97-7\"><a href=\"#cb97-7\"></a>    env.outer = outer</span>\n<span id=\"cb97-8\"><a href=\"#cb97-8\"></a>    <span class=\"kw\">return</span> env</span>\n<span id=\"cb97-9\"><a href=\"#cb97-9\"></a>}</span>\n<span id=\"cb97-10\"><a href=\"#cb97-10\"></a></span>\n<span id=\"cb97-11\"><a href=\"#cb97-11\"></a><span class=\"kw\">func</span> NewEnvironment() *Environment {</span>\n<span id=\"cb97-12\"><a href=\"#cb97-12\"></a>    s := <span class=\"bu\">make</span>(<span class=\"kw\">map</span>[<span class=\"dt\">string</span>]Object)</span>\n<span id=\"cb97-13\"><a href=\"#cb97-13\"></a>    <span class=\"kw\">return</span> &amp;Environment{store: s, outer: <span class=\"ot\">nil</span>}</span>\n<span id=\"cb97-14\"><a href=\"#cb97-14\"></a>}</span>\n<span id=\"cb97-15\"><a href=\"#cb97-15\"></a></span>\n<span id=\"cb97-16\"><a href=\"#cb97-16\"></a><span class=\"kw\">type</span> Environment <span class=\"kw\">struct</span> {</span>\n<span id=\"cb97-17\"><a href=\"#cb97-17\"></a>    store <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]Object</span>\n<span id=\"cb97-18\"><a href=\"#cb97-18\"></a>    outer *Environment</span>\n<span id=\"cb97-19\"><a href=\"#cb97-19\"></a>}</span>\n<span id=\"cb97-20\"><a href=\"#cb97-20\"></a></span>\n<span id=\"cb97-21\"><a href=\"#cb97-21\"></a><span class=\"kw\">func</span> (e *Environment) Get(name <span class=\"dt\">string</span>) (Object, <span class=\"dt\">bool</span>) {</span>\n<span id=\"cb97-22\"><a href=\"#cb97-22\"></a>    obj, ok := e.store[name]</span>\n<span id=\"cb97-23\"><a href=\"#cb97-23\"></a>    <span class=\"kw\">if</span> !ok &amp;&amp; e.outer != <span class=\"ot\">nil</span> {</span>\n<span id=\"cb97-24\"><a href=\"#cb97-24\"></a>        obj, ok = e.outer.Get(name)</span>\n<span id=\"cb97-25\"><a href=\"#cb97-25\"></a>    }</span>\n<span id=\"cb97-26\"><a href=\"#cb97-26\"></a>    <span class=\"kw\">return</span> obj, ok</span>\n<span id=\"cb97-27\"><a href=\"#cb97-27\"></a>}</span>\n<span id=\"cb97-28\"><a href=\"#cb97-28\"></a></span>\n<span id=\"cb97-29\"><a href=\"#cb97-29\"></a><span class=\"kw\">func</span> (e *Environment) Set(name <span class=\"dt\">string</span>, val Object) Object {</span>\n<span id=\"cb97-30\"><a href=\"#cb97-30\"></a>    e.store[name] = val</span>\n<span id=\"cb97-31\"><a href=\"#cb97-31\"></a>    <span class=\"kw\">return</span> val</span>\n<span id=\"cb97-32\"><a href=\"#cb97-32\"></a>}</span></code></pre></div>\n<p><code>object.Environment</code> now has a new field called <code>outer</code> that can contain a reference to another <code>object.Environment</code>, which is the enclosing environment, the one it’s extending. The <code>NewEnclosedEnvironment</code> function makes creating such an enclosed environment easy. The <code>Get</code> method has also been changed. It now checks the enclosing environment for the given name, too.</p>\n<p>This new behaviour mirrors how we think about variable scopes. There are an inner scope and an outer scope. If something is not found in the inner scope, it’s looked up in the outer scope. The outer scope <em>encloses</em> the inner scope. And the inner scope <em>extends</em> the outer one.</p>\n<p>With our updated <code>object.Environment</code> functionality we can correctly evaluate function bodies. Remember, the problem was this: possibly overwriting existing bindings in a environment when binding the arguments of a function call to the parameter names of the function. Now, instead of overwriting bindings, we create a new environment that’s enclosed by the current environment and add our bindings to this fresh and empty environment.</p>\n<p>But we won’t use the current environment as the enclosing environment, no. Instead we’ll use the environment our <code>*object.Function</code> carries around. Remember that one? That’s the environment our function was defined in.</p>\n<p>Here is the updated version of <code>Eval</code> that handles function calls completely and correctly:</p>\n<div class=\"sourceCode\" id=\"cb98\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb98-1\"><a href=\"#cb98-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb98-2\"><a href=\"#cb98-2\"></a></span>\n<span id=\"cb98-3\"><a href=\"#cb98-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb98-4\"><a href=\"#cb98-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb98-5\"><a href=\"#cb98-5\"></a>    <span class=\"kw\">case</span> *ast.CallExpression:</span>\n<span id=\"cb98-6\"><a href=\"#cb98-6\"></a>        function := Eval(node.Function, env)</span>\n<span id=\"cb98-7\"><a href=\"#cb98-7\"></a>        <span class=\"kw\">if</span> isError(function) {</span>\n<span id=\"cb98-8\"><a href=\"#cb98-8\"></a>            <span class=\"kw\">return</span> function</span>\n<span id=\"cb98-9\"><a href=\"#cb98-9\"></a>        }</span>\n<span id=\"cb98-10\"><a href=\"#cb98-10\"></a>        args := evalExpressions(node.Arguments, env)</span>\n<span id=\"cb98-11\"><a href=\"#cb98-11\"></a>        <span class=\"kw\">if</span> <span class=\"bu\">len</span>(args) == <span class=\"dv\">1</span> &amp;&amp; isError(args[<span class=\"dv\">0</span>]) {</span>\n<span id=\"cb98-12\"><a href=\"#cb98-12\"></a>            <span class=\"kw\">return</span> args[<span class=\"dv\">0</span>]</span>\n<span id=\"cb98-13\"><a href=\"#cb98-13\"></a>        }</span>\n<span id=\"cb98-14\"><a href=\"#cb98-14\"></a></span>\n<span id=\"cb98-15\"><a href=\"#cb98-15\"></a>        <span class=\"kw\">return</span> applyFunction(function, args)</span>\n<span id=\"cb98-16\"><a href=\"#cb98-16\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb98-17\"><a href=\"#cb98-17\"></a>}</span>\n<span id=\"cb98-18\"><a href=\"#cb98-18\"></a></span>\n<span id=\"cb98-19\"><a href=\"#cb98-19\"></a><span class=\"kw\">func</span> applyFunction(fn object.Object, args []object.Object) object.Object {</span>\n<span id=\"cb98-20\"><a href=\"#cb98-20\"></a>    function, ok := fn.(*object.Function)</span>\n<span id=\"cb98-21\"><a href=\"#cb98-21\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb98-22\"><a href=\"#cb98-22\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;not a function: %s&quot;</span>, fn.Type())</span>\n<span id=\"cb98-23\"><a href=\"#cb98-23\"></a>    }</span>\n<span id=\"cb98-24\"><a href=\"#cb98-24\"></a></span>\n<span id=\"cb98-25\"><a href=\"#cb98-25\"></a>    extendedEnv := extendFunctionEnv(function, args)</span>\n<span id=\"cb98-26\"><a href=\"#cb98-26\"></a>    evaluated := Eval(function.Body, extendedEnv)</span>\n<span id=\"cb98-27\"><a href=\"#cb98-27\"></a>    <span class=\"kw\">return</span> unwrapReturnValue(evaluated)</span>\n<span id=\"cb98-28\"><a href=\"#cb98-28\"></a>}</span>\n<span id=\"cb98-29\"><a href=\"#cb98-29\"></a></span>\n<span id=\"cb98-30\"><a href=\"#cb98-30\"></a><span class=\"kw\">func</span> extendFunctionEnv(</span>\n<span id=\"cb98-31\"><a href=\"#cb98-31\"></a>    fn *object.Function,</span>\n<span id=\"cb98-32\"><a href=\"#cb98-32\"></a>    args []object.Object,</span>\n<span id=\"cb98-33\"><a href=\"#cb98-33\"></a>) *object.Environment {</span>\n<span id=\"cb98-34\"><a href=\"#cb98-34\"></a>    env := object.NewEnclosedEnvironment(fn.Env)</span>\n<span id=\"cb98-35\"><a href=\"#cb98-35\"></a></span>\n<span id=\"cb98-36\"><a href=\"#cb98-36\"></a>    <span class=\"kw\">for</span> paramIdx, param := <span class=\"kw\">range</span> fn.Parameters {</span>\n<span id=\"cb98-37\"><a href=\"#cb98-37\"></a>        env.Set(param.Value, args[paramIdx])</span>\n<span id=\"cb98-38\"><a href=\"#cb98-38\"></a>    }</span>\n<span id=\"cb98-39\"><a href=\"#cb98-39\"></a></span>\n<span id=\"cb98-40\"><a href=\"#cb98-40\"></a>    <span class=\"kw\">return</span> env</span>\n<span id=\"cb98-41\"><a href=\"#cb98-41\"></a>}</span>\n<span id=\"cb98-42\"><a href=\"#cb98-42\"></a></span>\n<span id=\"cb98-43\"><a href=\"#cb98-43\"></a><span class=\"kw\">func</span> unwrapReturnValue(obj object.Object) object.Object {</span>\n<span id=\"cb98-44\"><a href=\"#cb98-44\"></a>    <span class=\"kw\">if</span> returnValue, ok := obj.(*object.ReturnValue); ok {</span>\n<span id=\"cb98-45\"><a href=\"#cb98-45\"></a>        <span class=\"kw\">return</span> returnValue.Value</span>\n<span id=\"cb98-46\"><a href=\"#cb98-46\"></a>    }</span>\n<span id=\"cb98-47\"><a href=\"#cb98-47\"></a></span>\n<span id=\"cb98-48\"><a href=\"#cb98-48\"></a>    <span class=\"kw\">return</span> obj</span>\n<span id=\"cb98-49\"><a href=\"#cb98-49\"></a>}</span></code></pre></div>\n<p>In the new <code>applyFunction</code> function we not only check that we really have a <code>*object.Function</code> at hand but also convert the <code>fn</code> parameter to a <code>*object.Function</code> reference in order to get access to the function’s <code>.Env</code> and <code>.Body</code> fields (which <code>object.Object</code> doesn’t define).</p>\n<p>The <code>extendFunctionEnv</code> function creates a new <code>*object.Environment</code> that’s enclosed by the function’s environment. In this new, enclosed environment it binds the arguments of the function call to the function’s parameter names.</p>\n<p>And this newly enclosed and updated environment is then the environment in which the function’s body is evaluated. The result of this evaluation is unwrapped if it’s an <code>*object.ReturnValue</code>. That’s necessary, because otherwise a <code>return</code> statement would bubble up through several functions and stop the evaluation in all of them. But we only want to stop the evaluation of the last called function’s body. That’s why we need unwrap it, so that <code>evalBlockStatement</code> won’t stop evaluating statements in “outer” functions. I also added a few test cases to our previous <code>TestReturnStatements</code> function to make sure that this works.</p>\n<p>Those were the last missing pieces. <em>What? Really?</em> Yeah! Take a look a this:</p>\n<div class=\"sourceCode\" id=\"cb99\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb99-1\"><a href=\"#cb99-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb99-2\"><a href=\"#cb99-2\"></a>ok      monkey/evaluator        0.007s</span>\n<span id=\"cb99-3\"><a href=\"#cb99-3\"></a>$ go run main.go</span>\n<span id=\"cb99-4\"><a href=\"#cb99-4\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb99-5\"><a href=\"#cb99-5\"></a>Feel free to type in commands</span>\n<span id=\"cb99-6\"><a href=\"#cb99-6\"></a>&gt;&gt; let addTwo = fn(x) { x + 2; };</span>\n<span id=\"cb99-7\"><a href=\"#cb99-7\"></a>&gt;&gt; addTwo(2)</span>\n<span id=\"cb99-8\"><a href=\"#cb99-8\"></a>4</span>\n<span id=\"cb99-9\"><a href=\"#cb99-9\"></a>&gt;&gt; let multiply = fn(x, y) { x * y };</span>\n<span id=\"cb99-10\"><a href=\"#cb99-10\"></a>&gt;&gt; multiply(50 / 2, 1 * 2)</span>\n<span id=\"cb99-11\"><a href=\"#cb99-11\"></a>50</span>\n<span id=\"cb99-12\"><a href=\"#cb99-12\"></a>&gt;&gt; fn(x) { x == 10 }(5)</span>\n<span id=\"cb99-13\"><a href=\"#cb99-13\"></a>false</span>\n<span id=\"cb99-14\"><a href=\"#cb99-14\"></a>&gt;&gt; fn(x) { x == 10 }(10)</span>\n<span id=\"cb99-15\"><a href=\"#cb99-15\"></a>true</span></code></pre></div>\n<p><em>Whaaat?</em> Yes! It works! We can now finally define and call functions! There’s a saying that goes “this is nothing to write home about”. Well, this is! But before we put on our party hats, it’s worth taking a closer look at the interaction between functions and their environment and what it means for function application. Because what we’ve seen is not all we can do, there is a lot more.</p>\n<p>So, I bet that one question still bugs you: “Why extend the function’s environment and not the current environment?” The short answer is this:</p>\n<div class=\"sourceCode\" id=\"cb100\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb100-1\"><a href=\"#cb100-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb100-2\"><a href=\"#cb100-2\"></a></span>\n<span id=\"cb100-3\"><a href=\"#cb100-3\"></a><span class=\"kw\">func</span> TestClosures(t *testing.T) {</span>\n<span id=\"cb100-4\"><a href=\"#cb100-4\"></a>    input := <span class=\"st\">`</span></span>\n<span id=\"cb100-5\"><a href=\"#cb100-5\"></a><span class=\"st\">let newAdder = fn(x) {</span></span>\n<span id=\"cb100-6\"><a href=\"#cb100-6\"></a><span class=\"st\">  fn(y) { x + y };</span></span>\n<span id=\"cb100-7\"><a href=\"#cb100-7\"></a><span class=\"st\">};</span></span>\n<span id=\"cb100-8\"><a href=\"#cb100-8\"></a></span>\n<span id=\"cb100-9\"><a href=\"#cb100-9\"></a><span class=\"st\">let addTwo = newAdder(2);</span></span>\n<span id=\"cb100-10\"><a href=\"#cb100-10\"></a><span class=\"st\">addTwo(2);`</span></span>\n<span id=\"cb100-11\"><a href=\"#cb100-11\"></a></span>\n<span id=\"cb100-12\"><a href=\"#cb100-12\"></a>    testIntegerObject(t, testEval(input), <span class=\"dv\">4</span>)</span>\n<span id=\"cb100-13\"><a href=\"#cb100-13\"></a>}</span></code></pre></div>\n<p>This test passes. Yes, really:</p>\n<div class=\"sourceCode\" id=\"cb101\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb101-1\"><a href=\"#cb101-1\"></a>$ go run main.go</span>\n<span id=\"cb101-2\"><a href=\"#cb101-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb101-3\"><a href=\"#cb101-3\"></a>Feel free to type in commands</span>\n<span id=\"cb101-4\"><a href=\"#cb101-4\"></a>&gt;&gt; let newAdder = fn(x) { fn(y) { x + y } };</span>\n<span id=\"cb101-5\"><a href=\"#cb101-5\"></a>&gt;&gt; let addTwo = newAdder(2);</span>\n<span id=\"cb101-6\"><a href=\"#cb101-6\"></a>&gt;&gt; addTwo(3);</span>\n<span id=\"cb101-7\"><a href=\"#cb101-7\"></a>5</span>\n<span id=\"cb101-8\"><a href=\"#cb101-8\"></a>&gt;&gt; let addThree = newAdder(3);</span>\n<span id=\"cb101-9\"><a href=\"#cb101-9\"></a>&gt;&gt; addThree(10);</span>\n<span id=\"cb101-10\"><a href=\"#cb101-10\"></a>13</span></code></pre></div>\n<p>Monkey has closures and they already work in our interpreter. How cool is that? Exactly. Very cool. But the connection between closures and the original question might not be so clear yet. Closures are functions that “close over” the environment they were defined in. They carry their own environment around and whenever they’re called they can access it.</p>\n<p>The two important lines from the example above are these:</p>\n<div class=\"sourceCode\" id=\"cb102\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb102-1\"><a href=\"#cb102-1\"></a><span class=\"kw\">let</span> newAdder <span class=\"op\">=</span> fn(x) { fn(y) { x <span class=\"op\">+</span> y } }<span class=\"op\">;</span></span>\n<span id=\"cb102-2\"><a href=\"#cb102-2\"></a><span class=\"kw\">let</span> addTwo <span class=\"op\">=</span> newAdder(<span class=\"dv\">2</span>)<span class=\"op\">;</span></span></code></pre></div>\n<p><code>newAdder</code> here is a higher-order function. Higher-order functions are functions that either return other functions or receive them as arguments. In this case <code>newAdder</code> returns another function. But not just any function: a closure. <code>addTwo</code> is bound to the closure that’s returned when calling <code>newAdder</code> with <code>2</code> as the sole argument.</p>\n<p>And what makes <code>addTwo</code> a closure? The bindings it has access to when called.</p>\n<p>When <code>addTwo</code> is called it not only has access to the arguments of the call, the <code>y</code> parameter, but it can also reach the value <code>x</code> was bound to at the time of the <code>newAdder(2)</code> call, even though that binding is long out of scope and not existent in the current environment anymore:</p>\n<div class=\"sourceCode\" id=\"cb103\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb103-1\"><a href=\"#cb103-1\"></a>&gt;&gt; let newAdder = fn(x) { fn(y) { x + y } };</span>\n<span id=\"cb103-2\"><a href=\"#cb103-2\"></a>&gt;&gt; let addTwo = newAdder(2);</span>\n<span id=\"cb103-3\"><a href=\"#cb103-3\"></a>&gt;&gt; x</span>\n<span id=\"cb103-4\"><a href=\"#cb103-4\"></a>ERROR: identifier not found: x</span></code></pre></div>\n<p><code>x</code> is not bound to a value in our top-level environment. But <code>addTwo</code> still has access to it:</p>\n<div class=\"sourceCode\" id=\"cb104\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb104-1\"><a href=\"#cb104-1\"></a>&gt;&gt; addTwo(3);</span>\n<span id=\"cb104-2\"><a href=\"#cb104-2\"></a>5</span></code></pre></div>\n<p>In other words: the closure <code>addTwo</code> still has access to the environment that was the current environment at the time of its definition. Which is when the last line of <code>newAdder</code>’s body was evaluated. This last line is a function literal. Remember: when function literals are evaluated we build an <code>object.Function</code> and keep a reference to the current environment in its <code>.Env</code> field.</p>\n<p>When we later on evaluate the body of <code>addTwo</code>, we don’t evaluate it in the current environment, but instead in the function’s environment. And we do that by extending the function’s environment and passing it to <code>Eval</code> instead of the current environment. Why? So it can still access it. Why? So we can use closures. Why? Because they’re freaking amazing and I love them!</p>\n<p>And since we’re talking about amazing things, it’s worth mentioning that we not only support returning functions from other functions but also accepting functions as arguments in a function call. Yes, functions are first-class citizens in Monkey and we can pass them around like any other value:</p>\n<div class=\"sourceCode\" id=\"cb105\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb105-1\"><a href=\"#cb105-1\"></a>&gt;&gt; let add = fn(a, b) { a + b };</span>\n<span id=\"cb105-2\"><a href=\"#cb105-2\"></a>&gt;&gt; let sub = fn(a, b) { a - b };</span>\n<span id=\"cb105-3\"><a href=\"#cb105-3\"></a>&gt;&gt; let applyFunc = fn(a, b, func) { func(a, b) };</span>\n<span id=\"cb105-4\"><a href=\"#cb105-4\"></a>&gt;&gt; applyFunc(2, 2, add);</span>\n<span id=\"cb105-5\"><a href=\"#cb105-5\"></a>4</span>\n<span id=\"cb105-6\"><a href=\"#cb105-6\"></a>&gt;&gt; applyFunc(10, 2, sub);</span>\n<span id=\"cb105-7\"><a href=\"#cb105-7\"></a>8</span></code></pre></div>\n<p>Here we pass the <code>add</code> and <code>sub</code> functions as arguments to <code>applyFunc</code>. <code>applyFunc</code> then calls this function without any problems: the <code>func</code> parameter resolves to the function object which then gets called with two arguments. There is not much more to it, everything works already in our interpreter.</p>\n<p>I know what you’re thinking right now and here is a template for the message you want to send:</p>\n<p><strong>Dear NAME_OF_FRIEND, remember when I said that someday I’ll be someone and do something great people will remember me for? Well, today’s the day. My Monkey interpreter works and it supports functions, higher-order functions, closures and integers and arithmetic and long story short: I’ve never been happier in my life!</strong></p>\n<p>We did it. We built a fully working Monkey interpreter that supports functions and function calls, higher-order functions and closures. Go on, celebrate! I’ll be waiting here.</p>\n</section>\n<section id=\"whos-taking-the-trash-out\" class=\"level2\" data-number=\"3.11\">\n<h2 data-number=\"3.11\">3.11 - Who’s taking the trash out?</h2>\n<p>At the beginning of this book I promised you that we wouldn’t take any shortcuts and build a fully functional interpreter with our own hands, from scratch and without any third party tools. And we did! But now I have a small confession to make.</p>\n<p>Consider what happens when we run this snippet of Monkey code in our interpreter:</p>\n<div class=\"sourceCode\" id=\"cb106\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb106-1\"><a href=\"#cb106-1\"></a><span class=\"kw\">let</span> counter <span class=\"op\">=</span> fn(x) {</span>\n<span id=\"cb106-2\"><a href=\"#cb106-2\"></a>  <span class=\"cf\">if</span> (x <span class=\"op\">&gt;</span> <span class=\"dv\">100</span>) {</span>\n<span id=\"cb106-3\"><a href=\"#cb106-3\"></a>    <span class=\"cf\">return</span> <span class=\"kw\">true</span><span class=\"op\">;</span></span>\n<span id=\"cb106-4\"><a href=\"#cb106-4\"></a>  } <span class=\"cf\">else</span> {</span>\n<span id=\"cb106-5\"><a href=\"#cb106-5\"></a>    <span class=\"kw\">let</span> foobar <span class=\"op\">=</span> <span class=\"dv\">9999</span><span class=\"op\">;</span></span>\n<span id=\"cb106-6\"><a href=\"#cb106-6\"></a>    counter(x <span class=\"op\">+</span> <span class=\"dv\">1</span>)<span class=\"op\">;</span></span>\n<span id=\"cb106-7\"><a href=\"#cb106-7\"></a>  }</span>\n<span id=\"cb106-8\"><a href=\"#cb106-8\"></a>}<span class=\"op\">;</span></span>\n<span id=\"cb106-9\"><a href=\"#cb106-9\"></a></span>\n<span id=\"cb106-10\"><a href=\"#cb106-10\"></a>counter(<span class=\"dv\">0</span>)<span class=\"op\">;</span></span></code></pre></div>\n<p>Obviously, it would return ‘true’ after evaluating the body of <code>counter</code> 101 times. But a lot is happening until the last of these recursive calls to <code>counter</code> returns.</p>\n<p>The first thing is the evaluation if-else-expression condition: <code>x &gt; 100</code>. If the produced value is not truthy, the alternative of the if-else-expression gets evaluated. In the alternative the integer literal <code>9999</code> gets bound to the name <code>foobar</code>, which is never referenced again. Then <code>x + 1</code> is evaluated. The result of that call to <code>Eval</code> is then passed to another call to <code>counter</code>. And then it all starts again, until <code>x &gt; 100</code> evaluates to <code>TRUE</code>.</p>\n<p>The point is this: in each call to <code>counter</code> a lot of objects are allocated. Or to put it in terms of our <code>Eval</code> function and our object system: each evaluation of <code>counter</code>’s body results in a lot of <code>object.Integer</code> being allocated and instantiated. The unused <code>9999</code> integer literal and the result of <code>x + 1</code> are obvious. But even the literals <code>100</code> and <code>1</code> produce new <code>object.Integer</code>s every time the body of <code>counter</code> is evaluated.</p>\n<p>If we were to modify our <code>Eval</code> function to track every instance of <code>&amp;object.Integer{}</code>, we’d see that running this small snippet of code results in around 400 allocated <code>object.Integer</code>s.</p>\n<p>What’s the problem with that?</p>\n<p>Our objects are stored in memory. The more objects we use the more memory we need. And even though the number of objects in the example is tiny compared to other programs memory is not infinite.</p>\n<p>With each call to <code>counter</code> the memory usage of our interpreter process should rise until it eventually runs out of memory and the operating system kills it. But if we were to monitor memory usage while running the snippet above, we’d see that it doesn’t steadily rise and never goes down. Instead it increases and decreases. Why?</p>\n<p>The answer to that question is the heart of the confession I have to make: we’re reusing Go’s garbage collector as a garbage collector for our guest language. We do not need to write our own.</p>\n<p>Go’s garbage collector (GC) is the reason why we don’t run out of memory. It manages memory for us. Even when we call the <code>counter</code> function from above many, many times and thus add a lot more unused integer literals and object allocations, we won’t run out of memory. Because the GC keeps track of which <code>object.Integer</code> are still reachable by us and which are not. When it notices that an object is not reachable anymore it makes the object’s memory available again.</p>\n<p>The example above generates a lot of integer objects that are unreachable after a call to <code>counter</code>: the literals <code>1</code> and <code>100</code> and the nonsense <code>9999</code> bound to <code>foobar</code>. There is no way to access these objects after <code>counter</code> returns. In the case of <code>1</code> and <code>100</code> it’s clear that they’re unreachable, since they’re not bound to a name. But even the <code>9999</code> bound to <code>foobar</code> is unreachable since <code>foobar</code> is out of scope when the function returns. The environment that was constructed for the evaluation of <code>counter</code>’s body gets destroyed (also by Go’s GC, mind you!) and with it the <code>foobar</code> binding.</p>\n<p>These unreachable objects are useless and take up memory. That’s why the GC collects them and frees up the memory they used.</p>\n<p>And that’s super handy for us! That saves us a lot of work! If we were to write our interpreter in a language like C, where we don’t have a GC, we’d need to implement one ourselves to manage memory for users of the interpreter.</p>\n<p>What would such a hypothetical GC need to do? In short: keep track of object allocations and references to objects, make enough memory available for future object allocations and give memory back when it’s not needed anymore. This last point is what garbage collection is all about. Without it the programs would “leak” and finally run out of memory.</p>\n<p>There are a myriad ways to accomplish all of the above, involving different algorithms and implementations. For example, there’s the basic “mark and sweep” algorithm. In order to implement it one has to decide whether the GC will be a generational GC or not, or whether it’s a stop-the-world GC or a concurrent GC, or how it’s organizing memory and handling memory fragmentation. Having decided all of that an efficient implementation is still a lot of hard work.</p>\n<p>But maybe you’re asking yourself: <em>Okay, so we have the GC of Go available. But can’t we just write our own GC for the guest language and use that one instead?</em></p>\n<p>Unfortunately, no. We’d have to disable Go’s GC and find a way to take over all of its duties. That’s easier said than done. It’s a huge undertaking since we would also have to take care of allocating and freeing memory ourselves - in a language that per default prohibits exactly that.</p>\n<p>That’s why I decided to not add a “Let’s write our own GC next to Go’s GC” section to this book and to instead reuse Go’s GC. Garbage collection itself is a huge topic and adding the dimension of working around an existing GC blows it out of the scope of this book. But still, I hope that this section gave you a rough idea of what a GC does and which problems it solves. Maybe you even know now what to do if you were to translate the interpreter we built here into another host language without garbage collection.</p>\n<p>And with that… we’re done! Our interpreter works. All that’s left for us is to extend it and make it more useful by adding more data types and functions.</p>\n</section>\n</section>\n</body>\n</html>\n" }, Chapter { title: "Extending the Interpreter", sections: [Section { title: "Extending the Interpreter", start_line: 0, fragment_id: Some("extending-the-interpreter") }, Section { title: "4.1 - Data Types & Functions", start_line: 2, fragment_id: Some("data-types-functions") }, Section { title: "4.2 - Strings", start_line: 33, fragment_id: Some("strings") }, Section { title: "4.3 - Built-in Functions", start_line: 482, fragment_id: Some("built-in-functions") }, Section { title: "4.4 - Array", start_line: 759, fragment_id: Some("array") }, Section { title: "4.5 - Hashes", start_line: 1820, fragment_id: Some("hashes") }, Section { title: "4.6 - The Grand Finale", start_line: 2834, fragment_id: Some("the-grand-finale") }], content_lines: [RenderedLine { text: "Extending the Interpreter", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "4.1 - Data Types & Functions", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Even though our interpreter works amazingly well and has some mind-blowing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "features, like first-class functions and closures, the only data types", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we had available as users of Monkey were integers and booleans. That’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "not especially useful and a lot less than what we’re used to from other", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programming languages. In this chapter we’re going to change that. We’re", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "going to add new data types to our interpreter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The great thing about this endeavor is that it takes us through the whole", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter again. We will add new token types, modify the lexer, extend the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser and finally add support for the data types to our evaluator and the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object system.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Even better is that the data types we’re going to add are already present", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in Go. That means that we only need to make them available in Monkey. We", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "don’t need to implement them from scratch, which is pretty handy, since this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "book isn’t called “Implementing Common Data Structures In Go” and we can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "concentrate on our interpreter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In addition to that we’re also going to make the interpreter much", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "more powerful by adding some new functions. Of course, as users of our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter we could define functions ourselves just fine, but those were", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "limited in what they could do. These new ones, called built-in functions,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "will be much more powerful, since they have access to the inner workings of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the Monkey programming language.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we’re going to do is add a data type we all know: the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "string. Nearly every programming language has it and Monkey shall have it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "too.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "4.2 - Strings", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In Monkey strings are a sequence of characters. They are first-class", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "values, can be bound to identifiers, used as arguments in functions calls", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and be returned by functions. They look just like the strings in many other", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programming languages: characters enclosed by double quotes.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides the data type itself, in this section we’ll also add support for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "string concatenation by supporting the infix operator + for strings.", style: Normal, search_matches: [], inline_styles: [(55, 56, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "At the end, we’ll be able to do this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let firstName = \"Thorsten\";", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let lastName = \"Ball\";", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let fullName = fn(first, last) { first + \" \" + last };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: ">> fullName(firstName, lastName);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "Thorsten Ball", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Supporting Strings in our Lexer", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we have to do is add support for string literals to our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "lexer. The basic structure of strings is this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "\"<sequence of characters>\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s not too hard, right? A sequence of characters enclosed by double", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "quotes.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What we want from our lexer is a single token for each string literal. So in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the case of \"Hello World\" we want a single token, instead of tokens for \",", style: Normal, search_matches: [], inline_styles: [(12, 25, Code), (72, 73, Code)], syntax_colors: [] }, RenderedLine { text: "Hello, World and \". A single token for string literals makes handling them", style: Normal, search_matches: [], inline_styles: [(0, 5, Code), (7, 12, Code), (17, 18, Code)], syntax_colors: [] }, RenderedLine { text: "in our parser a lot easier and we move the bulk of the work to one small", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "method in the lexer.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of course, the approach using multiple tokens is also valid and maybe", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "beneficial in some cases/parsers. We could use \" surrounding token.IDENT", style: Normal, search_matches: [], inline_styles: [(47, 48, Code), (61, 72, Code)], syntax_colors: [] }, RenderedLine { text: "tokens. But in our case, we’ll mirror the token.INT integer tokens we", style: Normal, search_matches: [], inline_styles: [(44, 53, Code)], syntax_colors: [] }, RenderedLine { text: "already have and carry the string literal itself around in the .Literal", style: Normal, search_matches: [], inline_styles: [(64, 71, Code)], syntax_colors: [] }, RenderedLine { text: "field of the token.", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And with that being clear, it’s time to work on our tokens and our lexer", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "again. We haven’t touched those since the first chapter, but I’m sure we’ll", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "do just fine.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we need to do is add a new STRING token type to our token", style: Normal, search_matches: [], inline_styles: [(43, 49, Code), (68, 73, Code)], syntax_colors: [] }, RenderedLine { text: "package:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// token/token.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    STRING = \"STRING\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With that in place we can add a test case for our lexer to see if strings", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "are properly supported. To do that we just extend the input in our", style: Normal, search_matches: [], inline_styles: [(54, 59, Code)], syntax_colors: [] }, RenderedLine { text: "TestNextToken test function:", style: Normal, search_matches: [], inline_styles: [(0, 13, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestNextToken(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `let five = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "let ten = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(x, y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  x + y;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let result = add(five, ten);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "!-/*5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 < 10 > 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (5 < 10) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "    return true;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "} else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    return false;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "10 == 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "10 != 9;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "\"foobar\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "\"foo bar\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedType    token.TokenType", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedLiteral string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.STRING, \"foobar\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.STRING, \"foo bar\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.EOF, \"\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The input now has two more lines containing the string literals we want", style: Normal, search_matches: [], inline_styles: [(4, 9, Code)], syntax_colors: [] }, RenderedLine { text: "to turn into tokens. There’s \"foobar\" to make sure that lexing of string", style: Normal, search_matches: [], inline_styles: [(31, 39, Code)], syntax_colors: [] }, RenderedLine { text: "literals works and \"foo bar\" to make sure that it still works even with", style: Normal, search_matches: [], inline_styles: [(20, 29, Code)], syntax_colors: [] }, RenderedLine { text: "whitespace inside a literal.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of course, the tests fail, because we haven’t changed anything in the Lexer", style: Normal, search_matches: [], inline_styles: [(72, 77, Code)], syntax_colors: [] }, RenderedLine { text: "yet:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestNextToken (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "  lexer_test.go:122: tests[73] - tokentype wrong. expected=\"STRING\",\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=\"ILLEGAL\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/lexer    0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fixing the tests is easier than you might think. All we need to do is add", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a case branch for \" to the switch statement in our Lexer and add a small", style: Normal, search_matches: [], inline_styles: [(2, 6, Code), (18, 19, Code), (51, 56, Code)], syntax_colors: [] }, RenderedLine { text: "helper method:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) NextToken() token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    switch l.ch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case '\"':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok.Type = token.STRING", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok.Literal = l.readString()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) readString() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    position := l.position + 1", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    for {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        l.readChar()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "        if l.ch == '\"' || l.ch == 0 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "            break", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "    return l.input[position:l.position]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There’s really nothing mysterious about these changes. A new case branch and", style: Normal, search_matches: [], inline_styles: [(63, 67, Code)], syntax_colors: [] }, RenderedLine { text: "a helper function called readString that calls readChar until it encounters", style: Normal, search_matches: [], inline_styles: [(25, 35, Code), (47, 55, Code)], syntax_colors: [] }, RenderedLine { text: "either a closing double quote or the end of the input.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If you think that this is too easy, feel free to make readString report", style: Normal, search_matches: [], inline_styles: [(54, 64, Code)], syntax_colors: [] }, RenderedLine { text: "an error instead of simply returning when it reaches the end of the input.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Or you can add support for character escaping so that string literals like", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "\"hello \\\"world\\\"\", \"hello\\n world\" and \"hello\\t\\t\\tworld\" work.", style: Normal, search_matches: [], inline_styles: [(0, 17, Code), (19, 34, Code), (39, 57, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Meanwhile, our tests are passing:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/lexer    0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Great! Our lexer now knows how to handle string literals. It’s time to teach", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the parser how to do the same.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Parsing Strings", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order for our parser to turn token.STRING into a string literal AST node", style: Normal, search_matches: [], inline_styles: [(32, 44, Code)], syntax_colors: [] }, RenderedLine { text: "we need to define said node. Thankfully the definition couldn’t be simpler.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It looks really similar to ast.IntegerLiteral, except that the Value field", style: Normal, search_matches: [], inline_styles: [(28, 46, Code), (64, 69, Code)], syntax_colors: [] }, RenderedLine { text: "now contains a string instead of an int64.", style: Normal, search_matches: [], inline_styles: [(17, 23, Code), (38, 42, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type StringLiteral struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token token.Token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (sl *StringLiteral) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "func (sl *StringLiteral) TokenLiteral() string { return sl.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "func (sl *StringLiteral) String() string       { return sl.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of course, string literals are expressions and not statements. They evaluate", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to the string.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With that definition we can write a small test case that makes", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "sure the parser knows how to handle token.STRING tokens and outputs", style: Normal, search_matches: [], inline_styles: [(36, 48, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.StringLiterals:", style: Normal, search_matches: [], inline_styles: [(0, 18, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestStringLiteralExpression(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `\"hello world\";`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    literal, ok := stmt.Expression.(*ast.StringLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"exp not *ast.StringLiteral. got=%T\", stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if literal.Value != \"hello world\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"literal.Value not %q. got=%q\", \"hello world\", literal.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 78, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Running the tests results in a well known type of parser error:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestStringLiteralExpression (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:888: parser has 1 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:890: parser error: \"no prefix parse function for STRING found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’ve seen that many times before and we know how to fix it. All we have", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to do is register a new prefixParseFn for token.STRING tokens. This parse", style: Normal, search_matches: [], inline_styles: [(25, 38, Code), (43, 55, Code)], syntax_colors: [] }, RenderedLine { text: "function then returns an *ast.StringLiteral:", style: Normal, search_matches: [], inline_styles: [(27, 44, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.STRING, p.parseStringLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseStringLiteral() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "    return &ast.StringLiteral{Token: p.curToken, Value: p.curToken.Literal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Three new lines! That’s all it takes to make the tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So now our lexer turns string literals into token.STRING tokens and the", style: Normal, search_matches: [], inline_styles: [(44, 56, Code)], syntax_colors: [] }, RenderedLine { text: "parser turns those into *ast.StringLiteral nodes. We’re now ready to make", style: Normal, search_matches: [], inline_styles: [(24, 42, Code)], syntax_colors: [] }, RenderedLine { text: "changes to our object system and the evaluator.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Evaluating Strings", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Representing a string in our object system is as easy as representing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "integers. And the biggest reason why it’s so easy is that we reuse Go’s", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "string data type. Imagine adding a data type to the guest language that", style: Normal, search_matches: [], inline_styles: [(1, 7, Code)], syntax_colors: [] }, RenderedLine { text: "can’t be represented with built-in data structures of the host language.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "E.g.: strings in C. That’s a lot more work. But instead, all we have to do", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is define a new object that holds a string:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    STRING_OBJ = \"STRING\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type String struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (s *String) Type() ObjectType { return STRING_OBJ }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "func (s *String) Inspect() string  { return s.Value }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now we need to extend our evaluator so it turns *ast.StringLiteral in", style: Normal, search_matches: [], inline_styles: [(48, 66, Code)], syntax_colors: [] }, RenderedLine { text: "object.String objects. The test to make sure that this works is tiny:", style: Normal, search_matches: [], inline_styles: [(0, 13, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestStringLiteral(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `\"Hello World!\"`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    evaluated := testEval(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    str, ok := evaluated.(*object.String)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"object is not String. got=%T (%+v)\", evaluated, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if str.Value != \"Hello World!\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"String has wrong value. got=%q\", str.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The call to Eval doesn’t return an *object.String yet but nil:", style: Normal, search_matches: [], inline_styles: [(12, 16, Code), (37, 51, Code), (60, 63, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestStringLiteral (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:317: object is not String. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Getting this test to pass needs even fewer lines than in the parser. Just", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "two:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    case *ast.StringLiteral:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.String{Value: node.Value}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That makes the tests pass and we can now use strings in our REPL:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> \"Hello world!\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello world!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let hello = \"Hello there, fellow Monkey users and fans!\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: ">> hello", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello there, fellow Monkey users and fans!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let giveMeHello = fn() { \"Hello!\" }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: ">> giveMeHello()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We now have full support for strings in our interpreter! Sweet! Or should", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I say…", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> \"This is amazing!\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "This is amazing!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "String Concatenation", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Having the string data type available is great. But we can’t do much with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "strings yet, besides creating them. Let’s change that! In this section we’re", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "going to add string concatenation to our interpreter. And we’ll do that by", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "adding support for the + infix operator with string operands.", style: Normal, search_matches: [], inline_styles: [(26, 27, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "What we want is perfectly described by this test:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestStringConcatenation(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `\"Hello\" + \" \" + \"World!\"`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    evaluated := testEval(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    str, ok := evaluated.(*object.String)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"object is not String. got=%T (%+v)\", evaluated, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if str.Value != \"Hello World!\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"String has wrong value. got=%q\", str.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can also extend our TestErrorHandling function to make sure that we only", style: Normal, search_matches: [], inline_styles: [(23, 40, Code)], syntax_colors: [] }, RenderedLine { text: "add support for the + operator and nothing more:", style: Normal, search_matches: [], inline_styles: [(20, 21, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestErrorHandling(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input           string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedMessage string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `\"Hello\" - \"World\"`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"unknown operator: STRING - STRING\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This test case is already green and acts more as specification and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "regression testing than as a guide for an implementation. But our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "concatenation test is failing:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestStringConcatenation (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:336: object is not String. got=*object.Error\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "    (&{Message:unknown operator: STRING + STRING})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The place where we need to make changes is evalInfixExpression. Here we need", style: Normal, search_matches: [], inline_styles: [(43, 62, Code)], syntax_colors: [] }, RenderedLine { text: "to add a new branch to the existing switch statement that’s evaluated when", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "both operands are strings:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalInfixExpression(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    operator string,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    left, right object.Object,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case left.Type() == object.STRING_OBJ && right.Type() == object.STRING_OBJ:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalStringInfixExpression(operator, left, right)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The evalStringInfixExpression is the most minimal implementation possible:", style: Normal, search_matches: [], inline_styles: [(4, 29, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalStringInfixExpression(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    operator string,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    left, right object.Object,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    if operator != \"+\" {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"unknown operator: %s %s %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "            left.Type(), operator, right.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    leftVal := left.(*object.String).Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    rightVal := right.(*object.String).Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    return &object.String{Value: leftVal + rightVal}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing here is the check for the correct operator. If it’s the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "supported + we unwrap the string objects and construct a new string that’s a", style: Normal, search_matches: [], inline_styles: [(11, 12, Code)], syntax_colors: [] }, RenderedLine { text: "concatenation of both operands.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If we want to support more operators for strings this is the place where", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to add them. Also, if we want to support comparison of strings with the ==", style: Normal, search_matches: [], inline_styles: [(72, 74, Code)], syntax_colors: [] }, RenderedLine { text: "and != we’d need to add this here too. Pointer comparison doesn’t work for", style: Normal, search_matches: [], inline_styles: [(4, 6, Code)], syntax_colors: [] }, RenderedLine { text: "strings, at least not in the way we want it to: with strings we want to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "compare values and not pointers.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s it! Our tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can now use string literals, pass them around, bind them to names, return", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "them from functions and also concatenate them:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let makeGreeter = fn(greeting) { fn(name) { greeting + \" \" + name + \"!\" } };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let hello = makeGreeter(\"Hello\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: ">> hello(\"Thorsten\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello Thorsten!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let heythere = makeGreeter(\"Hey there\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: ">> heythere(\"Thorsten\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "Hey there Thorsten!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Alright! I’d say strings are now working very well in our interpreter. But", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we can still add something else to work with them…", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "4.3 - Built-in Functions", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In this section we’re going to add built-in functions to our interpreter.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "They’re called “built-in”, because they’re not defined by a user of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter and they’re not Monkey code - they are built right into the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter, into the language itself.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "These built-in functions are defined by us, in Go, and bridge the world of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Monkey with the world of our interpreter implementation. A lot of language", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implementations provide such functions to offer functionality to the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language’s user that’s not provided “inside” the language.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here’s an example: a function that returns the current time. In order to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "get the current time one could ask the kernel (or another computer, etc.).", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Asking and talking to the kernel is normally done via something called", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "system calls. But if the programming language doesn’t offer users to make", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "such system calls themselves, then the language implementation, be it the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "compiler or the interpreter, has to provide something to make these system", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "calls on behalf of the users instead.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So, again, the built-in functions we’re going to add are defined by us, the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "implementers of the interpreter. The user of the interpreter can call them,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "but we define them. What these functions can do, we leave open. The only", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "restriction they have is that they need to accept zero or more object.Object", style: Normal, search_matches: [], inline_styles: [(65, 76, Code)], syntax_colors: [] }, RenderedLine { text: "as arguments and return an object.Object.", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (29, 41, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type BuiltinFunction func(args ...Object) Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s the type definition of a callable Go function. But since we need to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "make these BuiltinFunctions available to our users we need to fit them into", style: Normal, search_matches: [], inline_styles: [(12, 27, Code)], syntax_colors: [] }, RenderedLine { text: "our object system. We do that by wrapping them:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    BUILTIN_OBJ = \"BUILTIN\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Builtin struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Fn BuiltinFunction", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (b *Builtin) Type() ObjectType { return BUILTIN_OBJ }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "func (b *Builtin) Inspect() string  { return \"builtin function\" }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There’s not much to object.Builtin, as you can see. It’s clearly just a", style: Normal, search_matches: [], inline_styles: [(22, 36, Code)], syntax_colors: [] }, RenderedLine { text: "wrapper. But in combination with object.BuiltinFunction it’s enough to get", style: Normal, search_matches: [], inline_styles: [(34, 56, Code)], syntax_colors: [] }, RenderedLine { text: "us started.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "len", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first built-in function we’re going to add to our interpreter is len.", style: Normal, search_matches: [], inline_styles: [(71, 74, Code)], syntax_colors: [] }, RenderedLine { text: "Its job is to return the number of characters in a string. It’s impossible", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to define this function as a user of Monkey. That’s why we need it to be", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "built-in. What we want from len is this:", style: Normal, search_matches: [], inline_styles: [(30, 33, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> len(\"Hello World!\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "12", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> len(\"\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "0", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> len(\"Hey Bob, how ya doin?\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "21", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I think that makes the idea behind len pretty clear. So clear in fact, that", style: Normal, search_matches: [], inline_styles: [(35, 38, Code)], syntax_colors: [] }, RenderedLine { text: "we can easily write a test for it:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestBuiltinFunctions(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected interface{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {`len(\"\")`, 0},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        {`len(\"four\")`, 4},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {`len(\"hello world\")`, 11},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        {`len(1)`, \"argument to `len` not supported, got INTEGER\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "        {`len(\"one\", \"two\")`, \"wrong number of arguments. got=2, want=1\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := testEval(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        switch expected := tt.expected.(type) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        case int:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "            testIntegerObject(t, evaluated, int64(expected))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "        case string:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "            errObj, ok := evaluated.(*object.Error)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "            if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "                t.Errorf(\"object is not Error. got=%T (%+v)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "                    evaluated, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "                continue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "            if errObj.Message != expected {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "                t.Errorf(\"wrong error message. expected=%q, got=%q\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "                    expected, errObj.Message)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So here we have a few test cases that run len through its paces: an empty", style: Normal, search_matches: [], inline_styles: [(42, 45, Code)], syntax_colors: [] }, RenderedLine { text: "string, a normal string and a string containing whitespace. It really", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "shouldn’t matter if there’s whitespace in the string, but you’ll never know,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "so I put the test case in. The last two test cases are more interesting:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we want to make sure that len returns an *object.Error when called with an", style: Normal, search_matches: [], inline_styles: [(28, 31, Code), (43, 56, Code)], syntax_colors: [] }, RenderedLine { text: "integer or with the wrong number of arguments.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If we run the tests we can see that calling len gives us an error, but not", style: Normal, search_matches: [], inline_styles: [(44, 47, Code)], syntax_colors: [] }, RenderedLine { text: "the one expected in our test case:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestBuiltinFunctions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:389: object is not Integer. got=*object.Error\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "    (&{Message:identifier not found: len})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:389: object is not Integer. got=*object.Error\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "    (&{Message:identifier not found: len})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:389: object is not Integer. got=*object.Error\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "    (&{Message:identifier not found: len})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:371: wrong error message.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    expected=\"argument to `len` not supported, got INTEGER\",\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=\"identifier not found: len\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "len can’t be found, which isn’t that baffling considering that we haven’t", style: Normal, search_matches: [], inline_styles: [(0, 3, Code)], syntax_colors: [] }, RenderedLine { text: "defined it yet.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order to do that, the first thing we have to do is provide a way for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "built-in functions to be found. One option is to add them to the top-level", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Environment, that gets passed into Eval. But instead we’re going to", style: Normal, search_matches: [], inline_styles: [(0, 18, Code), (42, 46, Code)], syntax_colors: [] }, RenderedLine { text: "keep a separate environment of built-in functions:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/builtins.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import \"monkey/object\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var builtins = map[string]*object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"len\": &object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        Fn: func(args ...object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "            return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order to make use of that, we need to edit our evalIdentifier function", style: Normal, search_matches: [], inline_styles: [(50, 64, Code)], syntax_colors: [] }, RenderedLine { text: "to lookup built-in functions as a fallback when the given identifier is not", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "bound to a value in the current environment:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalIdentifier(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    node *ast.Identifier,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    env *object.Environment,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    if val, ok := env.Get(node.Value); ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "        return val", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if builtin, ok := builtins[node.Value]; ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "        return builtin", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return newError(\"identifier not found: \" + node.Value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So now len is found when looking up the len identifier, calling it doesn’t", style: Normal, search_matches: [], inline_styles: [(7, 10, Code), (40, 43, Code)], syntax_colors: [] }, RenderedLine { text: "work yet:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> len()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "ERROR: not a function: BUILTIN", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: ">>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Running the tests gives us the same error. We need to teach our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "applyFunction about *object.Builtin and object.BuiltinFunction:", style: Normal, search_matches: [], inline_styles: [(0, 13, Code), (20, 35, Code), (40, 62, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func applyFunction(fn object.Object, args []object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch fn := fn.(type) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    case *object.Function:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        extendedEnv := extendFunctionEnv(fn, args)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := Eval(fn.Body, extendedEnv)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        return unwrapReturnValue(evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    case *object.Builtin:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        return fn.Fn(args...)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"not a function: %s\", fn.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides moving the existing lines around, what changed here is the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "addition of the case *object.Builtin branch, in which we call the", style: Normal, search_matches: [], inline_styles: [(16, 36, Code)], syntax_colors: [] }, RenderedLine { text: "object.BuiltinFunction. Doing so is as easy as using the args slice as", style: Normal, search_matches: [], inline_styles: [(0, 22, Code), (57, 61, Code)], syntax_colors: [] }, RenderedLine { text: "arguments and calling the function.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of note is that we don’t need to unwrapReturnValue when calling a built-in", style: Normal, search_matches: [], inline_styles: [(35, 52, Code)], syntax_colors: [] }, RenderedLine { text: "function. That’s because we never return an *object.ReturnValue from these", style: Normal, search_matches: [], inline_styles: [(47, 66, Code)], syntax_colors: [] }, RenderedLine { text: "functions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now the tests are rightfully complaining about NULL being returned when", style: Normal, search_matches: [], inline_styles: [(47, 51, Code)], syntax_colors: [] }, RenderedLine { text: "calling len:", style: Normal, search_matches: [], inline_styles: [(8, 11, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestBuiltinFunctions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:389: object is not Integer. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:389: object is not Integer. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:389: object is not Integer. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:366: object is not Error. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:366: object is not Error. got=*object.Null (&{})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That means that calling len works though! It’s just that it returns only", style: Normal, search_matches: [], inline_styles: [(24, 27, Code)], syntax_colors: [] }, RenderedLine { text: "NULL. But fixing this is as easy as writing any other Go function:", style: Normal, search_matches: [], inline_styles: [(1, 5, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/builtins.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/object\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var builtins = map[string]*object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"len\": &object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        Fn: func(args ...object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "            if len(args) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"wrong number of arguments. got=%d, want=1\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "                    len(args))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            switch arg := args[0].(type) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "            case *object.String:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "                return &object.Integer{Value: int64(len(arg.Value))}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "            default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"argument to `len` not supported, got %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "                    args[0].Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The most important part of this function is the call to Go’s len and the", style: Normal, search_matches: [], inline_styles: [(63, 66, Code)], syntax_colors: [] }, RenderedLine { text: "returning of a newly allocated object.Integer. Besides that we have error", style: Normal, search_matches: [], inline_styles: [(32, 46, Code)], syntax_colors: [] }, RenderedLine { text: "checking that makes sure that we can’t call this function with the wrong", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "number of arguments or with an argument of an unsupported type. And alas,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "our tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That means we can take len on a test drive in our REPL:", style: Normal, search_matches: [], inline_styles: [(23, 26, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> len(\"1234\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "4", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> len(\"Hello World!\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "12", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> len(\"Woooooohooo!\", \"len works!!\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "ERROR: wrong number of arguments. got=2, want=1", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: ">> len(12345)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "ERROR: argument to `len` not supported, got INTEGER", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Perfect! Our first built-in function works and is ready to go.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "4.4 - Array", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The data type we’re going to add to our Monkey interpreter in this section", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is the array. In Monkey an array is an ordered list of elements of possibly", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "different types. Each element in the array can be accessed individually.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Arrays are constructed by using their literal form: a comma separated list", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "of elements, enclosed by brackets.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Initializing a new array, binding it to a name and accessing individual", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "elements will look like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let myArray = [\"Thorsten\", \"Ball\", 28, fn(x) { x * x }];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: ">> myArray[0]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "Thorsten", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: ">> myArray[2]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "28", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> myArray[3](2);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "4", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As you can see, Monkey arrays really don’t care about the types of their", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "elements. Every possible value in Monkey can be an element in an array. In", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this example myArray holds two strings, an integer and a function.", style: Normal, search_matches: [], inline_styles: [(15, 22, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Accessing individual elements by their index in the array, as seen in the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "last three lines, is done with a new operator, called the index operator:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "array[index].", style: Normal, search_matches: [], inline_styles: [(0, 12, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In this section we’ll also add support for arrays to our newly added len", style: Normal, search_matches: [], inline_styles: [(71, 74, Code)], syntax_colors: [] }, RenderedLine { text: "function and also add a few more built-in functions that work with arrays:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let myArray = [\"one\", \"two\", \"three\"];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: ">> len(myArray)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "3", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> first(myArray)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "one", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: ">> rest(myArray)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "[two, three]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: ">> last(myArray)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "three", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: ">> push(myArray, \"four\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "[one, two, three, four]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The basis for our implementation of the Monkey array in our interpreter", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "will be a Go slice of type []object.Object. That means that we don’t have to", style: Normal, search_matches: [], inline_styles: [(27, 42, Code)], syntax_colors: [] }, RenderedLine { text: "implement a new data structure. We can just reuse Go’s slice.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Sounds awesome? Good! The first thing we have to do is teach our lexer a few", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "new tokens.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Supporting Arrays in our Lexer", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order to correctly parse array literals and the index operator, our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "lexer needs to be able to identify more tokens than it currently does. All", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the tokens we need in order to construct and use arrays in Monkey are [, ]", style: Normal, search_matches: [], inline_styles: [(70, 71, Code), (73, 74, Code)], syntax_colors: [] }, RenderedLine { text: "and ,. The lexer already knows about , so we only need to add support for", style: Normal, search_matches: [], inline_styles: [(4, 5, Code), (37, 38, Code)], syntax_colors: [] }, RenderedLine { text: "[ and ].", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (6, 7, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first step is to define these new token types in the token package:", style: Normal, search_matches: [], inline_styles: [(57, 62, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// token/token.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    LBRACKET = \"[\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    RBRACKET = \"]\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The second step is to extend the test suite of the lexer, which is easy,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "since we’ve done this many times before:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestNextToken(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `let five = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "let ten = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(x, y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  x + y;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let result = add(five, ten);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "!-/*5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 < 10 > 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (5 < 10) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "    return true;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "} else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    return false;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "10 == 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "10 != 9;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "\"foobar\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "\"foo bar\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "[1, 2];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedType    token.TokenType", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedLiteral string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LBRACKET, \"[\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.INT, \"1\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.COMMA, \",\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.INT, \"2\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.RBRACKET, \"]\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.SEMICOLON, \";\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.EOF, \"\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Again the input is extended to include new tokens ([1, 2] in this case) and", style: Normal, search_matches: [], inline_styles: [(10, 15, Code), (51, 57, Code)], syntax_colors: [] }, RenderedLine { text: "new tests have been added to make sure the lexer’s NextToken method really", style: Normal, search_matches: [], inline_styles: [(4, 9, Code), (53, 62, Code)], syntax_colors: [] }, RenderedLine { text: "returns token.LBRACKET and token.RBRACKET.", style: Normal, search_matches: [], inline_styles: [(9, 23, Code), (28, 42, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Making the test pass is as easy as adding these four lines to our", style: Normal, search_matches: [], inline_styles: [(48, 52, Italic)], syntax_colors: [] }, RenderedLine { text: "NextToken() method. Yes, just four:", style: Normal, search_matches: [], inline_styles: [(0, 11, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) NextToken() token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    case '[':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.LBRACKET, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    case ']':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.RBRACKET, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Alright! The tests are passing:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/lexer    0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In our parser we’ll now use token.LBRACKET and token.RBRACKET to parse", style: Normal, search_matches: [], inline_styles: [(30, 44, Code), (49, 63, Code)], syntax_colors: [] }, RenderedLine { text: "arrays.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Parsing Array Literals", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As we saw before, an array literal in Monkey is a comma-separated list of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions enclosed by an opening and a closing bracket.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[1, 2, 3 + 3, fn(x) { x }, add(2, 2)]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yes, the elements in an array literal can be any type of expression. Integer", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "literals, function literals, infix or prefix expressions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If that sounds complicated, don’t worry. We already know how to parse comma-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "separated lists of expressions - function call arguments are just that. And", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we also know how to parse something enclosed by matching tokens. In other", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "words: let’s get to it!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first thing we have to do is define the AST node for array literals.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Since we already have the essential pieces in place for this, the definition", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is rather self-explanatory:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type ArrayLiteral struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token    token.Token // the '[' token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    Elements []Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (al *ArrayLiteral) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "func (al *ArrayLiteral) TokenLiteral() string { return al.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 73, Rgb(192, 197, 206))] }, RenderedLine { text: "func (al *ArrayLiteral) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    elements := []string{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    for _, el := range al.Elements {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        elements = append(elements, el.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\"[\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(strings.Join(elements, \", \"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\"]\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The following test function makes sure that parsing array literals results", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in a *ast.ArrayLiteral being returned. (I also added a test function for", style: Normal, search_matches: [], inline_styles: [(5, 22, Code)], syntax_colors: [] }, RenderedLine { text: "empty array literals to make sure that we don’t run into nasty edge-cases)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestParsingArrayLiterals(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := \"[1, 2 * 2, 3 + 3]\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt, ok := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "    array, ok := stmt.Expression.(*ast.ArrayLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"exp not ast.ArrayLiteral. got=%T\", stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(array.Elements) != 3 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"len(array.Elements) not 3. got=%d\", len(array.Elements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    testIntegerLiteral(t, array.Elements[0], 1)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    testInfixExpression(t, array.Elements[1], 2, \"*\", 2)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    testInfixExpression(t, array.Elements[2], 3, \"+\", 3)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Just to make sure that the parsing of expressions really works the test", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "input contains two different infix operator expressions, even though integer", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "or boolean literals would be enough. Other than that the test is pretty", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "boring and asserts that the parser really returns an *ast.ArrayLiteral with", style: Normal, search_matches: [], inline_styles: [(53, 70, Code)], syntax_colors: [] }, RenderedLine { text: "the correct number of elements.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order to get the tests to pass we need to register a new prefixParseFn", style: Normal, search_matches: [], inline_styles: [(60, 73, Code)], syntax_colors: [] }, RenderedLine { text: "in our parser, since the opening token.LBRACKET of an array literal is in", style: Normal, search_matches: [], inline_styles: [(33, 47, Code)], syntax_colors: [] }, RenderedLine { text: "prefix position.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.registerPrefix(token.LBRACKET, p.parseArrayLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseArrayLiteral() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "    array := &ast.ArrayLiteral{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    array.Elements = p.parseExpressionList(token.RBRACKET)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return array", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’ve added prefixParseFns before, so that part’s not really exciting.", style: Normal, search_matches: [], inline_styles: [(14, 27, Code)], syntax_colors: [] }, RenderedLine { text: "What’s interesting here is the new method called parseExpressionList. This", style: Normal, search_matches: [], inline_styles: [(52, 71, Code)], syntax_colors: [] }, RenderedLine { text: "method is a modified and generalized version of parseCallArguments, which", style: Normal, search_matches: [], inline_styles: [(50, 68, Code)], syntax_colors: [] }, RenderedLine { text: "we used before in parseCallExpression to parse a list of comma separated", style: Normal, search_matches: [], inline_styles: [(21, 40, Code)], syntax_colors: [] }, RenderedLine { text: "arguments:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseExpressionList(end token.TokenType) []ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "    list := []ast.Expression{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if p.peekTokenIs(end) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        return list", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    list = append(list, p.parseExpression(LOWEST))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for p.peekTokenIs(token.COMMA) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        list = append(list, p.parseExpression(LOWEST))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(end) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return list", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Again, we’ve seen this before under the name parseCallArguments. The", style: Normal, search_matches: [], inline_styles: [(47, 65, Code)], syntax_colors: [] }, RenderedLine { text: "only change is that this new version now accepts an end parameter that", style: Normal, search_matches: [], inline_styles: [(53, 56, Code)], syntax_colors: [] }, RenderedLine { text: "tells the method which token signifies the end of the list. The updated", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parseCallExpression method, in which we used parseCallArguments before, now", style: Normal, search_matches: [], inline_styles: [(2, 21, Code), (47, 65, Code)], syntax_colors: [] }, RenderedLine { text: "looks like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseCallExpression(function ast.Expression) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 78, Rgb(192, 197, 206))] }, RenderedLine { text: "    exp := &ast.CallExpression{Token: p.curToken, Function: function}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "    exp.Arguments = p.parseExpressionList(token.RPAREN)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    return exp", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The only change is the call to parseExpressionList with token.RPAREN (which", style: Normal, search_matches: [], inline_styles: [(31, 50, Code), (56, 68, Code)], syntax_colors: [] }, RenderedLine { text: "signifies the end of the arguments list). We could reuse a relatively big", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "method by changing a few lines. Great! And the best of all? The tests are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "passing:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can mark “parsing array literals” as “done”.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Parsing Index Operator Expressions", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "To fully support arrays in Monkey we not only need to be able to parse", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "array literals but also index operator expressions. Maybe the name “index", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operator” doesn’t ring a bell, but I bet you know what it is. Index operator", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions look like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "myArray[0];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "myArray[1];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "myArray[2];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s the basic form at least, but there are many. Take a look at these", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "examples to spot the structure underlying them all:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[1, 2, 3, 4][2];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let myArray = [1, 2, 3, 4];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "myArray[2];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "myArray[2 + 1];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "returnsArray()[1];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Yep, you’re totally correct! The basic structure is this one:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "<expression>[<expression>]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That seems simple enough. We can define a new AST node, called", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "ast.IndexExpression, that reflects this structure:", style: Normal, search_matches: [], inline_styles: [(0, 19, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type IndexExpression struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token token.Token // The [ token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    Left  Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    Index Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (ie *IndexExpression) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "func (ie *IndexExpression) TokenLiteral() string { return ie.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "func (ie *IndexExpression) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\"(\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(ie.Left.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\"[\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(ie.Index.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\"])\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s important to note that both Left and Index are just Expressions. Left", style: Normal, search_matches: [], inline_styles: [(35, 39, Code), (44, 49, Code), (59, 69, Code), (72, 76, Code)], syntax_colors: [] }, RenderedLine { text: "is the object that’s being accessed and we’ve seen that it can be of any", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type: an identifier, an array literal, a function call. The same goes for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Index. It can be any expression. Syntactically it doesn’t make a difference", style: Normal, search_matches: [], inline_styles: [(3, 8, Code)], syntax_colors: [] }, RenderedLine { text: "which one it is, but semantically it has to produce an integer.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The fact that both Left and Index are expressions makes the parsing process", style: Normal, search_matches: [], inline_styles: [(19, 23, Code), (28, 33, Code)], syntax_colors: [] }, RenderedLine { text: "easier, because we can use our parseExpression method to parse them. But", style: Normal, search_matches: [], inline_styles: [(31, 46, Code)], syntax_colors: [] }, RenderedLine { text: "first things first! Here is the test case that makes sure our parser knows", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "how to return an *ast.IndexExpression:", style: Normal, search_matches: [], inline_styles: [(17, 37, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestParsingIndexExpressions(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := \"myArray[1 + 1]\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt, ok := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "    indexExp, ok := stmt.Expression.(*ast.IndexExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"exp not *ast.IndexExpression. got=%T\", stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 73, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !testIdentifier(t, indexExp.Left, \"myArray\") {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "        return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !testInfixExpression(t, indexExp.Index, 1, \"+\", 1) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "        return", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now, this test only asserts that the parser outputs the correct AST for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a single expression statement containing an index expression. But equally", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "important is that the parser handles the precedence of the index operator", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "correctly. The index operator has to have the highest precedence of all", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operators yet. Making sure of that is as easy as extending our existing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestOperatorPrecedenceParsing test function:", style: Normal, search_matches: [], inline_styles: [(0, 29, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestOperatorPrecedenceParsing(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"a * [1, 2, 3, 4][b * c] * d\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"((a * ([1, 2, 3, 4][(b * c)])) * d)\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"add(a * b[2], b[1], 2 * [1, 2][1])\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"add((a * (b[2])), (b[1]), (2 * ([1, 2][1])))\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The additional ( and ) in the String() output of *ast.IndexExpression help", style: Normal, search_matches: [], inline_styles: [(15, 16, Code), (21, 22, Code), (30, 38, Code), (49, 69, Code)], syntax_colors: [] }, RenderedLine { text: "us when writing these tests, since they make the precedence of the index", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operator visible. In these added test cases we expect that the precedence of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the index operator is higher than the precedence of call expressions or even", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the * operator in infix expressions.", style: Normal, search_matches: [], inline_styles: [(4, 5, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The tests fail because the parser doesn’t know anything about index", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions yet:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestOperatorPrecedenceParsing (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:393: expected=\"((a * ([1, 2, 3, 4][(b * c)])) * d)\",\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=\"(a * [1, 2, 3, 4])([(b * c)] * d)\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:968: parser has 4 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:970: parser error: \"expected next token to be ), got [ instead\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:970: parser error: \"no prefix parse function for , found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:970: parser error: \"no prefix parse function for , found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:970: parser error: \"no prefix parse function for ) found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestParsingIndexExpressions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:835: exp not *ast.IndexExpression. got=*ast.Identifier", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Even though the tests complain about a missing prefixParseFn what we want is", style: Normal, search_matches: [], inline_styles: [(47, 60, Code)], syntax_colors: [] }, RenderedLine { text: "an infixParseFn. Yes, index operator expressions do not really have a single", style: Normal, search_matches: [], inline_styles: [(3, 15, Code)], syntax_colors: [] }, RenderedLine { text: "operator between operands on each side. But in order to parse them without a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "lot of trouble it’s of advantage to act like they do, just like we did with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "call expressions. Specifically, that means treating the [ in myArray[0] as", style: Normal, search_matches: [], inline_styles: [(57, 58, Code), (62, 72, Code)], syntax_colors: [] }, RenderedLine { text: "the infix operator, myArray as the left operand and 0 as the right operand.", style: Normal, search_matches: [], inline_styles: [(22, 29, Code), (54, 55, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Doing this makes the implementation fit really nicely into our parser:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.registerInfix(token.LBRACKET, p.parseIndexExpression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseIndexExpression(left ast.Expression) ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "    exp := &ast.IndexExpression{Token: p.curToken, Left: left}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    exp.Index = p.parseExpression(LOWEST)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.RBRACKET) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return exp", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Neat! But that doesn’t fix our tests:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestOperatorPrecedenceParsing (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:393: expected=\"((a * ([1, 2, 3, 4][(b * c)])) * d)\",\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=\"(a * [1, 2, 3, 4])([(b * c)] * d)\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:968: parser has 4 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:970: parser error: \"expected next token to be ), got [ instead\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 80, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:970: parser error: \"no prefix parse function for , found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:970: parser error: \"no prefix parse function for , found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:970: parser error: \"no prefix parse function for ) found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestParsingIndexExpressions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:835: exp not *ast.IndexExpression. got=*ast.Identifier", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.008s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s because the whole idea behind our Pratt parser hinges on the idea of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "precedences and we haven’t defined the precedence of our index operator yet:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "    _ int = iota", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    INDEX       // array[index]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var precedences = map[token.TokenType]int{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    token.LBRACKET: INDEX,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s important that the definition of INDEX is the last line in the", style: Normal, search_matches: [], inline_styles: [(40, 45, Code)], syntax_colors: [] }, RenderedLine { text: "const block. That gives INDEX the highest value of all defined precedence", style: Normal, search_matches: [], inline_styles: [(1, 6, Code), (25, 30, Code)], syntax_colors: [] }, RenderedLine { text: "constants, thanks to the iota. The added entry in precedences gives", style: Normal, search_matches: [], inline_styles: [(27, 31, Code), (52, 63, Code)], syntax_colors: [] }, RenderedLine { text: "token.LBRACKET this highest precedence of all, INDEX. And, well, it does", style: Normal, search_matches: [], inline_styles: [(2, 16, Code), (49, 54, Code)], syntax_colors: [] }, RenderedLine { text: "wonders:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Lexer done, parser done. See you in the evaluator!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Evaluating Array Literals", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Evaluating array literals is not hard. Mapping Monkey arrays to Go’s slices", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "makes life pretty, pretty sweet. We don’t have to implement a new data", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "structure. We only need to define a new object.Array type, since that’s", style: Normal, search_matches: [], inline_styles: [(42, 54, Code)], syntax_colors: [] }, RenderedLine { text: "what the evaluation of array literals produces. And the definition of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Array is simple, since arrays in Monkey are simple: they are just a", style: Normal, search_matches: [], inline_styles: [(4, 16, Code)], syntax_colors: [] }, RenderedLine { text: "list of objects.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    ARRAY_OBJ = \"ARRAY\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Array struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    Elements []Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (ao *Array) Type() ObjectType { return ARRAY_OBJ }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "func (ao *Array) Inspect() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    elements := []string{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    for _, e := range ao.Elements {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        elements = append(elements, e.Inspect())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\"[\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(strings.Join(elements, \", \"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\"]\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I think you’ll agree with me when I say that the most complicated thing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "about this definition is the Inspect method. And even that one is pretty", style: Normal, search_matches: [], inline_styles: [(30, 37, Code)], syntax_colors: [] }, RenderedLine { text: "easy to understand.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is the evaluator test for array literals:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestArrayLiterals(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := \"[1, 2 * 2, 3 + 3]\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    evaluated := testEval(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    result, ok := evaluated.(*object.Array)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"object is not Array. got=%T (%+v)\", evaluated, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(result.Elements) != 3 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"array has wrong num of elements. got=%d\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "            len(result.Elements))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    testIntegerObject(t, result.Elements[0], 1)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    testIntegerObject(t, result.Elements[1], 4)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    testIntegerObject(t, result.Elements[2], 6)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can reuse some existing code to get this test to pass, just like we did", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in our parser. And again the code we’re reusing was originally written for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "call expressions. Here is the case branch that evaluates *ast.ArrayLiterals", style: Normal, search_matches: [], inline_styles: [(31, 35, Code), (58, 75, Code)], syntax_colors: [] }, RenderedLine { text: "and produces array objects:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    case *ast.ArrayLiteral:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        elements := evalExpressions(node.Elements, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "        if len(elements) == 1 && isError(elements[0]) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "            return elements[0]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        return &object.Array{Elements: elements}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Isn’t that one of the great joys of programming? Reusing existing code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "without having to turn it into a super generic, over-engineered spaceship.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The tests are passing and we can use array literals in our REPL to produce", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "arrays:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> [1, 2, 3, 4]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "[1, 2, 3, 4]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let double = fn(x) { x * 2 };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: ">> [1, double(2), 3 * 3, 4 - 3]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "[1, 4, 9, 1]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: ">>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Amazing, isn’t it? But what we can’t do yet is accessing single elements of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the array by using the index operator.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Evaluating Index Operator Expressions", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Great news: much harder than evaluating index expressions is parsing them.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And we already did that. The only problem left is the possibility of off-by-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "one errors when accessing and retrieving the elements in an array. But for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that we’ll just add a few tests to our test suite:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestArrayIndexExpressions(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected interface{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"[1, 2, 3][0]\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            1,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"[1, 2, 3][1]\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            2,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"[1, 2, 3][2]\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            3,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"let i = 0; [1][i];\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "            1,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"[1, 2, 3][1 + 1];\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "            3,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"let myArray = [1, 2, 3]; myArray[2];\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "            3,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"let myArray = [1, 2, 3]; myArray[0] + myArray[1] + myArray[2];\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 77, Rgb(192, 197, 206))] }, RenderedLine { text: "            6,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"let myArray = [1, 2, 3]; let i = myArray[0]; myArray[i]\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "            2,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"[1, 2, 3][3]\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            nil,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"[1, 2, 3][-1]\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "            nil,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := testEval(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        integer, ok := tt.expected.(int)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        if ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "            testIntegerObject(t, evaluated, int64(integer))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "        } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            testNullObject(t, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Okay, I’ll admit, these tests might seem excessive. A lot of the things", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "we’re testing implicitly here have already been tested elsewhere. But the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "test cases are so easy to write! And they are so readable! I love these", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tests.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Take note of the desired behaviour these tests specify. They contain", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "something we haven’t talked about yet: when we use an index that’s out of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the arrays bounds, we’ll return NULL. Some languages produce an error in", style: Normal, search_matches: [], inline_styles: [(34, 38, Code)], syntax_colors: [] }, RenderedLine { text: "such a case and some return a null value. I choose to return NULL.", style: Normal, search_matches: [], inline_styles: [(62, 66, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As expected the tests are failing. And not only that, they’re blowing up:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestArrayIndexExpressions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:492: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:492: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:492: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:492: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:492: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:492: object is not Integer. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "panic: runtime error: invalid memory address or nil pointer dereference", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "[signal SIGSEGV: segmentation violation code=0x1 addr=0x28 pc=0x70057]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "[redacted: backtrace here]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.011s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So how do we fix this and evaluate index expressions? As we’ve seen, the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "left operand of the index operator can be any expression and the index", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "itself can be any expression. That means we need to evaluate both before we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "can evaluate the “indexing” itself. Otherwise we’d try to access elements of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "an identifier or a function call, which doesn’t work.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is the case branch for *ast.IndexExpression that makes these desired", style: Normal, search_matches: [], inline_styles: [(12, 16, Code), (28, 48, Code)], syntax_colors: [] }, RenderedLine { text: "calls to Eval:", style: Normal, search_matches: [], inline_styles: [(9, 13, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    case *ast.IndexExpression:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        left := Eval(node.Left, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(left) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "            return left", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        index := Eval(node.Index, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(index) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            return index", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalIndexExpression(left, index)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And here is the evalIndexExpression function it uses:", style: Normal, search_matches: [], inline_styles: [(16, 35, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalIndexExpression(left, index object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "    case left.Type() == object.ARRAY_OBJ && index.Type() == object.INTEGER_OBJ:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalArrayIndexExpression(left, index)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"index operator not supported: %s\", left.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "An if-conditional would do the job of the switch statement here just", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fine, but we’re going to add another case branch later in this chapter.", style: Normal, search_matches: [], inline_styles: [(39, 43, Code)], syntax_colors: [] }, RenderedLine { text: "Besides the error handling (for which I also added a test) nothing really", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interesting happens in this function. The meat of the operation is in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evalArrayIndexExpression:", style: Normal, search_matches: [], inline_styles: [(2, 25, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalArrayIndexExpression(array, index object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 73, Rgb(192, 197, 206))] }, RenderedLine { text: "    arrayObject := array.(*object.Array)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    idx := index.(*object.Integer).Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    max := int64(len(arrayObject.Elements) - 1)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if idx < 0 || idx > max {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return arrayObject.Elements[idx]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here we actually retrieve the element with the specified index from the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "array. Besides the little type assertion and conversion dances this function", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is pretty straightforward: it checks if the given index is out of range and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if that’s the case it returns NULL, otherwise the desired element. Just like", style: Normal, search_matches: [], inline_styles: [(32, 36, Code)], syntax_colors: [] }, RenderedLine { text: "we specified in our tests, which are now passing:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Okay, now take a deep breath, relax and take a look at this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let a = [1, 2 * 2, 10 - 5, 8 / 2];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: ">> a[0]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "1", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> a[1]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "4", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> a[5 - 3]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "5", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: ">> a[99]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "null", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Retrieving elements from an array works! Sweet! I can only repeat myself", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "here: it’s amazing how easy it was to implement this language feature, isn’t", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "it?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Adding Built-in Functions for Arrays", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We are now able to construct arrays by using array literals. And we can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "access single elements by using index expressions. Just those two things", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "alone make arrays quite useful to have. But in order to make them even more", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "useful, we need to add a few built-in functions that make working with them", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "more convenient. In this sub-section we’re going to do exactly that.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I won’t be showing any test code and test cases in this section. The reason", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is that these particular tests take up space without adding anything new.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Our “framework” for testing built-in functions is already in place with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestBuiltinFunctions and the added tests follow the existing scheme. You can", style: Normal, search_matches: [], inline_styles: [(3, 23, Code)], syntax_colors: [] }, RenderedLine { text: "find them in the accompanying code.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Our goal is to add new built-in functions. But the first thing we actually", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "have to do is not adding a new one but changing an existing function. We", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "need to add support for arrays to len, which only supported strings until", style: Normal, search_matches: [], inline_styles: [(34, 37, Code)], syntax_colors: [] }, RenderedLine { text: "now:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/builtins.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var builtins = map[string]*object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"len\": &object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        Fn: func(args ...object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "            if len(args) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"wrong number of arguments. got=%d, want=1\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "                    len(args))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            switch arg := args[0].(type) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "            case *object.Array:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "                return &object.Integer{Value: int64(len(arg.Elements))}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "            case *object.String:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "                return &object.Integer{Value: int64(len(arg.Value))}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "            default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"argument to `len` not supported, got %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "                    args[0].Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The only change is the added case branch for *object.Array. And with that", style: Normal, search_matches: [], inline_styles: [(29, 33, Code), (45, 58, Code)], syntax_colors: [] }, RenderedLine { text: "out of the way, we’re ready to start adding new functions. Yay!", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The first of these new built-in functions is first. first returns the first", style: Normal, search_matches: [], inline_styles: [(45, 50, Code), (52, 57, Code)], syntax_colors: [] }, RenderedLine { text: "element of the given array. Yes, calling myArray[0] does the same thing. But", style: Normal, search_matches: [], inline_styles: [(41, 51, Code)], syntax_colors: [] }, RenderedLine { text: "first is arguably prettier. Here is its implementation:", style: Normal, search_matches: [], inline_styles: [(0, 5, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/builtins.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var builtins = map[string]*object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    \"first\": &object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        Fn: func(args ...object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "            if len(args) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"wrong number of arguments. got=%d, want=1\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "                    len(args))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "            if args[0].Type() != object.ARRAY_OBJ {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"argument to `first` must be ARRAY, got %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "                    args[0].Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            arr := args[0].(*object.Array)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "            if len(arr.Elements) > 0 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "                return arr.Elements[0]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Great! That works! And what comes after first? You’re correct, the next", style: Normal, search_matches: [], inline_styles: [(40, 45, Code)], syntax_colors: [] }, RenderedLine { text: "function we’re going to add is called last.", style: Normal, search_matches: [], inline_styles: [(41, 45, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The purpose of last is to return the last element of the given array. In", style: Normal, search_matches: [], inline_styles: [(15, 19, Code)], syntax_colors: [] }, RenderedLine { text: "index operator terms it returns myArray[len(myArray)-1]. And as it turns", style: Normal, search_matches: [], inline_styles: [(32, 55, Code)], syntax_colors: [] }, RenderedLine { text: "out, implementing last is not much harder than implementing first - who", style: Normal, search_matches: [], inline_styles: [(18, 22, Code), (60, 65, Code)], syntax_colors: [] }, RenderedLine { text: "would have thought that? Here it is:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/builtins.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var builtins = map[string]*object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    \"last\": &object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        Fn: func(args ...object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "            if len(args) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"wrong number of arguments. got=%d, want=1\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "                    len(args))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "            if args[0].Type() != object.ARRAY_OBJ {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"argument to `last` must be ARRAY, got %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "                    args[0].Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            arr := args[0].(*object.Array)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "            length := len(arr.Elements)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "            if length > 0 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "                return arr.Elements[length-1]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The next function we’re going to add would be called cdr in Scheme. In some", style: Normal, search_matches: [], inline_styles: [(55, 58, Code)], syntax_colors: [] }, RenderedLine { text: "other languages it’s sometimes called tail. We’re going to call it rest.", style: Normal, search_matches: [], inline_styles: [(41, 45, Code), (72, 76, Code)], syntax_colors: [] }, RenderedLine { text: "rest returns a new array containing all elements of the array passed as", style: Normal, search_matches: [], inline_styles: [(1, 5, Code)], syntax_colors: [] }, RenderedLine { text: "argument, except the first one. Here’s what using it looks like:", style: Normal, search_matches: [], inline_styles: [(12, 32, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let a = [1, 2, 3, 4];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: ">> rest(a)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "[2, 3, 4]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: ">> rest(rest(a))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "[3, 4]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: ">> rest(rest(rest(a)))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "[4]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: ">> rest(rest(rest(rest(a))))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "[]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> rest(rest(rest(rest(rest(a)))))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "null", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Its implementation is simple, but keep in mind that we’re returning a newly", style: Normal, search_matches: [], inline_styles: [(72, 77, Italic)], syntax_colors: [] }, RenderedLine { text: "allocated array. We’re not modifying the array passed to rest:", style: Normal, search_matches: [], inline_styles: [(0, 10, Italic), (60, 64, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/builtins.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var builtins = map[string]*object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    \"rest\": &object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        Fn: func(args ...object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "            if len(args) != 1 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"wrong number of arguments. got=%d, want=1\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "                    len(args))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "            if args[0].Type() != object.ARRAY_OBJ {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"argument to `rest` must be ARRAY, got %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "                    args[0].Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            arr := args[0].(*object.Array)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "            length := len(arr.Elements)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "            if length > 0 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "                newElements := make([]object.Object, length-1, length-1)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "                copy(newElements, arr.Elements[1:length])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 57, Rgb(192, 197, 206))] }, RenderedLine { text: "                return &object.Array{Elements: newElements}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The last array function we’re going to build into our interpreter is called", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "push. It adds a new element to the end of the array. But, and here’s the", style: Normal, search_matches: [], inline_styles: [(1, 5, Code)], syntax_colors: [] }, RenderedLine { text: "kicker, it doesn’t modify the given array. Instead it allocates a new array", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "with the same elements as the old one plus the new, pushed element. Arrays", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "are immutable in Monkey. Here is push in action:", style: Normal, search_matches: [], inline_styles: [(37, 41, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let a = [1, 2, 3, 4];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let b = push(a, 5);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: ">> a", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "[1, 2, 3, 4]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: ">> b", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "[1, 2, 3, 4, 5]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And here is its implementation:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/builtins.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var builtins = map[string]*object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    \"push\": &object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        Fn: func(args ...object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "            if len(args) != 2 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"wrong number of arguments. got=%d, want=2\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: "                    len(args))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "            if args[0].Type() != object.ARRAY_OBJ {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "                return newError(\"argument to `push` must be ARRAY, got %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "                    args[0].Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            arr := args[0].(*object.Array)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "            length := len(arr.Elements)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            newElements := make([]object.Object, length+1, length+1)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: "            copy(newElements, arr.Elements)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "            newElements[length] = args[1]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            return &object.Array{Elements: newElements}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Test-Driving Arrays", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We now have array literals, the index operator and a few built-in functions", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to work with arrays. It’s time to take them for a spin. Let’s see what they", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "can do.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "With first, rest and push we can build a map function:", style: Normal, search_matches: [], inline_styles: [(5, 10, Code), (12, 16, Code), (21, 25, Code), (41, 44, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let map = fn(arr, f) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "  let iter = fn(arr, accumulated) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "    if (len(arr) == 0) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "      accumulated", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "      iter(rest(arr), push(accumulated, f(first(arr))));", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "  };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  iter(arr, []);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And with map we can do things like this:", style: Normal, search_matches: [], inline_styles: [(9, 12, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let a = [1, 2, 3, 4];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let double = fn(x) { x * 2 };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: ">> map(a, double);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "[2, 4, 6, 8]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Isn’t this amazing? There’s more! Based on the same built-in functions we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "can also define a reduce function:", style: Normal, search_matches: [], inline_styles: [(18, 24, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let reduce = fn(arr, initial, f) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "  let iter = fn(arr, result) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    if (len(arr) == 0) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "      result", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "      iter(rest(arr), f(result, first(arr)));", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "  };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "  iter(arr, initial);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And reduce, in turn, can be used to define a sum function:", style: Normal, search_matches: [], inline_styles: [(4, 10, Code), (45, 48, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let sum = fn(arr) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "  reduce(arr, 0, fn(initial, el) { initial + el });", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And it works like a charm:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> sum([1, 2, 3, 4, 5]);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "15", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As you probably know, I’m not a fan of patting oneself on the back, but let", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "me just say this: holy monkey! Look at what our interpreter can do! A map", style: Normal, search_matches: [], inline_styles: [(71, 73, Code)], syntax_colors: [] }, RenderedLine { text: "function?! reduce?! We’ve come a long, long way!", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (13, 19, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s not even all of it! There’s a lot more we can do now and I urge", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "you to explore the possibilities the array data type and the few built-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "in functions give us. But you know what you should do first? Take some", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "time off, brag about this to your friends and family, enjoy the praise and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "compliments. And when you come back, we’ll add another data type.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "4.5 - Hashes", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The next data type we’re going to add is called “hash”. A hash in Monkey", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is what’s sometimes called hash, map, hash map or dictionary in other", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programming languages. It maps keys to values.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In order to construct a hash in Monkey one uses the hash literal: a comma-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "separated list of key-value pairs that’s enclosed by curly braces. Each key-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "value pair uses a colon to differentiate between the key and the value. Here", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is what using a hash literal looks like:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let myHash = {\"name\": \"Jimmy\", \"age\": 72, \"band\": \"Led Zeppelin\"};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: ">> myHash[\"name\"]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "Jimmy", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: ">> myHash[\"age\"]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "72", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> myHash[\"band\"]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "Led Zeppelin", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In this example myHash contains three key-value pairs. The keys are all", style: Normal, search_matches: [], inline_styles: [(16, 22, Code)], syntax_colors: [] }, RenderedLine { text: "strings. And, as you can see, we can use index operator expressions to get", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "values out of the hash again, just like we can with arrays. Except that in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "this example the index values are strings, which don’t work with arrays. And", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "that’s not even the only data type that’s usable as a hash key:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let myHash = {true: \"yes, a boolean\", 99: \"correct, an integer\"};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 68, Rgb(192, 197, 206))] }, RenderedLine { text: ">> myHash[true]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "yes, a boolean", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: ">> myHash[99]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "correct, an integer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s also valid. In fact, besides string, integer and boolean literals we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "can use any expression as index in index operator expressions:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> myHash[5 > 1]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "yes, a boolean", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: ">> myHash[100 - 1]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "correct, an integer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As long as these expressions evaluate to either strings, integers or", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "booleans they are usable as hash keys. Here 5 > 1 evaluates to true and 100", style: Normal, search_matches: [], inline_styles: [(44, 49, Code), (63, 67, Code), (72, 75, Code)], syntax_colors: [] }, RenderedLine { text: "- 1 evaluates to 99, both of which are valid and mapped to values in myHash.", style: Normal, search_matches: [], inline_styles: [(0, 3, Code), (17, 19, Code), (69, 75, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Rather unsurprisingly our implementation will use Go’s map as the underlying", style: Normal, search_matches: [], inline_styles: [(57, 60, Code)], syntax_colors: [] }, RenderedLine { text: "data structure for Monkey hashes. But since we want to use strings, integers", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "and booleans interchangeably as keys, we need to build something on top of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "plain old map to make it work. We’ll come to that when we extend our object", style: Normal, search_matches: [], inline_styles: [(12, 15, Code)], syntax_colors: [] }, RenderedLine { text: "system. But first we have to turn hash literals into tokens.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Lexing Hash Literals", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "How do we turn hash literals into tokens? Which tokens do we need to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "recognize and output in our lexer so that we can later work with them in the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "parser? Here is the hash literal from above again:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "{\"name\": \"Jimmy\", \"age\": 72, \"band\": \"Led Zeppelin\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides the string and integer literals there are four characters in use", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "here that are important: {, }, , and :. We already know how to lex the first", style: Normal, search_matches: [], inline_styles: [(25, 26, Code), (28, 29, Code), (31, 32, Code), (37, 38, Code)], syntax_colors: [] }, RenderedLine { text: "three. Our lexer turns these into token.LBRACE, token.RBRACE and token.COMMA", style: Normal, search_matches: [], inline_styles: [(34, 46, Code), (48, 60, Code), (65, 76, Code)], syntax_colors: [] }, RenderedLine { text: "respectively. That means, all that’s left for us to do in this section is to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "turn : into a token.", style: Normal, search_matches: [], inline_styles: [(6, 7, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And for that we first need to define the necessary token type in the token", style: Normal, search_matches: [], inline_styles: [(69, 74, Code)], syntax_colors: [] }, RenderedLine { text: "package:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// token/token.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    COLON = \":\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Next we’re going to add a new test for the NextToken method of Lexer that", style: Normal, search_matches: [], inline_styles: [(45, 54, Code), (65, 70, Code)], syntax_colors: [] }, RenderedLine { text: "expects a token.COLON:", style: Normal, search_matches: [], inline_styles: [(11, 22, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestNextToken(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `let five = 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "let ten = 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let add = fn(x, y) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "  x + y;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let result = add(five, ten);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "!-/*5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "5 < 10 > 5;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 11, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "if (5 < 10) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "    return true;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "} else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    return false;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "10 == 10;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "10 != 9;", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "\"foobar\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "\"foo bar\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "[1, 2];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "{\"foo\": \"bar\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedType    token.TokenType", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedLiteral string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.LBRACE, \"{\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.STRING, \"foo\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.COLON, \":\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.STRING, \"bar\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.RBRACE, \"}\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        {token.EOF, \"\"},", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We could get away with adding a single : to the test input, but using a hash", style: Normal, search_matches: [], inline_styles: [(39, 40, Code)], syntax_colors: [] }, RenderedLine { text: "literal as we did here provides a little more context when later reading and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "eventually debugging the test.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Turning : into token.COLON is as easy as it gets:", style: Normal, search_matches: [], inline_styles: [(8, 9, Code), (15, 26, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// lexer/lexer.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (l *Lexer) NextToken() token.Token {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    case ':':", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        tok = newToken(token.COLON, l.ch)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Only two new lines and the lexer now spits out token.COLON:", style: Normal, search_matches: [], inline_styles: [(47, 58, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./lexer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/lexer    0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Boom! The lexer now returns token.LBRACE, token.RBRACE, token.COMMA and the", style: Normal, search_matches: [], inline_styles: [(28, 40, Code), (42, 54, Code), (56, 67, Code)], syntax_colors: [] }, RenderedLine { text: "new token.COLON. That’s all we need in order to parse to hash literals.", style: Normal, search_matches: [], inline_styles: [(4, 15, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Parsing Hash Literals", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Before we start working on our parser or even writing a test, let’s look at", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the basic syntactic structure of a hash literal:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "{<expression> : <expression>, <expression> : <expression>, ... }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 64, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s a comma-separated list of pairs. Each pair consists of two expressions.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "One produces the hash key and one produces the value. The key is separated", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "from the value with a colon. The list is enclosed by a pair of curly braces.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When we turn this into an AST node, we have to keep track of the key-value", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "pairs. Now how would we do that? We’ll use a map, yes, but of what type are", style: Normal, search_matches: [], inline_styles: [(47, 50, Code)], syntax_colors: [] }, RenderedLine { text: "the keys and the values in this map?", style: Normal, search_matches: [], inline_styles: [(33, 36, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We said earlier that the only admissible data types for hash keys are", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "strings, integers and booleans. But we can’t enforce that in the parser.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Instead we’ll have to validate hash key types in the evaluation stage and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "generate possible errors there.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s because a lot of different expressions can produce strings, integers", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "or booleans. Not just their literal forms. Enforcing the data type of hash", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "keys in the parsing stage would prevent us from doing something like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let key = \"name\";", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "let hash = {key: \"Monkey\"};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here key evaluates to \"name\" and is thus totally valid as a hash key, even", style: Normal, search_matches: [], inline_styles: [(5, 8, Code), (22, 28, Code)], syntax_colors: [] }, RenderedLine { text: "though it’s an identifier. In order to allow this, we need to allow any", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expression as a key and any expression as a value in a hash literal. At", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "least in the parsing stage. Following that our ast.HashLiteral definition", style: Normal, search_matches: [], inline_styles: [(49, 64, Code)], syntax_colors: [] }, RenderedLine { text: "looks like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// ast/ast.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type HashLiteral struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    Token token.Token // the '{' token", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    Pairs map[Expression]Expression", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (hl *HashLiteral) expressionNode()      {}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "func (hl *HashLiteral) TokenLiteral() string { return hl.Token.Literal }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "func (hl *HashLiteral) String() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    pairs := []string{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    for key, value := range hl.Pairs {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "        pairs = append(pairs, key.String()+\":\"+value.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 62, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\"{\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(strings.Join(pairs, \", \"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\"}\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now that we’re clear about the structure of hash literals and have", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "ast.HashLiteral defined, we can write tests for our parser:", style: Normal, search_matches: [], inline_styles: [(1, 16, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestParsingHashLiteralsStringKeys(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `{\"one\": 1, \"two\": 2, \"three\": 3}`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    hash, ok := stmt.Expression.(*ast.HashLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"exp is not ast.HashLiteral. got=%T\", stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(hash.Pairs) != 3 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"hash.Pairs has wrong length. got=%d\", len(hash.Pairs))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    expected := map[string]int64{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        \"one\":   1,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        \"two\":   2,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        \"three\": 3,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for key, value := range hash.Pairs {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        literal, ok := key.(*ast.StringLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Errorf(\"key is not ast.StringLiteral. got=%T\", key)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        expectedValue := expected[literal.String()]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        testIntegerLiteral(t, value, expectedValue)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And of course, we also have to be sure that we parse an empty hash literal", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "correctly, because such edge-cases are the root of all hair loss in", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "programming:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestParsingEmptyHashLiteral(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := \"{}\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    hash, ok := stmt.Expression.(*ast.HashLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"exp is not ast.HashLiteral. got=%T\", stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(hash.Pairs) != 0 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"hash.Pairs has wrong length. got=%d\", len(hash.Pairs))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "I also added two more tests that are similar to TestHashLiteralStringKeys", style: Normal, search_matches: [], inline_styles: [(48, 73, Code)], syntax_colors: [] }, RenderedLine { text: "but use integers and booleans as hash keys and make sure the parser turns", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "those into *ast.IntegerLiteral and *ast.Boolean respectively. And then there", style: Normal, search_matches: [], inline_styles: [(11, 30, Code), (35, 47, Code)], syntax_colors: [] }, RenderedLine { text: "is a fifth test function that makes sure the values in a hash literal can be", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "any expression, even operator expressions. It looks like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestParsingHashLiteralsWithExpressions(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `{\"one\": 0 + 1, \"two\": 10 - 8, \"three\": 15 / 5}`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 61, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    l := lexer.New(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    p := New(l)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "    program := p.ParseProgram()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "    checkParserErrors(t, p)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    stmt := program.Statements[0].(*ast.ExpressionStatement)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 60, Rgb(192, 197, 206))] }, RenderedLine { text: "    hash, ok := stmt.Expression.(*ast.HashLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 50, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"exp is not ast.HashLiteral. got=%T\", stmt.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(hash.Pairs) != 3 {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"hash.Pairs has wrong length. got=%d\", len(hash.Pairs))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    tests := map[string]func(ast.Expression){", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        \"one\": func(e ast.Expression) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "            testInfixExpression(t, e, 0, \"+\", 1)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        \"two\": func(e ast.Expression) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "            testInfixExpression(t, e, 10, \"-\", 8)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        \"three\": func(e ast.Expression) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "            testInfixExpression(t, e, 15, \"/\", 5)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 49, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for key, value := range hash.Pairs {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        literal, ok := key.(*ast.StringLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Errorf(\"key is not ast.StringLiteral. got=%T\", key)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "            continue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        testFunc, ok := tests[literal.String()]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Errorf(\"No test function for key %q found\", literal.String())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "            continue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        testFunc(value)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So how are all of these test functions doing? Not so well, to be honest. We", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "get a lot of failures and parser errors:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestParsingEmptyHashLiteral (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:1173: parser has 2 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:1175: parser error: \"no prefix parse function for { found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:1175: parser error: \"no prefix parse function for } found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestParsingHashLiteralsStringKeys (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:1173: parser has 7 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:1175: parser error: \"no prefix parse function for { found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "[... more errors ...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestParsingHashLiteralsBooleanKeys (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:1173: parser has 5 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:1175: parser error: \"no prefix parse function for { found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "[... more errors ...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestParsingHashLiteralsIntegerKeys (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:967: parser has 7 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:969: parser error: \"no prefix parse function for { found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "[... more errors ...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestParsingHashLiteralsWithExpressions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:1173: parser has 7 errors", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "  parser_test.go:1175: parser error: \"no prefix parse function for { found\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 75, Rgb(192, 197, 206))] }, RenderedLine { text: "[... more errors ...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/parser   0.008s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It might sound unbelievable but there’s good news: it only takes one", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "function to make all of these tests pass. One prefixParseFn, to be exact.", style: Normal, search_matches: [], inline_styles: [(47, 60, Code)], syntax_colors: [] }, RenderedLine { text: "Since the token.LBRACE of a hash literal is in prefix position, just like", style: Normal, search_matches: [], inline_styles: [(12, 24, Code)], syntax_colors: [] }, RenderedLine { text: "the token.LBRACKET of an array literal, we can define a parseHashLiteral", style: Normal, search_matches: [], inline_styles: [(6, 20, Code), (58, 72, Code)], syntax_colors: [] }, RenderedLine { text: "method as a prefixParseFn:", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (14, 26, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// parser/parser.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func New(l *lexer.Lexer) *Parser {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    p.registerPrefix(token.LBRACE, p.parseHashLiteral)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (p *Parser) parseHashLiteral() ast.Expression {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    hash := &ast.HashLiteral{Token: p.curToken}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    hash.Pairs = make(map[ast.Expression]ast.Expression)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for !p.peekTokenIs(token.RBRACE) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        key := p.parseExpression(LOWEST)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if !p.expectPeek(token.COLON) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "            return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        p.nextToken()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "        value := p.parseExpression(LOWEST)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        hash.Pairs[key] = value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        if !p.peekTokenIs(token.RBRACE) && !p.expectPeek(token.COMMA) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "            return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if !p.expectPeek(token.RBRACE) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "        return nil", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return hash", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It may look intimidating, but there is nothing in parseHashLiteral we", style: Normal, search_matches: [], inline_styles: [(50, 66, Code)], syntax_colors: [] }, RenderedLine { text: "haven’t seen before. It only loops over key-value expression pairs by", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "checking for a closing token.RBRACE and calling parseExpression two times.", style: Normal, search_matches: [], inline_styles: [(24, 36, Code), (49, 64, Code)], syntax_colors: [] }, RenderedLine { text: "That and the filling of hash.Pairs are the most important parts of this", style: Normal, search_matches: [], inline_styles: [(26, 36, Code)], syntax_colors: [] }, RenderedLine { text: "method. It does its job well:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./parser", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/parser   0.006s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "All of our parser tests pass! And judging by the numbers of tests we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "added, we can be reasonably sure that our parser now knows how to parse", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "hash literals. That means we’re now coming to the most interesting part of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "adding hashes to our interpreter: representing them in the object system and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "evaluating hash literals.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Hashing Objects", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides extending the lexer and parser, adding a new data type also means", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "representing it in the object system. We successfully did that for integers,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "strings and arrays. But whereas implementing these other data types just", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "meant defining a struct that has a .Value field with the correct type,", style: Normal, search_matches: [], inline_styles: [(35, 41, Code)], syntax_colors: [] }, RenderedLine { text: "hashes require a little bit more effort. Let me explain why.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s say we defined a new object.Hash type like this:", style: Normal, search_matches: [], inline_styles: [(29, 40, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Hash struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "  Pairs map[Object]Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s the most obvious choice for implementing a Hash data type based on", style: Normal, search_matches: [], inline_styles: [(52, 56, Code)], syntax_colors: [] }, RenderedLine { text: "Go’s map. But with this definition, how would we fill the Pairs map? And", style: Normal, search_matches: [], inline_styles: [(8, 11, Code), (61, 66, Code)], syntax_colors: [] }, RenderedLine { text: "more importantly, how would we get values back out of it?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Consider this piece of Monkey code:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "let hash = {\"name\": \"Monkey\"};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "hash[\"name\"]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Let’s say we are evaluating these two lines and are using the object.Hash", style: Normal, search_matches: [], inline_styles: [(64, 75, Code)], syntax_colors: [] }, RenderedLine { text: "definition from above. When evaluating the hash literal in the first line we", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "take every key-value pair and put it in the map[Object]Object map, resulting", style: Normal, search_matches: [], inline_styles: [(46, 63, Code)], syntax_colors: [] }, RenderedLine { text: "in .Pairs having the following mapping: an *object.String with .Value being", style: Normal, search_matches: [], inline_styles: [(5, 11, Code), (45, 59, Code), (65, 71, Code)], syntax_colors: [] }, RenderedLine { text: "\"name\" mapped to an *object.String with .Value being \"Monkey\".", style: Normal, search_matches: [], inline_styles: [(2, 8, Code), (22, 36, Code), (42, 48, Code), (55, 62, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "So far, so good. But the problem arises in the second line where we use an", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "index expression to try to access the \"Monkey\" string.", style: Normal, search_matches: [], inline_styles: [(38, 46, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In this second line the \"name\" string literal of the index expression", style: Normal, search_matches: [], inline_styles: [(24, 30, Code)], syntax_colors: [] }, RenderedLine { text: "evaluates to a new, freshly allocated *object.String. And even though this", style: Normal, search_matches: [], inline_styles: [(38, 52, Code)], syntax_colors: [] }, RenderedLine { text: "new *object.String also contains \"name\" in its .Value field, just like", style: Normal, search_matches: [], inline_styles: [(4, 18, Code), (33, 39, Code), (47, 53, Code)], syntax_colors: [] }, RenderedLine { text: "the other *object.String in Pairs, we can’t use the new one to retrieve", style: Normal, search_matches: [], inline_styles: [(10, 24, Code), (28, 33, Code)], syntax_colors: [] }, RenderedLine { text: "\"Monkey\".", style: Normal, search_matches: [], inline_styles: [(1, 9, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The reason for this is that they’re pointers pointing to different memory", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "locations. The fact that the content of the memory locations they point to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "is the same (\"name\") doesn’t matter. Comparing these pointers would tell us", style: Normal, search_matches: [], inline_styles: [(15, 21, Code)], syntax_colors: [] }, RenderedLine { text: "that they’re not equal. That means using the newly created *object.String", style: Normal, search_matches: [], inline_styles: [(64, 75, Code)], syntax_colors: [] }, RenderedLine { text: "as a key doesn’t get us \"Monkey\". That’s how pointers and comparison between", style: Normal, search_matches: [], inline_styles: [(0, 2, Code), (29, 37, Code)], syntax_colors: [] }, RenderedLine { text: "them works in Go.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here is an example that demonstrates the problem we’d face with the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Hash implementation from above:", style: Normal, search_matches: [], inline_styles: [(1, 12, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "name1 := &object.String{Value: \"name\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "monkey := &object.String{Value: \"Monkey\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "pairs := map[object.Object]object.Object{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "pairs[name1] = monkey", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fmt.Printf(\"pairs[name1]=%+v\\n\", pairs[name1])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "// => pairs[name1]=&{Value:Monkey}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "name2 := &object.String{Value: \"name\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fmt.Printf(\"pairs[name2]=%+v\\n\", pairs[name2])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "// => pairs[name2]=<nil>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fmt.Printf(\"(name1 == name2)=%t\\n\", name1 == name2)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "// => (name1 == name2)=false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As a solution to this problem we could iterate over every key in .Pairs,", style: Normal, search_matches: [], inline_styles: [(65, 71, Code)], syntax_colors: [] }, RenderedLine { text: "check if it’s an *object.String and compare its .Value to the .Value of the", style: Normal, search_matches: [], inline_styles: [(19, 33, Code), (50, 56, Code), (64, 70, Code)], syntax_colors: [] }, RenderedLine { text: "key in the index expression. We’d find the matching value this way, but this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "method turns the lookup time for a given key from O(1) into O(n), defeating", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the entire purpose of using hashes in the first place.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Another option is to define Pairs as a map[string]Object and then use", style: Normal, search_matches: [], inline_styles: [(28, 33, Code), (39, 56, Code)], syntax_colors: [] }, RenderedLine { text: "the .Value of *object.String as the keys. That works, but not for integers", style: Normal, search_matches: [], inline_styles: [(4, 10, Code), (14, 28, Code)], syntax_colors: [] }, RenderedLine { text: "and booleans.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "No, what we need is a way to generate hashes for objects that we can", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "easily compare and use as hash keys in our object.Hash. We need to be able", style: Normal, search_matches: [], inline_styles: [(43, 54, Code)], syntax_colors: [] }, RenderedLine { text: "to generate a hash key for an *object.String that’s comparable and equal", style: Normal, search_matches: [], inline_styles: [(30, 44, Code)], syntax_colors: [] }, RenderedLine { text: "to the hash key of another *object.String with the same .Value. The same", style: Normal, search_matches: [], inline_styles: [(28, 42, Code), (57, 63, Code)], syntax_colors: [] }, RenderedLine { text: "goes for *object.Integer and *object.Boolean. But the hash keys for an", style: Normal, search_matches: [], inline_styles: [(11, 26, Code), (31, 46, Code)], syntax_colors: [] }, RenderedLine { text: "*object.String must never be equal to the hash key for an *object.Integer or", style: Normal, search_matches: [], inline_styles: [(2, 16, Code), (60, 75, Code)], syntax_colors: [] }, RenderedLine { text: "an *object.Boolean. Between types the hash keys always have to differ.", style: Normal, search_matches: [], inline_styles: [(5, 20, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can express the desired behaviour in a set of test functions in our", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object system:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "package object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import \"testing\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestStringHashKey(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    hello1 := &String{Value: \"Hello World\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    hello2 := &String{Value: \"Hello World\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "    diff1 := &String{Value: \"My name is johnny\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    diff2 := &String{Value: \"My name is johnny\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if hello1.HashKey() != hello2.HashKey() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"strings with same content have different hash keys\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if diff1.HashKey() != diff2.HashKey() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"strings with same content have different hash keys\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if hello1.HashKey() == diff1.HashKey() {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Errorf(\"strings with different content have same hash keys\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 70, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s exactly what we want from a HashKey() method. And not just for", style: Normal, search_matches: [], inline_styles: [(37, 46, Code)], syntax_colors: [] }, RenderedLine { text: "*object.String but for *object.Boolean and *object.Integer, which is why the", style: Normal, search_matches: [], inline_styles: [(1, 15, Code), (24, 39, Code), (44, 59, Code)], syntax_colors: [] }, RenderedLine { text: "same test function exists for both of them too.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "To stop the tests from blowing up we need to implement the HashKey() method", style: Normal, search_matches: [], inline_styles: [(59, 68, Code)], syntax_colors: [] }, RenderedLine { text: "on each of the three types:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"hash/fnv\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type HashKey struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    Type  ObjectType", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value uint64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (b *Boolean) HashKey() HashKey {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    var value uint64", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if b.Value {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "        value = 1", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        value = 0", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return HashKey{Type: b.Type(), Value: value}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (i *Integer) HashKey() HashKey {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    return HashKey{Type: i.Type(), Value: uint64(i.Value)}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 58, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (s *String) HashKey() HashKey {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 36, Rgb(192, 197, 206))] }, RenderedLine { text: "    h := fnv.New64a()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    h.Write([]byte(s.Value))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return HashKey{Type: s.Type(), Value: h.Sum64()}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Every HashKey() method returns a HashKey. As you can see in its definition,", style: Normal, search_matches: [], inline_styles: [(6, 15, Code), (33, 40, Code)], syntax_colors: [] }, RenderedLine { text: "HashKey is nothing fancy. The Type field contains an ObjectType (which is", style: Normal, search_matches: [], inline_styles: [(0, 7, Code), (30, 34, Code), (53, 63, Code)], syntax_colors: [] }, RenderedLine { text: "a string) and thus effectively “scopes” HashKeys to different object types.", style: Normal, search_matches: [], inline_styles: [(2, 8, Code), (44, 51, Code)], syntax_colors: [] }, RenderedLine { text: "The Value field holds the actual hash, which is an integer. Since it’s just", style: Normal, search_matches: [], inline_styles: [(4, 9, Code)], syntax_colors: [] }, RenderedLine { text: "a string and an integer we can easily compare a HashKey to another HashKey", style: Normal, search_matches: [], inline_styles: [(49, 56, Code), (68, 74, Code)], syntax_colors: [] }, RenderedLine { text: "by using the == operator. And that also makes HashKey usable as a key in a", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (15, 17, Code), (48, 55, Code)], syntax_colors: [] }, RenderedLine { text: "Go map.", style: Normal, search_matches: [], inline_styles: [(6, 7, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "There is still a possibility, albeit a small one, that different Strings", style: Normal, search_matches: [], inline_styles: [(65, 71, Code)], syntax_colors: [] }, RenderedLine { text: "with different Values result in the same hash. That happens when the hash/", style: Normal, search_matches: [], inline_styles: [(15, 20, Code), (69, 74, Code)], syntax_colors: [] }, RenderedLine { text: "fnv package generates the same integer for different values, an event called", style: Normal, search_matches: [], inline_styles: [(0, 3, Code)], syntax_colors: [] }, RenderedLine { text: "a hash collision. Chances that we experience it are low, but it should be", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "noted that there are well-known techniques such as “separate chaining” and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“open addressing” to work around the problem. Implementing one of these", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "mitigations is outside of this book’s scope, but certainly a nice exercise", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "for the curious reader.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The problem we demonstrated earlier is solved by using this newly defined", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "HashKey and the HashKey() methods:", style: Normal, search_matches: [], inline_styles: [(0, 7, Code), (16, 25, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "name1 := &object.String{Value: \"name\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "monkey := &object.String{Value: \"Monkey\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "pairs := map[object.HashKey]object.Object{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "pairs[name1.HashKey()] = monkey", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 31, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fmt.Printf(\"pairs[name1.HashKey()]=%+v\\n\", pairs[name1.HashKey()])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "// => pairs[name1.HashKey()]=&{Value:Monkey}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "name2 := &object.String{Value: \"name\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fmt.Printf(\"pairs[name2.HashKey()]=%+v\\n\", pairs[name2.HashKey()])", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 66, Rgb(192, 197, 206))] }, RenderedLine { text: "// => pairs[name2.HashKey()]=&{Value:Monkey}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fmt.Printf(\"(name1 == name2)=%t\\n\", name1 == name2)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "// => (name1 == name2)=false", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "fmt.Printf(\"(name1.HashKey() == name2.HashKey())=%t\\n\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "  name1.HashKey() == name2.HashKey())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "// => (name1.HashKey() == name2.HashKey())=true", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s exactly what we want! The HashKey definition and the HashKey() method", style: Normal, search_matches: [], inline_styles: [(9, 16, Italic), (35, 42, Code), (62, 71, Code)], syntax_colors: [] }, RenderedLine { text: "implementations solve the problems we had with our naive Hash definition.", style: Normal, search_matches: [], inline_styles: [(58, 62, Code)], syntax_colors: [] }, RenderedLine { text: "They also make the tests pass:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/object   0.008s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now we can define object.Hash and use this new HashKey type:", style: Normal, search_matches: [], inline_styles: [(18, 29, Code), (47, 54, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "const (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    HASH_OBJ = \"HASH\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type HashPair struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "    Key   Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    Value Object", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Hash struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "    Pairs map[HashKey]HashPair", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (h *Hash) Type() ObjectType { return HASH_OBJ }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This adds both the definition of Hash and HashPair. HashPair is the type", style: Normal, search_matches: [], inline_styles: [(33, 37, Code), (42, 50, Code), (52, 60, Code)], syntax_colors: [] }, RenderedLine { text: "of the values in Hash.Pairs. You might be wondering why we use that and not", style: Normal, search_matches: [], inline_styles: [(17, 27, Code)], syntax_colors: [] }, RenderedLine { text: "just define Pairs as a map[HashKey]Object.", style: Normal, search_matches: [], inline_styles: [(12, 17, Code), (23, 41, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The reason is the Inspect() method of Hash. When we later print a Monkey", style: Normal, search_matches: [], inline_styles: [(18, 27, Code), (38, 42, Code)], syntax_colors: [] }, RenderedLine { text: "hash in our REPL, we want to print the values contained in the hash as well", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "as its keys. And just printing the HashKeys is not really useful. So we", style: Normal, search_matches: [], inline_styles: [(35, 42, Code)], syntax_colors: [] }, RenderedLine { text: "keep track of the objects that generated the HashKeys by using HashPairs", style: Normal, search_matches: [], inline_styles: [(45, 52, Code), (63, 71, Code)], syntax_colors: [] }, RenderedLine { text: "as values, where we save the original key object and the value object its", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "mapped to. That way we can call the Inspect() methods of the key objects", style: Normal, search_matches: [], inline_styles: [(36, 45, Code)], syntax_colors: [] }, RenderedLine { text: "to generate the Inspect() output for *object.Hash. Here is said Inspect()", style: Normal, search_matches: [], inline_styles: [(16, 25, Code), (37, 49, Code), (64, 73, Code)], syntax_colors: [] }, RenderedLine { text: "method:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func (h *Hash) Inspect() string {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "    var out bytes.Buffer", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    pairs := []string{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "    for _, pair := range h.Pairs {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "        pairs = append(pairs, fmt.Sprintf(\"%s: %s\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "            pair.Key.Inspect(), pair.Value.Inspect()))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    out.WriteString(\"{\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(strings.Join(pairs, \", \"))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    out.WriteString(\"}\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return out.String()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The Inspect() method is not the only reason why it’s good to keep track of", style: Normal, search_matches: [], inline_styles: [(4, 13, Code)], syntax_colors: [] }, RenderedLine { text: "the objects that generated the HashKey. That would also be necessary if we", style: Normal, search_matches: [], inline_styles: [(32, 39, Code)], syntax_colors: [] }, RenderedLine { text: "were to implement something like a range function for Monkey hashes, which", style: Normal, search_matches: [], inline_styles: [(37, 42, Code)], syntax_colors: [] }, RenderedLine { text: "iterates over keys and values in the hash. Or if we want to add a firstPair", style: Normal, search_matches: [], inline_styles: [(68, 75, Code)], syntax_colors: [] }, RenderedLine { text: "function that returns the first key and value of a given hash as an array.", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "Or if we want… You get the drift. Keeping track of keys is highly useful,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "even though for now only the Inspect() method benefits.", style: Normal, search_matches: [], inline_styles: [(32, 41, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s it! That’s the whole implementation of object.Hash. But there’s a", style: Normal, search_matches: [], inline_styles: [(54, 65, Code)], syntax_colors: [] }, RenderedLine { text: "small thing we ought to do while we still have the object package open:", style: Normal, search_matches: [], inline_styles: [(51, 57, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// object/object.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "type Hashable interface {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "    HashKey() HashKey", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can use this interface in our evaluator to check if the given object is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "usable as a hash key when we evaluate hash literals or index expressions", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "for hashes.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "At the moment it’s only implemented by *object.String, *object.Boolean and", style: Normal, search_matches: [], inline_styles: [(41, 55, Code), (57, 72, Code)], syntax_colors: [] }, RenderedLine { text: "*object.Integer.", style: Normal, search_matches: [], inline_styles: [(1, 16, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Granted, there’s one more thing we could do before moving on: we could", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "optimize the performance of the HashKey() methods by caching their return", style: Normal, search_matches: [], inline_styles: [(33, 42, Code)], syntax_colors: [] }, RenderedLine { text: "values, but that sounds like a nice exercise for the performance-minded", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "reader.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Evaluating Hash Literals", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We’re about to start evaluating hash literals and I’ll be completely honest", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "with you: the hardest part about adding hashes to our interpreter is over.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "It’s smooth sailing from here on out. So, let’s enjoy the ride, relax and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "write a test:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestHashLiterals(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "    input := `let two = \"two\";", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "        \"one\": 10 - 9,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        two: 1 + 1,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "        \"thr\" + \"ee\": 6 / 2,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        4: 4,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "        true: 5,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "        false: 6", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "    }`", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    evaluated := testEval(input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "    result, ok := evaluated.(*object.Hash)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"Eval didn't return Hash. got=%T (%+v)\", evaluated, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    expected := map[object.HashKey]int64{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "        (&object.String{Value: \"one\"}).HashKey():   1,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        (&object.String{Value: \"two\"}).HashKey():   2,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        (&object.String{Value: \"three\"}).HashKey(): 3,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        (&object.Integer{Value: 4}).HashKey():      4,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        TRUE.HashKey():                             5,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        FALSE.HashKey():                            6,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    if len(result.Pairs) != len(expected) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 43, Rgb(192, 197, 206))] }, RenderedLine { text: "        t.Fatalf(\"Hash has wrong num of pairs. got=%d\", len(result.Pairs))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 74, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for expectedKey, expectedValue := range expected {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        pair, ok := result.Pairs[expectedKey]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            t.Errorf(\"no pair for given key in Pairs\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 54, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        testIntegerObject(t, pair.Value, expectedValue)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "This test function shows what we want from Eval when it encounters a", style: Normal, search_matches: [], inline_styles: [(43, 47, Code)], syntax_colors: [] }, RenderedLine { text: "*ast.HashLiteral: a fresh *object.Hash with the correct number of HashPairs", style: Normal, search_matches: [], inline_styles: [(0, 16, Code), (26, 38, Code), (66, 74, Code)], syntax_colors: [] }, RenderedLine { text: "mapped to the matching HashKeys in its Pairs attribute.", style: Normal, search_matches: [], inline_styles: [(23, 30, Code), (39, 44, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And it also shows another requirement we have: strings, identifiers, infix", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "operator expressions, booleans and integers - they should all be usable", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "as keys. Any expression really. As long as it produces an object that", style: Normal, search_matches: [], inline_styles: [(58, 64, Code)], syntax_colors: [] }, RenderedLine { text: "implements the Hashable interface it should usable as a hash key.", style: Normal, search_matches: [], inline_styles: [(15, 23, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Then there are the values. They can be produced by any expression, too. We", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "test for this here by asserting that 10 - 9 evaluates to 1, 6 / 2 to 3 and", style: Normal, search_matches: [], inline_styles: [(37, 43, Code), (57, 58, Code), (60, 65, Code), (69, 70, Code)], syntax_colors: [] }, RenderedLine { text: "so on.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "As expected the test fails:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestHashLiterals (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 34, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:522: Eval didn't return Hash. got=<nil> (<nil>)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.008s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We know how to get it to pass, though. We need to extend our Eval function", style: Normal, search_matches: [], inline_styles: [(61, 65, Code)], syntax_colors: [] }, RenderedLine { text: "with another case branch for *ast.HashLiterals:", style: Normal, search_matches: [], inline_styles: [(13, 17, Code), (29, 45, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func Eval(node ast.Node, env *object.Environment) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    case *ast.HashLiteral:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalHashLiteral(node, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The evalHashLiteral function here may look intimidating, but trust me, it", style: Normal, search_matches: [], inline_styles: [(4, 19, Code)], syntax_colors: [] }, RenderedLine { text: "doesn’t bite:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalHashLiteral(", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "    node *ast.HashLiteral,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 26, Rgb(192, 197, 206))] }, RenderedLine { text: "    env *object.Environment,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: ") object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "    pairs := make(map[object.HashKey]object.HashPair)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 53, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for keyNode, valueNode := range node.Pairs {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "        key := Eval(keyNode, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 33, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(key) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "            return key", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        hashKey, ok := key.(object.Hashable)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "        if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            return newError(\"unusable as hash key: %s\", key.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        value := Eval(valueNode, env)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "        if isError(value) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 27, Rgb(192, 197, 206))] }, RenderedLine { text: "            return value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "        hashed := hashKey.HashKey()", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "        pairs[hashed] = object.HashPair{Key: key, Value: value}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 63, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return &object.Hash{Pairs: pairs}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "When iterating over the node.Pairs the keyNode is the first to be evaluated.", style: Normal, search_matches: [], inline_styles: [(24, 34, Code), (39, 46, Code)], syntax_colors: [] }, RenderedLine { text: "Besides checking if the call to Eval produced an error we also make a", style: Normal, search_matches: [], inline_styles: [(32, 36, Code)], syntax_colors: [] }, RenderedLine { text: "type assertion about the evaluation result: it needs to implement the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Hashable interface, otherwise it’s unusable as a hash key. That’s", style: Normal, search_matches: [], inline_styles: [(0, 15, Code)], syntax_colors: [] }, RenderedLine { text: "exactly why we added the Hashable definition.", style: Normal, search_matches: [], inline_styles: [(26, 34, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Then we call Eval again, to evaluate valueNode. If that call to Eval also", style: Normal, search_matches: [], inline_styles: [(13, 17, Code), (37, 46, Code), (64, 68, Code)], syntax_colors: [] }, RenderedLine { text: "doesn’t produce an error, we can add the newly produced key-value pair", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "to our pairs map. We do this by generating a HashKey for the aptly-named", style: Normal, search_matches: [], inline_styles: [(8, 13, Code), (46, 53, Code)], syntax_colors: [] }, RenderedLine { text: "hashKey object with a call to HashKey(). Then we initialize a new HashPair,", style: Normal, search_matches: [], inline_styles: [(2, 9, Code), (32, 41, Code), (68, 75, Code)], syntax_colors: [] }, RenderedLine { text: "pointing to both key and value and add it to pairs.", style: Normal, search_matches: [], inline_styles: [(19, 22, Code), (27, 32, Code), (47, 51, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And that’s all it takes. The tests are now passing:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That means we can already start using hash literals in our REPL:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> {\"name\": \"Monkey\", \"age\": 0, \"type\": \"Language\", \"status\": \"awesome\"}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "{age: 0, type: Language, status: awesome, name: Monkey}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s awesome! But we can’t get elements out of the hash yet, which kinda", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "diminishes their usefulness:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let bob = {\"name\": \"Bob\", \"age\": 99};", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: ">> bob[\"name\"]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "ERROR: index operator not supported: HASH", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 41, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That’s what we’re going to fix now.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Evaluating Index Expressions With Hashes", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Remember that switch statement we added to evalIndexExpression in our", style: Normal, search_matches: [], inline_styles: [(43, 62, Code)], syntax_colors: [] }, RenderedLine { text: "evaluator? And do you also remember when I told you that we’re going to add", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "another case branch? Well, here we are!", style: Normal, search_matches: [], inline_styles: [(9, 13, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But first of all we need to add a test function that makes sure accessing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "values in a hash via an index expression works:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestHashIndexExpressions(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input    string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        expected interface{}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `{\"foo\": 5}[\"foo\"]`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "            5,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `{\"foo\": 5}[\"bar\"]`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "            nil,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `let key = \"foo\"; {\"foo\": 5}[key]`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "            5,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `{}[\"foo\"]`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            nil,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `{5: 5}[5]`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "            5,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `{true: 5}[true]`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "            5,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `{false: 5}[false]`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 32, Rgb(192, 197, 206))] }, RenderedLine { text: "            5,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 14, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    for _, tt := range tests {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        evaluated := testEval(tt.input)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "        integer, ok := tt.expected.(int)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        if ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 15, Rgb(192, 197, 206))] }, RenderedLine { text: "            testIntegerObject(t, evaluated, int64(integer))", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 59, Rgb(192, 197, 206))] }, RenderedLine { text: "        } else {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "            testNullObject(t, evaluated)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Just like in TestArrayIndexExpressions we’re making sure using index", style: Normal, search_matches: [], inline_styles: [(13, 38, Code)], syntax_colors: [] }, RenderedLine { text: "operator expressions produces the correct value - only this time with", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "hashes. The different test cases here use string, integer or boolean hash", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "keys when retrieving values out of a hash. So, in essence, what the test", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "really asserts is that the HashKey methods implemented by various data types", style: Normal, search_matches: [], inline_styles: [(29, 36, Code)], syntax_colors: [] }, RenderedLine { text: "are called correctly.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And to make sure that using an object as hash key that does not implement", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "object.Hashable produces an error, we can add another test to our", style: Normal, search_matches: [], inline_styles: [(0, 15, Code)], syntax_colors: [] }, RenderedLine { text: "TestErrorHandling test function:", style: Normal, search_matches: [], inline_styles: [(0, 17, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator_test.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func TestErrorHandling(t *testing.T) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    tests := []struct {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        input           string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "        expectedMessage string", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 30, Rgb(192, 197, 206))] }, RenderedLine { text: "    }{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "        {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "            `{\"name\": \"Monkey\"}[fn(x) { x }];`,", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "            \"unusable as hash key: FUNCTION\",", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Running go test now results in the expected failures:", style: Normal, search_matches: [], inline_styles: [(8, 15, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestErrorHandling (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 35, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:237: wrong error message.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "    expected=\"unusable as hash key: FUNCTION\",\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=\"index operator not supported: HASH\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 44, Rgb(192, 197, 206))] }, RenderedLine { text: "--- FAIL: TestHashIndexExpressions (0.00s)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:597: object is not Integer.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Error (&{Message:index operator not supported: HASH})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:625: object is not NULL.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Error (&{Message:index operator not supported: HASH})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:597: object is not Integer.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Error (&{Message:index operator not supported: HASH})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:625: object is not NULL.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 45, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Error (&{Message:index operator not supported: HASH})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:597: object is not Integer.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Error (&{Message:index operator not supported: HASH})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:597: object is not Integer.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Error (&{Message:index operator not supported: HASH})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "  evaluator_test.go:597: object is not Integer.\\", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: "    got=*object.Error (&{Message:index operator not supported: HASH})", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 69, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "FAIL    monkey/evaluator        0.009s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That means we’re ready to add another case branch to the switch statement in", style: Normal, search_matches: [], inline_styles: [(40, 44, Code)], syntax_colors: [] }, RenderedLine { text: "evalIndexExpression:", style: Normal, search_matches: [], inline_styles: [(1, 20, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalIndexExpression(left, index object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 67, Rgb(192, 197, 206))] }, RenderedLine { text: "    switch {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "    case left.Type() == object.ARRAY_OBJ && index.Type() == object.INTEGER_OBJ:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 79, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalArrayIndexExpression(left, index)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 52, Rgb(192, 197, 206))] }, RenderedLine { text: "    case left.Type() == object.HASH_OBJ:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "        return evalHashIndexExpression(left, index)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 51, Rgb(192, 197, 206))] }, RenderedLine { text: "    default:", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"index operator not supported: %s\", left.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 72, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The new case branch calls a new function: evalHashIndexExpression. And we", style: Normal, search_matches: [], inline_styles: [(8, 12, Code), (42, 65, Code)], syntax_colors: [] }, RenderedLine { text: "already know how evalHashIndexExpression has to work, since we successfully", style: Normal, search_matches: [], inline_styles: [(17, 40, Code)], syntax_colors: [] }, RenderedLine { text: "tested the usage of the object.Hashable interface before - in our tests and", style: Normal, search_matches: [], inline_styles: [(24, 39, Code)], syntax_colors: [] }, RenderedLine { text: "when evaluating hash literals. So no surprises here:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/evaluator.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 25, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "func evalHashIndexExpression(hash, index object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 71, Rgb(192, 197, 206))] }, RenderedLine { text: "    hashObject := hash.(*object.Hash)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 37, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    key, ok := index.(object.Hashable)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return newError(\"unusable as hash key: %s\", index.Type())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 65, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    pair, ok := hashObject.Pairs[key.HashKey()]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 47, Rgb(192, 197, 206))] }, RenderedLine { text: "    if !ok {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "        return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: "    }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "    return pair.Value", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Adding evalHashIndexExpression to the switch statement makes the tests pass:", style: Normal, search_matches: [], inline_styles: [(7, 30, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go test ./evaluator", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "ok      monkey/evaluator        0.007s", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "We can now successfully retrieve values from our hashes! Don’t believe me?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Think the tests are lying to us? I faked the test output? It can’t be? The", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "whole book is full of li.. what? No, watch this.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let people = [{\"name\": \"Alice\", \"age\": 24}, {\"name\": \"Anna\", \"age\": 28}];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 76, Rgb(192, 197, 206))] }, RenderedLine { text: ">> people[0][\"name\"];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 21, Rgb(192, 197, 206))] }, RenderedLine { text: "Alice", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: ">> people[1][\"age\"];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 20, Rgb(192, 197, 206))] }, RenderedLine { text: "28", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> people[1][\"age\"] + people[0][\"age\"];", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 39, Rgb(192, 197, 206))] }, RenderedLine { text: "52", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: ">> let getName = fn(person) { person[\"name\"]; };", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 48, Rgb(192, 197, 206))] }, RenderedLine { text: ">> getName(people[0]);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "Alice", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: ">> getName(people[1]);", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 22, Rgb(192, 197, 206))] }, RenderedLine { text: "Anna", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "4.6 - The Grand Finale", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Our Monkey interpreter is now fully functional. It supports mathematical", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "expressions, variable bindings, functions and the application of those", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "functions, conditionals, return statements and even advanced concepts like", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "higher-order functions and closures. And then there are the different data", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "types: integers, booleans, strings, arrays and hashes. We can be proud of", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "ourselves.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "But… and here comes the but… our interpreter still does not pass the most", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "basic of all programming language tests: printing something. Yes, our Monkey", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "interpreter can’t communicate with the outside world. Even programming", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "language scoundrel like Bash and Brainfuck manage to do that. It’s clear", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "what we have to do. We have to add one last built-in function: puts.", style: Normal, search_matches: [], inline_styles: [(66, 68, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "puts prints the given arguments on new lines to STDOUT. It calls the", style: Normal, search_matches: [], inline_styles: [(0, 4, Code)], syntax_colors: [] }, RenderedLine { text: "Inspect() method on the objects passed in as arguments and prints the return", style: Normal, search_matches: [], inline_styles: [(0, 9, Code)], syntax_colors: [] }, RenderedLine { text: "value of these calls. The Inspect() method is part of the Object interface,", style: Normal, search_matches: [], inline_styles: [(26, 35, Code), (58, 64, Code)], syntax_colors: [] }, RenderedLine { text: "so every entity in our object system supports it. Using puts should look", style: Normal, search_matches: [], inline_styles: [(56, 60, Code)], syntax_colors: [] }, RenderedLine { text: "kinda like this:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> puts(\"Hello!\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: ">> puts(1234)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "1234", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: ">> puts(fn(x) { x * x })", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "fn(x) {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "(x * x)", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 7, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And puts is a variadic function. It takes an unlimited number of arguments", style: Normal, search_matches: [], inline_styles: [(4, 8, Code)], syntax_colors: [] }, RenderedLine { text: "and prints each on a separate line:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> puts(\"hello\", \"world\", \"how\", \"are\", \"you\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 46, Rgb(192, 197, 206))] }, RenderedLine { text: "hello", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "world", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 5, Rgb(192, 197, 206))] }, RenderedLine { text: "how", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "are", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "you", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 3, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Of course, puts is all about printing things and not producing a value, so", style: Normal, search_matches: [], inline_styles: [(11, 15, Code)], syntax_colors: [] }, RenderedLine { text: "we need to make sure that it returns NULL:", style: Normal, search_matches: [], inline_styles: [(37, 41, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> let putsReturnValue = puts(\"foobar\");", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 40, Rgb(192, 197, 206))] }, RenderedLine { text: "foobar", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: ">> putsReturnValue", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 18, Rgb(192, 197, 206))] }, RenderedLine { text: "null", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "That also means that our REPL will print the null in addition to the output", style: Normal, search_matches: [], inline_styles: [(45, 49, Code)], syntax_colors: [] }, RenderedLine { text: "we expect from puts. So it will look like this:", style: Normal, search_matches: [], inline_styles: [(15, 19, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: ">> puts(\"Hello!\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 17, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "null", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Now that’s more than enough information and specification to complete this", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "last quest of ours. Are you ready?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Here it is, here’s what this section has been building up to, here is the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "complete, working implementation of puts:", style: Normal, search_matches: [], inline_styles: [(37, 41, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "// evaluator/builtins.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 24, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "import (", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"fmt\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 9, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"monkey/object\"", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 19, Rgb(192, 197, 206))] }, RenderedLine { text: ")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "var builtins = map[string]*object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "// [...]", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 8, Rgb(192, 197, 206))] }, RenderedLine { text: "    \"puts\": &object.Builtin{", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 28, Rgb(192, 197, 206))] }, RenderedLine { text: "        Fn: func(args ...object.Object) object.Object {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 55, Rgb(192, 197, 206))] }, RenderedLine { text: "            for _, arg := range args {", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 38, Rgb(192, 197, 206))] }, RenderedLine { text: "                fmt.Println(arg.Inspect())", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 42, Rgb(192, 197, 206))] }, RenderedLine { text: "            }", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 13, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "            return NULL", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "        },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 10, Rgb(192, 197, 206))] }, RenderedLine { text: "    },", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 6, Rgb(192, 197, 206))] }, RenderedLine { text: "}", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 1, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "And with that, we did it. We’re done. Even if you were wary of our little", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "celebrations and shrugged them off before, now’s the time to go looking for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "a funny party hat and put it on.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In chapter three we brought the Monkey programming language to life. It", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "started to breathe. With our last change, we made it talk. Now, Monkey is", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "finally a real programming language:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "$ go run main.go", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 16, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello mrnugget! This is the Monkey programming language!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 56, Rgb(192, 197, 206))] }, RenderedLine { text: "Feel free to type in commands", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 29, Rgb(192, 197, 206))] }, RenderedLine { text: ">> puts(\"Hello World!\")", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 23, Rgb(192, 197, 206))] }, RenderedLine { text: "Hello World!", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 12, Rgb(192, 197, 206))] }, RenderedLine { text: "null", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 4, Rgb(192, 197, 206))] }, RenderedLine { text: ">>", style: CodeBlock { language: Some("") }, search_matches: [], inline_styles: [], syntax_colors: [(0, 2, Rgb(192, 197, 206))] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>ch006.xhtml</title>\n  <style>\npre > code.sourceCode { white-space: pre; position: relative; }\npre > code.sourceCode > span { display: inline-block; line-height: 1.25; }\npre > code.sourceCode > span:empty { height: 1.2em; }\ncode.sourceCode > span { color: inherit; text-decoration: inherit; }\ndiv.sourceCode { margin: 1em 0; }\npre.sourceCode { margin: 0; }\n@media screen {\ndiv.sourceCode { overflow: auto; }\n}\n@media print {\npre > code.sourceCode { white-space: pre-wrap; }\npre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }\n}\npre.numberSource code\n  { counter-reset: source-line 0; }\npre.numberSource code > span\n  { position: relative; left: -4em; counter-increment: source-line; }\npre.numberSource code > span > a:first-child::before\n  { content: counter(source-line);\n    position: relative; left: -1em; text-align: right; vertical-align: baseline;\n    border: none; display: inline-block;\n    -webkit-touch-callout: none; -webkit-user-select: none;\n    -khtml-user-select: none; -moz-user-select: none;\n    -ms-user-select: none; user-select: none;\n    padding: 0 4px; width: 4em;\n    color: #aaaaaa;\n  }\npre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\ndiv.sourceCode\n  {   }\n@media screen {\npre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }\n}\ncode span.al { color: #ff0000; font-weight: bold; } /* Alert */\ncode span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */\ncode span.at { color: #7d9029; } /* Attribute */\ncode span.bn { color: #40a070; } /* BaseN */\ncode span.bu { } /* BuiltIn */\ncode span.cf { color: #007020; font-weight: bold; } /* ControlFlow */\ncode span.ch { color: #4070a0; } /* Char */\ncode span.cn { color: #880000; } /* Constant */\ncode span.co { color: #60a0b0; font-style: italic; } /* Comment */\ncode span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */\ncode span.do { color: #ba2121; font-style: italic; } /* Documentation */\ncode span.dt { color: #902000; } /* DataType */\ncode span.dv { color: #40a070; } /* DecVal */\ncode span.er { color: #ff0000; font-weight: bold; } /* Error */\ncode span.ex { } /* Extension */\ncode span.fl { color: #40a070; } /* Float */\ncode span.fu { color: #06287e; } /* Function */\ncode span.im { } /* Import */\ncode span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */\ncode span.kw { color: #007020; font-weight: bold; } /* Keyword */\ncode span.op { color: #666666; } /* Operator */\ncode span.ot { color: #007020; } /* Other */\ncode span.pp { color: #bc7a00; } /* Preprocessor */\ncode span.sc { color: #4070a0; } /* SpecialChar */\ncode span.ss { color: #bb6688; } /* SpecialString */\ncode span.st { color: #4070a0; } /* String */\ncode span.va { color: #19177c; } /* Variable */\ncode span.vs { color: #4070a0; } /* VerbatimString */\ncode span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */\n/* Apple Books 2.4+ doesn't like overflow:auto on syntax highlighting generated by skylighting */\n@media screen {\n  div.sourceCode { overflow: visible !important; }\n  p, span, pre, code, blockquote { overflow: visible !important; }\n}\n  </style>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"bodymatter\">\n<section id=\"extending-the-interpreter\" class=\"level1\" data-number=\"4\">\n<h1 data-number=\"4\">Extending the Interpreter</h1>\n<section id=\"data-types-functions\" class=\"level2\" data-number=\"4.1\">\n<h2 data-number=\"4.1\">4.1 - Data Types &amp; Functions</h2>\n<p>Even though our interpreter works amazingly well and has some mind-blowing features, like first-class functions and closures, the only data types we had available as users of Monkey were integers and booleans. That’s not especially useful and a lot less than what we’re used to from other programming languages. In this chapter we’re going to change that. We’re going to add new data types to our interpreter.</p>\n<p>The great thing about this endeavor is that it takes us through the whole interpreter again. We will add new token types, modify the lexer, extend the parser and finally add support for the data types to our evaluator and the object system.</p>\n<p>Even better is that the data types we’re going to add are already present in Go. That means that we only need to make them available in Monkey. We don’t need to implement them from scratch, which is pretty handy, since this book isn’t called “Implementing Common Data Structures In Go” and we can concentrate on our interpreter.</p>\n<p>In addition to that we’re also going to make the interpreter much more powerful by adding some new functions. Of course, as users of our interpreter we could define functions ourselves just fine, but those were limited in what they could do. These new ones, called built-in functions, will be much more powerful, since they have access to the inner workings of the Monkey programming language.</p>\n<p>The first thing we’re going to do is add a data type we all know: the string. Nearly every programming language has it and Monkey shall have it too.</p>\n</section>\n<section id=\"strings\" class=\"level2\" data-number=\"4.2\">\n<h2 data-number=\"4.2\">4.2 - Strings</h2>\n<p>In Monkey strings are a sequence of characters. They are first-class values, can be bound to identifiers, used as arguments in functions calls and be returned by functions. They look just like the strings in many other programming languages: characters enclosed by double quotes.</p>\n<p>Besides the data type itself, in this section we’ll also add support for string concatenation by supporting the infix operator <code>+</code> for strings.</p>\n<p>At the end, we’ll be able to do this:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb1-1\"><a href=\"#cb1-1\"></a>$ go run main.go</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\"></a>Feel free to type in commands</span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\"></a>&gt;&gt; let firstName = &quot;Thorsten&quot;;</span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\"></a>&gt;&gt; let lastName = &quot;Ball&quot;;</span>\n<span id=\"cb1-6\"><a href=\"#cb1-6\"></a>&gt;&gt; let fullName = fn(first, last) { first + &quot; &quot; + last };</span>\n<span id=\"cb1-7\"><a href=\"#cb1-7\"></a>&gt;&gt; fullName(firstName, lastName);</span>\n<span id=\"cb1-8\"><a href=\"#cb1-8\"></a>Thorsten Ball</span></code></pre></div>\n<section id=\"supporting-strings-in-our-lexer\" class=\"level3\" data-number=\"4.2.1\">\n<h3 data-number=\"4.2.1\">Supporting Strings in our Lexer</h3>\n<p>The first thing we have to do is add support for string literals to our lexer. The basic structure of strings is this:</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb2-1\"><a href=\"#cb2-1\"></a>&quot;&lt;sequence of characters&gt;&quot;</span></code></pre></div>\n<p>That’s not too hard, right? A sequence of characters enclosed by double quotes.</p>\n<p>What we want from our lexer is a single token for each string literal. So in the case of <code>\"Hello World\"</code> we want a single token, instead of tokens for <code>\"</code>, <code>Hello</code>, <code>World</code> and <code>\"</code>. A single token for string literals makes handling them in our parser a lot easier and we move the bulk of the work to one small method in the lexer.</p>\n<p>Of course, the approach using multiple tokens is also valid and maybe beneficial in some cases/parsers. We could use <code>\"</code> surrounding <code>token.IDENT</code> tokens. But in our case, we’ll mirror the <code>token.INT</code> integer tokens we already have and carry the string literal itself around in the <code>.Literal</code> field of the token.</p>\n<p>And with that being clear, it’s time to work on our tokens and our lexer again. We haven’t touched those since the first chapter, but I’m sure we’ll do just fine.</p>\n<p>The first thing we need to do is add a new <code>STRING</code> token type to our <code>token</code> package:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb3-1\"><a href=\"#cb3-1\"></a><span class=\"co\">// token/token.go</span></span>\n<span id=\"cb3-2\"><a href=\"#cb3-2\"></a></span>\n<span id=\"cb3-3\"><a href=\"#cb3-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb3-4\"><a href=\"#cb3-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb3-5\"><a href=\"#cb3-5\"></a>    STRING = <span class=\"st\">&quot;STRING&quot;</span></span>\n<span id=\"cb3-6\"><a href=\"#cb3-6\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb3-7\"><a href=\"#cb3-7\"></a>)</span></code></pre></div>\n<p>With that in place we can add a test case for our lexer to see if strings are properly supported. To do that we just extend the <code>input</code> in our <code>TestNextToken</code> test function:</p>\n<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb4-1\"><a href=\"#cb4-1\"></a><span class=\"co\">// lexer/lexer_test.go</span></span>\n<span id=\"cb4-2\"><a href=\"#cb4-2\"></a></span>\n<span id=\"cb4-3\"><a href=\"#cb4-3\"></a><span class=\"kw\">func</span> TestNextToken(t *testing.T) {</span>\n<span id=\"cb4-4\"><a href=\"#cb4-4\"></a>    input := <span class=\"st\">`let five = 5;</span></span>\n<span id=\"cb4-5\"><a href=\"#cb4-5\"></a><span class=\"st\">let ten = 10;</span></span>\n<span id=\"cb4-6\"><a href=\"#cb4-6\"></a></span>\n<span id=\"cb4-7\"><a href=\"#cb4-7\"></a><span class=\"st\">let add = fn(x, y) {</span></span>\n<span id=\"cb4-8\"><a href=\"#cb4-8\"></a><span class=\"st\">  x + y;</span></span>\n<span id=\"cb4-9\"><a href=\"#cb4-9\"></a><span class=\"st\">};</span></span>\n<span id=\"cb4-10\"><a href=\"#cb4-10\"></a></span>\n<span id=\"cb4-11\"><a href=\"#cb4-11\"></a><span class=\"st\">let result = add(five, ten);</span></span>\n<span id=\"cb4-12\"><a href=\"#cb4-12\"></a><span class=\"st\">!-/*5;</span></span>\n<span id=\"cb4-13\"><a href=\"#cb4-13\"></a><span class=\"st\">5 &lt; 10 &gt; 5;</span></span>\n<span id=\"cb4-14\"><a href=\"#cb4-14\"></a></span>\n<span id=\"cb4-15\"><a href=\"#cb4-15\"></a><span class=\"st\">if (5 &lt; 10) {</span></span>\n<span id=\"cb4-16\"><a href=\"#cb4-16\"></a><span class=\"st\">    return true;</span></span>\n<span id=\"cb4-17\"><a href=\"#cb4-17\"></a><span class=\"st\">} else {</span></span>\n<span id=\"cb4-18\"><a href=\"#cb4-18\"></a><span class=\"st\">    return false;</span></span>\n<span id=\"cb4-19\"><a href=\"#cb4-19\"></a><span class=\"st\">}</span></span>\n<span id=\"cb4-20\"><a href=\"#cb4-20\"></a></span>\n<span id=\"cb4-21\"><a href=\"#cb4-21\"></a><span class=\"st\">10 == 10;</span></span>\n<span id=\"cb4-22\"><a href=\"#cb4-22\"></a><span class=\"st\">10 != 9;</span></span>\n<span id=\"cb4-23\"><a href=\"#cb4-23\"></a><span class=\"st\">&quot;foobar&quot;</span></span>\n<span id=\"cb4-24\"><a href=\"#cb4-24\"></a><span class=\"st\">&quot;foo bar&quot;</span></span>\n<span id=\"cb4-25\"><a href=\"#cb4-25\"></a><span class=\"st\">`</span></span>\n<span id=\"cb4-26\"><a href=\"#cb4-26\"></a></span>\n<span id=\"cb4-27\"><a href=\"#cb4-27\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb4-28\"><a href=\"#cb4-28\"></a>        expectedType    token.TokenType</span>\n<span id=\"cb4-29\"><a href=\"#cb4-29\"></a>        expectedLiteral <span class=\"dt\">string</span></span>\n<span id=\"cb4-30\"><a href=\"#cb4-30\"></a>    }{</span>\n<span id=\"cb4-31\"><a href=\"#cb4-31\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb4-32\"><a href=\"#cb4-32\"></a>        {token.STRING, <span class=\"st\">&quot;foobar&quot;</span>},</span>\n<span id=\"cb4-33\"><a href=\"#cb4-33\"></a>        {token.STRING, <span class=\"st\">&quot;foo bar&quot;</span>},</span>\n<span id=\"cb4-34\"><a href=\"#cb4-34\"></a>        {token.EOF, <span class=\"st\">&quot;&quot;</span>},</span>\n<span id=\"cb4-35\"><a href=\"#cb4-35\"></a>    }</span>\n<span id=\"cb4-36\"><a href=\"#cb4-36\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb4-37\"><a href=\"#cb4-37\"></a>}</span></code></pre></div>\n<p>The <code>input</code> now has two more lines containing the string literals we want to turn into tokens. There’s <code>\"foobar\"</code> to make sure that lexing of string literals works and <code>\"foo bar\"</code> to make sure that it still works even with whitespace inside a literal.</p>\n<p>Of course, the tests fail, because we haven’t changed anything in the <code>Lexer</code> yet:</p>\n<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb5-1\"><a href=\"#cb5-1\"></a>$ go test ./lexer</span>\n<span id=\"cb5-2\"><a href=\"#cb5-2\"></a>--- FAIL: TestNextToken (0.00s)</span>\n<span id=\"cb5-3\"><a href=\"#cb5-3\"></a>  lexer_test.go:122: tests[73] - tokentype wrong. expected=&quot;STRING&quot;,\\</span>\n<span id=\"cb5-4\"><a href=\"#cb5-4\"></a>    got=&quot;ILLEGAL&quot;</span>\n<span id=\"cb5-5\"><a href=\"#cb5-5\"></a>FAIL</span>\n<span id=\"cb5-6\"><a href=\"#cb5-6\"></a>FAIL    monkey/lexer    0.006s</span></code></pre></div>\n<p>Fixing the tests is easier than you might think. All we need to do is add a <code>case</code> branch for <code>\"</code> to the switch statement in our <code>Lexer</code> and add a small helper method:</p>\n<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb6-1\"><a href=\"#cb6-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb6-2\"><a href=\"#cb6-2\"></a></span>\n<span id=\"cb6-3\"><a href=\"#cb6-3\"></a><span class=\"kw\">func</span> (l *Lexer) NextToken() token.Token {</span>\n<span id=\"cb6-4\"><a href=\"#cb6-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb6-5\"><a href=\"#cb6-5\"></a></span>\n<span id=\"cb6-6\"><a href=\"#cb6-6\"></a>    <span class=\"kw\">switch</span> l.ch {</span>\n<span id=\"cb6-7\"><a href=\"#cb6-7\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb6-8\"><a href=\"#cb6-8\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;&quot;&#39;</span>:</span>\n<span id=\"cb6-9\"><a href=\"#cb6-9\"></a>        tok.Type = token.STRING</span>\n<span id=\"cb6-10\"><a href=\"#cb6-10\"></a>        tok.Literal = l.readString()</span>\n<span id=\"cb6-11\"><a href=\"#cb6-11\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb6-12\"><a href=\"#cb6-12\"></a>    }</span>\n<span id=\"cb6-13\"><a href=\"#cb6-13\"></a></span>\n<span id=\"cb6-14\"><a href=\"#cb6-14\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb6-15\"><a href=\"#cb6-15\"></a>}</span>\n<span id=\"cb6-16\"><a href=\"#cb6-16\"></a></span>\n<span id=\"cb6-17\"><a href=\"#cb6-17\"></a><span class=\"kw\">func</span> (l *Lexer) readString() <span class=\"dt\">string</span> {</span>\n<span id=\"cb6-18\"><a href=\"#cb6-18\"></a>    position := l.position + <span class=\"dv\">1</span></span>\n<span id=\"cb6-19\"><a href=\"#cb6-19\"></a>    <span class=\"kw\">for</span> {</span>\n<span id=\"cb6-20\"><a href=\"#cb6-20\"></a>        l.readChar()</span>\n<span id=\"cb6-21\"><a href=\"#cb6-21\"></a>        <span class=\"kw\">if</span> l.ch == <span class=\"ch\">&#39;&quot;&#39;</span> || l.ch == <span class=\"dv\">0</span> {</span>\n<span id=\"cb6-22\"><a href=\"#cb6-22\"></a>            <span class=\"kw\">break</span></span>\n<span id=\"cb6-23\"><a href=\"#cb6-23\"></a>        }</span>\n<span id=\"cb6-24\"><a href=\"#cb6-24\"></a>    }</span>\n<span id=\"cb6-25\"><a href=\"#cb6-25\"></a>    <span class=\"kw\">return</span> l.input[position:l.position]</span>\n<span id=\"cb6-26\"><a href=\"#cb6-26\"></a>}</span></code></pre></div>\n<p>There’s really nothing mysterious about these changes. A new <code>case</code> branch and a helper function called <code>readString</code> that calls <code>readChar</code> until it encounters either a closing double quote or the end of the input.</p>\n<p>If you think that this is too easy, feel free to make <code>readString</code> report an error instead of simply returning when it reaches the end of the input. Or you can add support for character escaping so that string literals like <code>\"hello \\\"world\\\"\"</code>, <code>\"hello\\n world\"</code> and <code>\"hello\\t\\t\\tworld\"</code> work.</p>\n<p>Meanwhile, our tests are passing:</p>\n<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb7-1\"><a href=\"#cb7-1\"></a>$ go test ./lexer</span>\n<span id=\"cb7-2\"><a href=\"#cb7-2\"></a>ok      monkey/lexer    0.006s</span></code></pre></div>\n<p>Great! Our lexer now knows how to handle string literals. It’s time to teach the parser how to do the same.</p>\n</section>\n<section id=\"parsing-strings\" class=\"level3\" data-number=\"4.2.2\">\n<h3 data-number=\"4.2.2\">Parsing Strings</h3>\n<p>In order for our parser to turn <code>token.STRING</code> into a string literal AST node we need to define said node. Thankfully the definition couldn’t be simpler. It looks really similar to <code>ast.IntegerLiteral</code>, except that the <code>Value</code> field now contains a <code>string</code> instead of an <code>int64</code>.</p>\n<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb8-1\"><a href=\"#cb8-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb8-2\"><a href=\"#cb8-2\"></a></span>\n<span id=\"cb8-3\"><a href=\"#cb8-3\"></a><span class=\"kw\">type</span> StringLiteral <span class=\"kw\">struct</span> {</span>\n<span id=\"cb8-4\"><a href=\"#cb8-4\"></a>    Token token.Token</span>\n<span id=\"cb8-5\"><a href=\"#cb8-5\"></a>    Value <span class=\"dt\">string</span></span>\n<span id=\"cb8-6\"><a href=\"#cb8-6\"></a>}</span>\n<span id=\"cb8-7\"><a href=\"#cb8-7\"></a></span>\n<span id=\"cb8-8\"><a href=\"#cb8-8\"></a><span class=\"kw\">func</span> (sl *StringLiteral) expressionNode()      {}</span>\n<span id=\"cb8-9\"><a href=\"#cb8-9\"></a><span class=\"kw\">func</span> (sl *StringLiteral) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> sl.Token.Literal }</span>\n<span id=\"cb8-10\"><a href=\"#cb8-10\"></a><span class=\"kw\">func</span> (sl *StringLiteral) String() <span class=\"dt\">string</span>       { <span class=\"kw\">return</span> sl.Token.Literal }</span></code></pre></div>\n<p>Of course, string literals are expressions and not statements. They evaluate to the string.</p>\n<p>With that definition we can write a small test case that makes sure the parser knows how to handle <code>token.STRING</code> tokens and outputs <code>*ast.StringLiteral</code>s:</p>\n<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb9-1\"><a href=\"#cb9-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb9-2\"><a href=\"#cb9-2\"></a></span>\n<span id=\"cb9-3\"><a href=\"#cb9-3\"></a><span class=\"kw\">func</span> TestStringLiteralExpression(t *testing.T) {</span>\n<span id=\"cb9-4\"><a href=\"#cb9-4\"></a>    input := <span class=\"st\">`&quot;hello world&quot;;`</span></span>\n<span id=\"cb9-5\"><a href=\"#cb9-5\"></a></span>\n<span id=\"cb9-6\"><a href=\"#cb9-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb9-7\"><a href=\"#cb9-7\"></a>    p := New(l)</span>\n<span id=\"cb9-8\"><a href=\"#cb9-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb9-9\"><a href=\"#cb9-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb9-10\"><a href=\"#cb9-10\"></a></span>\n<span id=\"cb9-11\"><a href=\"#cb9-11\"></a>    stmt := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb9-12\"><a href=\"#cb9-12\"></a>    literal, ok := stmt.Expression.(*ast.StringLiteral)</span>\n<span id=\"cb9-13\"><a href=\"#cb9-13\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb9-14\"><a href=\"#cb9-14\"></a>        t.Fatalf(<span class=\"st\">&quot;exp not *ast.StringLiteral. got=%T&quot;</span>, stmt.Expression)</span>\n<span id=\"cb9-15\"><a href=\"#cb9-15\"></a>    }</span>\n<span id=\"cb9-16\"><a href=\"#cb9-16\"></a></span>\n<span id=\"cb9-17\"><a href=\"#cb9-17\"></a>    <span class=\"kw\">if</span> literal.Value != <span class=\"st\">&quot;hello world&quot;</span> {</span>\n<span id=\"cb9-18\"><a href=\"#cb9-18\"></a>        t.Errorf(<span class=\"st\">&quot;literal.Value not %q. got=%q&quot;</span>, <span class=\"st\">&quot;hello world&quot;</span>, literal.Value)</span>\n<span id=\"cb9-19\"><a href=\"#cb9-19\"></a>    }</span>\n<span id=\"cb9-20\"><a href=\"#cb9-20\"></a>}</span></code></pre></div>\n<p>Running the tests results in a well known type of parser error:</p>\n<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb10-1\"><a href=\"#cb10-1\"></a>$ go test ./parser</span>\n<span id=\"cb10-2\"><a href=\"#cb10-2\"></a>--- FAIL: TestStringLiteralExpression (0.00s)</span>\n<span id=\"cb10-3\"><a href=\"#cb10-3\"></a>  parser_test.go:888: parser has 1 errors</span>\n<span id=\"cb10-4\"><a href=\"#cb10-4\"></a>  parser_test.go:890: parser error: &quot;no prefix parse function for STRING found&quot;</span>\n<span id=\"cb10-5\"><a href=\"#cb10-5\"></a>FAIL</span>\n<span id=\"cb10-6\"><a href=\"#cb10-6\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>We’ve seen that many times before and we know how to fix it. All we have to do is register a new <code>prefixParseFn</code> for <code>token.STRING</code> tokens. This parse function then returns an <code>*ast.StringLiteral</code>:</p>\n<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb11-1\"><a href=\"#cb11-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb11-2\"><a href=\"#cb11-2\"></a></span>\n<span id=\"cb11-3\"><a href=\"#cb11-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb11-4\"><a href=\"#cb11-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb11-5\"><a href=\"#cb11-5\"></a>    p.registerPrefix(token.STRING, p.parseStringLiteral)</span>\n<span id=\"cb11-6\"><a href=\"#cb11-6\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb11-7\"><a href=\"#cb11-7\"></a>}</span>\n<span id=\"cb11-8\"><a href=\"#cb11-8\"></a></span>\n<span id=\"cb11-9\"><a href=\"#cb11-9\"></a><span class=\"kw\">func</span> (p *Parser) parseStringLiteral() ast.Expression {</span>\n<span id=\"cb11-10\"><a href=\"#cb11-10\"></a>    <span class=\"kw\">return</span> &amp;ast.StringLiteral{Token: p.curToken, Value: p.curToken.Literal}</span>\n<span id=\"cb11-11\"><a href=\"#cb11-11\"></a>}</span></code></pre></div>\n<p>Three new lines! That’s all it takes to make the tests pass:</p>\n<div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb12-1\"><a href=\"#cb12-1\"></a>$ go test ./parser</span>\n<span id=\"cb12-2\"><a href=\"#cb12-2\"></a>ok      monkey/parser   0.007s</span></code></pre></div>\n<p>So now our lexer turns string literals into <code>token.STRING</code> tokens and the parser turns those into <code>*ast.StringLiteral</code> nodes. We’re now ready to make changes to our object system and the evaluator.</p>\n</section>\n<section id=\"evaluating-strings\" class=\"level3\" data-number=\"4.2.3\">\n<h3 data-number=\"4.2.3\">Evaluating Strings</h3>\n<p>Representing a string in our object system is as easy as representing integers. And the biggest reason why it’s so easy is that we reuse Go’s <code>string</code> data type. Imagine adding a data type to the guest language that can’t be represented with built-in data structures of the host language. E.g.: strings in C. That’s a lot more work. But instead, all we have to do is define a new object that holds a string:</p>\n<div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb13-1\"><a href=\"#cb13-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb13-2\"><a href=\"#cb13-2\"></a></span>\n<span id=\"cb13-3\"><a href=\"#cb13-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb13-4\"><a href=\"#cb13-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb13-5\"><a href=\"#cb13-5\"></a>    STRING_OBJ = <span class=\"st\">&quot;STRING&quot;</span></span>\n<span id=\"cb13-6\"><a href=\"#cb13-6\"></a>)</span>\n<span id=\"cb13-7\"><a href=\"#cb13-7\"></a></span>\n<span id=\"cb13-8\"><a href=\"#cb13-8\"></a><span class=\"kw\">type</span> String <span class=\"kw\">struct</span> {</span>\n<span id=\"cb13-9\"><a href=\"#cb13-9\"></a>    Value <span class=\"dt\">string</span></span>\n<span id=\"cb13-10\"><a href=\"#cb13-10\"></a>}</span>\n<span id=\"cb13-11\"><a href=\"#cb13-11\"></a></span>\n<span id=\"cb13-12\"><a href=\"#cb13-12\"></a><span class=\"kw\">func</span> (s *String) Type() ObjectType { <span class=\"kw\">return</span> STRING_OBJ }</span>\n<span id=\"cb13-13\"><a href=\"#cb13-13\"></a><span class=\"kw\">func</span> (s *String) Inspect() <span class=\"dt\">string</span>  { <span class=\"kw\">return</span> s.Value }</span></code></pre></div>\n<p>Now we need to extend our evaluator so it turns <code>*ast.StringLiteral</code> in <code>object.String</code> objects. The test to make sure that this works is tiny:</p>\n<div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb14-1\"><a href=\"#cb14-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb14-2\"><a href=\"#cb14-2\"></a></span>\n<span id=\"cb14-3\"><a href=\"#cb14-3\"></a><span class=\"kw\">func</span> TestStringLiteral(t *testing.T) {</span>\n<span id=\"cb14-4\"><a href=\"#cb14-4\"></a>    input := <span class=\"st\">`&quot;Hello World!&quot;`</span></span>\n<span id=\"cb14-5\"><a href=\"#cb14-5\"></a></span>\n<span id=\"cb14-6\"><a href=\"#cb14-6\"></a>    evaluated := testEval(input)</span>\n<span id=\"cb14-7\"><a href=\"#cb14-7\"></a>    str, ok := evaluated.(*object.String)</span>\n<span id=\"cb14-8\"><a href=\"#cb14-8\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb14-9\"><a href=\"#cb14-9\"></a>        t.Fatalf(<span class=\"st\">&quot;object is not String. got=%T (%+v)&quot;</span>, evaluated, evaluated)</span>\n<span id=\"cb14-10\"><a href=\"#cb14-10\"></a>    }</span>\n<span id=\"cb14-11\"><a href=\"#cb14-11\"></a></span>\n<span id=\"cb14-12\"><a href=\"#cb14-12\"></a>    <span class=\"kw\">if</span> str.Value != <span class=\"st\">&quot;Hello World!&quot;</span> {</span>\n<span id=\"cb14-13\"><a href=\"#cb14-13\"></a>        t.Errorf(<span class=\"st\">&quot;String has wrong value. got=%q&quot;</span>, str.Value)</span>\n<span id=\"cb14-14\"><a href=\"#cb14-14\"></a>    }</span>\n<span id=\"cb14-15\"><a href=\"#cb14-15\"></a>}</span></code></pre></div>\n<p>The call to <code>Eval</code> doesn’t return an <code>*object.String</code> yet but <code>nil</code>:</p>\n<div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb15-1\"><a href=\"#cb15-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb15-2\"><a href=\"#cb15-2\"></a>--- FAIL: TestStringLiteral (0.00s)</span>\n<span id=\"cb15-3\"><a href=\"#cb15-3\"></a>  evaluator_test.go:317: object is not String. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb15-4\"><a href=\"#cb15-4\"></a>FAIL</span>\n<span id=\"cb15-5\"><a href=\"#cb15-5\"></a>FAIL    monkey/evaluator        0.007s</span></code></pre></div>\n<p>Getting this test to pass needs even fewer lines than in the parser. Just two:</p>\n<div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb16-1\"><a href=\"#cb16-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb16-2\"><a href=\"#cb16-2\"></a></span>\n<span id=\"cb16-3\"><a href=\"#cb16-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb16-4\"><a href=\"#cb16-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb16-5\"><a href=\"#cb16-5\"></a></span>\n<span id=\"cb16-6\"><a href=\"#cb16-6\"></a>    <span class=\"kw\">case</span> *ast.StringLiteral:</span>\n<span id=\"cb16-7\"><a href=\"#cb16-7\"></a>        <span class=\"kw\">return</span> &amp;object.String{Value: node.Value}</span>\n<span id=\"cb16-8\"><a href=\"#cb16-8\"></a></span>\n<span id=\"cb16-9\"><a href=\"#cb16-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb16-10\"><a href=\"#cb16-10\"></a>}</span></code></pre></div>\n<p>That makes the tests pass and we can now use strings in our REPL:</p>\n<div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb17-1\"><a href=\"#cb17-1\"></a>$ go run main.go</span>\n<span id=\"cb17-2\"><a href=\"#cb17-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb17-3\"><a href=\"#cb17-3\"></a>Feel free to type in commands</span>\n<span id=\"cb17-4\"><a href=\"#cb17-4\"></a>&gt;&gt; &quot;Hello world!&quot;</span>\n<span id=\"cb17-5\"><a href=\"#cb17-5\"></a>Hello world!</span>\n<span id=\"cb17-6\"><a href=\"#cb17-6\"></a>&gt;&gt; let hello = &quot;Hello there, fellow Monkey users and fans!&quot;</span>\n<span id=\"cb17-7\"><a href=\"#cb17-7\"></a>&gt;&gt; hello</span>\n<span id=\"cb17-8\"><a href=\"#cb17-8\"></a>Hello there, fellow Monkey users and fans!</span>\n<span id=\"cb17-9\"><a href=\"#cb17-9\"></a>&gt;&gt; let giveMeHello = fn() { &quot;Hello!&quot; }</span>\n<span id=\"cb17-10\"><a href=\"#cb17-10\"></a>&gt;&gt; giveMeHello()</span>\n<span id=\"cb17-11\"><a href=\"#cb17-11\"></a>Hello!</span></code></pre></div>\n<p>We now have full support for strings in our interpreter! Sweet! Or should I say…</p>\n<div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb18-1\"><a href=\"#cb18-1\"></a>&gt;&gt; &quot;This is amazing!&quot;</span>\n<span id=\"cb18-2\"><a href=\"#cb18-2\"></a>This is amazing!</span></code></pre></div>\n</section>\n<section id=\"string-concatenation\" class=\"level3\" data-number=\"4.2.4\">\n<h3 data-number=\"4.2.4\">String Concatenation</h3>\n<p>Having the string data type available is great. But we can’t do much with strings yet, besides creating them. Let’s change that! In this section we’re going to add string concatenation to our interpreter. And we’ll do that by adding support for the <code>+</code> infix operator with string operands.</p>\n<p>What we want is perfectly described by this test:</p>\n<div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb19-1\"><a href=\"#cb19-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb19-2\"><a href=\"#cb19-2\"></a></span>\n<span id=\"cb19-3\"><a href=\"#cb19-3\"></a><span class=\"kw\">func</span> TestStringConcatenation(t *testing.T) {</span>\n<span id=\"cb19-4\"><a href=\"#cb19-4\"></a>    input := <span class=\"st\">`&quot;Hello&quot; + &quot; &quot; + &quot;World!&quot;`</span></span>\n<span id=\"cb19-5\"><a href=\"#cb19-5\"></a></span>\n<span id=\"cb19-6\"><a href=\"#cb19-6\"></a>    evaluated := testEval(input)</span>\n<span id=\"cb19-7\"><a href=\"#cb19-7\"></a>    str, ok := evaluated.(*object.String)</span>\n<span id=\"cb19-8\"><a href=\"#cb19-8\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb19-9\"><a href=\"#cb19-9\"></a>        t.Fatalf(<span class=\"st\">&quot;object is not String. got=%T (%+v)&quot;</span>, evaluated, evaluated)</span>\n<span id=\"cb19-10\"><a href=\"#cb19-10\"></a>    }</span>\n<span id=\"cb19-11\"><a href=\"#cb19-11\"></a></span>\n<span id=\"cb19-12\"><a href=\"#cb19-12\"></a>    <span class=\"kw\">if</span> str.Value != <span class=\"st\">&quot;Hello World!&quot;</span> {</span>\n<span id=\"cb19-13\"><a href=\"#cb19-13\"></a>        t.Errorf(<span class=\"st\">&quot;String has wrong value. got=%q&quot;</span>, str.Value)</span>\n<span id=\"cb19-14\"><a href=\"#cb19-14\"></a>    }</span>\n<span id=\"cb19-15\"><a href=\"#cb19-15\"></a>}</span></code></pre></div>\n<p>We can also extend our <code>TestErrorHandling</code> function to make sure that we only add support for the <code>+</code> operator and nothing more:</p>\n<div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb20-1\"><a href=\"#cb20-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb20-2\"><a href=\"#cb20-2\"></a></span>\n<span id=\"cb20-3\"><a href=\"#cb20-3\"></a><span class=\"kw\">func</span> TestErrorHandling(t *testing.T) {</span>\n<span id=\"cb20-4\"><a href=\"#cb20-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb20-5\"><a href=\"#cb20-5\"></a>        input           <span class=\"dt\">string</span></span>\n<span id=\"cb20-6\"><a href=\"#cb20-6\"></a>        expectedMessage <span class=\"dt\">string</span></span>\n<span id=\"cb20-7\"><a href=\"#cb20-7\"></a>    }{</span>\n<span id=\"cb20-8\"><a href=\"#cb20-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb20-9\"><a href=\"#cb20-9\"></a>        {</span>\n<span id=\"cb20-10\"><a href=\"#cb20-10\"></a>            <span class=\"st\">`&quot;Hello&quot; - &quot;World&quot;`</span>,</span>\n<span id=\"cb20-11\"><a href=\"#cb20-11\"></a>            <span class=\"st\">&quot;unknown operator: STRING - STRING&quot;</span>,</span>\n<span id=\"cb20-12\"><a href=\"#cb20-12\"></a>        },</span>\n<span id=\"cb20-13\"><a href=\"#cb20-13\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb20-14\"><a href=\"#cb20-14\"></a>    }</span>\n<span id=\"cb20-15\"><a href=\"#cb20-15\"></a></span>\n<span id=\"cb20-16\"><a href=\"#cb20-16\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb20-17\"><a href=\"#cb20-17\"></a>}</span></code></pre></div>\n<p>This test case is already green and acts more as specification and regression testing than as a guide for an implementation. But our concatenation test is failing:</p>\n<div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb21-1\"><a href=\"#cb21-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb21-2\"><a href=\"#cb21-2\"></a>--- FAIL: TestStringConcatenation (0.00s)</span>\n<span id=\"cb21-3\"><a href=\"#cb21-3\"></a>  evaluator_test.go:336: object is not String. got=*object.Error\\</span>\n<span id=\"cb21-4\"><a href=\"#cb21-4\"></a>    (&amp;{Message:unknown operator: STRING + STRING})</span>\n<span id=\"cb21-5\"><a href=\"#cb21-5\"></a>FAIL</span>\n<span id=\"cb21-6\"><a href=\"#cb21-6\"></a>FAIL    monkey/evaluator        0.007s</span></code></pre></div>\n<p>The place where we need to make changes is <code>evalInfixExpression</code>. Here we need to add a new branch to the existing switch statement that’s evaluated when both operands are strings:</p>\n<div class=\"sourceCode\" id=\"cb22\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb22-1\"><a href=\"#cb22-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb22-2\"><a href=\"#cb22-2\"></a></span>\n<span id=\"cb22-3\"><a href=\"#cb22-3\"></a><span class=\"kw\">func</span> evalInfixExpression(</span>\n<span id=\"cb22-4\"><a href=\"#cb22-4\"></a>    operator <span class=\"dt\">string</span>,</span>\n<span id=\"cb22-5\"><a href=\"#cb22-5\"></a>    left, right object.Object,</span>\n<span id=\"cb22-6\"><a href=\"#cb22-6\"></a>) object.Object {</span>\n<span id=\"cb22-7\"><a href=\"#cb22-7\"></a>    <span class=\"kw\">switch</span> {</span>\n<span id=\"cb22-8\"><a href=\"#cb22-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb22-9\"><a href=\"#cb22-9\"></a>    <span class=\"kw\">case</span> left.Type() == object.STRING_OBJ &amp;&amp; right.Type() == object.STRING_OBJ:</span>\n<span id=\"cb22-10\"><a href=\"#cb22-10\"></a>        <span class=\"kw\">return</span> evalStringInfixExpression(operator, left, right)</span>\n<span id=\"cb22-11\"><a href=\"#cb22-11\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb22-12\"><a href=\"#cb22-12\"></a>    }</span>\n<span id=\"cb22-13\"><a href=\"#cb22-13\"></a>}</span></code></pre></div>\n<p>The <code>evalStringInfixExpression</code> is the most minimal implementation possible:</p>\n<div class=\"sourceCode\" id=\"cb23\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb23-1\"><a href=\"#cb23-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb23-2\"><a href=\"#cb23-2\"></a></span>\n<span id=\"cb23-3\"><a href=\"#cb23-3\"></a><span class=\"kw\">func</span> evalStringInfixExpression(</span>\n<span id=\"cb23-4\"><a href=\"#cb23-4\"></a>    operator <span class=\"dt\">string</span>,</span>\n<span id=\"cb23-5\"><a href=\"#cb23-5\"></a>    left, right object.Object,</span>\n<span id=\"cb23-6\"><a href=\"#cb23-6\"></a>) object.Object {</span>\n<span id=\"cb23-7\"><a href=\"#cb23-7\"></a>    <span class=\"kw\">if</span> operator != <span class=\"st\">&quot;+&quot;</span> {</span>\n<span id=\"cb23-8\"><a href=\"#cb23-8\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;unknown operator: %s %s %s&quot;</span>,</span>\n<span id=\"cb23-9\"><a href=\"#cb23-9\"></a>            left.Type(), operator, right.Type())</span>\n<span id=\"cb23-10\"><a href=\"#cb23-10\"></a>    }</span>\n<span id=\"cb23-11\"><a href=\"#cb23-11\"></a></span>\n<span id=\"cb23-12\"><a href=\"#cb23-12\"></a>    leftVal := left.(*object.String).Value</span>\n<span id=\"cb23-13\"><a href=\"#cb23-13\"></a>    rightVal := right.(*object.String).Value</span>\n<span id=\"cb23-14\"><a href=\"#cb23-14\"></a>    <span class=\"kw\">return</span> &amp;object.String{Value: leftVal + rightVal}</span>\n<span id=\"cb23-15\"><a href=\"#cb23-15\"></a>}</span></code></pre></div>\n<p>The first thing here is the check for the correct operator. If it’s the supported <code>+</code> we unwrap the string objects and construct a new string that’s a concatenation of both operands.</p>\n<p>If we want to support more operators for strings this is the place where to add them. Also, if we want to support comparison of strings with the <code>==</code> and <code>!=</code> we’d need to add this here too. Pointer comparison doesn’t work for strings, at least not in the way we want it to: with strings we want to compare values and not pointers.</p>\n<p>And that’s it! Our tests pass:</p>\n<div class=\"sourceCode\" id=\"cb24\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb24-1\"><a href=\"#cb24-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb24-2\"><a href=\"#cb24-2\"></a>ok      monkey/evaluator        0.007s</span></code></pre></div>\n<p>We can now use string literals, pass them around, bind them to names, return them from functions and also concatenate them:</p>\n<div class=\"sourceCode\" id=\"cb25\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb25-1\"><a href=\"#cb25-1\"></a>&gt;&gt; let makeGreeter = fn(greeting) { fn(name) { greeting + &quot; &quot; + name + &quot;!&quot; } };</span>\n<span id=\"cb25-2\"><a href=\"#cb25-2\"></a>&gt;&gt; let hello = makeGreeter(&quot;Hello&quot;);</span>\n<span id=\"cb25-3\"><a href=\"#cb25-3\"></a>&gt;&gt; hello(&quot;Thorsten&quot;);</span>\n<span id=\"cb25-4\"><a href=\"#cb25-4\"></a>Hello Thorsten!</span>\n<span id=\"cb25-5\"><a href=\"#cb25-5\"></a>&gt;&gt; let heythere = makeGreeter(&quot;Hey there&quot;);</span>\n<span id=\"cb25-6\"><a href=\"#cb25-6\"></a>&gt;&gt; heythere(&quot;Thorsten&quot;);</span>\n<span id=\"cb25-7\"><a href=\"#cb25-7\"></a>Hey there Thorsten!</span></code></pre></div>\n<p>Alright! I’d say strings are now working very well in our interpreter. But we can still add something else to work with them…</p>\n</section>\n</section>\n<section id=\"built-in-functions\" class=\"level2\" data-number=\"4.3\">\n<h2 data-number=\"4.3\">4.3 - Built-in Functions</h2>\n<p>In this section we’re going to add built-in functions to our interpreter. They’re called “built-in”, because they’re not defined by a user of the interpreter and they’re not Monkey code - they are built right into the interpreter, into the language itself.</p>\n<p>These built-in functions are defined by us, in Go, and bridge the world of Monkey with the world of our interpreter implementation. A lot of language implementations provide such functions to offer functionality to the language’s user that’s not provided “inside” the language.</p>\n<p>Here’s an example: a function that returns the current time. In order to get the current time one could ask the kernel (or another computer, etc.). Asking and talking to the kernel is normally done via something called system calls. But if the programming language doesn’t offer users to make such system calls themselves, then the language implementation, be it the compiler or the interpreter, has to provide something to make these system calls on behalf of the users instead.</p>\n<p>So, again, the built-in functions we’re going to add are defined by us, the implementers of the interpreter. The user of the interpreter can call them, but we define them. What these functions can do, we leave open. The only restriction they have is that they need to accept zero or more <code>object.Object</code> as arguments and return an <code>object.Object</code>.</p>\n<div class=\"sourceCode\" id=\"cb26\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb26-1\"><a href=\"#cb26-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb26-2\"><a href=\"#cb26-2\"></a></span>\n<span id=\"cb26-3\"><a href=\"#cb26-3\"></a><span class=\"kw\">type</span> BuiltinFunction <span class=\"kw\">func</span>(args ...Object) Object</span></code></pre></div>\n<p>That’s the type definition of a callable Go function. But since we need to make these <code>BuiltinFunction</code>s available to our users we need to fit them into our object system. We do that by wrapping them:</p>\n<div class=\"sourceCode\" id=\"cb27\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb27-1\"><a href=\"#cb27-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb27-2\"><a href=\"#cb27-2\"></a></span>\n<span id=\"cb27-3\"><a href=\"#cb27-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb27-4\"><a href=\"#cb27-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb27-5\"><a href=\"#cb27-5\"></a>    BUILTIN_OBJ = <span class=\"st\">&quot;BUILTIN&quot;</span></span>\n<span id=\"cb27-6\"><a href=\"#cb27-6\"></a>)</span>\n<span id=\"cb27-7\"><a href=\"#cb27-7\"></a></span>\n<span id=\"cb27-8\"><a href=\"#cb27-8\"></a><span class=\"kw\">type</span> Builtin <span class=\"kw\">struct</span> {</span>\n<span id=\"cb27-9\"><a href=\"#cb27-9\"></a>    Fn BuiltinFunction</span>\n<span id=\"cb27-10\"><a href=\"#cb27-10\"></a>}</span>\n<span id=\"cb27-11\"><a href=\"#cb27-11\"></a></span>\n<span id=\"cb27-12\"><a href=\"#cb27-12\"></a><span class=\"kw\">func</span> (b *Builtin) Type() ObjectType { <span class=\"kw\">return</span> BUILTIN_OBJ }</span>\n<span id=\"cb27-13\"><a href=\"#cb27-13\"></a><span class=\"kw\">func</span> (b *Builtin) Inspect() <span class=\"dt\">string</span>  { <span class=\"kw\">return</span> <span class=\"st\">&quot;builtin function&quot;</span> }</span></code></pre></div>\n<p>There’s not much to <code>object.Builtin</code>, as you can see. It’s clearly just a wrapper. But in combination with <code>object.BuiltinFunction</code> it’s enough to get us started.</p>\n<section id=\"len\" class=\"level3\" data-number=\"4.3.1\">\n<h3 data-number=\"4.3.1\">len</h3>\n<p>The first built-in function we’re going to add to our interpreter is <code>len</code>. Its job is to return the number of characters in a string. It’s impossible to define this function as a user of Monkey. That’s why we need it to be built-in. What we want from <code>len</code> is this:</p>\n<div class=\"sourceCode\" id=\"cb28\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb28-1\"><a href=\"#cb28-1\"></a>&gt;&gt; len(&quot;Hello World!&quot;)</span>\n<span id=\"cb28-2\"><a href=\"#cb28-2\"></a>12</span>\n<span id=\"cb28-3\"><a href=\"#cb28-3\"></a>&gt;&gt; len(&quot;&quot;)</span>\n<span id=\"cb28-4\"><a href=\"#cb28-4\"></a>0</span>\n<span id=\"cb28-5\"><a href=\"#cb28-5\"></a>&gt;&gt; len(&quot;Hey Bob, how ya doin?&quot;)</span>\n<span id=\"cb28-6\"><a href=\"#cb28-6\"></a>21</span></code></pre></div>\n<p>I think that makes the idea behind <code>len</code> pretty clear. So clear in fact, that we can easily write a test for it:</p>\n<div class=\"sourceCode\" id=\"cb29\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb29-1\"><a href=\"#cb29-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb29-2\"><a href=\"#cb29-2\"></a></span>\n<span id=\"cb29-3\"><a href=\"#cb29-3\"></a><span class=\"kw\">func</span> TestBuiltinFunctions(t *testing.T) {</span>\n<span id=\"cb29-4\"><a href=\"#cb29-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb29-5\"><a href=\"#cb29-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb29-6\"><a href=\"#cb29-6\"></a>        expected <span class=\"kw\">interface</span>{}</span>\n<span id=\"cb29-7\"><a href=\"#cb29-7\"></a>    }{</span>\n<span id=\"cb29-8\"><a href=\"#cb29-8\"></a>        {<span class=\"st\">`len(&quot;&quot;)`</span>, <span class=\"dv\">0</span>},</span>\n<span id=\"cb29-9\"><a href=\"#cb29-9\"></a>        {<span class=\"st\">`len(&quot;four&quot;)`</span>, <span class=\"dv\">4</span>},</span>\n<span id=\"cb29-10\"><a href=\"#cb29-10\"></a>        {<span class=\"st\">`len(&quot;hello world&quot;)`</span>, <span class=\"dv\">11</span>},</span>\n<span id=\"cb29-11\"><a href=\"#cb29-11\"></a>        {<span class=\"st\">`len(1)`</span>, <span class=\"st\">&quot;argument to `len` not supported, got INTEGER&quot;</span>},</span>\n<span id=\"cb29-12\"><a href=\"#cb29-12\"></a>        {<span class=\"st\">`len(&quot;one&quot;, &quot;two&quot;)`</span>, <span class=\"st\">&quot;wrong number of arguments. got=2, want=1&quot;</span>},</span>\n<span id=\"cb29-13\"><a href=\"#cb29-13\"></a>    }</span>\n<span id=\"cb29-14\"><a href=\"#cb29-14\"></a></span>\n<span id=\"cb29-15\"><a href=\"#cb29-15\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb29-16\"><a href=\"#cb29-16\"></a>        evaluated := testEval(tt.input)</span>\n<span id=\"cb29-17\"><a href=\"#cb29-17\"></a></span>\n<span id=\"cb29-18\"><a href=\"#cb29-18\"></a>        <span class=\"kw\">switch</span> expected := tt.expected.(<span class=\"kw\">type</span>) {</span>\n<span id=\"cb29-19\"><a href=\"#cb29-19\"></a>        <span class=\"kw\">case</span> <span class=\"dt\">int</span>:</span>\n<span id=\"cb29-20\"><a href=\"#cb29-20\"></a>            testIntegerObject(t, evaluated, <span class=\"dt\">int64</span>(expected))</span>\n<span id=\"cb29-21\"><a href=\"#cb29-21\"></a>        <span class=\"kw\">case</span> <span class=\"dt\">string</span>:</span>\n<span id=\"cb29-22\"><a href=\"#cb29-22\"></a>            errObj, ok := evaluated.(*object.Error)</span>\n<span id=\"cb29-23\"><a href=\"#cb29-23\"></a>            <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb29-24\"><a href=\"#cb29-24\"></a>                t.Errorf(<span class=\"st\">&quot;object is not Error. got=%T (%+v)&quot;</span>,</span>\n<span id=\"cb29-25\"><a href=\"#cb29-25\"></a>                    evaluated, evaluated)</span>\n<span id=\"cb29-26\"><a href=\"#cb29-26\"></a>                <span class=\"kw\">continue</span></span>\n<span id=\"cb29-27\"><a href=\"#cb29-27\"></a>            }</span>\n<span id=\"cb29-28\"><a href=\"#cb29-28\"></a>            <span class=\"kw\">if</span> errObj.Message != expected {</span>\n<span id=\"cb29-29\"><a href=\"#cb29-29\"></a>                t.Errorf(<span class=\"st\">&quot;wrong error message. expected=%q, got=%q&quot;</span>,</span>\n<span id=\"cb29-30\"><a href=\"#cb29-30\"></a>                    expected, errObj.Message)</span>\n<span id=\"cb29-31\"><a href=\"#cb29-31\"></a>            }</span>\n<span id=\"cb29-32\"><a href=\"#cb29-32\"></a>        }</span>\n<span id=\"cb29-33\"><a href=\"#cb29-33\"></a>    }</span>\n<span id=\"cb29-34\"><a href=\"#cb29-34\"></a>}</span></code></pre></div>\n<p>So here we have a few test cases that run <code>len</code> through its paces: an empty string, a normal string and a string containing whitespace. It really shouldn’t matter if there’s whitespace in the string, but you’ll never know, so I put the test case in. The last two test cases are more interesting: we want to make sure that <code>len</code> returns an <code>*object.Error</code> when called with an integer or with the wrong number of arguments.</p>\n<p>If we run the tests we can see that calling <code>len</code> gives us an error, but not the one expected in our test case:</p>\n<div class=\"sourceCode\" id=\"cb30\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb30-1\"><a href=\"#cb30-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb30-2\"><a href=\"#cb30-2\"></a>--- FAIL: TestBuiltinFunctions (0.00s)</span>\n<span id=\"cb30-3\"><a href=\"#cb30-3\"></a>  evaluator_test.go:389: object is not Integer. got=*object.Error\\</span>\n<span id=\"cb30-4\"><a href=\"#cb30-4\"></a>    (&amp;{Message:identifier not found: len})</span>\n<span id=\"cb30-5\"><a href=\"#cb30-5\"></a>  evaluator_test.go:389: object is not Integer. got=*object.Error\\</span>\n<span id=\"cb30-6\"><a href=\"#cb30-6\"></a>    (&amp;{Message:identifier not found: len})</span>\n<span id=\"cb30-7\"><a href=\"#cb30-7\"></a>  evaluator_test.go:389: object is not Integer. got=*object.Error\\</span>\n<span id=\"cb30-8\"><a href=\"#cb30-8\"></a>    (&amp;{Message:identifier not found: len})</span>\n<span id=\"cb30-9\"><a href=\"#cb30-9\"></a>  evaluator_test.go:371: wrong error message.\\</span>\n<span id=\"cb30-10\"><a href=\"#cb30-10\"></a>    expected=&quot;argument to `len` not supported, got INTEGER&quot;,\\</span>\n<span id=\"cb30-11\"><a href=\"#cb30-11\"></a>    got=&quot;identifier not found: len&quot;</span>\n<span id=\"cb30-12\"><a href=\"#cb30-12\"></a>FAIL</span>\n<span id=\"cb30-13\"><a href=\"#cb30-13\"></a>FAIL    monkey/evaluator        0.007s</span></code></pre></div>\n<p><code>len</code> can’t be found, which isn’t that baffling considering that we haven’t defined it yet.</p>\n<p>In order to do that, the first thing we have to do is provide a way for built-in functions to be found. One option is to add them to the top-level <code>object.Environment</code>, that gets passed into <code>Eval</code>. But instead we’re going to keep a separate environment of built-in functions:</p>\n<div class=\"sourceCode\" id=\"cb31\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb31-1\"><a href=\"#cb31-1\"></a><span class=\"co\">// evaluator/builtins.go</span></span>\n<span id=\"cb31-2\"><a href=\"#cb31-2\"></a></span>\n<span id=\"cb31-3\"><a href=\"#cb31-3\"></a><span class=\"kw\">package</span> evaluator</span>\n<span id=\"cb31-4\"><a href=\"#cb31-4\"></a></span>\n<span id=\"cb31-5\"><a href=\"#cb31-5\"></a><span class=\"kw\">import</span> <span class=\"st\">&quot;monkey/object&quot;</span></span>\n<span id=\"cb31-6\"><a href=\"#cb31-6\"></a></span>\n<span id=\"cb31-7\"><a href=\"#cb31-7\"></a><span class=\"kw\">var</span> builtins = <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]*object.Builtin{</span>\n<span id=\"cb31-8\"><a href=\"#cb31-8\"></a>    <span class=\"st\">&quot;len&quot;</span>: &amp;object.Builtin{</span>\n<span id=\"cb31-9\"><a href=\"#cb31-9\"></a>        Fn: <span class=\"kw\">func</span>(args ...object.Object) object.Object {</span>\n<span id=\"cb31-10\"><a href=\"#cb31-10\"></a>            <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb31-11\"><a href=\"#cb31-11\"></a>        },</span>\n<span id=\"cb31-12\"><a href=\"#cb31-12\"></a>    },</span>\n<span id=\"cb31-13\"><a href=\"#cb31-13\"></a>}</span></code></pre></div>\n<p>In order to make use of that, we need to edit our <code>evalIdentifier</code> function to lookup built-in functions as a fallback when the given identifier is not bound to a value in the current environment:</p>\n<div class=\"sourceCode\" id=\"cb32\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb32-1\"><a href=\"#cb32-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb32-2\"><a href=\"#cb32-2\"></a></span>\n<span id=\"cb32-3\"><a href=\"#cb32-3\"></a><span class=\"kw\">func</span> evalIdentifier(</span>\n<span id=\"cb32-4\"><a href=\"#cb32-4\"></a>    node *ast.Identifier,</span>\n<span id=\"cb32-5\"><a href=\"#cb32-5\"></a>    env *object.Environment,</span>\n<span id=\"cb32-6\"><a href=\"#cb32-6\"></a>) object.Object {</span>\n<span id=\"cb32-7\"><a href=\"#cb32-7\"></a>    <span class=\"kw\">if</span> val, ok := env.Get(node.Value); ok {</span>\n<span id=\"cb32-8\"><a href=\"#cb32-8\"></a>        <span class=\"kw\">return</span> val</span>\n<span id=\"cb32-9\"><a href=\"#cb32-9\"></a>    }</span>\n<span id=\"cb32-10\"><a href=\"#cb32-10\"></a></span>\n<span id=\"cb32-11\"><a href=\"#cb32-11\"></a>    <span class=\"kw\">if</span> builtin, ok := builtins[node.Value]; ok {</span>\n<span id=\"cb32-12\"><a href=\"#cb32-12\"></a>        <span class=\"kw\">return</span> builtin</span>\n<span id=\"cb32-13\"><a href=\"#cb32-13\"></a>    }</span>\n<span id=\"cb32-14\"><a href=\"#cb32-14\"></a></span>\n<span id=\"cb32-15\"><a href=\"#cb32-15\"></a>    <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;identifier not found: &quot;</span> + node.Value)</span>\n<span id=\"cb32-16\"><a href=\"#cb32-16\"></a>}</span></code></pre></div>\n<p>So now <code>len</code> is found when looking up the <code>len</code> identifier, calling it doesn’t work yet:</p>\n<div class=\"sourceCode\" id=\"cb33\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb33-1\"><a href=\"#cb33-1\"></a>$ go run main.go</span>\n<span id=\"cb33-2\"><a href=\"#cb33-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb33-3\"><a href=\"#cb33-3\"></a>Feel free to type in commands</span>\n<span id=\"cb33-4\"><a href=\"#cb33-4\"></a>&gt;&gt; len()</span>\n<span id=\"cb33-5\"><a href=\"#cb33-5\"></a>ERROR: not a function: BUILTIN</span>\n<span id=\"cb33-6\"><a href=\"#cb33-6\"></a>&gt;&gt;</span></code></pre></div>\n<p>Running the tests gives us the same error. We need to teach our <code>applyFunction</code> about <code>*object.Builtin</code> and <code>object.BuiltinFunction</code>:</p>\n<div class=\"sourceCode\" id=\"cb34\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb34-1\"><a href=\"#cb34-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb34-2\"><a href=\"#cb34-2\"></a></span>\n<span id=\"cb34-3\"><a href=\"#cb34-3\"></a><span class=\"kw\">func</span> applyFunction(fn object.Object, args []object.Object) object.Object {</span>\n<span id=\"cb34-4\"><a href=\"#cb34-4\"></a>    <span class=\"kw\">switch</span> fn := fn.(<span class=\"kw\">type</span>) {</span>\n<span id=\"cb34-5\"><a href=\"#cb34-5\"></a></span>\n<span id=\"cb34-6\"><a href=\"#cb34-6\"></a>    <span class=\"kw\">case</span> *object.Function:</span>\n<span id=\"cb34-7\"><a href=\"#cb34-7\"></a>        extendedEnv := extendFunctionEnv(fn, args)</span>\n<span id=\"cb34-8\"><a href=\"#cb34-8\"></a>        evaluated := Eval(fn.Body, extendedEnv)</span>\n<span id=\"cb34-9\"><a href=\"#cb34-9\"></a>        <span class=\"kw\">return</span> unwrapReturnValue(evaluated)</span>\n<span id=\"cb34-10\"><a href=\"#cb34-10\"></a></span>\n<span id=\"cb34-11\"><a href=\"#cb34-11\"></a>    <span class=\"kw\">case</span> *object.Builtin:</span>\n<span id=\"cb34-12\"><a href=\"#cb34-12\"></a>        <span class=\"kw\">return</span> fn.Fn(args...)</span>\n<span id=\"cb34-13\"><a href=\"#cb34-13\"></a></span>\n<span id=\"cb34-14\"><a href=\"#cb34-14\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb34-15\"><a href=\"#cb34-15\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;not a function: %s&quot;</span>, fn.Type())</span>\n<span id=\"cb34-16\"><a href=\"#cb34-16\"></a>    }</span>\n<span id=\"cb34-17\"><a href=\"#cb34-17\"></a>}</span></code></pre></div>\n<p>Besides moving the existing lines around, what changed here is the addition of the <code>case *object.Builtin</code> branch, in which we call the <code>object.BuiltinFunction</code>. Doing so is as easy as using the <code>args</code> slice as arguments and calling the function.</p>\n<p>Of note is that we don’t need to <code>unwrapReturnValue</code> when calling a built-in function. That’s because we never return an <code>*object.ReturnValue</code> from these functions.</p>\n<p>Now the tests are rightfully complaining about <code>NULL</code> being returned when calling <code>len</code>:</p>\n<div class=\"sourceCode\" id=\"cb35\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb35-1\"><a href=\"#cb35-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb35-2\"><a href=\"#cb35-2\"></a>--- FAIL: TestBuiltinFunctions (0.00s)</span>\n<span id=\"cb35-3\"><a href=\"#cb35-3\"></a>  evaluator_test.go:389: object is not Integer. got=*object.Null (&amp;{})</span>\n<span id=\"cb35-4\"><a href=\"#cb35-4\"></a>  evaluator_test.go:389: object is not Integer. got=*object.Null (&amp;{})</span>\n<span id=\"cb35-5\"><a href=\"#cb35-5\"></a>  evaluator_test.go:389: object is not Integer. got=*object.Null (&amp;{})</span>\n<span id=\"cb35-6\"><a href=\"#cb35-6\"></a>  evaluator_test.go:366: object is not Error. got=*object.Null (&amp;{})</span>\n<span id=\"cb35-7\"><a href=\"#cb35-7\"></a>  evaluator_test.go:366: object is not Error. got=*object.Null (&amp;{})</span>\n<span id=\"cb35-8\"><a href=\"#cb35-8\"></a>FAIL</span>\n<span id=\"cb35-9\"><a href=\"#cb35-9\"></a>FAIL    monkey/evaluator        0.007s</span></code></pre></div>\n<p>That means that calling <code>len</code> works though! It’s just that it returns only <code>NULL</code>. But fixing this is as easy as writing any other Go function:</p>\n<div class=\"sourceCode\" id=\"cb36\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb36-1\"><a href=\"#cb36-1\"></a><span class=\"co\">// evaluator/builtins.go</span></span>\n<span id=\"cb36-2\"><a href=\"#cb36-2\"></a></span>\n<span id=\"cb36-3\"><a href=\"#cb36-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb36-4\"><a href=\"#cb36-4\"></a>    <span class=\"st\">&quot;monkey/object&quot;</span></span>\n<span id=\"cb36-5\"><a href=\"#cb36-5\"></a>)</span>\n<span id=\"cb36-6\"><a href=\"#cb36-6\"></a></span>\n<span id=\"cb36-7\"><a href=\"#cb36-7\"></a><span class=\"kw\">var</span> builtins = <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]*object.Builtin{</span>\n<span id=\"cb36-8\"><a href=\"#cb36-8\"></a>    <span class=\"st\">&quot;len&quot;</span>: &amp;object.Builtin{</span>\n<span id=\"cb36-9\"><a href=\"#cb36-9\"></a>        Fn: <span class=\"kw\">func</span>(args ...object.Object) object.Object {</span>\n<span id=\"cb36-10\"><a href=\"#cb36-10\"></a>            <span class=\"kw\">if</span> <span class=\"bu\">len</span>(args) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb36-11\"><a href=\"#cb36-11\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</span>\n<span id=\"cb36-12\"><a href=\"#cb36-12\"></a>                    <span class=\"bu\">len</span>(args))</span>\n<span id=\"cb36-13\"><a href=\"#cb36-13\"></a>            }</span>\n<span id=\"cb36-14\"><a href=\"#cb36-14\"></a></span>\n<span id=\"cb36-15\"><a href=\"#cb36-15\"></a>            <span class=\"kw\">switch</span> arg := args[<span class=\"dv\">0</span>].(<span class=\"kw\">type</span>) {</span>\n<span id=\"cb36-16\"><a href=\"#cb36-16\"></a>            <span class=\"kw\">case</span> *object.String:</span>\n<span id=\"cb36-17\"><a href=\"#cb36-17\"></a>                <span class=\"kw\">return</span> &amp;object.Integer{Value: <span class=\"dt\">int64</span>(<span class=\"bu\">len</span>(arg.Value))}</span>\n<span id=\"cb36-18\"><a href=\"#cb36-18\"></a>            <span class=\"kw\">default</span>:</span>\n<span id=\"cb36-19\"><a href=\"#cb36-19\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;argument to `len` not supported, got %s&quot;</span>,</span>\n<span id=\"cb36-20\"><a href=\"#cb36-20\"></a>                    args[<span class=\"dv\">0</span>].Type())</span>\n<span id=\"cb36-21\"><a href=\"#cb36-21\"></a>            }</span>\n<span id=\"cb36-22\"><a href=\"#cb36-22\"></a>        },</span>\n<span id=\"cb36-23\"><a href=\"#cb36-23\"></a>    },</span>\n<span id=\"cb36-24\"><a href=\"#cb36-24\"></a>}</span></code></pre></div>\n<p>The most important part of this function is the call to Go’s <code>len</code> and the returning of a newly allocated <code>object.Integer</code>. Besides that we have error checking that makes sure that we can’t call this function with the wrong number of arguments or with an argument of an unsupported type. And alas, our tests pass:</p>\n<div class=\"sourceCode\" id=\"cb37\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb37-1\"><a href=\"#cb37-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb37-2\"><a href=\"#cb37-2\"></a>ok      monkey/evaluator        0.007s</span></code></pre></div>\n<p>That means we can take <code>len</code> on a test drive in our REPL:</p>\n<div class=\"sourceCode\" id=\"cb38\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb38-1\"><a href=\"#cb38-1\"></a>$ go run main.go</span>\n<span id=\"cb38-2\"><a href=\"#cb38-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb38-3\"><a href=\"#cb38-3\"></a>Feel free to type in commands</span>\n<span id=\"cb38-4\"><a href=\"#cb38-4\"></a>&gt;&gt; len(&quot;1234&quot;)</span>\n<span id=\"cb38-5\"><a href=\"#cb38-5\"></a>4</span>\n<span id=\"cb38-6\"><a href=\"#cb38-6\"></a>&gt;&gt; len(&quot;Hello World!&quot;)</span>\n<span id=\"cb38-7\"><a href=\"#cb38-7\"></a>12</span>\n<span id=\"cb38-8\"><a href=\"#cb38-8\"></a>&gt;&gt; len(&quot;Woooooohooo!&quot;, &quot;len works!!&quot;)</span>\n<span id=\"cb38-9\"><a href=\"#cb38-9\"></a>ERROR: wrong number of arguments. got=2, want=1</span>\n<span id=\"cb38-10\"><a href=\"#cb38-10\"></a>&gt;&gt; len(12345)</span>\n<span id=\"cb38-11\"><a href=\"#cb38-11\"></a>ERROR: argument to `len` not supported, got INTEGER</span></code></pre></div>\n<p>Perfect! Our first built-in function works and is ready to go.</p>\n</section>\n</section>\n<section id=\"array\" class=\"level2\" data-number=\"4.4\">\n<h2 data-number=\"4.4\">4.4 - Array</h2>\n<p>The data type we’re going to add to our Monkey interpreter in this section is the array. In Monkey an array is an ordered list of elements of possibly different types. Each element in the array can be accessed individually. Arrays are constructed by using their literal form: a comma separated list of elements, enclosed by brackets.</p>\n<p>Initializing a new array, binding it to a name and accessing individual elements will look like this:</p>\n<div class=\"sourceCode\" id=\"cb39\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb39-1\"><a href=\"#cb39-1\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> myArray <span class=\"op\">=</span> [<span class=\"st\">&quot;Thorsten&quot;</span><span class=\"op\">,</span> <span class=\"st\">&quot;Ball&quot;</span><span class=\"op\">,</span> <span class=\"dv\">28</span><span class=\"op\">,</span> fn(x) { x <span class=\"op\">*</span> x }]<span class=\"op\">;</span></span>\n<span id=\"cb39-2\"><a href=\"#cb39-2\"></a><span class=\"op\">&gt;&gt;</span> myArray[<span class=\"dv\">0</span>]</span>\n<span id=\"cb39-3\"><a href=\"#cb39-3\"></a>Thorsten</span>\n<span id=\"cb39-4\"><a href=\"#cb39-4\"></a><span class=\"op\">&gt;&gt;</span> myArray[<span class=\"dv\">2</span>]</span>\n<span id=\"cb39-5\"><a href=\"#cb39-5\"></a><span class=\"dv\">28</span></span>\n<span id=\"cb39-6\"><a href=\"#cb39-6\"></a><span class=\"op\">&gt;&gt;</span> myArray[<span class=\"dv\">3</span>](<span class=\"dv\">2</span>)<span class=\"op\">;</span></span>\n<span id=\"cb39-7\"><a href=\"#cb39-7\"></a><span class=\"dv\">4</span></span></code></pre></div>\n<p>As you can see, Monkey arrays really don’t care about the types of their elements. Every possible value in Monkey can be an element in an array. In this example <code>myArray</code> holds two strings, an integer and a function.</p>\n<p>Accessing individual elements by their index in the array, as seen in the last three lines, is done with a new operator, called the index operator: <code>array[index]</code>.</p>\n<p>In this section we’ll also add support for arrays to our newly added <code>len</code> function and also add a few more built-in functions that work with arrays:</p>\n<div class=\"sourceCode\" id=\"cb40\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb40-1\"><a href=\"#cb40-1\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> myArray <span class=\"op\">=</span> [<span class=\"st\">&quot;one&quot;</span><span class=\"op\">,</span> <span class=\"st\">&quot;two&quot;</span><span class=\"op\">,</span> <span class=\"st\">&quot;three&quot;</span>]<span class=\"op\">;</span></span>\n<span id=\"cb40-2\"><a href=\"#cb40-2\"></a><span class=\"op\">&gt;&gt;</span> len(myArray)</span>\n<span id=\"cb40-3\"><a href=\"#cb40-3\"></a><span class=\"dv\">3</span></span>\n<span id=\"cb40-4\"><a href=\"#cb40-4\"></a><span class=\"op\">&gt;&gt;</span> first(myArray)</span>\n<span id=\"cb40-5\"><a href=\"#cb40-5\"></a>one</span>\n<span id=\"cb40-6\"><a href=\"#cb40-6\"></a><span class=\"op\">&gt;&gt;</span> rest(myArray)</span>\n<span id=\"cb40-7\"><a href=\"#cb40-7\"></a>[two<span class=\"op\">,</span> three]</span>\n<span id=\"cb40-8\"><a href=\"#cb40-8\"></a><span class=\"op\">&gt;&gt;</span> last(myArray)</span>\n<span id=\"cb40-9\"><a href=\"#cb40-9\"></a>three</span>\n<span id=\"cb40-10\"><a href=\"#cb40-10\"></a><span class=\"op\">&gt;&gt;</span> push(myArray<span class=\"op\">,</span> <span class=\"st\">&quot;four&quot;</span>)</span>\n<span id=\"cb40-11\"><a href=\"#cb40-11\"></a>[one<span class=\"op\">,</span> two<span class=\"op\">,</span> three<span class=\"op\">,</span> four]</span></code></pre></div>\n<p>The basis for our implementation of the Monkey array in our interpreter will be a Go slice of type <code>[]object.Object</code>. That means that we don’t have to implement a new data structure. We can just reuse Go’s slice.</p>\n<p>Sounds awesome? Good! The first thing we have to do is teach our lexer a few new tokens.</p>\n<section id=\"supporting-arrays-in-our-lexer\" class=\"level3\" data-number=\"4.4.1\">\n<h3 data-number=\"4.4.1\">Supporting Arrays in our Lexer</h3>\n<p>In order to correctly parse array literals and the index operator, our lexer needs to be able to identify more tokens than it currently does. All the tokens we need in order to construct and use arrays in Monkey are <code>[</code>, <code>]</code> and <code>,</code>. The lexer already knows about <code>,</code> so we only need to add support for <code>[</code> and <code>]</code>.</p>\n<p>The first step is to define these new token types in the <code>token</code> package:</p>\n<div class=\"sourceCode\" id=\"cb41\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb41-1\"><a href=\"#cb41-1\"></a><span class=\"co\">// token/token.go</span></span>\n<span id=\"cb41-2\"><a href=\"#cb41-2\"></a></span>\n<span id=\"cb41-3\"><a href=\"#cb41-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb41-4\"><a href=\"#cb41-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb41-5\"><a href=\"#cb41-5\"></a></span>\n<span id=\"cb41-6\"><a href=\"#cb41-6\"></a>    LBRACKET = <span class=\"st\">&quot;[&quot;</span></span>\n<span id=\"cb41-7\"><a href=\"#cb41-7\"></a>    RBRACKET = <span class=\"st\">&quot;]&quot;</span></span>\n<span id=\"cb41-8\"><a href=\"#cb41-8\"></a></span>\n<span id=\"cb41-9\"><a href=\"#cb41-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb41-10\"><a href=\"#cb41-10\"></a>)</span></code></pre></div>\n<p>The second step is to extend the test suite of the lexer, which is easy, since we’ve done this many times before:</p>\n<div class=\"sourceCode\" id=\"cb42\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb42-1\"><a href=\"#cb42-1\"></a><span class=\"co\">// lexer/lexer_test.go</span></span>\n<span id=\"cb42-2\"><a href=\"#cb42-2\"></a></span>\n<span id=\"cb42-3\"><a href=\"#cb42-3\"></a><span class=\"kw\">func</span> TestNextToken(t *testing.T) {</span>\n<span id=\"cb42-4\"><a href=\"#cb42-4\"></a>    input := <span class=\"st\">`let five = 5;</span></span>\n<span id=\"cb42-5\"><a href=\"#cb42-5\"></a><span class=\"st\">let ten = 10;</span></span>\n<span id=\"cb42-6\"><a href=\"#cb42-6\"></a></span>\n<span id=\"cb42-7\"><a href=\"#cb42-7\"></a><span class=\"st\">let add = fn(x, y) {</span></span>\n<span id=\"cb42-8\"><a href=\"#cb42-8\"></a><span class=\"st\">  x + y;</span></span>\n<span id=\"cb42-9\"><a href=\"#cb42-9\"></a><span class=\"st\">};</span></span>\n<span id=\"cb42-10\"><a href=\"#cb42-10\"></a></span>\n<span id=\"cb42-11\"><a href=\"#cb42-11\"></a><span class=\"st\">let result = add(five, ten);</span></span>\n<span id=\"cb42-12\"><a href=\"#cb42-12\"></a><span class=\"st\">!-/*5;</span></span>\n<span id=\"cb42-13\"><a href=\"#cb42-13\"></a><span class=\"st\">5 &lt; 10 &gt; 5;</span></span>\n<span id=\"cb42-14\"><a href=\"#cb42-14\"></a></span>\n<span id=\"cb42-15\"><a href=\"#cb42-15\"></a><span class=\"st\">if (5 &lt; 10) {</span></span>\n<span id=\"cb42-16\"><a href=\"#cb42-16\"></a><span class=\"st\">    return true;</span></span>\n<span id=\"cb42-17\"><a href=\"#cb42-17\"></a><span class=\"st\">} else {</span></span>\n<span id=\"cb42-18\"><a href=\"#cb42-18\"></a><span class=\"st\">    return false;</span></span>\n<span id=\"cb42-19\"><a href=\"#cb42-19\"></a><span class=\"st\">}</span></span>\n<span id=\"cb42-20\"><a href=\"#cb42-20\"></a></span>\n<span id=\"cb42-21\"><a href=\"#cb42-21\"></a><span class=\"st\">10 == 10;</span></span>\n<span id=\"cb42-22\"><a href=\"#cb42-22\"></a><span class=\"st\">10 != 9;</span></span>\n<span id=\"cb42-23\"><a href=\"#cb42-23\"></a><span class=\"st\">&quot;foobar&quot;</span></span>\n<span id=\"cb42-24\"><a href=\"#cb42-24\"></a><span class=\"st\">&quot;foo bar&quot;</span></span>\n<span id=\"cb42-25\"><a href=\"#cb42-25\"></a><span class=\"st\">[1, 2];</span></span>\n<span id=\"cb42-26\"><a href=\"#cb42-26\"></a><span class=\"st\">`</span></span>\n<span id=\"cb42-27\"><a href=\"#cb42-27\"></a></span>\n<span id=\"cb42-28\"><a href=\"#cb42-28\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb42-29\"><a href=\"#cb42-29\"></a>        expectedType    token.TokenType</span>\n<span id=\"cb42-30\"><a href=\"#cb42-30\"></a>        expectedLiteral <span class=\"dt\">string</span></span>\n<span id=\"cb42-31\"><a href=\"#cb42-31\"></a>    }{</span>\n<span id=\"cb42-32\"><a href=\"#cb42-32\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb42-33\"><a href=\"#cb42-33\"></a>        {token.LBRACKET, <span class=\"st\">&quot;[&quot;</span>},</span>\n<span id=\"cb42-34\"><a href=\"#cb42-34\"></a>        {token.INT, <span class=\"st\">&quot;1&quot;</span>},</span>\n<span id=\"cb42-35\"><a href=\"#cb42-35\"></a>        {token.COMMA, <span class=\"st\">&quot;,&quot;</span>},</span>\n<span id=\"cb42-36\"><a href=\"#cb42-36\"></a>        {token.INT, <span class=\"st\">&quot;2&quot;</span>},</span>\n<span id=\"cb42-37\"><a href=\"#cb42-37\"></a>        {token.RBRACKET, <span class=\"st\">&quot;]&quot;</span>},</span>\n<span id=\"cb42-38\"><a href=\"#cb42-38\"></a>        {token.SEMICOLON, <span class=\"st\">&quot;;&quot;</span>},</span>\n<span id=\"cb42-39\"><a href=\"#cb42-39\"></a>        {token.EOF, <span class=\"st\">&quot;&quot;</span>},</span>\n<span id=\"cb42-40\"><a href=\"#cb42-40\"></a>    }</span>\n<span id=\"cb42-41\"><a href=\"#cb42-41\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb42-42\"><a href=\"#cb42-42\"></a>}</span></code></pre></div>\n<p>Again the <code>input</code> is extended to include new tokens (<code>[1, 2]</code> in this case) and new <code>tests</code> have been added to make sure the lexer’s <code>NextToken</code> method really returns <code>token.LBRACKET</code> and <code>token.RBRACKET</code>.</p>\n<p>Making the test pass is as easy as adding these <em>four</em> lines to our <code>NextToken()</code> method. Yes, just four:</p>\n<div class=\"sourceCode\" id=\"cb43\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb43-1\"><a href=\"#cb43-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb43-2\"><a href=\"#cb43-2\"></a></span>\n<span id=\"cb43-3\"><a href=\"#cb43-3\"></a><span class=\"kw\">func</span> (l *Lexer) NextToken() token.Token {</span>\n<span id=\"cb43-4\"><a href=\"#cb43-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb43-5\"><a href=\"#cb43-5\"></a></span>\n<span id=\"cb43-6\"><a href=\"#cb43-6\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;[&#39;</span>:</span>\n<span id=\"cb43-7\"><a href=\"#cb43-7\"></a>        tok = newToken(token.LBRACKET, l.ch)</span>\n<span id=\"cb43-8\"><a href=\"#cb43-8\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;]&#39;</span>:</span>\n<span id=\"cb43-9\"><a href=\"#cb43-9\"></a>        tok = newToken(token.RBRACKET, l.ch)</span>\n<span id=\"cb43-10\"><a href=\"#cb43-10\"></a></span>\n<span id=\"cb43-11\"><a href=\"#cb43-11\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb43-12\"><a href=\"#cb43-12\"></a>}</span></code></pre></div>\n<p>Alright! The tests are passing:</p>\n<div class=\"sourceCode\" id=\"cb44\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb44-1\"><a href=\"#cb44-1\"></a>$ go test ./lexer</span>\n<span id=\"cb44-2\"><a href=\"#cb44-2\"></a>ok      monkey/lexer    0.006s</span></code></pre></div>\n<p>In our parser we’ll now use <code>token.LBRACKET</code> and <code>token.RBRACKET</code> to parse arrays.</p>\n</section>\n<section id=\"parsing-array-literals\" class=\"level3\" data-number=\"4.4.2\">\n<h3 data-number=\"4.4.2\">Parsing Array Literals</h3>\n<p>As we saw before, an array literal in Monkey is a comma-separated list of expressions enclosed by an opening and a closing bracket.</p>\n<div class=\"sourceCode\" id=\"cb45\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb45-1\"><a href=\"#cb45-1\"></a>[<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span> <span class=\"op\">+</span> <span class=\"dv\">3</span><span class=\"op\">,</span> fn(x) { x }<span class=\"op\">,</span> add(<span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">2</span>)]</span></code></pre></div>\n<p>Yes, the elements in an array literal can be any type of expression. Integer literals, function literals, infix or prefix expressions.</p>\n<p>If that sounds complicated, don’t worry. We already know how to parse comma-separated lists of expressions - function call arguments are just that. And we also know how to parse something enclosed by matching tokens. In other words: let’s get to it!</p>\n<p>The first thing we have to do is define the AST node for array literals. Since we already have the essential pieces in place for this, the definition is rather self-explanatory:</p>\n<div class=\"sourceCode\" id=\"cb46\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb46-1\"><a href=\"#cb46-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb46-2\"><a href=\"#cb46-2\"></a></span>\n<span id=\"cb46-3\"><a href=\"#cb46-3\"></a><span class=\"kw\">type</span> ArrayLiteral <span class=\"kw\">struct</span> {</span>\n<span id=\"cb46-4\"><a href=\"#cb46-4\"></a>    Token    token.Token <span class=\"co\">// the &#39;[&#39; token</span></span>\n<span id=\"cb46-5\"><a href=\"#cb46-5\"></a>    Elements []Expression</span>\n<span id=\"cb46-6\"><a href=\"#cb46-6\"></a>}</span>\n<span id=\"cb46-7\"><a href=\"#cb46-7\"></a></span>\n<span id=\"cb46-8\"><a href=\"#cb46-8\"></a><span class=\"kw\">func</span> (al *ArrayLiteral) expressionNode()      {}</span>\n<span id=\"cb46-9\"><a href=\"#cb46-9\"></a><span class=\"kw\">func</span> (al *ArrayLiteral) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> al.Token.Literal }</span>\n<span id=\"cb46-10\"><a href=\"#cb46-10\"></a><span class=\"kw\">func</span> (al *ArrayLiteral) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb46-11\"><a href=\"#cb46-11\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb46-12\"><a href=\"#cb46-12\"></a></span>\n<span id=\"cb46-13\"><a href=\"#cb46-13\"></a>    elements := []<span class=\"dt\">string</span>{}</span>\n<span id=\"cb46-14\"><a href=\"#cb46-14\"></a>    <span class=\"kw\">for</span> _, el := <span class=\"kw\">range</span> al.Elements {</span>\n<span id=\"cb46-15\"><a href=\"#cb46-15\"></a>        elements = <span class=\"bu\">append</span>(elements, el.String())</span>\n<span id=\"cb46-16\"><a href=\"#cb46-16\"></a>    }</span>\n<span id=\"cb46-17\"><a href=\"#cb46-17\"></a></span>\n<span id=\"cb46-18\"><a href=\"#cb46-18\"></a>    out.WriteString(<span class=\"st\">&quot;[&quot;</span>)</span>\n<span id=\"cb46-19\"><a href=\"#cb46-19\"></a>    out.WriteString(strings.Join(elements, <span class=\"st\">&quot;, &quot;</span>))</span>\n<span id=\"cb46-20\"><a href=\"#cb46-20\"></a>    out.WriteString(<span class=\"st\">&quot;]&quot;</span>)</span>\n<span id=\"cb46-21\"><a href=\"#cb46-21\"></a></span>\n<span id=\"cb46-22\"><a href=\"#cb46-22\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb46-23\"><a href=\"#cb46-23\"></a>}</span></code></pre></div>\n<p>The following test function makes sure that parsing array literals results in a <code>*ast.ArrayLiteral</code> being returned. (I also added a test function for empty array literals to make sure that we don’t run into nasty edge-cases)</p>\n<div class=\"sourceCode\" id=\"cb47\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb47-1\"><a href=\"#cb47-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb47-2\"><a href=\"#cb47-2\"></a></span>\n<span id=\"cb47-3\"><a href=\"#cb47-3\"></a><span class=\"kw\">func</span> TestParsingArrayLiterals(t *testing.T) {</span>\n<span id=\"cb47-4\"><a href=\"#cb47-4\"></a>    input := <span class=\"st\">&quot;[1, 2 * 2, 3 + 3]&quot;</span></span>\n<span id=\"cb47-5\"><a href=\"#cb47-5\"></a></span>\n<span id=\"cb47-6\"><a href=\"#cb47-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb47-7\"><a href=\"#cb47-7\"></a>    p := New(l)</span>\n<span id=\"cb47-8\"><a href=\"#cb47-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb47-9\"><a href=\"#cb47-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb47-10\"><a href=\"#cb47-10\"></a></span>\n<span id=\"cb47-11\"><a href=\"#cb47-11\"></a>    stmt, ok := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb47-12\"><a href=\"#cb47-12\"></a>    array, ok := stmt.Expression.(*ast.ArrayLiteral)</span>\n<span id=\"cb47-13\"><a href=\"#cb47-13\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb47-14\"><a href=\"#cb47-14\"></a>        t.Fatalf(<span class=\"st\">&quot;exp not ast.ArrayLiteral. got=%T&quot;</span>, stmt.Expression)</span>\n<span id=\"cb47-15\"><a href=\"#cb47-15\"></a>    }</span>\n<span id=\"cb47-16\"><a href=\"#cb47-16\"></a></span>\n<span id=\"cb47-17\"><a href=\"#cb47-17\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(array.Elements) != <span class=\"dv\">3</span> {</span>\n<span id=\"cb47-18\"><a href=\"#cb47-18\"></a>        t.Fatalf(<span class=\"st\">&quot;len(array.Elements) not 3. got=%d&quot;</span>, <span class=\"bu\">len</span>(array.Elements))</span>\n<span id=\"cb47-19\"><a href=\"#cb47-19\"></a>    }</span>\n<span id=\"cb47-20\"><a href=\"#cb47-20\"></a></span>\n<span id=\"cb47-21\"><a href=\"#cb47-21\"></a>    testIntegerLiteral(t, array.Elements[<span class=\"dv\">0</span>], <span class=\"dv\">1</span>)</span>\n<span id=\"cb47-22\"><a href=\"#cb47-22\"></a>    testInfixExpression(t, array.Elements[<span class=\"dv\">1</span>], <span class=\"dv\">2</span>, <span class=\"st\">&quot;*&quot;</span>, <span class=\"dv\">2</span>)</span>\n<span id=\"cb47-23\"><a href=\"#cb47-23\"></a>    testInfixExpression(t, array.Elements[<span class=\"dv\">2</span>], <span class=\"dv\">3</span>, <span class=\"st\">&quot;+&quot;</span>, <span class=\"dv\">3</span>)</span>\n<span id=\"cb47-24\"><a href=\"#cb47-24\"></a>}</span></code></pre></div>\n<p>Just to make sure that the parsing of expressions really works the test input contains two different infix operator expressions, even though integer or boolean literals would be enough. Other than that the test is pretty boring and asserts that the parser really returns an <code>*ast.ArrayLiteral</code> with the correct number of elements.</p>\n<p>In order to get the tests to pass we need to register a new <code>prefixParseFn</code> in our parser, since the opening <code>token.LBRACKET</code> of an array literal is in prefix position.</p>\n<div class=\"sourceCode\" id=\"cb48\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb48-1\"><a href=\"#cb48-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb48-2\"><a href=\"#cb48-2\"></a></span>\n<span id=\"cb48-3\"><a href=\"#cb48-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb48-4\"><a href=\"#cb48-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb48-5\"><a href=\"#cb48-5\"></a></span>\n<span id=\"cb48-6\"><a href=\"#cb48-6\"></a>    p.registerPrefix(token.LBRACKET, p.parseArrayLiteral)</span>\n<span id=\"cb48-7\"><a href=\"#cb48-7\"></a></span>\n<span id=\"cb48-8\"><a href=\"#cb48-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb48-9\"><a href=\"#cb48-9\"></a>}</span>\n<span id=\"cb48-10\"><a href=\"#cb48-10\"></a></span>\n<span id=\"cb48-11\"><a href=\"#cb48-11\"></a><span class=\"kw\">func</span> (p *Parser) parseArrayLiteral() ast.Expression {</span>\n<span id=\"cb48-12\"><a href=\"#cb48-12\"></a>    array := &amp;ast.ArrayLiteral{Token: p.curToken}</span>\n<span id=\"cb48-13\"><a href=\"#cb48-13\"></a></span>\n<span id=\"cb48-14\"><a href=\"#cb48-14\"></a>    array.Elements = p.parseExpressionList(token.RBRACKET)</span>\n<span id=\"cb48-15\"><a href=\"#cb48-15\"></a></span>\n<span id=\"cb48-16\"><a href=\"#cb48-16\"></a>    <span class=\"kw\">return</span> array</span>\n<span id=\"cb48-17\"><a href=\"#cb48-17\"></a>}</span></code></pre></div>\n<p>We’ve added <code>prefixParseFn</code>s before, so that part’s not really exciting. What’s interesting here is the new method called <code>parseExpressionList</code>. This method is a modified and generalized version of <code>parseCallArguments</code>, which we used before in <code>parseCallExpression</code> to parse a list of comma separated arguments:</p>\n<div class=\"sourceCode\" id=\"cb49\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb49-1\"><a href=\"#cb49-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb49-2\"><a href=\"#cb49-2\"></a></span>\n<span id=\"cb49-3\"><a href=\"#cb49-3\"></a><span class=\"kw\">func</span> (p *Parser) parseExpressionList(end token.TokenType) []ast.Expression {</span>\n<span id=\"cb49-4\"><a href=\"#cb49-4\"></a>    list := []ast.Expression{}</span>\n<span id=\"cb49-5\"><a href=\"#cb49-5\"></a></span>\n<span id=\"cb49-6\"><a href=\"#cb49-6\"></a>    <span class=\"kw\">if</span> p.peekTokenIs(end) {</span>\n<span id=\"cb49-7\"><a href=\"#cb49-7\"></a>        p.nextToken()</span>\n<span id=\"cb49-8\"><a href=\"#cb49-8\"></a>        <span class=\"kw\">return</span> list</span>\n<span id=\"cb49-9\"><a href=\"#cb49-9\"></a>    }</span>\n<span id=\"cb49-10\"><a href=\"#cb49-10\"></a></span>\n<span id=\"cb49-11\"><a href=\"#cb49-11\"></a>    p.nextToken()</span>\n<span id=\"cb49-12\"><a href=\"#cb49-12\"></a>    list = <span class=\"bu\">append</span>(list, p.parseExpression(LOWEST))</span>\n<span id=\"cb49-13\"><a href=\"#cb49-13\"></a></span>\n<span id=\"cb49-14\"><a href=\"#cb49-14\"></a>    <span class=\"kw\">for</span> p.peekTokenIs(token.COMMA) {</span>\n<span id=\"cb49-15\"><a href=\"#cb49-15\"></a>        p.nextToken()</span>\n<span id=\"cb49-16\"><a href=\"#cb49-16\"></a>        p.nextToken()</span>\n<span id=\"cb49-17\"><a href=\"#cb49-17\"></a>        list = <span class=\"bu\">append</span>(list, p.parseExpression(LOWEST))</span>\n<span id=\"cb49-18\"><a href=\"#cb49-18\"></a>    }</span>\n<span id=\"cb49-19\"><a href=\"#cb49-19\"></a></span>\n<span id=\"cb49-20\"><a href=\"#cb49-20\"></a>    <span class=\"kw\">if</span> !p.expectPeek(end) {</span>\n<span id=\"cb49-21\"><a href=\"#cb49-21\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb49-22\"><a href=\"#cb49-22\"></a>    }</span>\n<span id=\"cb49-23\"><a href=\"#cb49-23\"></a></span>\n<span id=\"cb49-24\"><a href=\"#cb49-24\"></a>    <span class=\"kw\">return</span> list</span>\n<span id=\"cb49-25\"><a href=\"#cb49-25\"></a>}</span></code></pre></div>\n<p>Again, we’ve seen this before under the name <code>parseCallArguments</code>. The only change is that this new version now accepts an <code>end</code> parameter that tells the method which token signifies the end of the list. The updated <code>parseCallExpression</code> method, in which we used <code>parseCallArguments</code> before, now looks like this:</p>\n<div class=\"sourceCode\" id=\"cb50\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb50-1\"><a href=\"#cb50-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb50-2\"><a href=\"#cb50-2\"></a></span>\n<span id=\"cb50-3\"><a href=\"#cb50-3\"></a><span class=\"kw\">func</span> (p *Parser) parseCallExpression(function ast.Expression) ast.Expression {</span>\n<span id=\"cb50-4\"><a href=\"#cb50-4\"></a>    exp := &amp;ast.CallExpression{Token: p.curToken, Function: function}</span>\n<span id=\"cb50-5\"><a href=\"#cb50-5\"></a>    exp.Arguments = p.parseExpressionList(token.RPAREN)</span>\n<span id=\"cb50-6\"><a href=\"#cb50-6\"></a>    <span class=\"kw\">return</span> exp</span>\n<span id=\"cb50-7\"><a href=\"#cb50-7\"></a>}</span></code></pre></div>\n<p>The only change is the call to <code>parseExpressionList</code> with <code>token.RPAREN</code> (which signifies the end of the arguments list). We could reuse a relatively big method by changing a few lines. Great! And the best of all? The tests are passing:</p>\n<div class=\"sourceCode\" id=\"cb51\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb51-1\"><a href=\"#cb51-1\"></a>$ go test ./parser</span>\n<span id=\"cb51-2\"><a href=\"#cb51-2\"></a>ok      monkey/parser   0.007s</span></code></pre></div>\n<p>We can mark “parsing array literals” as “done”.</p>\n</section>\n<section id=\"parsing-index-operator-expressions\" class=\"level3\" data-number=\"4.4.3\">\n<h3 data-number=\"4.4.3\">Parsing Index Operator Expressions</h3>\n<p>To fully support arrays in Monkey we not only need to be able to parse array literals but also index operator expressions. Maybe the name “index operator” doesn’t ring a bell, but I bet you know what it is. Index operator expressions look like this:</p>\n<div class=\"sourceCode\" id=\"cb52\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb52-1\"><a href=\"#cb52-1\"></a>myArray[<span class=\"dv\">0</span>]<span class=\"op\">;</span></span>\n<span id=\"cb52-2\"><a href=\"#cb52-2\"></a>myArray[<span class=\"dv\">1</span>]<span class=\"op\">;</span></span>\n<span id=\"cb52-3\"><a href=\"#cb52-3\"></a>myArray[<span class=\"dv\">2</span>]<span class=\"op\">;</span></span></code></pre></div>\n<p>That’s the basic form at least, but there are many. Take a look at these examples to spot the structure underlying them all:</p>\n<div class=\"sourceCode\" id=\"cb53\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb53-1\"><a href=\"#cb53-1\"></a>[<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span>][<span class=\"dv\">2</span>]<span class=\"op\">;</span></span>\n<span id=\"cb53-2\"><a href=\"#cb53-2\"></a></span>\n<span id=\"cb53-3\"><a href=\"#cb53-3\"></a><span class=\"kw\">let</span> myArray <span class=\"op\">=</span> [<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span>]<span class=\"op\">;</span></span>\n<span id=\"cb53-4\"><a href=\"#cb53-4\"></a>myArray[<span class=\"dv\">2</span>]<span class=\"op\">;</span></span>\n<span id=\"cb53-5\"><a href=\"#cb53-5\"></a></span>\n<span id=\"cb53-6\"><a href=\"#cb53-6\"></a>myArray[<span class=\"dv\">2</span> <span class=\"op\">+</span> <span class=\"dv\">1</span>]<span class=\"op\">;</span></span>\n<span id=\"cb53-7\"><a href=\"#cb53-7\"></a></span>\n<span id=\"cb53-8\"><a href=\"#cb53-8\"></a>returnsArray()[<span class=\"dv\">1</span>]<span class=\"op\">;</span></span></code></pre></div>\n<p>Yep, you’re totally correct! The basic structure is this one:</p>\n<div class=\"sourceCode\" id=\"cb54\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb54-1\"><a href=\"#cb54-1\"></a>&lt;expression&gt;[&lt;expression&gt;]</span></code></pre></div>\n<p>That seems simple enough. We can define a new AST node, called <code>ast.IndexExpression</code>, that reflects this structure:</p>\n<div class=\"sourceCode\" id=\"cb55\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb55-1\"><a href=\"#cb55-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb55-2\"><a href=\"#cb55-2\"></a></span>\n<span id=\"cb55-3\"><a href=\"#cb55-3\"></a><span class=\"kw\">type</span> IndexExpression <span class=\"kw\">struct</span> {</span>\n<span id=\"cb55-4\"><a href=\"#cb55-4\"></a>    Token token.Token <span class=\"co\">// The [ token</span></span>\n<span id=\"cb55-5\"><a href=\"#cb55-5\"></a>    Left  Expression</span>\n<span id=\"cb55-6\"><a href=\"#cb55-6\"></a>    Index Expression</span>\n<span id=\"cb55-7\"><a href=\"#cb55-7\"></a>}</span>\n<span id=\"cb55-8\"><a href=\"#cb55-8\"></a></span>\n<span id=\"cb55-9\"><a href=\"#cb55-9\"></a><span class=\"kw\">func</span> (ie *IndexExpression) expressionNode()      {}</span>\n<span id=\"cb55-10\"><a href=\"#cb55-10\"></a><span class=\"kw\">func</span> (ie *IndexExpression) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> ie.Token.Literal }</span>\n<span id=\"cb55-11\"><a href=\"#cb55-11\"></a><span class=\"kw\">func</span> (ie *IndexExpression) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb55-12\"><a href=\"#cb55-12\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb55-13\"><a href=\"#cb55-13\"></a></span>\n<span id=\"cb55-14\"><a href=\"#cb55-14\"></a>    out.WriteString(<span class=\"st\">&quot;(&quot;</span>)</span>\n<span id=\"cb55-15\"><a href=\"#cb55-15\"></a>    out.WriteString(ie.Left.String())</span>\n<span id=\"cb55-16\"><a href=\"#cb55-16\"></a>    out.WriteString(<span class=\"st\">&quot;[&quot;</span>)</span>\n<span id=\"cb55-17\"><a href=\"#cb55-17\"></a>    out.WriteString(ie.Index.String())</span>\n<span id=\"cb55-18\"><a href=\"#cb55-18\"></a>    out.WriteString(<span class=\"st\">&quot;])&quot;</span>)</span>\n<span id=\"cb55-19\"><a href=\"#cb55-19\"></a></span>\n<span id=\"cb55-20\"><a href=\"#cb55-20\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb55-21\"><a href=\"#cb55-21\"></a>}</span></code></pre></div>\n<p>It’s important to note that both <code>Left</code> and <code>Index</code> are just <code>Expression</code>s. <code>Left</code> is the object that’s being accessed and we’ve seen that it can be of any type: an identifier, an array literal, a function call. The same goes for <code>Index</code>. It can be any expression. Syntactically it doesn’t make a difference which one it is, but semantically it has to produce an integer.</p>\n<p>The fact that both <code>Left</code> and <code>Index</code> are expressions makes the parsing process easier, because we can use our <code>parseExpression</code> method to parse them. But first things first! Here is the test case that makes sure our parser knows how to return an <code>*ast.IndexExpression</code>:</p>\n<div class=\"sourceCode\" id=\"cb56\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb56-1\"><a href=\"#cb56-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb56-2\"><a href=\"#cb56-2\"></a></span>\n<span id=\"cb56-3\"><a href=\"#cb56-3\"></a><span class=\"kw\">func</span> TestParsingIndexExpressions(t *testing.T) {</span>\n<span id=\"cb56-4\"><a href=\"#cb56-4\"></a>    input := <span class=\"st\">&quot;myArray[1 + 1]&quot;</span></span>\n<span id=\"cb56-5\"><a href=\"#cb56-5\"></a></span>\n<span id=\"cb56-6\"><a href=\"#cb56-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb56-7\"><a href=\"#cb56-7\"></a>    p := New(l)</span>\n<span id=\"cb56-8\"><a href=\"#cb56-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb56-9\"><a href=\"#cb56-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb56-10\"><a href=\"#cb56-10\"></a></span>\n<span id=\"cb56-11\"><a href=\"#cb56-11\"></a>    stmt, ok := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb56-12\"><a href=\"#cb56-12\"></a>    indexExp, ok := stmt.Expression.(*ast.IndexExpression)</span>\n<span id=\"cb56-13\"><a href=\"#cb56-13\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb56-14\"><a href=\"#cb56-14\"></a>        t.Fatalf(<span class=\"st\">&quot;exp not *ast.IndexExpression. got=%T&quot;</span>, stmt.Expression)</span>\n<span id=\"cb56-15\"><a href=\"#cb56-15\"></a>    }</span>\n<span id=\"cb56-16\"><a href=\"#cb56-16\"></a></span>\n<span id=\"cb56-17\"><a href=\"#cb56-17\"></a>    <span class=\"kw\">if</span> !testIdentifier(t, indexExp.Left, <span class=\"st\">&quot;myArray&quot;</span>) {</span>\n<span id=\"cb56-18\"><a href=\"#cb56-18\"></a>        <span class=\"kw\">return</span></span>\n<span id=\"cb56-19\"><a href=\"#cb56-19\"></a>    }</span>\n<span id=\"cb56-20\"><a href=\"#cb56-20\"></a></span>\n<span id=\"cb56-21\"><a href=\"#cb56-21\"></a>    <span class=\"kw\">if</span> !testInfixExpression(t, indexExp.Index, <span class=\"dv\">1</span>, <span class=\"st\">&quot;+&quot;</span>, <span class=\"dv\">1</span>) {</span>\n<span id=\"cb56-22\"><a href=\"#cb56-22\"></a>        <span class=\"kw\">return</span></span>\n<span id=\"cb56-23\"><a href=\"#cb56-23\"></a>    }</span>\n<span id=\"cb56-24\"><a href=\"#cb56-24\"></a>}</span></code></pre></div>\n<p>Now, this test only asserts that the parser outputs the correct AST for a single expression statement containing an index expression. But equally important is that the parser handles the precedence of the index operator correctly. The index operator has to have the highest precedence of all operators yet. Making sure of that is as easy as extending our existing <code>TestOperatorPrecedenceParsing</code> test function:</p>\n<div class=\"sourceCode\" id=\"cb57\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb57-1\"><a href=\"#cb57-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb57-2\"><a href=\"#cb57-2\"></a></span>\n<span id=\"cb57-3\"><a href=\"#cb57-3\"></a><span class=\"kw\">func</span> TestOperatorPrecedenceParsing(t *testing.T) {</span>\n<span id=\"cb57-4\"><a href=\"#cb57-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb57-5\"><a href=\"#cb57-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb57-6\"><a href=\"#cb57-6\"></a>        expected <span class=\"dt\">string</span></span>\n<span id=\"cb57-7\"><a href=\"#cb57-7\"></a>    }{</span>\n<span id=\"cb57-8\"><a href=\"#cb57-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb57-9\"><a href=\"#cb57-9\"></a>        {</span>\n<span id=\"cb57-10\"><a href=\"#cb57-10\"></a>            <span class=\"st\">&quot;a * [1, 2, 3, 4][b * c] * d&quot;</span>,</span>\n<span id=\"cb57-11\"><a href=\"#cb57-11\"></a>            <span class=\"st\">&quot;((a * ([1, 2, 3, 4][(b * c)])) * d)&quot;</span>,</span>\n<span id=\"cb57-12\"><a href=\"#cb57-12\"></a>        },</span>\n<span id=\"cb57-13\"><a href=\"#cb57-13\"></a>        {</span>\n<span id=\"cb57-14\"><a href=\"#cb57-14\"></a>            <span class=\"st\">&quot;add(a * b[2], b[1], 2 * [1, 2][1])&quot;</span>,</span>\n<span id=\"cb57-15\"><a href=\"#cb57-15\"></a>            <span class=\"st\">&quot;add((a * (b[2])), (b[1]), (2 * ([1, 2][1])))&quot;</span>,</span>\n<span id=\"cb57-16\"><a href=\"#cb57-16\"></a>        },</span>\n<span id=\"cb57-17\"><a href=\"#cb57-17\"></a>    }</span>\n<span id=\"cb57-18\"><a href=\"#cb57-18\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb57-19\"><a href=\"#cb57-19\"></a>}</span></code></pre></div>\n<p>The additional <code>(</code> and <code>)</code> in the <code>String()</code> output of <code>*ast.IndexExpression</code> help us when writing these tests, since they make the precedence of the index operator visible. In these added test cases we expect that the precedence of the index operator is higher than the precedence of call expressions or even the <code>*</code> operator in infix expressions.</p>\n<p>The tests fail because the parser doesn’t know anything about index expressions yet:</p>\n<div class=\"sourceCode\" id=\"cb58\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb58-1\"><a href=\"#cb58-1\"></a>$ go test ./parser</span>\n<span id=\"cb58-2\"><a href=\"#cb58-2\"></a>--- FAIL: TestOperatorPrecedenceParsing (0.00s)</span>\n<span id=\"cb58-3\"><a href=\"#cb58-3\"></a>  parser_test.go:393: expected=&quot;((a * ([1, 2, 3, 4][(b * c)])) * d)&quot;,\\</span>\n<span id=\"cb58-4\"><a href=\"#cb58-4\"></a>    got=&quot;(a * [1, 2, 3, 4])([(b * c)] * d)&quot;</span>\n<span id=\"cb58-5\"><a href=\"#cb58-5\"></a>  parser_test.go:968: parser has 4 errors</span>\n<span id=\"cb58-6\"><a href=\"#cb58-6\"></a>  parser_test.go:970: parser error: &quot;expected next token to be ), got [ instead&quot;</span>\n<span id=\"cb58-7\"><a href=\"#cb58-7\"></a>  parser_test.go:970: parser error: &quot;no prefix parse function for , found&quot;</span>\n<span id=\"cb58-8\"><a href=\"#cb58-8\"></a>  parser_test.go:970: parser error: &quot;no prefix parse function for , found&quot;</span>\n<span id=\"cb58-9\"><a href=\"#cb58-9\"></a>  parser_test.go:970: parser error: &quot;no prefix parse function for ) found&quot;</span>\n<span id=\"cb58-10\"><a href=\"#cb58-10\"></a>--- FAIL: TestParsingIndexExpressions (0.00s)</span>\n<span id=\"cb58-11\"><a href=\"#cb58-11\"></a>  parser_test.go:835: exp not *ast.IndexExpression. got=*ast.Identifier</span>\n<span id=\"cb58-12\"><a href=\"#cb58-12\"></a>FAIL</span>\n<span id=\"cb58-13\"><a href=\"#cb58-13\"></a>FAIL    monkey/parser   0.007s</span></code></pre></div>\n<p>Even though the tests complain about a missing <code>prefixParseFn</code> what we want is an <code>infixParseFn</code>. Yes, index operator expressions do not really have a single operator between operands on each side. But in order to parse them without a lot of trouble it’s of advantage to act like they do, just like we did with call expressions. Specifically, that means treating the <code>[</code> in <code>myArray[0]</code> as the infix operator, <code>myArray</code> as the left operand and <code>0</code> as the right operand.</p>\n<p>Doing this makes the implementation fit really nicely into our parser:</p>\n<div class=\"sourceCode\" id=\"cb59\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb59-1\"><a href=\"#cb59-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb59-2\"><a href=\"#cb59-2\"></a></span>\n<span id=\"cb59-3\"><a href=\"#cb59-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb59-4\"><a href=\"#cb59-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb59-5\"><a href=\"#cb59-5\"></a></span>\n<span id=\"cb59-6\"><a href=\"#cb59-6\"></a>    p.registerInfix(token.LBRACKET, p.parseIndexExpression)</span>\n<span id=\"cb59-7\"><a href=\"#cb59-7\"></a></span>\n<span id=\"cb59-8\"><a href=\"#cb59-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb59-9\"><a href=\"#cb59-9\"></a>}</span>\n<span id=\"cb59-10\"><a href=\"#cb59-10\"></a></span>\n<span id=\"cb59-11\"><a href=\"#cb59-11\"></a><span class=\"kw\">func</span> (p *Parser) parseIndexExpression(left ast.Expression) ast.Expression {</span>\n<span id=\"cb59-12\"><a href=\"#cb59-12\"></a>    exp := &amp;ast.IndexExpression{Token: p.curToken, Left: left}</span>\n<span id=\"cb59-13\"><a href=\"#cb59-13\"></a></span>\n<span id=\"cb59-14\"><a href=\"#cb59-14\"></a>    p.nextToken()</span>\n<span id=\"cb59-15\"><a href=\"#cb59-15\"></a>    exp.Index = p.parseExpression(LOWEST)</span>\n<span id=\"cb59-16\"><a href=\"#cb59-16\"></a></span>\n<span id=\"cb59-17\"><a href=\"#cb59-17\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.RBRACKET) {</span>\n<span id=\"cb59-18\"><a href=\"#cb59-18\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb59-19\"><a href=\"#cb59-19\"></a>    }</span>\n<span id=\"cb59-20\"><a href=\"#cb59-20\"></a></span>\n<span id=\"cb59-21\"><a href=\"#cb59-21\"></a>    <span class=\"kw\">return</span> exp</span>\n<span id=\"cb59-22\"><a href=\"#cb59-22\"></a>}</span></code></pre></div>\n<p>Neat! But that doesn’t fix our tests:</p>\n<div class=\"sourceCode\" id=\"cb60\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb60-1\"><a href=\"#cb60-1\"></a>$ go test ./parser</span>\n<span id=\"cb60-2\"><a href=\"#cb60-2\"></a>--- FAIL: TestOperatorPrecedenceParsing (0.00s)</span>\n<span id=\"cb60-3\"><a href=\"#cb60-3\"></a>  parser_test.go:393: expected=&quot;((a * ([1, 2, 3, 4][(b * c)])) * d)&quot;,\\</span>\n<span id=\"cb60-4\"><a href=\"#cb60-4\"></a>    got=&quot;(a * [1, 2, 3, 4])([(b * c)] * d)&quot;</span>\n<span id=\"cb60-5\"><a href=\"#cb60-5\"></a>  parser_test.go:968: parser has 4 errors</span>\n<span id=\"cb60-6\"><a href=\"#cb60-6\"></a>  parser_test.go:970: parser error: &quot;expected next token to be ), got [ instead&quot;</span>\n<span id=\"cb60-7\"><a href=\"#cb60-7\"></a>  parser_test.go:970: parser error: &quot;no prefix parse function for , found&quot;</span>\n<span id=\"cb60-8\"><a href=\"#cb60-8\"></a>  parser_test.go:970: parser error: &quot;no prefix parse function for , found&quot;</span>\n<span id=\"cb60-9\"><a href=\"#cb60-9\"></a>  parser_test.go:970: parser error: &quot;no prefix parse function for ) found&quot;</span>\n<span id=\"cb60-10\"><a href=\"#cb60-10\"></a>--- FAIL: TestParsingIndexExpressions (0.00s)</span>\n<span id=\"cb60-11\"><a href=\"#cb60-11\"></a>  parser_test.go:835: exp not *ast.IndexExpression. got=*ast.Identifier</span>\n<span id=\"cb60-12\"><a href=\"#cb60-12\"></a>FAIL</span>\n<span id=\"cb60-13\"><a href=\"#cb60-13\"></a>FAIL    monkey/parser   0.008s</span></code></pre></div>\n<p>That’s because the whole idea behind our Pratt parser hinges on the idea of precedences and we haven’t defined the precedence of our index operator yet:</p>\n<div class=\"sourceCode\" id=\"cb61\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb61-1\"><a href=\"#cb61-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb61-2\"><a href=\"#cb61-2\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb61-3\"><a href=\"#cb61-3\"></a>    _ <span class=\"dt\">int</span> = <span class=\"ot\">iota</span></span>\n<span id=\"cb61-4\"><a href=\"#cb61-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb61-5\"><a href=\"#cb61-5\"></a>    INDEX       <span class=\"co\">// array[index]</span></span>\n<span id=\"cb61-6\"><a href=\"#cb61-6\"></a>)</span>\n<span id=\"cb61-7\"><a href=\"#cb61-7\"></a></span>\n<span id=\"cb61-8\"><a href=\"#cb61-8\"></a><span class=\"kw\">var</span> precedences = <span class=\"kw\">map</span>[token.TokenType]<span class=\"dt\">int</span>{</span>\n<span id=\"cb61-9\"><a href=\"#cb61-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb61-10\"><a href=\"#cb61-10\"></a>    token.LBRACKET: INDEX,</span>\n<span id=\"cb61-11\"><a href=\"#cb61-11\"></a>}</span></code></pre></div>\n<p>It’s important that the definition of <code>INDEX</code> is the last line in the <code>const</code> block. That gives <code>INDEX</code> the highest value of all defined precedence constants, thanks to the <code>iota</code>. The added entry in <code>precedences</code> gives <code>token.LBRACKET</code> this highest precedence of all, <code>INDEX</code>. And, well, it does wonders:</p>\n<div class=\"sourceCode\" id=\"cb62\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb62-1\"><a href=\"#cb62-1\"></a>$ go test ./parser</span>\n<span id=\"cb62-2\"><a href=\"#cb62-2\"></a>ok      monkey/parser   0.007s</span></code></pre></div>\n<p>Lexer done, parser done. See you in the evaluator!</p>\n</section>\n<section id=\"evaluating-array-literals\" class=\"level3\" data-number=\"4.4.4\">\n<h3 data-number=\"4.4.4\">Evaluating Array Literals</h3>\n<p>Evaluating array literals is not hard. Mapping Monkey arrays to Go’s slices makes life pretty, pretty sweet. We don’t have to implement a new data structure. We only need to define a new <code>object.Array</code> type, since that’s what the evaluation of array literals produces. And the definition of <code>object.Array</code> is simple, since arrays in Monkey are simple: they are just a list of objects.</p>\n<div class=\"sourceCode\" id=\"cb63\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb63-1\"><a href=\"#cb63-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb63-2\"><a href=\"#cb63-2\"></a></span>\n<span id=\"cb63-3\"><a href=\"#cb63-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb63-4\"><a href=\"#cb63-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb63-5\"><a href=\"#cb63-5\"></a>    ARRAY_OBJ = <span class=\"st\">&quot;ARRAY&quot;</span></span>\n<span id=\"cb63-6\"><a href=\"#cb63-6\"></a>)</span>\n<span id=\"cb63-7\"><a href=\"#cb63-7\"></a></span>\n<span id=\"cb63-8\"><a href=\"#cb63-8\"></a><span class=\"kw\">type</span> Array <span class=\"kw\">struct</span> {</span>\n<span id=\"cb63-9\"><a href=\"#cb63-9\"></a>    Elements []Object</span>\n<span id=\"cb63-10\"><a href=\"#cb63-10\"></a>}</span>\n<span id=\"cb63-11\"><a href=\"#cb63-11\"></a></span>\n<span id=\"cb63-12\"><a href=\"#cb63-12\"></a><span class=\"kw\">func</span> (ao *Array) Type() ObjectType { <span class=\"kw\">return</span> ARRAY_OBJ }</span>\n<span id=\"cb63-13\"><a href=\"#cb63-13\"></a><span class=\"kw\">func</span> (ao *Array) Inspect() <span class=\"dt\">string</span> {</span>\n<span id=\"cb63-14\"><a href=\"#cb63-14\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb63-15\"><a href=\"#cb63-15\"></a></span>\n<span id=\"cb63-16\"><a href=\"#cb63-16\"></a>    elements := []<span class=\"dt\">string</span>{}</span>\n<span id=\"cb63-17\"><a href=\"#cb63-17\"></a>    <span class=\"kw\">for</span> _, e := <span class=\"kw\">range</span> ao.Elements {</span>\n<span id=\"cb63-18\"><a href=\"#cb63-18\"></a>        elements = <span class=\"bu\">append</span>(elements, e.Inspect())</span>\n<span id=\"cb63-19\"><a href=\"#cb63-19\"></a>    }</span>\n<span id=\"cb63-20\"><a href=\"#cb63-20\"></a></span>\n<span id=\"cb63-21\"><a href=\"#cb63-21\"></a>    out.WriteString(<span class=\"st\">&quot;[&quot;</span>)</span>\n<span id=\"cb63-22\"><a href=\"#cb63-22\"></a>    out.WriteString(strings.Join(elements, <span class=\"st\">&quot;, &quot;</span>))</span>\n<span id=\"cb63-23\"><a href=\"#cb63-23\"></a>    out.WriteString(<span class=\"st\">&quot;]&quot;</span>)</span>\n<span id=\"cb63-24\"><a href=\"#cb63-24\"></a></span>\n<span id=\"cb63-25\"><a href=\"#cb63-25\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb63-26\"><a href=\"#cb63-26\"></a>}</span></code></pre></div>\n<p>I think you’ll agree with me when I say that the most complicated thing about this definition is the <code>Inspect</code> method. And even that one is pretty easy to understand.</p>\n<p>Here is the evaluator test for array literals:</p>\n<div class=\"sourceCode\" id=\"cb64\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb64-1\"><a href=\"#cb64-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb64-2\"><a href=\"#cb64-2\"></a></span>\n<span id=\"cb64-3\"><a href=\"#cb64-3\"></a><span class=\"kw\">func</span> TestArrayLiterals(t *testing.T) {</span>\n<span id=\"cb64-4\"><a href=\"#cb64-4\"></a>    input := <span class=\"st\">&quot;[1, 2 * 2, 3 + 3]&quot;</span></span>\n<span id=\"cb64-5\"><a href=\"#cb64-5\"></a></span>\n<span id=\"cb64-6\"><a href=\"#cb64-6\"></a>    evaluated := testEval(input)</span>\n<span id=\"cb64-7\"><a href=\"#cb64-7\"></a>    result, ok := evaluated.(*object.Array)</span>\n<span id=\"cb64-8\"><a href=\"#cb64-8\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb64-9\"><a href=\"#cb64-9\"></a>        t.Fatalf(<span class=\"st\">&quot;object is not Array. got=%T (%+v)&quot;</span>, evaluated, evaluated)</span>\n<span id=\"cb64-10\"><a href=\"#cb64-10\"></a>    }</span>\n<span id=\"cb64-11\"><a href=\"#cb64-11\"></a></span>\n<span id=\"cb64-12\"><a href=\"#cb64-12\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(result.Elements) != <span class=\"dv\">3</span> {</span>\n<span id=\"cb64-13\"><a href=\"#cb64-13\"></a>        t.Fatalf(<span class=\"st\">&quot;array has wrong num of elements. got=%d&quot;</span>,</span>\n<span id=\"cb64-14\"><a href=\"#cb64-14\"></a>            <span class=\"bu\">len</span>(result.Elements))</span>\n<span id=\"cb64-15\"><a href=\"#cb64-15\"></a>    }</span>\n<span id=\"cb64-16\"><a href=\"#cb64-16\"></a></span>\n<span id=\"cb64-17\"><a href=\"#cb64-17\"></a>    testIntegerObject(t, result.Elements[<span class=\"dv\">0</span>], <span class=\"dv\">1</span>)</span>\n<span id=\"cb64-18\"><a href=\"#cb64-18\"></a>    testIntegerObject(t, result.Elements[<span class=\"dv\">1</span>], <span class=\"dv\">4</span>)</span>\n<span id=\"cb64-19\"><a href=\"#cb64-19\"></a>    testIntegerObject(t, result.Elements[<span class=\"dv\">2</span>], <span class=\"dv\">6</span>)</span>\n<span id=\"cb64-20\"><a href=\"#cb64-20\"></a>}</span></code></pre></div>\n<p>We can reuse some existing code to get this test to pass, just like we did in our parser. And again the code we’re reusing was originally written for call expressions. Here is the <code>case</code> branch that evaluates <code>*ast.ArrayLiteral</code>s and produces array objects:</p>\n<div class=\"sourceCode\" id=\"cb65\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb65-1\"><a href=\"#cb65-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb65-2\"><a href=\"#cb65-2\"></a></span>\n<span id=\"cb65-3\"><a href=\"#cb65-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb65-4\"><a href=\"#cb65-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb65-5\"><a href=\"#cb65-5\"></a></span>\n<span id=\"cb65-6\"><a href=\"#cb65-6\"></a>    <span class=\"kw\">case</span> *ast.ArrayLiteral:</span>\n<span id=\"cb65-7\"><a href=\"#cb65-7\"></a>        elements := evalExpressions(node.Elements, env)</span>\n<span id=\"cb65-8\"><a href=\"#cb65-8\"></a>        <span class=\"kw\">if</span> <span class=\"bu\">len</span>(elements) == <span class=\"dv\">1</span> &amp;&amp; isError(elements[<span class=\"dv\">0</span>]) {</span>\n<span id=\"cb65-9\"><a href=\"#cb65-9\"></a>            <span class=\"kw\">return</span> elements[<span class=\"dv\">0</span>]</span>\n<span id=\"cb65-10\"><a href=\"#cb65-10\"></a>        }</span>\n<span id=\"cb65-11\"><a href=\"#cb65-11\"></a>        <span class=\"kw\">return</span> &amp;object.Array{Elements: elements}</span>\n<span id=\"cb65-12\"><a href=\"#cb65-12\"></a>    }</span>\n<span id=\"cb65-13\"><a href=\"#cb65-13\"></a></span>\n<span id=\"cb65-14\"><a href=\"#cb65-14\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb65-15\"><a href=\"#cb65-15\"></a>}</span></code></pre></div>\n<p>Isn’t that one of the great joys of programming? Reusing existing code without having to turn it into a super generic, over-engineered spaceship.</p>\n<p>The tests are passing and we can use array literals in our REPL to produce arrays:</p>\n<div class=\"sourceCode\" id=\"cb66\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb66-1\"><a href=\"#cb66-1\"></a>$ go run main<span class=\"op\">.</span><span class=\"at\">go</span></span>\n<span id=\"cb66-2\"><a href=\"#cb66-2\"></a>Hello mrnugget<span class=\"op\">!</span> This is the Monkey programming language<span class=\"op\">!</span></span>\n<span id=\"cb66-3\"><a href=\"#cb66-3\"></a>Feel free to type <span class=\"kw\">in</span> commands</span>\n<span id=\"cb66-4\"><a href=\"#cb66-4\"></a><span class=\"op\">&gt;&gt;</span> [<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span>]</span>\n<span id=\"cb66-5\"><a href=\"#cb66-5\"></a>[<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span>]</span>\n<span id=\"cb66-6\"><a href=\"#cb66-6\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> double <span class=\"op\">=</span> fn(x) { x <span class=\"op\">*</span> <span class=\"dv\">2</span> }<span class=\"op\">;</span></span>\n<span id=\"cb66-7\"><a href=\"#cb66-7\"></a><span class=\"op\">&gt;&gt;</span> [<span class=\"dv\">1</span><span class=\"op\">,</span> double(<span class=\"dv\">2</span>)<span class=\"op\">,</span> <span class=\"dv\">3</span> <span class=\"op\">*</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span> <span class=\"op\">-</span> <span class=\"dv\">3</span>]</span>\n<span id=\"cb66-8\"><a href=\"#cb66-8\"></a>[<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">4</span><span class=\"op\">,</span> <span class=\"dv\">9</span><span class=\"op\">,</span> <span class=\"dv\">1</span>]</span>\n<span id=\"cb66-9\"><a href=\"#cb66-9\"></a><span class=\"op\">&gt;&gt;</span></span></code></pre></div>\n<p>Amazing, isn’t it? But what we can’t do yet is accessing single elements of the array by using the index operator.</p>\n</section>\n<section id=\"evaluating-index-operator-expressions\" class=\"level3\" data-number=\"4.4.5\">\n<h3 data-number=\"4.4.5\">Evaluating Index Operator Expressions</h3>\n<p>Great news: much harder than evaluating index expressions is parsing them. And we already did that. The only problem left is the possibility of off-by-one errors when accessing and retrieving the elements in an array. But for that we’ll just add a few tests to our test suite:</p>\n<div class=\"sourceCode\" id=\"cb67\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb67-1\"><a href=\"#cb67-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb67-2\"><a href=\"#cb67-2\"></a></span>\n<span id=\"cb67-3\"><a href=\"#cb67-3\"></a><span class=\"kw\">func</span> TestArrayIndexExpressions(t *testing.T) {</span>\n<span id=\"cb67-4\"><a href=\"#cb67-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb67-5\"><a href=\"#cb67-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb67-6\"><a href=\"#cb67-6\"></a>        expected <span class=\"kw\">interface</span>{}</span>\n<span id=\"cb67-7\"><a href=\"#cb67-7\"></a>    }{</span>\n<span id=\"cb67-8\"><a href=\"#cb67-8\"></a>        {</span>\n<span id=\"cb67-9\"><a href=\"#cb67-9\"></a>            <span class=\"st\">&quot;[1, 2, 3][0]&quot;</span>,</span>\n<span id=\"cb67-10\"><a href=\"#cb67-10\"></a>            <span class=\"dv\">1</span>,</span>\n<span id=\"cb67-11\"><a href=\"#cb67-11\"></a>        },</span>\n<span id=\"cb67-12\"><a href=\"#cb67-12\"></a>        {</span>\n<span id=\"cb67-13\"><a href=\"#cb67-13\"></a>            <span class=\"st\">&quot;[1, 2, 3][1]&quot;</span>,</span>\n<span id=\"cb67-14\"><a href=\"#cb67-14\"></a>            <span class=\"dv\">2</span>,</span>\n<span id=\"cb67-15\"><a href=\"#cb67-15\"></a>        },</span>\n<span id=\"cb67-16\"><a href=\"#cb67-16\"></a>        {</span>\n<span id=\"cb67-17\"><a href=\"#cb67-17\"></a>            <span class=\"st\">&quot;[1, 2, 3][2]&quot;</span>,</span>\n<span id=\"cb67-18\"><a href=\"#cb67-18\"></a>            <span class=\"dv\">3</span>,</span>\n<span id=\"cb67-19\"><a href=\"#cb67-19\"></a>        },</span>\n<span id=\"cb67-20\"><a href=\"#cb67-20\"></a>        {</span>\n<span id=\"cb67-21\"><a href=\"#cb67-21\"></a>            <span class=\"st\">&quot;let i = 0; [1][i];&quot;</span>,</span>\n<span id=\"cb67-22\"><a href=\"#cb67-22\"></a>            <span class=\"dv\">1</span>,</span>\n<span id=\"cb67-23\"><a href=\"#cb67-23\"></a>        },</span>\n<span id=\"cb67-24\"><a href=\"#cb67-24\"></a>        {</span>\n<span id=\"cb67-25\"><a href=\"#cb67-25\"></a>            <span class=\"st\">&quot;[1, 2, 3][1 + 1];&quot;</span>,</span>\n<span id=\"cb67-26\"><a href=\"#cb67-26\"></a>            <span class=\"dv\">3</span>,</span>\n<span id=\"cb67-27\"><a href=\"#cb67-27\"></a>        },</span>\n<span id=\"cb67-28\"><a href=\"#cb67-28\"></a>        {</span>\n<span id=\"cb67-29\"><a href=\"#cb67-29\"></a>            <span class=\"st\">&quot;let myArray = [1, 2, 3]; myArray[2];&quot;</span>,</span>\n<span id=\"cb67-30\"><a href=\"#cb67-30\"></a>            <span class=\"dv\">3</span>,</span>\n<span id=\"cb67-31\"><a href=\"#cb67-31\"></a>        },</span>\n<span id=\"cb67-32\"><a href=\"#cb67-32\"></a>        {</span>\n<span id=\"cb67-33\"><a href=\"#cb67-33\"></a>            <span class=\"st\">&quot;let myArray = [1, 2, 3]; myArray[0] + myArray[1] + myArray[2];&quot;</span>,</span>\n<span id=\"cb67-34\"><a href=\"#cb67-34\"></a>            <span class=\"dv\">6</span>,</span>\n<span id=\"cb67-35\"><a href=\"#cb67-35\"></a>        },</span>\n<span id=\"cb67-36\"><a href=\"#cb67-36\"></a>        {</span>\n<span id=\"cb67-37\"><a href=\"#cb67-37\"></a>            <span class=\"st\">&quot;let myArray = [1, 2, 3]; let i = myArray[0]; myArray[i]&quot;</span>,</span>\n<span id=\"cb67-38\"><a href=\"#cb67-38\"></a>            <span class=\"dv\">2</span>,</span>\n<span id=\"cb67-39\"><a href=\"#cb67-39\"></a>        },</span>\n<span id=\"cb67-40\"><a href=\"#cb67-40\"></a>        {</span>\n<span id=\"cb67-41\"><a href=\"#cb67-41\"></a>            <span class=\"st\">&quot;[1, 2, 3][3]&quot;</span>,</span>\n<span id=\"cb67-42\"><a href=\"#cb67-42\"></a>            <span class=\"ot\">nil</span>,</span>\n<span id=\"cb67-43\"><a href=\"#cb67-43\"></a>        },</span>\n<span id=\"cb67-44\"><a href=\"#cb67-44\"></a>        {</span>\n<span id=\"cb67-45\"><a href=\"#cb67-45\"></a>            <span class=\"st\">&quot;[1, 2, 3][-1]&quot;</span>,</span>\n<span id=\"cb67-46\"><a href=\"#cb67-46\"></a>            <span class=\"ot\">nil</span>,</span>\n<span id=\"cb67-47\"><a href=\"#cb67-47\"></a>        },</span>\n<span id=\"cb67-48\"><a href=\"#cb67-48\"></a>    }</span>\n<span id=\"cb67-49\"><a href=\"#cb67-49\"></a></span>\n<span id=\"cb67-50\"><a href=\"#cb67-50\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb67-51\"><a href=\"#cb67-51\"></a>        evaluated := testEval(tt.input)</span>\n<span id=\"cb67-52\"><a href=\"#cb67-52\"></a>        integer, ok := tt.expected.(<span class=\"dt\">int</span>)</span>\n<span id=\"cb67-53\"><a href=\"#cb67-53\"></a>        <span class=\"kw\">if</span> ok {</span>\n<span id=\"cb67-54\"><a href=\"#cb67-54\"></a>            testIntegerObject(t, evaluated, <span class=\"dt\">int64</span>(integer))</span>\n<span id=\"cb67-55\"><a href=\"#cb67-55\"></a>        } <span class=\"kw\">else</span> {</span>\n<span id=\"cb67-56\"><a href=\"#cb67-56\"></a>            testNullObject(t, evaluated)</span>\n<span id=\"cb67-57\"><a href=\"#cb67-57\"></a>        }</span>\n<span id=\"cb67-58\"><a href=\"#cb67-58\"></a>    }</span>\n<span id=\"cb67-59\"><a href=\"#cb67-59\"></a>}</span></code></pre></div>\n<p>Okay, I’ll admit, these tests might seem excessive. A lot of the things we’re testing implicitly here have already been tested elsewhere. But the test cases are so easy to write! And they are so readable! I love these tests.</p>\n<p>Take note of the desired behaviour these tests specify. They contain something we haven’t talked about yet: when we use an index that’s out of the arrays bounds, we’ll return <code>NULL</code>. Some languages produce an error in such a case and some return a null value. I choose to return <code>NULL</code>.</p>\n<p>As expected the tests are failing. And not only that, they’re blowing up:</p>\n<div class=\"sourceCode\" id=\"cb68\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb68-1\"><a href=\"#cb68-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb68-2\"><a href=\"#cb68-2\"></a>--- FAIL: TestArrayIndexExpressions (0.00s)</span>\n<span id=\"cb68-3\"><a href=\"#cb68-3\"></a>  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb68-4\"><a href=\"#cb68-4\"></a>  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb68-5\"><a href=\"#cb68-5\"></a>  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb68-6\"><a href=\"#cb68-6\"></a>  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb68-7\"><a href=\"#cb68-7\"></a>  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb68-8\"><a href=\"#cb68-8\"></a>  evaluator_test.go:492: object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb68-9\"><a href=\"#cb68-9\"></a>panic: runtime error: invalid memory address or nil pointer dereference</span>\n<span id=\"cb68-10\"><a href=\"#cb68-10\"></a>[signal SIGSEGV: segmentation violation code=0x1 addr=0x28 pc=0x70057]</span>\n<span id=\"cb68-11\"><a href=\"#cb68-11\"></a>[redacted: backtrace here]</span>\n<span id=\"cb68-12\"><a href=\"#cb68-12\"></a>FAIL    monkey/evaluator        0.011s</span></code></pre></div>\n<p>So how do we fix this and evaluate index expressions? As we’ve seen, the left operand of the index operator can be any expression and the index itself can be any expression. That means we need to evaluate both before we can evaluate the “indexing” itself. Otherwise we’d try to access elements of an identifier or a function call, which doesn’t work.</p>\n<p>Here is the <code>case</code> branch for <code>*ast.IndexExpression</code> that makes these desired calls to <code>Eval</code>:</p>\n<div class=\"sourceCode\" id=\"cb69\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb69-1\"><a href=\"#cb69-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb69-2\"><a href=\"#cb69-2\"></a></span>\n<span id=\"cb69-3\"><a href=\"#cb69-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb69-4\"><a href=\"#cb69-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb69-5\"><a href=\"#cb69-5\"></a></span>\n<span id=\"cb69-6\"><a href=\"#cb69-6\"></a>    <span class=\"kw\">case</span> *ast.IndexExpression:</span>\n<span id=\"cb69-7\"><a href=\"#cb69-7\"></a>        left := Eval(node.Left, env)</span>\n<span id=\"cb69-8\"><a href=\"#cb69-8\"></a>        <span class=\"kw\">if</span> isError(left) {</span>\n<span id=\"cb69-9\"><a href=\"#cb69-9\"></a>            <span class=\"kw\">return</span> left</span>\n<span id=\"cb69-10\"><a href=\"#cb69-10\"></a>        }</span>\n<span id=\"cb69-11\"><a href=\"#cb69-11\"></a>        index := Eval(node.Index, env)</span>\n<span id=\"cb69-12\"><a href=\"#cb69-12\"></a>        <span class=\"kw\">if</span> isError(index) {</span>\n<span id=\"cb69-13\"><a href=\"#cb69-13\"></a>            <span class=\"kw\">return</span> index</span>\n<span id=\"cb69-14\"><a href=\"#cb69-14\"></a>        }</span>\n<span id=\"cb69-15\"><a href=\"#cb69-15\"></a>        <span class=\"kw\">return</span> evalIndexExpression(left, index)</span>\n<span id=\"cb69-16\"><a href=\"#cb69-16\"></a></span>\n<span id=\"cb69-17\"><a href=\"#cb69-17\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb69-18\"><a href=\"#cb69-18\"></a>}</span></code></pre></div>\n<p>And here is the <code>evalIndexExpression</code> function it uses:</p>\n<div class=\"sourceCode\" id=\"cb70\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb70-1\"><a href=\"#cb70-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb70-2\"><a href=\"#cb70-2\"></a></span>\n<span id=\"cb70-3\"><a href=\"#cb70-3\"></a><span class=\"kw\">func</span> evalIndexExpression(left, index object.Object) object.Object {</span>\n<span id=\"cb70-4\"><a href=\"#cb70-4\"></a>    <span class=\"kw\">switch</span> {</span>\n<span id=\"cb70-5\"><a href=\"#cb70-5\"></a>    <span class=\"kw\">case</span> left.Type() == object.ARRAY_OBJ &amp;&amp; index.Type() == object.INTEGER_OBJ:</span>\n<span id=\"cb70-6\"><a href=\"#cb70-6\"></a>        <span class=\"kw\">return</span> evalArrayIndexExpression(left, index)</span>\n<span id=\"cb70-7\"><a href=\"#cb70-7\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb70-8\"><a href=\"#cb70-8\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;index operator not supported: %s&quot;</span>, left.Type())</span>\n<span id=\"cb70-9\"><a href=\"#cb70-9\"></a>    }</span>\n<span id=\"cb70-10\"><a href=\"#cb70-10\"></a>}</span></code></pre></div>\n<p>An if-conditional would do the job of the switch statement here just fine, but we’re going to add another <code>case</code> branch later in this chapter. Besides the error handling (for which I also added a test) nothing really interesting happens in this function. The meat of the operation is in <code>evalArrayIndexExpression</code>:</p>\n<div class=\"sourceCode\" id=\"cb71\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb71-1\"><a href=\"#cb71-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb71-2\"><a href=\"#cb71-2\"></a></span>\n<span id=\"cb71-3\"><a href=\"#cb71-3\"></a><span class=\"kw\">func</span> evalArrayIndexExpression(array, index object.Object) object.Object {</span>\n<span id=\"cb71-4\"><a href=\"#cb71-4\"></a>    arrayObject := array.(*object.Array)</span>\n<span id=\"cb71-5\"><a href=\"#cb71-5\"></a>    idx := index.(*object.Integer).Value</span>\n<span id=\"cb71-6\"><a href=\"#cb71-6\"></a>    max := <span class=\"dt\">int64</span>(<span class=\"bu\">len</span>(arrayObject.Elements) - <span class=\"dv\">1</span>)</span>\n<span id=\"cb71-7\"><a href=\"#cb71-7\"></a></span>\n<span id=\"cb71-8\"><a href=\"#cb71-8\"></a>    <span class=\"kw\">if</span> idx &lt; <span class=\"dv\">0</span> || idx &gt; max {</span>\n<span id=\"cb71-9\"><a href=\"#cb71-9\"></a>        <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb71-10\"><a href=\"#cb71-10\"></a>    }</span>\n<span id=\"cb71-11\"><a href=\"#cb71-11\"></a></span>\n<span id=\"cb71-12\"><a href=\"#cb71-12\"></a>    <span class=\"kw\">return</span> arrayObject.Elements[idx]</span>\n<span id=\"cb71-13\"><a href=\"#cb71-13\"></a>}</span></code></pre></div>\n<p>Here we actually retrieve the element with the specified index from the array. Besides the little type assertion and conversion dances this function is pretty straightforward: it checks if the given index is out of range and if that’s the case it returns <code>NULL</code>, otherwise the desired element. Just like we specified in our tests, which are now passing:</p>\n<div class=\"sourceCode\" id=\"cb72\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb72-1\"><a href=\"#cb72-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb72-2\"><a href=\"#cb72-2\"></a>ok      monkey/evaluator        0.007s</span></code></pre></div>\n<p>Okay, now take a deep breath, relax and take a look at this:</p>\n<div class=\"sourceCode\" id=\"cb73\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb73-1\"><a href=\"#cb73-1\"></a>$ go run main.go</span>\n<span id=\"cb73-2\"><a href=\"#cb73-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb73-3\"><a href=\"#cb73-3\"></a>Feel free to type in commands</span>\n<span id=\"cb73-4\"><a href=\"#cb73-4\"></a>&gt;&gt; let a = [1, 2 * 2, 10 - 5, 8 / 2];</span>\n<span id=\"cb73-5\"><a href=\"#cb73-5\"></a>&gt;&gt; a[0]</span>\n<span id=\"cb73-6\"><a href=\"#cb73-6\"></a>1</span>\n<span id=\"cb73-7\"><a href=\"#cb73-7\"></a>&gt;&gt; a[1]</span>\n<span id=\"cb73-8\"><a href=\"#cb73-8\"></a>4</span>\n<span id=\"cb73-9\"><a href=\"#cb73-9\"></a>&gt;&gt; a[5 - 3]</span>\n<span id=\"cb73-10\"><a href=\"#cb73-10\"></a>5</span>\n<span id=\"cb73-11\"><a href=\"#cb73-11\"></a>&gt;&gt; a[99]</span>\n<span id=\"cb73-12\"><a href=\"#cb73-12\"></a>null</span></code></pre></div>\n<p>Retrieving elements from an array works! Sweet! I can only repeat myself here: it’s amazing how easy it was to implement this language feature, isn’t it?</p>\n</section>\n<section id=\"adding-built-in-functions-for-arrays\" class=\"level3\" data-number=\"4.4.6\">\n<h3 data-number=\"4.4.6\">Adding Built-in Functions for Arrays</h3>\n<p>We are now able to construct arrays by using array literals. And we can access single elements by using index expressions. Just those two things alone make arrays quite useful to have. But in order to make them even more useful, we need to add a few built-in functions that make working with them more convenient. In this sub-section we’re going to do exactly that.</p>\n<p>I won’t be showing any test code and test cases in this section. The reason is that these particular tests take up space without adding anything new. Our “framework” for testing built-in functions is already in place with <code>TestBuiltinFunctions</code> and the added tests follow the existing scheme. You can find them in the accompanying code.</p>\n<p>Our goal is to add new built-in functions. But the first thing we actually have to do is not adding a new one but changing an existing function. We need to add support for arrays to <code>len</code>, which only supported strings until now:</p>\n<div class=\"sourceCode\" id=\"cb74\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb74-1\"><a href=\"#cb74-1\"></a><span class=\"co\">// evaluator/builtins.go</span></span>\n<span id=\"cb74-2\"><a href=\"#cb74-2\"></a></span>\n<span id=\"cb74-3\"><a href=\"#cb74-3\"></a><span class=\"kw\">var</span> builtins = <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]*object.Builtin{</span>\n<span id=\"cb74-4\"><a href=\"#cb74-4\"></a>    <span class=\"st\">&quot;len&quot;</span>: &amp;object.Builtin{</span>\n<span id=\"cb74-5\"><a href=\"#cb74-5\"></a>        Fn: <span class=\"kw\">func</span>(args ...object.Object) object.Object {</span>\n<span id=\"cb74-6\"><a href=\"#cb74-6\"></a>            <span class=\"kw\">if</span> <span class=\"bu\">len</span>(args) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb74-7\"><a href=\"#cb74-7\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</span>\n<span id=\"cb74-8\"><a href=\"#cb74-8\"></a>                    <span class=\"bu\">len</span>(args))</span>\n<span id=\"cb74-9\"><a href=\"#cb74-9\"></a>            }</span>\n<span id=\"cb74-10\"><a href=\"#cb74-10\"></a></span>\n<span id=\"cb74-11\"><a href=\"#cb74-11\"></a>            <span class=\"kw\">switch</span> arg := args[<span class=\"dv\">0</span>].(<span class=\"kw\">type</span>) {</span>\n<span id=\"cb74-12\"><a href=\"#cb74-12\"></a>            <span class=\"kw\">case</span> *object.Array:</span>\n<span id=\"cb74-13\"><a href=\"#cb74-13\"></a>                <span class=\"kw\">return</span> &amp;object.Integer{Value: <span class=\"dt\">int64</span>(<span class=\"bu\">len</span>(arg.Elements))}</span>\n<span id=\"cb74-14\"><a href=\"#cb74-14\"></a>            <span class=\"kw\">case</span> *object.String:</span>\n<span id=\"cb74-15\"><a href=\"#cb74-15\"></a>                <span class=\"kw\">return</span> &amp;object.Integer{Value: <span class=\"dt\">int64</span>(<span class=\"bu\">len</span>(arg.Value))}</span>\n<span id=\"cb74-16\"><a href=\"#cb74-16\"></a>            <span class=\"kw\">default</span>:</span>\n<span id=\"cb74-17\"><a href=\"#cb74-17\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;argument to `len` not supported, got %s&quot;</span>,</span>\n<span id=\"cb74-18\"><a href=\"#cb74-18\"></a>                    args[<span class=\"dv\">0</span>].Type())</span>\n<span id=\"cb74-19\"><a href=\"#cb74-19\"></a>            }</span>\n<span id=\"cb74-20\"><a href=\"#cb74-20\"></a>        },</span>\n<span id=\"cb74-21\"><a href=\"#cb74-21\"></a>    },</span>\n<span id=\"cb74-22\"><a href=\"#cb74-22\"></a>}</span></code></pre></div>\n<p>The only change is the added <code>case</code> branch for <code>*object.Array</code>. And with that out of the way, we’re ready to start adding new functions. Yay!</p>\n<p>The first of these new built-in functions is <code>first</code>. <code>first</code> returns the first element of the given array. Yes, calling <code>myArray[0]</code> does the same thing. But <code>first</code> is arguably prettier. Here is its implementation:</p>\n<div class=\"sourceCode\" id=\"cb75\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb75-1\"><a href=\"#cb75-1\"></a><span class=\"co\">// evaluator/builtins.go</span></span>\n<span id=\"cb75-2\"><a href=\"#cb75-2\"></a></span>\n<span id=\"cb75-3\"><a href=\"#cb75-3\"></a><span class=\"kw\">var</span> builtins = <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]*object.Builtin{</span>\n<span id=\"cb75-4\"><a href=\"#cb75-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb75-5\"><a href=\"#cb75-5\"></a></span>\n<span id=\"cb75-6\"><a href=\"#cb75-6\"></a>    <span class=\"st\">&quot;first&quot;</span>: &amp;object.Builtin{</span>\n<span id=\"cb75-7\"><a href=\"#cb75-7\"></a>        Fn: <span class=\"kw\">func</span>(args ...object.Object) object.Object {</span>\n<span id=\"cb75-8\"><a href=\"#cb75-8\"></a>            <span class=\"kw\">if</span> <span class=\"bu\">len</span>(args) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb75-9\"><a href=\"#cb75-9\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</span>\n<span id=\"cb75-10\"><a href=\"#cb75-10\"></a>                    <span class=\"bu\">len</span>(args))</span>\n<span id=\"cb75-11\"><a href=\"#cb75-11\"></a>            }</span>\n<span id=\"cb75-12\"><a href=\"#cb75-12\"></a>            <span class=\"kw\">if</span> args[<span class=\"dv\">0</span>].Type() != object.ARRAY_OBJ {</span>\n<span id=\"cb75-13\"><a href=\"#cb75-13\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;argument to `first` must be ARRAY, got %s&quot;</span>,</span>\n<span id=\"cb75-14\"><a href=\"#cb75-14\"></a>                    args[<span class=\"dv\">0</span>].Type())</span>\n<span id=\"cb75-15\"><a href=\"#cb75-15\"></a>            }</span>\n<span id=\"cb75-16\"><a href=\"#cb75-16\"></a></span>\n<span id=\"cb75-17\"><a href=\"#cb75-17\"></a>            arr := args[<span class=\"dv\">0</span>].(*object.Array)</span>\n<span id=\"cb75-18\"><a href=\"#cb75-18\"></a>            <span class=\"kw\">if</span> <span class=\"bu\">len</span>(arr.Elements) &gt; <span class=\"dv\">0</span> {</span>\n<span id=\"cb75-19\"><a href=\"#cb75-19\"></a>                <span class=\"kw\">return</span> arr.Elements[<span class=\"dv\">0</span>]</span>\n<span id=\"cb75-20\"><a href=\"#cb75-20\"></a>            }</span>\n<span id=\"cb75-21\"><a href=\"#cb75-21\"></a></span>\n<span id=\"cb75-22\"><a href=\"#cb75-22\"></a>            <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb75-23\"><a href=\"#cb75-23\"></a>        },</span>\n<span id=\"cb75-24\"><a href=\"#cb75-24\"></a>    },</span>\n<span id=\"cb75-25\"><a href=\"#cb75-25\"></a>}</span></code></pre></div>\n<p>Great! That works! And what comes after <code>first</code>? You’re correct, the next function we’re going to add is called <code>last</code>.</p>\n<p>The purpose of <code>last</code> is to return the last element of the given array. In index operator terms it returns <code>myArray[len(myArray)-1]</code>. And as it turns out, implementing <code>last</code> is not much harder than implementing <code>first</code> - who would have thought that? Here it is:</p>\n<div class=\"sourceCode\" id=\"cb76\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb76-1\"><a href=\"#cb76-1\"></a><span class=\"co\">// evaluator/builtins.go</span></span>\n<span id=\"cb76-2\"><a href=\"#cb76-2\"></a></span>\n<span id=\"cb76-3\"><a href=\"#cb76-3\"></a><span class=\"kw\">var</span> builtins = <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]*object.Builtin{</span>\n<span id=\"cb76-4\"><a href=\"#cb76-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb76-5\"><a href=\"#cb76-5\"></a></span>\n<span id=\"cb76-6\"><a href=\"#cb76-6\"></a>    <span class=\"st\">&quot;last&quot;</span>: &amp;object.Builtin{</span>\n<span id=\"cb76-7\"><a href=\"#cb76-7\"></a>        Fn: <span class=\"kw\">func</span>(args ...object.Object) object.Object {</span>\n<span id=\"cb76-8\"><a href=\"#cb76-8\"></a>            <span class=\"kw\">if</span> <span class=\"bu\">len</span>(args) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb76-9\"><a href=\"#cb76-9\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</span>\n<span id=\"cb76-10\"><a href=\"#cb76-10\"></a>                    <span class=\"bu\">len</span>(args))</span>\n<span id=\"cb76-11\"><a href=\"#cb76-11\"></a>            }</span>\n<span id=\"cb76-12\"><a href=\"#cb76-12\"></a>            <span class=\"kw\">if</span> args[<span class=\"dv\">0</span>].Type() != object.ARRAY_OBJ {</span>\n<span id=\"cb76-13\"><a href=\"#cb76-13\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;argument to `last` must be ARRAY, got %s&quot;</span>,</span>\n<span id=\"cb76-14\"><a href=\"#cb76-14\"></a>                    args[<span class=\"dv\">0</span>].Type())</span>\n<span id=\"cb76-15\"><a href=\"#cb76-15\"></a>            }</span>\n<span id=\"cb76-16\"><a href=\"#cb76-16\"></a></span>\n<span id=\"cb76-17\"><a href=\"#cb76-17\"></a>            arr := args[<span class=\"dv\">0</span>].(*object.Array)</span>\n<span id=\"cb76-18\"><a href=\"#cb76-18\"></a>            length := <span class=\"bu\">len</span>(arr.Elements)</span>\n<span id=\"cb76-19\"><a href=\"#cb76-19\"></a>            <span class=\"kw\">if</span> length &gt; <span class=\"dv\">0</span> {</span>\n<span id=\"cb76-20\"><a href=\"#cb76-20\"></a>                <span class=\"kw\">return</span> arr.Elements[length<span class=\"dv\">-1</span>]</span>\n<span id=\"cb76-21\"><a href=\"#cb76-21\"></a>            }</span>\n<span id=\"cb76-22\"><a href=\"#cb76-22\"></a></span>\n<span id=\"cb76-23\"><a href=\"#cb76-23\"></a>            <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb76-24\"><a href=\"#cb76-24\"></a>        },</span>\n<span id=\"cb76-25\"><a href=\"#cb76-25\"></a>    },</span>\n<span id=\"cb76-26\"><a href=\"#cb76-26\"></a>}</span></code></pre></div>\n<p>The next function we’re going to add would be called <code>cdr</code> in Scheme. In some other languages it’s sometimes called <code>tail</code>. We’re going to call it <code>rest</code>. <code>rest</code> returns a new array containing all elements of the array passed as argument, <em>except the first one</em>. Here’s what using it looks like:</p>\n<div class=\"sourceCode\" id=\"cb77\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb77-1\"><a href=\"#cb77-1\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> a <span class=\"op\">=</span> [<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span>]<span class=\"op\">;</span></span>\n<span id=\"cb77-2\"><a href=\"#cb77-2\"></a><span class=\"op\">&gt;&gt;</span> rest(a)</span>\n<span id=\"cb77-3\"><a href=\"#cb77-3\"></a>[<span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span>]</span>\n<span id=\"cb77-4\"><a href=\"#cb77-4\"></a><span class=\"op\">&gt;&gt;</span> rest(rest(a))</span>\n<span id=\"cb77-5\"><a href=\"#cb77-5\"></a>[<span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span>]</span>\n<span id=\"cb77-6\"><a href=\"#cb77-6\"></a><span class=\"op\">&gt;&gt;</span> rest(rest(rest(a)))</span>\n<span id=\"cb77-7\"><a href=\"#cb77-7\"></a>[<span class=\"dv\">4</span>]</span>\n<span id=\"cb77-8\"><a href=\"#cb77-8\"></a><span class=\"op\">&gt;&gt;</span> rest(rest(rest(rest(a))))</span>\n<span id=\"cb77-9\"><a href=\"#cb77-9\"></a>[]</span>\n<span id=\"cb77-10\"><a href=\"#cb77-10\"></a><span class=\"op\">&gt;&gt;</span> rest(rest(rest(rest(rest(a)))))</span>\n<span id=\"cb77-11\"><a href=\"#cb77-11\"></a><span class=\"kw\">null</span></span></code></pre></div>\n<p>Its implementation is simple, but keep in mind that we’re returning a <em>newly allocated</em> array. We’re not modifying the array passed to <code>rest</code>:</p>\n<div class=\"sourceCode\" id=\"cb78\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb78-1\"><a href=\"#cb78-1\"></a><span class=\"co\">// evaluator/builtins.go</span></span>\n<span id=\"cb78-2\"><a href=\"#cb78-2\"></a></span>\n<span id=\"cb78-3\"><a href=\"#cb78-3\"></a><span class=\"kw\">var</span> builtins = <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]*object.Builtin{</span>\n<span id=\"cb78-4\"><a href=\"#cb78-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb78-5\"><a href=\"#cb78-5\"></a></span>\n<span id=\"cb78-6\"><a href=\"#cb78-6\"></a>    <span class=\"st\">&quot;rest&quot;</span>: &amp;object.Builtin{</span>\n<span id=\"cb78-7\"><a href=\"#cb78-7\"></a>        Fn: <span class=\"kw\">func</span>(args ...object.Object) object.Object {</span>\n<span id=\"cb78-8\"><a href=\"#cb78-8\"></a>            <span class=\"kw\">if</span> <span class=\"bu\">len</span>(args) != <span class=\"dv\">1</span> {</span>\n<span id=\"cb78-9\"><a href=\"#cb78-9\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</span>\n<span id=\"cb78-10\"><a href=\"#cb78-10\"></a>                    <span class=\"bu\">len</span>(args))</span>\n<span id=\"cb78-11\"><a href=\"#cb78-11\"></a>            }</span>\n<span id=\"cb78-12\"><a href=\"#cb78-12\"></a>            <span class=\"kw\">if</span> args[<span class=\"dv\">0</span>].Type() != object.ARRAY_OBJ {</span>\n<span id=\"cb78-13\"><a href=\"#cb78-13\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;argument to `rest` must be ARRAY, got %s&quot;</span>,</span>\n<span id=\"cb78-14\"><a href=\"#cb78-14\"></a>                    args[<span class=\"dv\">0</span>].Type())</span>\n<span id=\"cb78-15\"><a href=\"#cb78-15\"></a>            }</span>\n<span id=\"cb78-16\"><a href=\"#cb78-16\"></a></span>\n<span id=\"cb78-17\"><a href=\"#cb78-17\"></a>            arr := args[<span class=\"dv\">0</span>].(*object.Array)</span>\n<span id=\"cb78-18\"><a href=\"#cb78-18\"></a>            length := <span class=\"bu\">len</span>(arr.Elements)</span>\n<span id=\"cb78-19\"><a href=\"#cb78-19\"></a>            <span class=\"kw\">if</span> length &gt; <span class=\"dv\">0</span> {</span>\n<span id=\"cb78-20\"><a href=\"#cb78-20\"></a>                newElements := <span class=\"bu\">make</span>([]object.Object, length<span class=\"dv\">-1</span>, length<span class=\"dv\">-1</span>)</span>\n<span id=\"cb78-21\"><a href=\"#cb78-21\"></a>                <span class=\"bu\">copy</span>(newElements, arr.Elements[<span class=\"dv\">1</span>:length])</span>\n<span id=\"cb78-22\"><a href=\"#cb78-22\"></a>                <span class=\"kw\">return</span> &amp;object.Array{Elements: newElements}</span>\n<span id=\"cb78-23\"><a href=\"#cb78-23\"></a>            }</span>\n<span id=\"cb78-24\"><a href=\"#cb78-24\"></a></span>\n<span id=\"cb78-25\"><a href=\"#cb78-25\"></a>            <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb78-26\"><a href=\"#cb78-26\"></a>        },</span>\n<span id=\"cb78-27\"><a href=\"#cb78-27\"></a>    },</span>\n<span id=\"cb78-28\"><a href=\"#cb78-28\"></a>}</span></code></pre></div>\n<p>The last array function we’re going to build into our interpreter is called <code>push</code>. It adds a new element to the end of the array. But, and here’s the kicker, it doesn’t modify the given array. Instead it allocates a new array with the same elements as the old one plus the new, pushed element. Arrays are immutable in Monkey. Here is <code>push</code> in action:</p>\n<div class=\"sourceCode\" id=\"cb79\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb79-1\"><a href=\"#cb79-1\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> a <span class=\"op\">=</span> [<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span>]<span class=\"op\">;</span></span>\n<span id=\"cb79-2\"><a href=\"#cb79-2\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> b <span class=\"op\">=</span> push(a<span class=\"op\">,</span> <span class=\"dv\">5</span>)<span class=\"op\">;</span></span>\n<span id=\"cb79-3\"><a href=\"#cb79-3\"></a><span class=\"op\">&gt;&gt;</span> a</span>\n<span id=\"cb79-4\"><a href=\"#cb79-4\"></a>[<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span>]</span>\n<span id=\"cb79-5\"><a href=\"#cb79-5\"></a><span class=\"op\">&gt;&gt;</span> b</span>\n<span id=\"cb79-6\"><a href=\"#cb79-6\"></a>[<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span><span class=\"op\">,</span> <span class=\"dv\">5</span>]</span></code></pre></div>\n<p>And here is its implementation:</p>\n<div class=\"sourceCode\" id=\"cb80\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb80-1\"><a href=\"#cb80-1\"></a><span class=\"co\">// evaluator/builtins.go</span></span>\n<span id=\"cb80-2\"><a href=\"#cb80-2\"></a></span>\n<span id=\"cb80-3\"><a href=\"#cb80-3\"></a><span class=\"kw\">var</span> builtins = <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]*object.Builtin{</span>\n<span id=\"cb80-4\"><a href=\"#cb80-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb80-5\"><a href=\"#cb80-5\"></a></span>\n<span id=\"cb80-6\"><a href=\"#cb80-6\"></a>    <span class=\"st\">&quot;push&quot;</span>: &amp;object.Builtin{</span>\n<span id=\"cb80-7\"><a href=\"#cb80-7\"></a>        Fn: <span class=\"kw\">func</span>(args ...object.Object) object.Object {</span>\n<span id=\"cb80-8\"><a href=\"#cb80-8\"></a>            <span class=\"kw\">if</span> <span class=\"bu\">len</span>(args) != <span class=\"dv\">2</span> {</span>\n<span id=\"cb80-9\"><a href=\"#cb80-9\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;wrong number of arguments. got=%d, want=2&quot;</span>,</span>\n<span id=\"cb80-10\"><a href=\"#cb80-10\"></a>                    <span class=\"bu\">len</span>(args))</span>\n<span id=\"cb80-11\"><a href=\"#cb80-11\"></a>            }</span>\n<span id=\"cb80-12\"><a href=\"#cb80-12\"></a>            <span class=\"kw\">if</span> args[<span class=\"dv\">0</span>].Type() != object.ARRAY_OBJ {</span>\n<span id=\"cb80-13\"><a href=\"#cb80-13\"></a>                <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;argument to `push` must be ARRAY, got %s&quot;</span>,</span>\n<span id=\"cb80-14\"><a href=\"#cb80-14\"></a>                    args[<span class=\"dv\">0</span>].Type())</span>\n<span id=\"cb80-15\"><a href=\"#cb80-15\"></a>            }</span>\n<span id=\"cb80-16\"><a href=\"#cb80-16\"></a></span>\n<span id=\"cb80-17\"><a href=\"#cb80-17\"></a>            arr := args[<span class=\"dv\">0</span>].(*object.Array)</span>\n<span id=\"cb80-18\"><a href=\"#cb80-18\"></a>            length := <span class=\"bu\">len</span>(arr.Elements)</span>\n<span id=\"cb80-19\"><a href=\"#cb80-19\"></a></span>\n<span id=\"cb80-20\"><a href=\"#cb80-20\"></a>            newElements := <span class=\"bu\">make</span>([]object.Object, length+<span class=\"dv\">1</span>, length+<span class=\"dv\">1</span>)</span>\n<span id=\"cb80-21\"><a href=\"#cb80-21\"></a>            <span class=\"bu\">copy</span>(newElements, arr.Elements)</span>\n<span id=\"cb80-22\"><a href=\"#cb80-22\"></a>            newElements[length] = args[<span class=\"dv\">1</span>]</span>\n<span id=\"cb80-23\"><a href=\"#cb80-23\"></a></span>\n<span id=\"cb80-24\"><a href=\"#cb80-24\"></a>            <span class=\"kw\">return</span> &amp;object.Array{Elements: newElements}</span>\n<span id=\"cb80-25\"><a href=\"#cb80-25\"></a>        },</span>\n<span id=\"cb80-26\"><a href=\"#cb80-26\"></a>    },</span>\n<span id=\"cb80-27\"><a href=\"#cb80-27\"></a>}</span></code></pre></div>\n</section>\n<section id=\"test-driving-arrays\" class=\"level3\" data-number=\"4.4.7\">\n<h3 data-number=\"4.4.7\">Test-Driving Arrays</h3>\n<p>We now have array literals, the index operator and a few built-in functions to work with arrays. It’s time to take them for a spin. Let’s see what they can do.</p>\n<p>With <code>first</code>, <code>rest</code> and <code>push</code> we can build a <code>map</code> function:</p>\n<div class=\"sourceCode\" id=\"cb81\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb81-1\"><a href=\"#cb81-1\"></a><span class=\"kw\">let</span> map <span class=\"op\">=</span> fn(arr<span class=\"op\">,</span> f) {</span>\n<span id=\"cb81-2\"><a href=\"#cb81-2\"></a>  <span class=\"kw\">let</span> iter <span class=\"op\">=</span> fn(arr<span class=\"op\">,</span> accumulated) {</span>\n<span id=\"cb81-3\"><a href=\"#cb81-3\"></a>    <span class=\"cf\">if</span> (len(arr) <span class=\"op\">==</span> <span class=\"dv\">0</span>) {</span>\n<span id=\"cb81-4\"><a href=\"#cb81-4\"></a>      accumulated</span>\n<span id=\"cb81-5\"><a href=\"#cb81-5\"></a>    } <span class=\"cf\">else</span> {</span>\n<span id=\"cb81-6\"><a href=\"#cb81-6\"></a>      iter(rest(arr)<span class=\"op\">,</span> push(accumulated<span class=\"op\">,</span> f(first(arr))))<span class=\"op\">;</span></span>\n<span id=\"cb81-7\"><a href=\"#cb81-7\"></a>    }</span>\n<span id=\"cb81-8\"><a href=\"#cb81-8\"></a>  }<span class=\"op\">;</span></span>\n<span id=\"cb81-9\"><a href=\"#cb81-9\"></a></span>\n<span id=\"cb81-10\"><a href=\"#cb81-10\"></a>  iter(arr<span class=\"op\">,</span> [])<span class=\"op\">;</span></span>\n<span id=\"cb81-11\"><a href=\"#cb81-11\"></a>}<span class=\"op\">;</span></span></code></pre></div>\n<p>And with <code>map</code> we can do things like this:</p>\n<div class=\"sourceCode\" id=\"cb82\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb82-1\"><a href=\"#cb82-1\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> a <span class=\"op\">=</span> [<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span>]<span class=\"op\">;</span></span>\n<span id=\"cb82-2\"><a href=\"#cb82-2\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> double <span class=\"op\">=</span> fn(x) { x <span class=\"op\">*</span> <span class=\"dv\">2</span> }<span class=\"op\">;</span></span>\n<span id=\"cb82-3\"><a href=\"#cb82-3\"></a><span class=\"op\">&gt;&gt;</span> map(a<span class=\"op\">,</span> double)<span class=\"op\">;</span></span>\n<span id=\"cb82-4\"><a href=\"#cb82-4\"></a>[<span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">4</span><span class=\"op\">,</span> <span class=\"dv\">6</span><span class=\"op\">,</span> <span class=\"dv\">8</span>]</span></code></pre></div>\n<p>Isn’t this amazing? There’s more! Based on the same built-in functions we can also define a <code>reduce</code> function:</p>\n<div class=\"sourceCode\" id=\"cb83\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb83-1\"><a href=\"#cb83-1\"></a><span class=\"kw\">let</span> reduce <span class=\"op\">=</span> fn(arr<span class=\"op\">,</span> initial<span class=\"op\">,</span> f) {</span>\n<span id=\"cb83-2\"><a href=\"#cb83-2\"></a>  <span class=\"kw\">let</span> iter <span class=\"op\">=</span> fn(arr<span class=\"op\">,</span> result) {</span>\n<span id=\"cb83-3\"><a href=\"#cb83-3\"></a>    <span class=\"cf\">if</span> (len(arr) <span class=\"op\">==</span> <span class=\"dv\">0</span>) {</span>\n<span id=\"cb83-4\"><a href=\"#cb83-4\"></a>      result</span>\n<span id=\"cb83-5\"><a href=\"#cb83-5\"></a>    } <span class=\"cf\">else</span> {</span>\n<span id=\"cb83-6\"><a href=\"#cb83-6\"></a>      iter(rest(arr)<span class=\"op\">,</span> f(result<span class=\"op\">,</span> first(arr)))<span class=\"op\">;</span></span>\n<span id=\"cb83-7\"><a href=\"#cb83-7\"></a>    }</span>\n<span id=\"cb83-8\"><a href=\"#cb83-8\"></a>  }<span class=\"op\">;</span></span>\n<span id=\"cb83-9\"><a href=\"#cb83-9\"></a></span>\n<span id=\"cb83-10\"><a href=\"#cb83-10\"></a>  iter(arr<span class=\"op\">,</span> initial)<span class=\"op\">;</span></span>\n<span id=\"cb83-11\"><a href=\"#cb83-11\"></a>}<span class=\"op\">;</span></span></code></pre></div>\n<p>And <code>reduce</code>, in turn, can be used to define a <code>sum</code> function:</p>\n<div class=\"sourceCode\" id=\"cb84\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb84-1\"><a href=\"#cb84-1\"></a><span class=\"kw\">let</span> sum <span class=\"op\">=</span> fn(arr) {</span>\n<span id=\"cb84-2\"><a href=\"#cb84-2\"></a>  reduce(arr<span class=\"op\">,</span> <span class=\"dv\">0</span><span class=\"op\">,</span> fn(initial<span class=\"op\">,</span> el) { initial <span class=\"op\">+</span> el })<span class=\"op\">;</span></span>\n<span id=\"cb84-3\"><a href=\"#cb84-3\"></a>}<span class=\"op\">;</span></span></code></pre></div>\n<p>And it works like a charm:</p>\n<div class=\"sourceCode\" id=\"cb85\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb85-1\"><a href=\"#cb85-1\"></a><span class=\"op\">&gt;&gt;</span> sum([<span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">,</span> <span class=\"dv\">4</span><span class=\"op\">,</span> <span class=\"dv\">5</span>])<span class=\"op\">;</span></span>\n<span id=\"cb85-2\"><a href=\"#cb85-2\"></a><span class=\"dv\">15</span></span></code></pre></div>\n<p>As you probably know, I’m not a fan of patting oneself on the back, but let me just say this: holy monkey! Look at what our interpreter can do! A <code>map</code> function?! <code>reduce</code>?! We’ve come a long, long way!</p>\n<p>And that’s not even all of it! There’s a lot more we can do now and I urge you to explore the possibilities the array data type and the few built-in functions give us. But you know what you should do first? Take some time off, brag about this to your friends and family, enjoy the praise and compliments. And when you come back, we’ll add another data type.</p>\n</section>\n</section>\n<section id=\"hashes\" class=\"level2\" data-number=\"4.5\">\n<h2 data-number=\"4.5\">4.5 - Hashes</h2>\n<p>The next data type we’re going to add is called “hash”. A hash in Monkey is what’s sometimes called hash, map, hash map or dictionary in other programming languages. It maps keys to values.</p>\n<p>In order to construct a hash in Monkey one uses the hash literal: a comma-separated list of key-value pairs that’s enclosed by curly braces. Each key-value pair uses a colon to differentiate between the key and the value. Here is what using a hash literal looks like:</p>\n<div class=\"sourceCode\" id=\"cb86\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb86-1\"><a href=\"#cb86-1\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> myHash <span class=\"op\">=</span> {<span class=\"st\">&quot;name&quot;</span><span class=\"op\">:</span> <span class=\"st\">&quot;Jimmy&quot;</span><span class=\"op\">,</span> <span class=\"st\">&quot;age&quot;</span><span class=\"op\">:</span> <span class=\"dv\">72</span><span class=\"op\">,</span> <span class=\"st\">&quot;band&quot;</span><span class=\"op\">:</span> <span class=\"st\">&quot;Led Zeppelin&quot;</span>}<span class=\"op\">;</span></span>\n<span id=\"cb86-2\"><a href=\"#cb86-2\"></a><span class=\"op\">&gt;&gt;</span> myHash[<span class=\"st\">&quot;name&quot;</span>]</span>\n<span id=\"cb86-3\"><a href=\"#cb86-3\"></a>Jimmy</span>\n<span id=\"cb86-4\"><a href=\"#cb86-4\"></a><span class=\"op\">&gt;&gt;</span> myHash[<span class=\"st\">&quot;age&quot;</span>]</span>\n<span id=\"cb86-5\"><a href=\"#cb86-5\"></a><span class=\"dv\">72</span></span>\n<span id=\"cb86-6\"><a href=\"#cb86-6\"></a><span class=\"op\">&gt;&gt;</span> myHash[<span class=\"st\">&quot;band&quot;</span>]</span>\n<span id=\"cb86-7\"><a href=\"#cb86-7\"></a>Led Zeppelin</span></code></pre></div>\n<p>In this example <code>myHash</code> contains three key-value pairs. The keys are all strings. And, as you can see, we can use index operator expressions to get values out of the hash again, just like we can with arrays. Except that in this example the index values are strings, which don’t work with arrays. And that’s not even the only data type that’s usable as a hash key:</p>\n<div class=\"sourceCode\" id=\"cb87\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb87-1\"><a href=\"#cb87-1\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> myHash <span class=\"op\">=</span> {<span class=\"dt\">true</span><span class=\"op\">:</span> <span class=\"st\">&quot;yes, a boolean&quot;</span><span class=\"op\">,</span> <span class=\"dv\">99</span><span class=\"op\">:</span> <span class=\"st\">&quot;correct, an integer&quot;</span>}<span class=\"op\">;</span></span>\n<span id=\"cb87-2\"><a href=\"#cb87-2\"></a><span class=\"op\">&gt;&gt;</span> myHash[<span class=\"kw\">true</span>]</span>\n<span id=\"cb87-3\"><a href=\"#cb87-3\"></a>yes<span class=\"op\">,</span> a boolean</span>\n<span id=\"cb87-4\"><a href=\"#cb87-4\"></a><span class=\"op\">&gt;&gt;</span> myHash[<span class=\"dv\">99</span>]</span>\n<span id=\"cb87-5\"><a href=\"#cb87-5\"></a>correct<span class=\"op\">,</span> an integer</span></code></pre></div>\n<p>That’s also valid. In fact, besides string, integer and boolean literals we can use any expression as index in index operator expressions:</p>\n<div class=\"sourceCode\" id=\"cb88\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb88-1\"><a href=\"#cb88-1\"></a><span class=\"op\">&gt;&gt;</span> myHash[<span class=\"dv\">5</span> <span class=\"op\">&gt;</span> <span class=\"dv\">1</span>]</span>\n<span id=\"cb88-2\"><a href=\"#cb88-2\"></a>yes<span class=\"op\">,</span> a boolean</span>\n<span id=\"cb88-3\"><a href=\"#cb88-3\"></a><span class=\"op\">&gt;&gt;</span> myHash[<span class=\"dv\">100</span> <span class=\"op\">-</span> <span class=\"dv\">1</span>]</span>\n<span id=\"cb88-4\"><a href=\"#cb88-4\"></a>correct<span class=\"op\">,</span> an integer</span></code></pre></div>\n<p>As long as these expressions evaluate to either strings, integers or booleans they are usable as hash keys. Here <code>5 &gt; 1</code> evaluates to <code>true</code> and <code>100 - 1</code> evaluates to <code>99</code>, both of which are valid and mapped to values in <code>myHash</code>.</p>\n<p>Rather unsurprisingly our implementation will use Go’s <code>map</code> as the underlying data structure for Monkey hashes. But since we want to use strings, integers and booleans interchangeably as keys, we need to build something on top of plain old <code>map</code> to make it work. We’ll come to that when we extend our object system. But first we have to turn hash literals into tokens.</p>\n<section id=\"lexing-hash-literals\" class=\"level3\" data-number=\"4.5.1\">\n<h3 data-number=\"4.5.1\">Lexing Hash Literals</h3>\n<p>How do we turn hash literals into tokens? Which tokens do we need to recognize and output in our lexer so that we can later work with them in the parser? Here is the hash literal from above again:</p>\n<div class=\"sourceCode\" id=\"cb89\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb89-1\"><a href=\"#cb89-1\"></a>{<span class=\"st\">&quot;name&quot;</span><span class=\"op\">:</span> <span class=\"st\">&quot;Jimmy&quot;</span><span class=\"op\">,</span> <span class=\"st\">&quot;age&quot;</span><span class=\"op\">:</span> <span class=\"dv\">72</span><span class=\"op\">,</span> <span class=\"st\">&quot;band&quot;</span><span class=\"op\">:</span> <span class=\"st\">&quot;Led Zeppelin&quot;</span>}</span></code></pre></div>\n<p>Besides the string and integer literals there are four characters in use here that are important: <code>{</code>, <code>}</code>, <code>,</code> and <code>:</code>. We already know how to lex the first three. Our lexer turns these into <code>token.LBRACE</code>, <code>token.RBRACE</code> and <code>token.COMMA</code> respectively. That means, all that’s left for us to do in this section is to turn <code>:</code> into a token.</p>\n<p>And for that we first need to define the necessary token type in the <code>token</code> package:</p>\n<div class=\"sourceCode\" id=\"cb90\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb90-1\"><a href=\"#cb90-1\"></a><span class=\"co\">// token/token.go</span></span>\n<span id=\"cb90-2\"><a href=\"#cb90-2\"></a></span>\n<span id=\"cb90-3\"><a href=\"#cb90-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb90-4\"><a href=\"#cb90-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb90-5\"><a href=\"#cb90-5\"></a>    COLON = <span class=\"st\">&quot;:&quot;</span></span>\n<span id=\"cb90-6\"><a href=\"#cb90-6\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb90-7\"><a href=\"#cb90-7\"></a>)</span></code></pre></div>\n<p>Next we’re going to add a new test for the <code>NextToken</code> method of <code>Lexer</code> that expects a <code>token.COLON</code>:</p>\n<div class=\"sourceCode\" id=\"cb91\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb91-1\"><a href=\"#cb91-1\"></a><span class=\"co\">// lexer/lexer_test.go</span></span>\n<span id=\"cb91-2\"><a href=\"#cb91-2\"></a></span>\n<span id=\"cb91-3\"><a href=\"#cb91-3\"></a><span class=\"kw\">func</span> TestNextToken(t *testing.T) {</span>\n<span id=\"cb91-4\"><a href=\"#cb91-4\"></a>    input := <span class=\"st\">`let five = 5;</span></span>\n<span id=\"cb91-5\"><a href=\"#cb91-5\"></a><span class=\"st\">let ten = 10;</span></span>\n<span id=\"cb91-6\"><a href=\"#cb91-6\"></a></span>\n<span id=\"cb91-7\"><a href=\"#cb91-7\"></a><span class=\"st\">let add = fn(x, y) {</span></span>\n<span id=\"cb91-8\"><a href=\"#cb91-8\"></a><span class=\"st\">  x + y;</span></span>\n<span id=\"cb91-9\"><a href=\"#cb91-9\"></a><span class=\"st\">};</span></span>\n<span id=\"cb91-10\"><a href=\"#cb91-10\"></a></span>\n<span id=\"cb91-11\"><a href=\"#cb91-11\"></a><span class=\"st\">let result = add(five, ten);</span></span>\n<span id=\"cb91-12\"><a href=\"#cb91-12\"></a><span class=\"st\">!-/*5;</span></span>\n<span id=\"cb91-13\"><a href=\"#cb91-13\"></a><span class=\"st\">5 &lt; 10 &gt; 5;</span></span>\n<span id=\"cb91-14\"><a href=\"#cb91-14\"></a></span>\n<span id=\"cb91-15\"><a href=\"#cb91-15\"></a><span class=\"st\">if (5 &lt; 10) {</span></span>\n<span id=\"cb91-16\"><a href=\"#cb91-16\"></a><span class=\"st\">    return true;</span></span>\n<span id=\"cb91-17\"><a href=\"#cb91-17\"></a><span class=\"st\">} else {</span></span>\n<span id=\"cb91-18\"><a href=\"#cb91-18\"></a><span class=\"st\">    return false;</span></span>\n<span id=\"cb91-19\"><a href=\"#cb91-19\"></a><span class=\"st\">}</span></span>\n<span id=\"cb91-20\"><a href=\"#cb91-20\"></a></span>\n<span id=\"cb91-21\"><a href=\"#cb91-21\"></a><span class=\"st\">10 == 10;</span></span>\n<span id=\"cb91-22\"><a href=\"#cb91-22\"></a><span class=\"st\">10 != 9;</span></span>\n<span id=\"cb91-23\"><a href=\"#cb91-23\"></a><span class=\"st\">&quot;foobar&quot;</span></span>\n<span id=\"cb91-24\"><a href=\"#cb91-24\"></a><span class=\"st\">&quot;foo bar&quot;</span></span>\n<span id=\"cb91-25\"><a href=\"#cb91-25\"></a><span class=\"st\">[1, 2];</span></span>\n<span id=\"cb91-26\"><a href=\"#cb91-26\"></a><span class=\"st\">{&quot;foo&quot;: &quot;bar&quot;}</span></span>\n<span id=\"cb91-27\"><a href=\"#cb91-27\"></a><span class=\"st\">`</span></span>\n<span id=\"cb91-28\"><a href=\"#cb91-28\"></a></span>\n<span id=\"cb91-29\"><a href=\"#cb91-29\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb91-30\"><a href=\"#cb91-30\"></a>        expectedType    token.TokenType</span>\n<span id=\"cb91-31\"><a href=\"#cb91-31\"></a>        expectedLiteral <span class=\"dt\">string</span></span>\n<span id=\"cb91-32\"><a href=\"#cb91-32\"></a>    }{</span>\n<span id=\"cb91-33\"><a href=\"#cb91-33\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb91-34\"><a href=\"#cb91-34\"></a>        {token.LBRACE, <span class=\"st\">&quot;{&quot;</span>},</span>\n<span id=\"cb91-35\"><a href=\"#cb91-35\"></a>        {token.STRING, <span class=\"st\">&quot;foo&quot;</span>},</span>\n<span id=\"cb91-36\"><a href=\"#cb91-36\"></a>        {token.COLON, <span class=\"st\">&quot;:&quot;</span>},</span>\n<span id=\"cb91-37\"><a href=\"#cb91-37\"></a>        {token.STRING, <span class=\"st\">&quot;bar&quot;</span>},</span>\n<span id=\"cb91-38\"><a href=\"#cb91-38\"></a>        {token.RBRACE, <span class=\"st\">&quot;}&quot;</span>},</span>\n<span id=\"cb91-39\"><a href=\"#cb91-39\"></a>        {token.EOF, <span class=\"st\">&quot;&quot;</span>},</span>\n<span id=\"cb91-40\"><a href=\"#cb91-40\"></a>    }</span>\n<span id=\"cb91-41\"><a href=\"#cb91-41\"></a></span>\n<span id=\"cb91-42\"><a href=\"#cb91-42\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb91-43\"><a href=\"#cb91-43\"></a>}</span></code></pre></div>\n<p>We could get away with adding a single <code>:</code> to the test input, but using a hash literal as we did here provides a little more context when later reading and eventually debugging the test.</p>\n<p>Turning <code>:</code> into <code>token.COLON</code> is as easy as it gets:</p>\n<div class=\"sourceCode\" id=\"cb92\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb92-1\"><a href=\"#cb92-1\"></a><span class=\"co\">// lexer/lexer.go</span></span>\n<span id=\"cb92-2\"><a href=\"#cb92-2\"></a></span>\n<span id=\"cb92-3\"><a href=\"#cb92-3\"></a><span class=\"kw\">func</span> (l *Lexer) NextToken() token.Token {</span>\n<span id=\"cb92-4\"><a href=\"#cb92-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb92-5\"><a href=\"#cb92-5\"></a>    <span class=\"kw\">case</span> <span class=\"ch\">&#39;:&#39;</span>:</span>\n<span id=\"cb92-6\"><a href=\"#cb92-6\"></a>        tok = newToken(token.COLON, l.ch)</span>\n<span id=\"cb92-7\"><a href=\"#cb92-7\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb92-8\"><a href=\"#cb92-8\"></a>}</span></code></pre></div>\n<p>Only two new lines and the lexer now spits out <code>token.COLON</code>:</p>\n<div class=\"sourceCode\" id=\"cb93\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb93-1\"><a href=\"#cb93-1\"></a>$ go test ./lexer</span>\n<span id=\"cb93-2\"><a href=\"#cb93-2\"></a>ok      monkey/lexer    0.006s</span></code></pre></div>\n<p>Boom! The lexer now returns <code>token.LBRACE</code>, <code>token.RBRACE</code>, <code>token.COMMA</code> and the new <code>token.COLON</code>. That’s all we need in order to parse to hash literals.</p>\n</section>\n<section id=\"parsing-hash-literals\" class=\"level3\" data-number=\"4.5.2\">\n<h3 data-number=\"4.5.2\">Parsing Hash Literals</h3>\n<p>Before we start working on our parser or even writing a test, let’s look at the basic syntactic structure of a hash literal:</p>\n<div class=\"sourceCode\" id=\"cb94\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb94-1\"><a href=\"#cb94-1\"></a>{&lt;expression&gt; : &lt;expression&gt;, &lt;expression&gt; : &lt;expression&gt;, ... }</span></code></pre></div>\n<p>It’s a comma-separated list of pairs. Each pair consists of two expressions. One produces the hash key and one produces the value. The key is separated from the value with a colon. The list is enclosed by a pair of curly braces.</p>\n<p>When we turn this into an AST node, we have to keep track of the key-value pairs. Now how would we do that? We’ll use a <code>map</code>, yes, but of what type are the keys and the values in this <code>map</code>?</p>\n<p>We said earlier that the only admissible data types for hash keys are strings, integers and booleans. But we can’t enforce that in the parser. Instead we’ll have to validate hash key types in the evaluation stage and generate possible errors there.</p>\n<p>That’s because a lot of different expressions can produce strings, integers or booleans. Not just their literal forms. Enforcing the data type of hash keys in the parsing stage would prevent us from doing something like this:</p>\n<div class=\"sourceCode\" id=\"cb95\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb95-1\"><a href=\"#cb95-1\"></a><span class=\"kw\">let</span> key <span class=\"op\">=</span> <span class=\"st\">&quot;name&quot;</span><span class=\"op\">;</span></span>\n<span id=\"cb95-2\"><a href=\"#cb95-2\"></a><span class=\"kw\">let</span> hash <span class=\"op\">=</span> {<span class=\"dt\">key</span><span class=\"op\">:</span> <span class=\"st\">&quot;Monkey&quot;</span>}<span class=\"op\">;</span></span></code></pre></div>\n<p>Here <code>key</code> evaluates to <code>\"name\"</code> and is thus totally valid as a hash key, even though it’s an identifier. In order to allow this, we need to allow any expression as a key and any expression as a value in a hash literal. At least in the parsing stage. Following that our <code>ast.HashLiteral</code> definition looks like this:</p>\n<div class=\"sourceCode\" id=\"cb96\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb96-1\"><a href=\"#cb96-1\"></a><span class=\"co\">// ast/ast.go</span></span>\n<span id=\"cb96-2\"><a href=\"#cb96-2\"></a></span>\n<span id=\"cb96-3\"><a href=\"#cb96-3\"></a><span class=\"kw\">type</span> HashLiteral <span class=\"kw\">struct</span> {</span>\n<span id=\"cb96-4\"><a href=\"#cb96-4\"></a>    Token token.Token <span class=\"co\">// the &#39;{&#39; token</span></span>\n<span id=\"cb96-5\"><a href=\"#cb96-5\"></a>    Pairs <span class=\"kw\">map</span>[Expression]Expression</span>\n<span id=\"cb96-6\"><a href=\"#cb96-6\"></a>}</span>\n<span id=\"cb96-7\"><a href=\"#cb96-7\"></a></span>\n<span id=\"cb96-8\"><a href=\"#cb96-8\"></a><span class=\"kw\">func</span> (hl *HashLiteral) expressionNode()      {}</span>\n<span id=\"cb96-9\"><a href=\"#cb96-9\"></a><span class=\"kw\">func</span> (hl *HashLiteral) TokenLiteral() <span class=\"dt\">string</span> { <span class=\"kw\">return</span> hl.Token.Literal }</span>\n<span id=\"cb96-10\"><a href=\"#cb96-10\"></a><span class=\"kw\">func</span> (hl *HashLiteral) String() <span class=\"dt\">string</span> {</span>\n<span id=\"cb96-11\"><a href=\"#cb96-11\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb96-12\"><a href=\"#cb96-12\"></a></span>\n<span id=\"cb96-13\"><a href=\"#cb96-13\"></a>    pairs := []<span class=\"dt\">string</span>{}</span>\n<span id=\"cb96-14\"><a href=\"#cb96-14\"></a>    <span class=\"kw\">for</span> key, value := <span class=\"kw\">range</span> hl.Pairs {</span>\n<span id=\"cb96-15\"><a href=\"#cb96-15\"></a>        pairs = <span class=\"bu\">append</span>(pairs, key.String()+<span class=\"st\">&quot;:&quot;</span>+value.String())</span>\n<span id=\"cb96-16\"><a href=\"#cb96-16\"></a>    }</span>\n<span id=\"cb96-17\"><a href=\"#cb96-17\"></a></span>\n<span id=\"cb96-18\"><a href=\"#cb96-18\"></a>    out.WriteString(<span class=\"st\">&quot;{&quot;</span>)</span>\n<span id=\"cb96-19\"><a href=\"#cb96-19\"></a>    out.WriteString(strings.Join(pairs, <span class=\"st\">&quot;, &quot;</span>))</span>\n<span id=\"cb96-20\"><a href=\"#cb96-20\"></a>    out.WriteString(<span class=\"st\">&quot;}&quot;</span>)</span>\n<span id=\"cb96-21\"><a href=\"#cb96-21\"></a></span>\n<span id=\"cb96-22\"><a href=\"#cb96-22\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb96-23\"><a href=\"#cb96-23\"></a>}</span></code></pre></div>\n<p>Now that we’re clear about the structure of hash literals and have <code>ast.HashLiteral</code> defined, we can write tests for our parser:</p>\n<div class=\"sourceCode\" id=\"cb97\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb97-1\"><a href=\"#cb97-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb97-2\"><a href=\"#cb97-2\"></a></span>\n<span id=\"cb97-3\"><a href=\"#cb97-3\"></a><span class=\"kw\">func</span> TestParsingHashLiteralsStringKeys(t *testing.T) {</span>\n<span id=\"cb97-4\"><a href=\"#cb97-4\"></a>    input := <span class=\"st\">`{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}`</span></span>\n<span id=\"cb97-5\"><a href=\"#cb97-5\"></a></span>\n<span id=\"cb97-6\"><a href=\"#cb97-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb97-7\"><a href=\"#cb97-7\"></a>    p := New(l)</span>\n<span id=\"cb97-8\"><a href=\"#cb97-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb97-9\"><a href=\"#cb97-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb97-10\"><a href=\"#cb97-10\"></a></span>\n<span id=\"cb97-11\"><a href=\"#cb97-11\"></a>    stmt := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb97-12\"><a href=\"#cb97-12\"></a>    hash, ok := stmt.Expression.(*ast.HashLiteral)</span>\n<span id=\"cb97-13\"><a href=\"#cb97-13\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb97-14\"><a href=\"#cb97-14\"></a>        t.Fatalf(<span class=\"st\">&quot;exp is not ast.HashLiteral. got=%T&quot;</span>, stmt.Expression)</span>\n<span id=\"cb97-15\"><a href=\"#cb97-15\"></a>    }</span>\n<span id=\"cb97-16\"><a href=\"#cb97-16\"></a></span>\n<span id=\"cb97-17\"><a href=\"#cb97-17\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(hash.Pairs) != <span class=\"dv\">3</span> {</span>\n<span id=\"cb97-18\"><a href=\"#cb97-18\"></a>        t.Errorf(<span class=\"st\">&quot;hash.Pairs has wrong length. got=%d&quot;</span>, <span class=\"bu\">len</span>(hash.Pairs))</span>\n<span id=\"cb97-19\"><a href=\"#cb97-19\"></a>    }</span>\n<span id=\"cb97-20\"><a href=\"#cb97-20\"></a></span>\n<span id=\"cb97-21\"><a href=\"#cb97-21\"></a>    expected := <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]<span class=\"dt\">int64</span>{</span>\n<span id=\"cb97-22\"><a href=\"#cb97-22\"></a>        <span class=\"st\">&quot;one&quot;</span>:   <span class=\"dv\">1</span>,</span>\n<span id=\"cb97-23\"><a href=\"#cb97-23\"></a>        <span class=\"st\">&quot;two&quot;</span>:   <span class=\"dv\">2</span>,</span>\n<span id=\"cb97-24\"><a href=\"#cb97-24\"></a>        <span class=\"st\">&quot;three&quot;</span>: <span class=\"dv\">3</span>,</span>\n<span id=\"cb97-25\"><a href=\"#cb97-25\"></a>    }</span>\n<span id=\"cb97-26\"><a href=\"#cb97-26\"></a></span>\n<span id=\"cb97-27\"><a href=\"#cb97-27\"></a>    <span class=\"kw\">for</span> key, value := <span class=\"kw\">range</span> hash.Pairs {</span>\n<span id=\"cb97-28\"><a href=\"#cb97-28\"></a>        literal, ok := key.(*ast.StringLiteral)</span>\n<span id=\"cb97-29\"><a href=\"#cb97-29\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb97-30\"><a href=\"#cb97-30\"></a>            t.Errorf(<span class=\"st\">&quot;key is not ast.StringLiteral. got=%T&quot;</span>, key)</span>\n<span id=\"cb97-31\"><a href=\"#cb97-31\"></a>        }</span>\n<span id=\"cb97-32\"><a href=\"#cb97-32\"></a></span>\n<span id=\"cb97-33\"><a href=\"#cb97-33\"></a>        expectedValue := expected[literal.String()]</span>\n<span id=\"cb97-34\"><a href=\"#cb97-34\"></a></span>\n<span id=\"cb97-35\"><a href=\"#cb97-35\"></a>        testIntegerLiteral(t, value, expectedValue)</span>\n<span id=\"cb97-36\"><a href=\"#cb97-36\"></a>    }</span>\n<span id=\"cb97-37\"><a href=\"#cb97-37\"></a>}</span></code></pre></div>\n<p>And of course, we also have to be sure that we parse an empty hash literal correctly, because such edge-cases are the root of all hair loss in programming:</p>\n<div class=\"sourceCode\" id=\"cb98\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb98-1\"><a href=\"#cb98-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb98-2\"><a href=\"#cb98-2\"></a></span>\n<span id=\"cb98-3\"><a href=\"#cb98-3\"></a><span class=\"kw\">func</span> TestParsingEmptyHashLiteral(t *testing.T) {</span>\n<span id=\"cb98-4\"><a href=\"#cb98-4\"></a>    input := <span class=\"st\">&quot;{}&quot;</span></span>\n<span id=\"cb98-5\"><a href=\"#cb98-5\"></a></span>\n<span id=\"cb98-6\"><a href=\"#cb98-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb98-7\"><a href=\"#cb98-7\"></a>    p := New(l)</span>\n<span id=\"cb98-8\"><a href=\"#cb98-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb98-9\"><a href=\"#cb98-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb98-10\"><a href=\"#cb98-10\"></a></span>\n<span id=\"cb98-11\"><a href=\"#cb98-11\"></a>    stmt := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb98-12\"><a href=\"#cb98-12\"></a>    hash, ok := stmt.Expression.(*ast.HashLiteral)</span>\n<span id=\"cb98-13\"><a href=\"#cb98-13\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb98-14\"><a href=\"#cb98-14\"></a>        t.Fatalf(<span class=\"st\">&quot;exp is not ast.HashLiteral. got=%T&quot;</span>, stmt.Expression)</span>\n<span id=\"cb98-15\"><a href=\"#cb98-15\"></a>    }</span>\n<span id=\"cb98-16\"><a href=\"#cb98-16\"></a></span>\n<span id=\"cb98-17\"><a href=\"#cb98-17\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(hash.Pairs) != <span class=\"dv\">0</span> {</span>\n<span id=\"cb98-18\"><a href=\"#cb98-18\"></a>        t.Errorf(<span class=\"st\">&quot;hash.Pairs has wrong length. got=%d&quot;</span>, <span class=\"bu\">len</span>(hash.Pairs))</span>\n<span id=\"cb98-19\"><a href=\"#cb98-19\"></a>    }</span>\n<span id=\"cb98-20\"><a href=\"#cb98-20\"></a>}</span></code></pre></div>\n<p>I also added two more tests that are similar to <code>TestHashLiteralStringKeys</code> but use integers and booleans as hash keys and make sure the parser turns those into <code>*ast.IntegerLiteral</code> and <code>*ast.Boolean</code> respectively. And then there is a fifth test function that makes sure the values in a hash literal can be any expression, even operator expressions. It looks like this:</p>\n<div class=\"sourceCode\" id=\"cb99\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb99-1\"><a href=\"#cb99-1\"></a><span class=\"co\">// parser/parser_test.go</span></span>\n<span id=\"cb99-2\"><a href=\"#cb99-2\"></a></span>\n<span id=\"cb99-3\"><a href=\"#cb99-3\"></a><span class=\"kw\">func</span> TestParsingHashLiteralsWithExpressions(t *testing.T) {</span>\n<span id=\"cb99-4\"><a href=\"#cb99-4\"></a>    input := <span class=\"st\">`{&quot;one&quot;: 0 + 1, &quot;two&quot;: 10 - 8, &quot;three&quot;: 15 / 5}`</span></span>\n<span id=\"cb99-5\"><a href=\"#cb99-5\"></a></span>\n<span id=\"cb99-6\"><a href=\"#cb99-6\"></a>    l := lexer.New(input)</span>\n<span id=\"cb99-7\"><a href=\"#cb99-7\"></a>    p := New(l)</span>\n<span id=\"cb99-8\"><a href=\"#cb99-8\"></a>    program := p.ParseProgram()</span>\n<span id=\"cb99-9\"><a href=\"#cb99-9\"></a>    checkParserErrors(t, p)</span>\n<span id=\"cb99-10\"><a href=\"#cb99-10\"></a></span>\n<span id=\"cb99-11\"><a href=\"#cb99-11\"></a>    stmt := program.Statements[<span class=\"dv\">0</span>].(*ast.ExpressionStatement)</span>\n<span id=\"cb99-12\"><a href=\"#cb99-12\"></a>    hash, ok := stmt.Expression.(*ast.HashLiteral)</span>\n<span id=\"cb99-13\"><a href=\"#cb99-13\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb99-14\"><a href=\"#cb99-14\"></a>        t.Fatalf(<span class=\"st\">&quot;exp is not ast.HashLiteral. got=%T&quot;</span>, stmt.Expression)</span>\n<span id=\"cb99-15\"><a href=\"#cb99-15\"></a>    }</span>\n<span id=\"cb99-16\"><a href=\"#cb99-16\"></a></span>\n<span id=\"cb99-17\"><a href=\"#cb99-17\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(hash.Pairs) != <span class=\"dv\">3</span> {</span>\n<span id=\"cb99-18\"><a href=\"#cb99-18\"></a>        t.Errorf(<span class=\"st\">&quot;hash.Pairs has wrong length. got=%d&quot;</span>, <span class=\"bu\">len</span>(hash.Pairs))</span>\n<span id=\"cb99-19\"><a href=\"#cb99-19\"></a>    }</span>\n<span id=\"cb99-20\"><a href=\"#cb99-20\"></a></span>\n<span id=\"cb99-21\"><a href=\"#cb99-21\"></a>    tests := <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]<span class=\"kw\">func</span>(ast.Expression){</span>\n<span id=\"cb99-22\"><a href=\"#cb99-22\"></a>        <span class=\"st\">&quot;one&quot;</span>: <span class=\"kw\">func</span>(e ast.Expression) {</span>\n<span id=\"cb99-23\"><a href=\"#cb99-23\"></a>            testInfixExpression(t, e, <span class=\"dv\">0</span>, <span class=\"st\">&quot;+&quot;</span>, <span class=\"dv\">1</span>)</span>\n<span id=\"cb99-24\"><a href=\"#cb99-24\"></a>        },</span>\n<span id=\"cb99-25\"><a href=\"#cb99-25\"></a>        <span class=\"st\">&quot;two&quot;</span>: <span class=\"kw\">func</span>(e ast.Expression) {</span>\n<span id=\"cb99-26\"><a href=\"#cb99-26\"></a>            testInfixExpression(t, e, <span class=\"dv\">10</span>, <span class=\"st\">&quot;-&quot;</span>, <span class=\"dv\">8</span>)</span>\n<span id=\"cb99-27\"><a href=\"#cb99-27\"></a>        },</span>\n<span id=\"cb99-28\"><a href=\"#cb99-28\"></a>        <span class=\"st\">&quot;three&quot;</span>: <span class=\"kw\">func</span>(e ast.Expression) {</span>\n<span id=\"cb99-29\"><a href=\"#cb99-29\"></a>            testInfixExpression(t, e, <span class=\"dv\">15</span>, <span class=\"st\">&quot;/&quot;</span>, <span class=\"dv\">5</span>)</span>\n<span id=\"cb99-30\"><a href=\"#cb99-30\"></a>        },</span>\n<span id=\"cb99-31\"><a href=\"#cb99-31\"></a>    }</span>\n<span id=\"cb99-32\"><a href=\"#cb99-32\"></a></span>\n<span id=\"cb99-33\"><a href=\"#cb99-33\"></a>    <span class=\"kw\">for</span> key, value := <span class=\"kw\">range</span> hash.Pairs {</span>\n<span id=\"cb99-34\"><a href=\"#cb99-34\"></a>        literal, ok := key.(*ast.StringLiteral)</span>\n<span id=\"cb99-35\"><a href=\"#cb99-35\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb99-36\"><a href=\"#cb99-36\"></a>            t.Errorf(<span class=\"st\">&quot;key is not ast.StringLiteral. got=%T&quot;</span>, key)</span>\n<span id=\"cb99-37\"><a href=\"#cb99-37\"></a>            <span class=\"kw\">continue</span></span>\n<span id=\"cb99-38\"><a href=\"#cb99-38\"></a>        }</span>\n<span id=\"cb99-39\"><a href=\"#cb99-39\"></a></span>\n<span id=\"cb99-40\"><a href=\"#cb99-40\"></a>        testFunc, ok := tests[literal.String()]</span>\n<span id=\"cb99-41\"><a href=\"#cb99-41\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb99-42\"><a href=\"#cb99-42\"></a>            t.Errorf(<span class=\"st\">&quot;No test function for key %q found&quot;</span>, literal.String())</span>\n<span id=\"cb99-43\"><a href=\"#cb99-43\"></a>            <span class=\"kw\">continue</span></span>\n<span id=\"cb99-44\"><a href=\"#cb99-44\"></a>        }</span>\n<span id=\"cb99-45\"><a href=\"#cb99-45\"></a></span>\n<span id=\"cb99-46\"><a href=\"#cb99-46\"></a>        testFunc(value)</span>\n<span id=\"cb99-47\"><a href=\"#cb99-47\"></a>    }</span>\n<span id=\"cb99-48\"><a href=\"#cb99-48\"></a>}</span></code></pre></div>\n<p>So how are all of these test functions doing? Not so well, to be honest. We get a lot of failures and parser errors:</p>\n<div class=\"sourceCode\" id=\"cb100\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb100-1\"><a href=\"#cb100-1\"></a>$ go test ./parser</span>\n<span id=\"cb100-2\"><a href=\"#cb100-2\"></a>--- FAIL: TestParsingEmptyHashLiteral (0.00s)</span>\n<span id=\"cb100-3\"><a href=\"#cb100-3\"></a>  parser_test.go:1173: parser has 2 errors</span>\n<span id=\"cb100-4\"><a href=\"#cb100-4\"></a>  parser_test.go:1175: parser error: &quot;no prefix parse function for { found&quot;</span>\n<span id=\"cb100-5\"><a href=\"#cb100-5\"></a>  parser_test.go:1175: parser error: &quot;no prefix parse function for } found&quot;</span>\n<span id=\"cb100-6\"><a href=\"#cb100-6\"></a>--- FAIL: TestParsingHashLiteralsStringKeys (0.00s)</span>\n<span id=\"cb100-7\"><a href=\"#cb100-7\"></a>  parser_test.go:1173: parser has 7 errors</span>\n<span id=\"cb100-8\"><a href=\"#cb100-8\"></a>  parser_test.go:1175: parser error: &quot;no prefix parse function for { found&quot;</span>\n<span id=\"cb100-9\"><a href=\"#cb100-9\"></a>[... more errors ...]</span>\n<span id=\"cb100-10\"><a href=\"#cb100-10\"></a>--- FAIL: TestParsingHashLiteralsBooleanKeys (0.00s)</span>\n<span id=\"cb100-11\"><a href=\"#cb100-11\"></a>  parser_test.go:1173: parser has 5 errors</span>\n<span id=\"cb100-12\"><a href=\"#cb100-12\"></a>  parser_test.go:1175: parser error: &quot;no prefix parse function for { found&quot;</span>\n<span id=\"cb100-13\"><a href=\"#cb100-13\"></a>[... more errors ...]</span>\n<span id=\"cb100-14\"><a href=\"#cb100-14\"></a>--- FAIL: TestParsingHashLiteralsIntegerKeys (0.00s)</span>\n<span id=\"cb100-15\"><a href=\"#cb100-15\"></a>  parser_test.go:967: parser has 7 errors</span>\n<span id=\"cb100-16\"><a href=\"#cb100-16\"></a>  parser_test.go:969: parser error: &quot;no prefix parse function for { found&quot;</span>\n<span id=\"cb100-17\"><a href=\"#cb100-17\"></a>[... more errors ...]</span>\n<span id=\"cb100-18\"><a href=\"#cb100-18\"></a>--- FAIL: TestParsingHashLiteralsWithExpressions (0.00s)</span>\n<span id=\"cb100-19\"><a href=\"#cb100-19\"></a>  parser_test.go:1173: parser has 7 errors</span>\n<span id=\"cb100-20\"><a href=\"#cb100-20\"></a>  parser_test.go:1175: parser error: &quot;no prefix parse function for { found&quot;</span>\n<span id=\"cb100-21\"><a href=\"#cb100-21\"></a>[... more errors ...]</span>\n<span id=\"cb100-22\"><a href=\"#cb100-22\"></a>FAIL</span>\n<span id=\"cb100-23\"><a href=\"#cb100-23\"></a>FAIL    monkey/parser   0.008s</span></code></pre></div>\n<p>It might sound unbelievable but there’s good news: it only takes one function to make all of these tests pass. One <code>prefixParseFn</code>, to be exact. Since the <code>token.LBRACE</code> of a hash literal is in prefix position, just like the <code>token.LBRACKET</code> of an array literal, we can define a <code>parseHashLiteral</code> method as a <code>prefixParseFn</code>:</p>\n<div class=\"sourceCode\" id=\"cb101\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb101-1\"><a href=\"#cb101-1\"></a><span class=\"co\">// parser/parser.go</span></span>\n<span id=\"cb101-2\"><a href=\"#cb101-2\"></a></span>\n<span id=\"cb101-3\"><a href=\"#cb101-3\"></a><span class=\"kw\">func</span> New(l *lexer.Lexer) *Parser {</span>\n<span id=\"cb101-4\"><a href=\"#cb101-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb101-5\"><a href=\"#cb101-5\"></a>    p.registerPrefix(token.LBRACE, p.parseHashLiteral)</span>\n<span id=\"cb101-6\"><a href=\"#cb101-6\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb101-7\"><a href=\"#cb101-7\"></a>}</span>\n<span id=\"cb101-8\"><a href=\"#cb101-8\"></a></span>\n<span id=\"cb101-9\"><a href=\"#cb101-9\"></a><span class=\"kw\">func</span> (p *Parser) parseHashLiteral() ast.Expression {</span>\n<span id=\"cb101-10\"><a href=\"#cb101-10\"></a>    hash := &amp;ast.HashLiteral{Token: p.curToken}</span>\n<span id=\"cb101-11\"><a href=\"#cb101-11\"></a>    hash.Pairs = <span class=\"bu\">make</span>(<span class=\"kw\">map</span>[ast.Expression]ast.Expression)</span>\n<span id=\"cb101-12\"><a href=\"#cb101-12\"></a></span>\n<span id=\"cb101-13\"><a href=\"#cb101-13\"></a>    <span class=\"kw\">for</span> !p.peekTokenIs(token.RBRACE) {</span>\n<span id=\"cb101-14\"><a href=\"#cb101-14\"></a>        p.nextToken()</span>\n<span id=\"cb101-15\"><a href=\"#cb101-15\"></a>        key := p.parseExpression(LOWEST)</span>\n<span id=\"cb101-16\"><a href=\"#cb101-16\"></a></span>\n<span id=\"cb101-17\"><a href=\"#cb101-17\"></a>        <span class=\"kw\">if</span> !p.expectPeek(token.COLON) {</span>\n<span id=\"cb101-18\"><a href=\"#cb101-18\"></a>            <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb101-19\"><a href=\"#cb101-19\"></a>        }</span>\n<span id=\"cb101-20\"><a href=\"#cb101-20\"></a></span>\n<span id=\"cb101-21\"><a href=\"#cb101-21\"></a>        p.nextToken()</span>\n<span id=\"cb101-22\"><a href=\"#cb101-22\"></a>        value := p.parseExpression(LOWEST)</span>\n<span id=\"cb101-23\"><a href=\"#cb101-23\"></a></span>\n<span id=\"cb101-24\"><a href=\"#cb101-24\"></a>        hash.Pairs[key] = value</span>\n<span id=\"cb101-25\"><a href=\"#cb101-25\"></a></span>\n<span id=\"cb101-26\"><a href=\"#cb101-26\"></a>        <span class=\"kw\">if</span> !p.peekTokenIs(token.RBRACE) &amp;&amp; !p.expectPeek(token.COMMA) {</span>\n<span id=\"cb101-27\"><a href=\"#cb101-27\"></a>            <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb101-28\"><a href=\"#cb101-28\"></a>        }</span>\n<span id=\"cb101-29\"><a href=\"#cb101-29\"></a>    }</span>\n<span id=\"cb101-30\"><a href=\"#cb101-30\"></a></span>\n<span id=\"cb101-31\"><a href=\"#cb101-31\"></a>    <span class=\"kw\">if</span> !p.expectPeek(token.RBRACE) {</span>\n<span id=\"cb101-32\"><a href=\"#cb101-32\"></a>        <span class=\"kw\">return</span> <span class=\"ot\">nil</span></span>\n<span id=\"cb101-33\"><a href=\"#cb101-33\"></a>    }</span>\n<span id=\"cb101-34\"><a href=\"#cb101-34\"></a></span>\n<span id=\"cb101-35\"><a href=\"#cb101-35\"></a>    <span class=\"kw\">return</span> hash</span>\n<span id=\"cb101-36\"><a href=\"#cb101-36\"></a>}</span></code></pre></div>\n<p>It may look intimidating, but there is nothing in <code>parseHashLiteral</code> we haven’t seen before. It only loops over key-value expression pairs by checking for a closing <code>token.RBRACE</code> and calling <code>parseExpression</code> two times. That and the filling of <code>hash.Pairs</code> are the most important parts of this method. It does its job well:</p>\n<div class=\"sourceCode\" id=\"cb102\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb102-1\"><a href=\"#cb102-1\"></a>$ go test ./parser</span>\n<span id=\"cb102-2\"><a href=\"#cb102-2\"></a>ok      monkey/parser   0.006s</span></code></pre></div>\n<p>All of our parser tests pass! And judging by the numbers of tests we added, we can be reasonably sure that our parser now knows how to parse hash literals. That means we’re now coming to the most interesting part of adding hashes to our interpreter: representing them in the object system and evaluating hash literals.</p>\n</section>\n<section id=\"hashing-objects\" class=\"level3\" data-number=\"4.5.3\">\n<h3 data-number=\"4.5.3\">Hashing Objects</h3>\n<p>Besides extending the lexer and parser, adding a new data type also means representing it in the object system. We successfully did that for integers, strings and arrays. But whereas implementing these other data types just meant defining a struct that has a <code>.Value</code> field with the correct type, hashes require a little bit more effort. Let me explain why.</p>\n<p>Let’s say we defined a new <code>object.Hash</code> type like this:</p>\n<div class=\"sourceCode\" id=\"cb103\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb103-1\"><a href=\"#cb103-1\"></a><span class=\"kw\">type</span> Hash <span class=\"kw\">struct</span> {</span>\n<span id=\"cb103-2\"><a href=\"#cb103-2\"></a>  Pairs <span class=\"kw\">map</span>[Object]Object</span>\n<span id=\"cb103-3\"><a href=\"#cb103-3\"></a>}</span></code></pre></div>\n<p>That’s the most obvious choice for implementing a <code>Hash</code> data type based on Go’s <code>map</code>. But with this definition, how would we fill the <code>Pairs</code> map? And more importantly, how would we get values back out of it?</p>\n<p>Consider this piece of Monkey code:</p>\n<div class=\"sourceCode\" id=\"cb104\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb104-1\"><a href=\"#cb104-1\"></a><span class=\"kw\">let</span> hash <span class=\"op\">=</span> {<span class=\"st\">&quot;name&quot;</span><span class=\"op\">:</span> <span class=\"st\">&quot;Monkey&quot;</span>}<span class=\"op\">;</span></span>\n<span id=\"cb104-2\"><a href=\"#cb104-2\"></a>hash[<span class=\"st\">&quot;name&quot;</span>]</span></code></pre></div>\n<p>Let’s say we are evaluating these two lines and are using the <code>object.Hash</code> definition from above. When evaluating the hash literal in the first line we take every key-value pair and put it in the <code>map[Object]Object</code> map, resulting in <code>.Pairs</code> having the following mapping: an <code>*object.String</code> with <code>.Value</code> being <code>\"name\"</code> mapped to an <code>*object.String</code> with <code>.Value</code> being <code>\"Monkey\"</code>.</p>\n<p>So far, so good. But the problem arises in the second line where we use an index expression to try to access the <code>\"Monkey\"</code> string.</p>\n<p>In this second line the <code>\"name\"</code> string literal of the index expression evaluates to a new, freshly allocated <code>*object.String</code>. And even though this new <code>*object.String</code> also contains <code>\"name\"</code> in its <code>.Value</code> field, just like the other <code>*object.String</code> in <code>Pairs</code>, we can’t use the new one to retrieve <code>\"Monkey\"</code>.</p>\n<p>The reason for this is that they’re pointers pointing to different memory locations. The fact that the content of the memory locations they point to is the same (<code>\"name\"</code>) doesn’t matter. Comparing these pointers would tell us that they’re not equal. That means using the newly created <code>*object.String</code> as a key doesn’t get us <code>\"Monkey\"</code>. That’s how pointers and comparison between them works in Go.</p>\n<p>Here is an example that demonstrates the problem we’d face with the <code>object.Hash</code> implementation from above:</p>\n<div class=\"sourceCode\" id=\"cb105\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb105-1\"><a href=\"#cb105-1\"></a>name1 := &amp;object.String{Value: <span class=\"st\">&quot;name&quot;</span>}</span>\n<span id=\"cb105-2\"><a href=\"#cb105-2\"></a>monkey := &amp;object.String{Value: <span class=\"st\">&quot;Monkey&quot;</span>}</span>\n<span id=\"cb105-3\"><a href=\"#cb105-3\"></a></span>\n<span id=\"cb105-4\"><a href=\"#cb105-4\"></a>pairs := <span class=\"kw\">map</span>[object.Object]object.Object{}</span>\n<span id=\"cb105-5\"><a href=\"#cb105-5\"></a>pairs[name1] = monkey</span>\n<span id=\"cb105-6\"><a href=\"#cb105-6\"></a></span>\n<span id=\"cb105-7\"><a href=\"#cb105-7\"></a>fmt.Printf(<span class=\"st\">&quot;pairs[name1]=%+v</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>, pairs[name1])</span>\n<span id=\"cb105-8\"><a href=\"#cb105-8\"></a><span class=\"co\">// =&gt; pairs[name1]=&amp;{Value:Monkey}</span></span>\n<span id=\"cb105-9\"><a href=\"#cb105-9\"></a></span>\n<span id=\"cb105-10\"><a href=\"#cb105-10\"></a>name2 := &amp;object.String{Value: <span class=\"st\">&quot;name&quot;</span>}</span>\n<span id=\"cb105-11\"><a href=\"#cb105-11\"></a></span>\n<span id=\"cb105-12\"><a href=\"#cb105-12\"></a>fmt.Printf(<span class=\"st\">&quot;pairs[name2]=%+v</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>, pairs[name2])</span>\n<span id=\"cb105-13\"><a href=\"#cb105-13\"></a><span class=\"co\">// =&gt; pairs[name2]=&lt;nil&gt;</span></span>\n<span id=\"cb105-14\"><a href=\"#cb105-14\"></a></span>\n<span id=\"cb105-15\"><a href=\"#cb105-15\"></a>fmt.Printf(<span class=\"st\">&quot;(name1 == name2)=%t</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>, name1 == name2)</span>\n<span id=\"cb105-16\"><a href=\"#cb105-16\"></a><span class=\"co\">// =&gt; (name1 == name2)=false</span></span></code></pre></div>\n<p>As a solution to this problem we could iterate over every key in <code>.Pairs</code>, check if it’s an <code>*object.String</code> and compare its <code>.Value</code> to the <code>.Value</code> of the key in the index expression. We’d find the matching value this way, but this method turns the lookup time for a given key from O(1) into O(n), defeating the entire purpose of using hashes in the first place.</p>\n<p>Another option is to define <code>Pairs</code> as a <code>map[string]Object</code> and then use the <code>.Value</code> of <code>*object.String</code> as the keys. That works, but not for integers and booleans.</p>\n<p>No, what we need is a way to generate hashes for objects that we can easily compare and use as hash keys in our <code>object.Hash</code>. We need to be able to generate a hash key for an <code>*object.String</code> that’s comparable and equal to the hash key of another <code>*object.String</code> with the same <code>.Value</code>. The same goes for <code>*object.Integer</code> and <code>*object.Boolean</code>. But the hash keys for an <code>*object.String</code> must never be equal to the hash key for an <code>*object.Integer</code> or an <code>*object.Boolean</code>. Between types the hash keys always have to differ.</p>\n<p>We can express the desired behaviour in a set of test functions in our object system:</p>\n<div class=\"sourceCode\" id=\"cb106\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb106-1\"><a href=\"#cb106-1\"></a><span class=\"co\">// object/object_test.go</span></span>\n<span id=\"cb106-2\"><a href=\"#cb106-2\"></a></span>\n<span id=\"cb106-3\"><a href=\"#cb106-3\"></a><span class=\"kw\">package</span> object</span>\n<span id=\"cb106-4\"><a href=\"#cb106-4\"></a></span>\n<span id=\"cb106-5\"><a href=\"#cb106-5\"></a><span class=\"kw\">import</span> <span class=\"st\">&quot;testing&quot;</span></span>\n<span id=\"cb106-6\"><a href=\"#cb106-6\"></a></span>\n<span id=\"cb106-7\"><a href=\"#cb106-7\"></a><span class=\"kw\">func</span> TestStringHashKey(t *testing.T) {</span>\n<span id=\"cb106-8\"><a href=\"#cb106-8\"></a>    hello1 := &amp;String{Value: <span class=\"st\">&quot;Hello World&quot;</span>}</span>\n<span id=\"cb106-9\"><a href=\"#cb106-9\"></a>    hello2 := &amp;String{Value: <span class=\"st\">&quot;Hello World&quot;</span>}</span>\n<span id=\"cb106-10\"><a href=\"#cb106-10\"></a>    diff1 := &amp;String{Value: <span class=\"st\">&quot;My name is johnny&quot;</span>}</span>\n<span id=\"cb106-11\"><a href=\"#cb106-11\"></a>    diff2 := &amp;String{Value: <span class=\"st\">&quot;My name is johnny&quot;</span>}</span>\n<span id=\"cb106-12\"><a href=\"#cb106-12\"></a></span>\n<span id=\"cb106-13\"><a href=\"#cb106-13\"></a>    <span class=\"kw\">if</span> hello1.HashKey() != hello2.HashKey() {</span>\n<span id=\"cb106-14\"><a href=\"#cb106-14\"></a>        t.Errorf(<span class=\"st\">&quot;strings with same content have different hash keys&quot;</span>)</span>\n<span id=\"cb106-15\"><a href=\"#cb106-15\"></a>    }</span>\n<span id=\"cb106-16\"><a href=\"#cb106-16\"></a></span>\n<span id=\"cb106-17\"><a href=\"#cb106-17\"></a>    <span class=\"kw\">if</span> diff1.HashKey() != diff2.HashKey() {</span>\n<span id=\"cb106-18\"><a href=\"#cb106-18\"></a>        t.Errorf(<span class=\"st\">&quot;strings with same content have different hash keys&quot;</span>)</span>\n<span id=\"cb106-19\"><a href=\"#cb106-19\"></a>    }</span>\n<span id=\"cb106-20\"><a href=\"#cb106-20\"></a></span>\n<span id=\"cb106-21\"><a href=\"#cb106-21\"></a>    <span class=\"kw\">if</span> hello1.HashKey() == diff1.HashKey() {</span>\n<span id=\"cb106-22\"><a href=\"#cb106-22\"></a>        t.Errorf(<span class=\"st\">&quot;strings with different content have same hash keys&quot;</span>)</span>\n<span id=\"cb106-23\"><a href=\"#cb106-23\"></a>    }</span>\n<span id=\"cb106-24\"><a href=\"#cb106-24\"></a>}</span></code></pre></div>\n<p>That’s exactly what we want from a <code>HashKey()</code> method. And not just for <code>*object.String</code> but for <code>*object.Boolean</code> and <code>*object.Integer</code>, which is why the same test function exists for both of them too.</p>\n<p>To stop the tests from blowing up we need to implement the <code>HashKey()</code> method on each of the three types:</p>\n<div class=\"sourceCode\" id=\"cb107\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb107-1\"><a href=\"#cb107-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb107-2\"><a href=\"#cb107-2\"></a></span>\n<span id=\"cb107-3\"><a href=\"#cb107-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb107-4\"><a href=\"#cb107-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb107-5\"><a href=\"#cb107-5\"></a>    <span class=\"st\">&quot;hash/fnv&quot;</span></span>\n<span id=\"cb107-6\"><a href=\"#cb107-6\"></a>)</span>\n<span id=\"cb107-7\"><a href=\"#cb107-7\"></a></span>\n<span id=\"cb107-8\"><a href=\"#cb107-8\"></a><span class=\"kw\">type</span> HashKey <span class=\"kw\">struct</span> {</span>\n<span id=\"cb107-9\"><a href=\"#cb107-9\"></a>    Type  ObjectType</span>\n<span id=\"cb107-10\"><a href=\"#cb107-10\"></a>    Value <span class=\"dt\">uint64</span></span>\n<span id=\"cb107-11\"><a href=\"#cb107-11\"></a>}</span>\n<span id=\"cb107-12\"><a href=\"#cb107-12\"></a></span>\n<span id=\"cb107-13\"><a href=\"#cb107-13\"></a><span class=\"kw\">func</span> (b *Boolean) HashKey() HashKey {</span>\n<span id=\"cb107-14\"><a href=\"#cb107-14\"></a>    <span class=\"kw\">var</span> value <span class=\"dt\">uint64</span></span>\n<span id=\"cb107-15\"><a href=\"#cb107-15\"></a></span>\n<span id=\"cb107-16\"><a href=\"#cb107-16\"></a>    <span class=\"kw\">if</span> b.Value {</span>\n<span id=\"cb107-17\"><a href=\"#cb107-17\"></a>        value = <span class=\"dv\">1</span></span>\n<span id=\"cb107-18\"><a href=\"#cb107-18\"></a>    } <span class=\"kw\">else</span> {</span>\n<span id=\"cb107-19\"><a href=\"#cb107-19\"></a>        value = <span class=\"dv\">0</span></span>\n<span id=\"cb107-20\"><a href=\"#cb107-20\"></a>    }</span>\n<span id=\"cb107-21\"><a href=\"#cb107-21\"></a></span>\n<span id=\"cb107-22\"><a href=\"#cb107-22\"></a>    <span class=\"kw\">return</span> HashKey{Type: b.Type(), Value: value}</span>\n<span id=\"cb107-23\"><a href=\"#cb107-23\"></a>}</span>\n<span id=\"cb107-24\"><a href=\"#cb107-24\"></a></span>\n<span id=\"cb107-25\"><a href=\"#cb107-25\"></a><span class=\"kw\">func</span> (i *Integer) HashKey() HashKey {</span>\n<span id=\"cb107-26\"><a href=\"#cb107-26\"></a>    <span class=\"kw\">return</span> HashKey{Type: i.Type(), Value: <span class=\"dt\">uint64</span>(i.Value)}</span>\n<span id=\"cb107-27\"><a href=\"#cb107-27\"></a>}</span>\n<span id=\"cb107-28\"><a href=\"#cb107-28\"></a></span>\n<span id=\"cb107-29\"><a href=\"#cb107-29\"></a><span class=\"kw\">func</span> (s *String) HashKey() HashKey {</span>\n<span id=\"cb107-30\"><a href=\"#cb107-30\"></a>    h := fnv.New64a()</span>\n<span id=\"cb107-31\"><a href=\"#cb107-31\"></a>    h.Write([]<span class=\"dt\">byte</span>(s.Value))</span>\n<span id=\"cb107-32\"><a href=\"#cb107-32\"></a></span>\n<span id=\"cb107-33\"><a href=\"#cb107-33\"></a>    <span class=\"kw\">return</span> HashKey{Type: s.Type(), Value: h.Sum64()}</span>\n<span id=\"cb107-34\"><a href=\"#cb107-34\"></a>}</span></code></pre></div>\n<p>Every <code>HashKey()</code> method returns a <code>HashKey</code>. As you can see in its definition, <code>HashKey</code> is nothing fancy. The <code>Type</code> field contains an <code>ObjectType</code> (which is a <code>string</code>) and thus effectively “scopes” <code>HashKey</code>s to different object types. The <code>Value</code> field holds the actual hash, which is an integer. Since it’s just a string and an integer we can easily compare a <code>HashKey</code> to another <code>HashKey</code> by using the <code>==</code> operator. And that also makes <code>HashKey</code> usable as a key in a Go <code>map</code>.</p>\n<p>There is still a possibility, albeit a small one, that different <code>String</code>s with different <code>Value</code>s result in the same hash. That happens when the <code>hash/fnv</code> package generates the same integer for different values, an event called a hash collision. Chances that we experience it are low, but it should be noted that there are well-known techniques such as “separate chaining” and “open addressing” to work around the problem. Implementing one of these mitigations is outside of this book’s scope, but certainly a nice exercise for the curious reader.</p>\n<p>The problem we demonstrated earlier is solved by using this newly defined <code>HashKey</code> and the <code>HashKey()</code> methods:</p>\n<div class=\"sourceCode\" id=\"cb108\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb108-1\"><a href=\"#cb108-1\"></a>name1 := &amp;object.String{Value: <span class=\"st\">&quot;name&quot;</span>}</span>\n<span id=\"cb108-2\"><a href=\"#cb108-2\"></a>monkey := &amp;object.String{Value: <span class=\"st\">&quot;Monkey&quot;</span>}</span>\n<span id=\"cb108-3\"><a href=\"#cb108-3\"></a></span>\n<span id=\"cb108-4\"><a href=\"#cb108-4\"></a>pairs := <span class=\"kw\">map</span>[object.HashKey]object.Object{}</span>\n<span id=\"cb108-5\"><a href=\"#cb108-5\"></a>pairs[name1.HashKey()] = monkey</span>\n<span id=\"cb108-6\"><a href=\"#cb108-6\"></a></span>\n<span id=\"cb108-7\"><a href=\"#cb108-7\"></a>fmt.Printf(<span class=\"st\">&quot;pairs[name1.HashKey()]=%+v</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>, pairs[name1.HashKey()])</span>\n<span id=\"cb108-8\"><a href=\"#cb108-8\"></a><span class=\"co\">// =&gt; pairs[name1.HashKey()]=&amp;{Value:Monkey}</span></span>\n<span id=\"cb108-9\"><a href=\"#cb108-9\"></a></span>\n<span id=\"cb108-10\"><a href=\"#cb108-10\"></a>name2 := &amp;object.String{Value: <span class=\"st\">&quot;name&quot;</span>}</span>\n<span id=\"cb108-11\"><a href=\"#cb108-11\"></a></span>\n<span id=\"cb108-12\"><a href=\"#cb108-12\"></a>fmt.Printf(<span class=\"st\">&quot;pairs[name2.HashKey()]=%+v</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>, pairs[name2.HashKey()])</span>\n<span id=\"cb108-13\"><a href=\"#cb108-13\"></a><span class=\"co\">// =&gt; pairs[name2.HashKey()]=&amp;{Value:Monkey}</span></span>\n<span id=\"cb108-14\"><a href=\"#cb108-14\"></a></span>\n<span id=\"cb108-15\"><a href=\"#cb108-15\"></a>fmt.Printf(<span class=\"st\">&quot;(name1 == name2)=%t</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>, name1 == name2)</span>\n<span id=\"cb108-16\"><a href=\"#cb108-16\"></a><span class=\"co\">// =&gt; (name1 == name2)=false</span></span>\n<span id=\"cb108-17\"><a href=\"#cb108-17\"></a></span>\n<span id=\"cb108-18\"><a href=\"#cb108-18\"></a>fmt.Printf(<span class=\"st\">&quot;(name1.HashKey() == name2.HashKey())=%t</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span>,</span>\n<span id=\"cb108-19\"><a href=\"#cb108-19\"></a>  name1.HashKey() == name2.HashKey())</span>\n<span id=\"cb108-20\"><a href=\"#cb108-20\"></a><span class=\"co\">// =&gt; (name1.HashKey() == name2.HashKey())=true</span></span></code></pre></div>\n<p>That’s <em>exactly</em> what we want! The <code>HashKey</code> definition and the <code>HashKey()</code> method implementations solve the problems we had with our naive <code>Hash</code> definition. They also make the tests pass:</p>\n<div class=\"sourceCode\" id=\"cb109\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb109-1\"><a href=\"#cb109-1\"></a>$ go test ./object</span>\n<span id=\"cb109-2\"><a href=\"#cb109-2\"></a>ok      monkey/object   0.008s</span></code></pre></div>\n<p>Now we can define <code>object.Hash</code> and use this new <code>HashKey</code> type:</p>\n<div class=\"sourceCode\" id=\"cb110\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb110-1\"><a href=\"#cb110-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb110-2\"><a href=\"#cb110-2\"></a></span>\n<span id=\"cb110-3\"><a href=\"#cb110-3\"></a><span class=\"kw\">const</span> (</span>\n<span id=\"cb110-4\"><a href=\"#cb110-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb110-5\"><a href=\"#cb110-5\"></a>    HASH_OBJ = <span class=\"st\">&quot;HASH&quot;</span></span>\n<span id=\"cb110-6\"><a href=\"#cb110-6\"></a>)</span>\n<span id=\"cb110-7\"><a href=\"#cb110-7\"></a></span>\n<span id=\"cb110-8\"><a href=\"#cb110-8\"></a><span class=\"kw\">type</span> HashPair <span class=\"kw\">struct</span> {</span>\n<span id=\"cb110-9\"><a href=\"#cb110-9\"></a>    Key   Object</span>\n<span id=\"cb110-10\"><a href=\"#cb110-10\"></a>    Value Object</span>\n<span id=\"cb110-11\"><a href=\"#cb110-11\"></a>}</span>\n<span id=\"cb110-12\"><a href=\"#cb110-12\"></a></span>\n<span id=\"cb110-13\"><a href=\"#cb110-13\"></a><span class=\"kw\">type</span> Hash <span class=\"kw\">struct</span> {</span>\n<span id=\"cb110-14\"><a href=\"#cb110-14\"></a>    Pairs <span class=\"kw\">map</span>[HashKey]HashPair</span>\n<span id=\"cb110-15\"><a href=\"#cb110-15\"></a>}</span>\n<span id=\"cb110-16\"><a href=\"#cb110-16\"></a></span>\n<span id=\"cb110-17\"><a href=\"#cb110-17\"></a><span class=\"kw\">func</span> (h *Hash) Type() ObjectType { <span class=\"kw\">return</span> HASH_OBJ }</span></code></pre></div>\n<p>This adds both the definition of <code>Hash</code> and <code>HashPair</code>. <code>HashPair</code> is the type of the values in <code>Hash.Pairs</code>. You might be wondering why we use that and not just define <code>Pairs</code> as a <code>map[HashKey]Object</code>.</p>\n<p>The reason is the <code>Inspect()</code> method of <code>Hash</code>. When we later print a Monkey hash in our REPL, we want to print the values contained in the hash as well as its keys. And just printing the <code>HashKey</code>s is not really useful. So we keep track of the objects that generated the <code>HashKey</code>s by using <code>HashPair</code>s as values, where we save the original key object and the value object its mapped to. That way we can call the <code>Inspect()</code> methods of the key objects to generate the <code>Inspect()</code> output for <code>*object.Hash</code>. Here is said <code>Inspect()</code> method:</p>\n<div class=\"sourceCode\" id=\"cb111\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb111-1\"><a href=\"#cb111-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb111-2\"><a href=\"#cb111-2\"></a></span>\n<span id=\"cb111-3\"><a href=\"#cb111-3\"></a><span class=\"kw\">func</span> (h *Hash) Inspect() <span class=\"dt\">string</span> {</span>\n<span id=\"cb111-4\"><a href=\"#cb111-4\"></a>    <span class=\"kw\">var</span> out bytes.Buffer</span>\n<span id=\"cb111-5\"><a href=\"#cb111-5\"></a></span>\n<span id=\"cb111-6\"><a href=\"#cb111-6\"></a>    pairs := []<span class=\"dt\">string</span>{}</span>\n<span id=\"cb111-7\"><a href=\"#cb111-7\"></a>    <span class=\"kw\">for</span> _, pair := <span class=\"kw\">range</span> h.Pairs {</span>\n<span id=\"cb111-8\"><a href=\"#cb111-8\"></a>        pairs = <span class=\"bu\">append</span>(pairs, fmt.Sprintf(<span class=\"st\">&quot;%s: %s&quot;</span>,</span>\n<span id=\"cb111-9\"><a href=\"#cb111-9\"></a>            pair.Key.Inspect(), pair.Value.Inspect()))</span>\n<span id=\"cb111-10\"><a href=\"#cb111-10\"></a>    }</span>\n<span id=\"cb111-11\"><a href=\"#cb111-11\"></a></span>\n<span id=\"cb111-12\"><a href=\"#cb111-12\"></a>    out.WriteString(<span class=\"st\">&quot;{&quot;</span>)</span>\n<span id=\"cb111-13\"><a href=\"#cb111-13\"></a>    out.WriteString(strings.Join(pairs, <span class=\"st\">&quot;, &quot;</span>))</span>\n<span id=\"cb111-14\"><a href=\"#cb111-14\"></a>    out.WriteString(<span class=\"st\">&quot;}&quot;</span>)</span>\n<span id=\"cb111-15\"><a href=\"#cb111-15\"></a></span>\n<span id=\"cb111-16\"><a href=\"#cb111-16\"></a>    <span class=\"kw\">return</span> out.String()</span>\n<span id=\"cb111-17\"><a href=\"#cb111-17\"></a>}</span></code></pre></div>\n<p>The <code>Inspect()</code> method is not the only reason why it’s good to keep track of the objects that generated the <code>HashKey</code>. That would also be necessary if we were to implement something like a <code>range</code> function for Monkey hashes, which iterates over keys and values in the hash. Or if we want to add a <code>firstPair</code> function that returns the first key and value of a given hash as an array. Or if we want… You get the drift. Keeping track of keys is highly useful, even though for now only the <code>Inspect()</code> method benefits.</p>\n<p>And that’s it! That’s the whole implementation of <code>object.Hash</code>. But there’s a small thing we ought to do while we still have the <code>object</code> package open:</p>\n<div class=\"sourceCode\" id=\"cb112\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb112-1\"><a href=\"#cb112-1\"></a><span class=\"co\">// object/object.go</span></span>\n<span id=\"cb112-2\"><a href=\"#cb112-2\"></a></span>\n<span id=\"cb112-3\"><a href=\"#cb112-3\"></a><span class=\"kw\">type</span> Hashable <span class=\"kw\">interface</span> {</span>\n<span id=\"cb112-4\"><a href=\"#cb112-4\"></a>    HashKey() HashKey</span>\n<span id=\"cb112-5\"><a href=\"#cb112-5\"></a>}</span></code></pre></div>\n<p>We can use this interface in our evaluator to check if the given object is usable as a hash key when we evaluate hash literals or index expressions for hashes.</p>\n<p>At the moment it’s only implemented by <code>*object.String</code>, <code>*object.Boolean</code> and <code>*object.Integer</code>.</p>\n<p>Granted, there’s one more thing we could do before moving on: we could optimize the performance of the <code>HashKey()</code> methods by caching their return values, but that sounds like a nice exercise for the performance-minded reader.</p>\n</section>\n<section id=\"evaluating-hash-literals\" class=\"level3\" data-number=\"4.5.4\">\n<h3 data-number=\"4.5.4\">Evaluating Hash Literals</h3>\n<p>We’re about to start evaluating hash literals and I’ll be completely honest with you: the hardest part about adding hashes to our interpreter is over. It’s smooth sailing from here on out. So, let’s enjoy the ride, relax and write a test:</p>\n<div class=\"sourceCode\" id=\"cb113\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb113-1\"><a href=\"#cb113-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb113-2\"><a href=\"#cb113-2\"></a></span>\n<span id=\"cb113-3\"><a href=\"#cb113-3\"></a><span class=\"kw\">func</span> TestHashLiterals(t *testing.T) {</span>\n<span id=\"cb113-4\"><a href=\"#cb113-4\"></a>    input := <span class=\"st\">`let two = &quot;two&quot;;</span></span>\n<span id=\"cb113-5\"><a href=\"#cb113-5\"></a><span class=\"st\">    {</span></span>\n<span id=\"cb113-6\"><a href=\"#cb113-6\"></a><span class=\"st\">        &quot;one&quot;: 10 - 9,</span></span>\n<span id=\"cb113-7\"><a href=\"#cb113-7\"></a><span class=\"st\">        two: 1 + 1,</span></span>\n<span id=\"cb113-8\"><a href=\"#cb113-8\"></a><span class=\"st\">        &quot;thr&quot; + &quot;ee&quot;: 6 / 2,</span></span>\n<span id=\"cb113-9\"><a href=\"#cb113-9\"></a><span class=\"st\">        4: 4,</span></span>\n<span id=\"cb113-10\"><a href=\"#cb113-10\"></a><span class=\"st\">        true: 5,</span></span>\n<span id=\"cb113-11\"><a href=\"#cb113-11\"></a><span class=\"st\">        false: 6</span></span>\n<span id=\"cb113-12\"><a href=\"#cb113-12\"></a><span class=\"st\">    }`</span></span>\n<span id=\"cb113-13\"><a href=\"#cb113-13\"></a></span>\n<span id=\"cb113-14\"><a href=\"#cb113-14\"></a>    evaluated := testEval(input)</span>\n<span id=\"cb113-15\"><a href=\"#cb113-15\"></a>    result, ok := evaluated.(*object.Hash)</span>\n<span id=\"cb113-16\"><a href=\"#cb113-16\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb113-17\"><a href=\"#cb113-17\"></a>        t.Fatalf(<span class=\"st\">&quot;Eval didn&#39;t return Hash. got=%T (%+v)&quot;</span>, evaluated, evaluated)</span>\n<span id=\"cb113-18\"><a href=\"#cb113-18\"></a>    }</span>\n<span id=\"cb113-19\"><a href=\"#cb113-19\"></a></span>\n<span id=\"cb113-20\"><a href=\"#cb113-20\"></a>    expected := <span class=\"kw\">map</span>[object.HashKey]<span class=\"dt\">int64</span>{</span>\n<span id=\"cb113-21\"><a href=\"#cb113-21\"></a>        (&amp;object.String{Value: <span class=\"st\">&quot;one&quot;</span>}).HashKey():   <span class=\"dv\">1</span>,</span>\n<span id=\"cb113-22\"><a href=\"#cb113-22\"></a>        (&amp;object.String{Value: <span class=\"st\">&quot;two&quot;</span>}).HashKey():   <span class=\"dv\">2</span>,</span>\n<span id=\"cb113-23\"><a href=\"#cb113-23\"></a>        (&amp;object.String{Value: <span class=\"st\">&quot;three&quot;</span>}).HashKey(): <span class=\"dv\">3</span>,</span>\n<span id=\"cb113-24\"><a href=\"#cb113-24\"></a>        (&amp;object.Integer{Value: <span class=\"dv\">4</span>}).HashKey():      <span class=\"dv\">4</span>,</span>\n<span id=\"cb113-25\"><a href=\"#cb113-25\"></a>        TRUE.HashKey():                             <span class=\"dv\">5</span>,</span>\n<span id=\"cb113-26\"><a href=\"#cb113-26\"></a>        FALSE.HashKey():                            <span class=\"dv\">6</span>,</span>\n<span id=\"cb113-27\"><a href=\"#cb113-27\"></a>    }</span>\n<span id=\"cb113-28\"><a href=\"#cb113-28\"></a></span>\n<span id=\"cb113-29\"><a href=\"#cb113-29\"></a>    <span class=\"kw\">if</span> <span class=\"bu\">len</span>(result.Pairs) != <span class=\"bu\">len</span>(expected) {</span>\n<span id=\"cb113-30\"><a href=\"#cb113-30\"></a>        t.Fatalf(<span class=\"st\">&quot;Hash has wrong num of pairs. got=%d&quot;</span>, <span class=\"bu\">len</span>(result.Pairs))</span>\n<span id=\"cb113-31\"><a href=\"#cb113-31\"></a>    }</span>\n<span id=\"cb113-32\"><a href=\"#cb113-32\"></a></span>\n<span id=\"cb113-33\"><a href=\"#cb113-33\"></a>    <span class=\"kw\">for</span> expectedKey, expectedValue := <span class=\"kw\">range</span> expected {</span>\n<span id=\"cb113-34\"><a href=\"#cb113-34\"></a>        pair, ok := result.Pairs[expectedKey]</span>\n<span id=\"cb113-35\"><a href=\"#cb113-35\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb113-36\"><a href=\"#cb113-36\"></a>            t.Errorf(<span class=\"st\">&quot;no pair for given key in Pairs&quot;</span>)</span>\n<span id=\"cb113-37\"><a href=\"#cb113-37\"></a>        }</span>\n<span id=\"cb113-38\"><a href=\"#cb113-38\"></a></span>\n<span id=\"cb113-39\"><a href=\"#cb113-39\"></a>        testIntegerObject(t, pair.Value, expectedValue)</span>\n<span id=\"cb113-40\"><a href=\"#cb113-40\"></a>    }</span>\n<span id=\"cb113-41\"><a href=\"#cb113-41\"></a>}</span></code></pre></div>\n<p>This test function shows what we want from <code>Eval</code> when it encounters a <code>*ast.HashLiteral</code>: a fresh <code>*object.Hash</code> with the correct number of <code>HashPair</code>s mapped to the matching <code>HashKey</code>s in its <code>Pairs</code> attribute.</p>\n<p>And it also shows another requirement we have: strings, identifiers, infix operator expressions, booleans and integers - they should all be usable as keys. Any expression really. As long as it produces an <code>object</code> that implements the <code>Hashable</code> interface it should usable as a hash key.</p>\n<p>Then there are the values. They can be produced by any expression, too. We test for this here by asserting that <code>10 - 9</code> evaluates to <code>1</code>, <code>6 / 2</code> to <code>3</code> and so on.</p>\n<p>As expected the test fails:</p>\n<div class=\"sourceCode\" id=\"cb114\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb114-1\"><a href=\"#cb114-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb114-2\"><a href=\"#cb114-2\"></a>--- FAIL: TestHashLiterals (0.00s)</span>\n<span id=\"cb114-3\"><a href=\"#cb114-3\"></a>  evaluator_test.go:522: Eval didn&#39;t return Hash. got=&lt;nil&gt; (&lt;nil&gt;)</span>\n<span id=\"cb114-4\"><a href=\"#cb114-4\"></a>FAIL</span>\n<span id=\"cb114-5\"><a href=\"#cb114-5\"></a>FAIL    monkey/evaluator        0.008s</span></code></pre></div>\n<p>We know how to get it to pass, though. We need to extend our <code>Eval</code> function with another <code>case</code> branch for <code>*ast.HashLiteral</code>s:</p>\n<div class=\"sourceCode\" id=\"cb115\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb115-1\"><a href=\"#cb115-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb115-2\"><a href=\"#cb115-2\"></a></span>\n<span id=\"cb115-3\"><a href=\"#cb115-3\"></a><span class=\"kw\">func</span> Eval(node ast.Node, env *object.Environment) object.Object {</span>\n<span id=\"cb115-4\"><a href=\"#cb115-4\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb115-5\"><a href=\"#cb115-5\"></a></span>\n<span id=\"cb115-6\"><a href=\"#cb115-6\"></a>    <span class=\"kw\">case</span> *ast.HashLiteral:</span>\n<span id=\"cb115-7\"><a href=\"#cb115-7\"></a>        <span class=\"kw\">return</span> evalHashLiteral(node, env)</span>\n<span id=\"cb115-8\"><a href=\"#cb115-8\"></a></span>\n<span id=\"cb115-9\"><a href=\"#cb115-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb115-10\"><a href=\"#cb115-10\"></a>}</span></code></pre></div>\n<p>The <code>evalHashLiteral</code> function here may look intimidating, but trust me, it doesn’t bite:</p>\n<div class=\"sourceCode\" id=\"cb116\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb116-1\"><a href=\"#cb116-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb116-2\"><a href=\"#cb116-2\"></a></span>\n<span id=\"cb116-3\"><a href=\"#cb116-3\"></a><span class=\"kw\">func</span> evalHashLiteral(</span>\n<span id=\"cb116-4\"><a href=\"#cb116-4\"></a>    node *ast.HashLiteral,</span>\n<span id=\"cb116-5\"><a href=\"#cb116-5\"></a>    env *object.Environment,</span>\n<span id=\"cb116-6\"><a href=\"#cb116-6\"></a>) object.Object {</span>\n<span id=\"cb116-7\"><a href=\"#cb116-7\"></a>    pairs := <span class=\"bu\">make</span>(<span class=\"kw\">map</span>[object.HashKey]object.HashPair)</span>\n<span id=\"cb116-8\"><a href=\"#cb116-8\"></a></span>\n<span id=\"cb116-9\"><a href=\"#cb116-9\"></a>    <span class=\"kw\">for</span> keyNode, valueNode := <span class=\"kw\">range</span> node.Pairs {</span>\n<span id=\"cb116-10\"><a href=\"#cb116-10\"></a>        key := Eval(keyNode, env)</span>\n<span id=\"cb116-11\"><a href=\"#cb116-11\"></a>        <span class=\"kw\">if</span> isError(key) {</span>\n<span id=\"cb116-12\"><a href=\"#cb116-12\"></a>            <span class=\"kw\">return</span> key</span>\n<span id=\"cb116-13\"><a href=\"#cb116-13\"></a>        }</span>\n<span id=\"cb116-14\"><a href=\"#cb116-14\"></a></span>\n<span id=\"cb116-15\"><a href=\"#cb116-15\"></a>        hashKey, ok := key.(object.Hashable)</span>\n<span id=\"cb116-16\"><a href=\"#cb116-16\"></a>        <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb116-17\"><a href=\"#cb116-17\"></a>            <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;unusable as hash key: %s&quot;</span>, key.Type())</span>\n<span id=\"cb116-18\"><a href=\"#cb116-18\"></a>        }</span>\n<span id=\"cb116-19\"><a href=\"#cb116-19\"></a></span>\n<span id=\"cb116-20\"><a href=\"#cb116-20\"></a>        value := Eval(valueNode, env)</span>\n<span id=\"cb116-21\"><a href=\"#cb116-21\"></a>        <span class=\"kw\">if</span> isError(value) {</span>\n<span id=\"cb116-22\"><a href=\"#cb116-22\"></a>            <span class=\"kw\">return</span> value</span>\n<span id=\"cb116-23\"><a href=\"#cb116-23\"></a>        }</span>\n<span id=\"cb116-24\"><a href=\"#cb116-24\"></a></span>\n<span id=\"cb116-25\"><a href=\"#cb116-25\"></a>        hashed := hashKey.HashKey()</span>\n<span id=\"cb116-26\"><a href=\"#cb116-26\"></a>        pairs[hashed] = object.HashPair{Key: key, Value: value}</span>\n<span id=\"cb116-27\"><a href=\"#cb116-27\"></a>    }</span>\n<span id=\"cb116-28\"><a href=\"#cb116-28\"></a></span>\n<span id=\"cb116-29\"><a href=\"#cb116-29\"></a>    <span class=\"kw\">return</span> &amp;object.Hash{Pairs: pairs}</span>\n<span id=\"cb116-30\"><a href=\"#cb116-30\"></a>}</span></code></pre></div>\n<p>When iterating over the <code>node.Pairs</code> the <code>keyNode</code> is the first to be evaluated. Besides checking if the call to <code>Eval</code> produced an error we also make a type assertion about the evaluation result: it needs to implement the <code>object.Hashable</code> interface, otherwise it’s unusable as a hash key. That’s exactly why we added the <code>Hashable</code> definition.</p>\n<p>Then we call <code>Eval</code> again, to evaluate <code>valueNode</code>. If that call to <code>Eval</code> also doesn’t produce an error, we can add the newly produced key-value pair to our <code>pairs</code> map. We do this by generating a <code>HashKey</code> for the aptly-named <code>hashKey</code> object with a call to <code>HashKey()</code>. Then we initialize a new <code>HashPair</code>, pointing to both <code>key</code> and <code>value</code> and add it to <code>pairs</code>.</p>\n<p>And that’s all it takes. The tests are now passing:</p>\n<div class=\"sourceCode\" id=\"cb117\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb117-1\"><a href=\"#cb117-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb117-2\"><a href=\"#cb117-2\"></a>ok      monkey/evaluator        0.007s</span></code></pre></div>\n<p>That means we can already start using hash literals in our REPL:</p>\n<div class=\"sourceCode\" id=\"cb118\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb118-1\"><a href=\"#cb118-1\"></a>$ go run main.go</span>\n<span id=\"cb118-2\"><a href=\"#cb118-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb118-3\"><a href=\"#cb118-3\"></a>Feel free to type in commands</span>\n<span id=\"cb118-4\"><a href=\"#cb118-4\"></a>&gt;&gt; {&quot;name&quot;: &quot;Monkey&quot;, &quot;age&quot;: 0, &quot;type&quot;: &quot;Language&quot;, &quot;status&quot;: &quot;awesome&quot;}</span>\n<span id=\"cb118-5\"><a href=\"#cb118-5\"></a>{age: 0, type: Language, status: awesome, name: Monkey}</span></code></pre></div>\n<p>That’s awesome! But we can’t get elements out of the hash yet, which kinda diminishes their usefulness:</p>\n<div class=\"sourceCode\" id=\"cb119\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><span id=\"cb119-1\"><a href=\"#cb119-1\"></a><span class=\"op\">&gt;&gt;</span> <span class=\"kw\">let</span> bob <span class=\"op\">=</span> {<span class=\"st\">&quot;name&quot;</span><span class=\"op\">:</span> <span class=\"st\">&quot;Bob&quot;</span><span class=\"op\">,</span> <span class=\"st\">&quot;age&quot;</span><span class=\"op\">:</span> <span class=\"dv\">99</span>}<span class=\"op\">;</span></span>\n<span id=\"cb119-2\"><a href=\"#cb119-2\"></a><span class=\"op\">&gt;&gt;</span> bob[<span class=\"st\">&quot;name&quot;</span>]</span>\n<span id=\"cb119-3\"><a href=\"#cb119-3\"></a>ERROR<span class=\"op\">:</span> index operator not supported<span class=\"op\">:</span> HASH</span></code></pre></div>\n<p>That’s what we’re going to fix now.</p>\n</section>\n<section id=\"evaluating-index-expressions-with-hashes\" class=\"level3\" data-number=\"4.5.5\">\n<h3 data-number=\"4.5.5\">Evaluating Index Expressions With Hashes</h3>\n<p>Remember that switch statement we added to <code>evalIndexExpression</code> in our evaluator? And do you also remember when I told you that we’re going to add another <code>case</code> branch? Well, here we are!</p>\n<p>But first of all we need to add a test function that makes sure accessing values in a hash via an index expression works:</p>\n<div class=\"sourceCode\" id=\"cb120\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb120-1\"><a href=\"#cb120-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb120-2\"><a href=\"#cb120-2\"></a></span>\n<span id=\"cb120-3\"><a href=\"#cb120-3\"></a><span class=\"kw\">func</span> TestHashIndexExpressions(t *testing.T) {</span>\n<span id=\"cb120-4\"><a href=\"#cb120-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb120-5\"><a href=\"#cb120-5\"></a>        input    <span class=\"dt\">string</span></span>\n<span id=\"cb120-6\"><a href=\"#cb120-6\"></a>        expected <span class=\"kw\">interface</span>{}</span>\n<span id=\"cb120-7\"><a href=\"#cb120-7\"></a>    }{</span>\n<span id=\"cb120-8\"><a href=\"#cb120-8\"></a>        {</span>\n<span id=\"cb120-9\"><a href=\"#cb120-9\"></a>            <span class=\"st\">`{&quot;foo&quot;: 5}[&quot;foo&quot;]`</span>,</span>\n<span id=\"cb120-10\"><a href=\"#cb120-10\"></a>            <span class=\"dv\">5</span>,</span>\n<span id=\"cb120-11\"><a href=\"#cb120-11\"></a>        },</span>\n<span id=\"cb120-12\"><a href=\"#cb120-12\"></a>        {</span>\n<span id=\"cb120-13\"><a href=\"#cb120-13\"></a>            <span class=\"st\">`{&quot;foo&quot;: 5}[&quot;bar&quot;]`</span>,</span>\n<span id=\"cb120-14\"><a href=\"#cb120-14\"></a>            <span class=\"ot\">nil</span>,</span>\n<span id=\"cb120-15\"><a href=\"#cb120-15\"></a>        },</span>\n<span id=\"cb120-16\"><a href=\"#cb120-16\"></a>        {</span>\n<span id=\"cb120-17\"><a href=\"#cb120-17\"></a>            <span class=\"st\">`let key = &quot;foo&quot;; {&quot;foo&quot;: 5}[key]`</span>,</span>\n<span id=\"cb120-18\"><a href=\"#cb120-18\"></a>            <span class=\"dv\">5</span>,</span>\n<span id=\"cb120-19\"><a href=\"#cb120-19\"></a>        },</span>\n<span id=\"cb120-20\"><a href=\"#cb120-20\"></a>        {</span>\n<span id=\"cb120-21\"><a href=\"#cb120-21\"></a>            <span class=\"st\">`{}[&quot;foo&quot;]`</span>,</span>\n<span id=\"cb120-22\"><a href=\"#cb120-22\"></a>            <span class=\"ot\">nil</span>,</span>\n<span id=\"cb120-23\"><a href=\"#cb120-23\"></a>        },</span>\n<span id=\"cb120-24\"><a href=\"#cb120-24\"></a>        {</span>\n<span id=\"cb120-25\"><a href=\"#cb120-25\"></a>            <span class=\"st\">`{5: 5}[5]`</span>,</span>\n<span id=\"cb120-26\"><a href=\"#cb120-26\"></a>            <span class=\"dv\">5</span>,</span>\n<span id=\"cb120-27\"><a href=\"#cb120-27\"></a>        },</span>\n<span id=\"cb120-28\"><a href=\"#cb120-28\"></a>        {</span>\n<span id=\"cb120-29\"><a href=\"#cb120-29\"></a>            <span class=\"st\">`{true: 5}[true]`</span>,</span>\n<span id=\"cb120-30\"><a href=\"#cb120-30\"></a>            <span class=\"dv\">5</span>,</span>\n<span id=\"cb120-31\"><a href=\"#cb120-31\"></a>        },</span>\n<span id=\"cb120-32\"><a href=\"#cb120-32\"></a>        {</span>\n<span id=\"cb120-33\"><a href=\"#cb120-33\"></a>            <span class=\"st\">`{false: 5}[false]`</span>,</span>\n<span id=\"cb120-34\"><a href=\"#cb120-34\"></a>            <span class=\"dv\">5</span>,</span>\n<span id=\"cb120-35\"><a href=\"#cb120-35\"></a>        },</span>\n<span id=\"cb120-36\"><a href=\"#cb120-36\"></a>    }</span>\n<span id=\"cb120-37\"><a href=\"#cb120-37\"></a></span>\n<span id=\"cb120-38\"><a href=\"#cb120-38\"></a>    <span class=\"kw\">for</span> _, tt := <span class=\"kw\">range</span> tests {</span>\n<span id=\"cb120-39\"><a href=\"#cb120-39\"></a>        evaluated := testEval(tt.input)</span>\n<span id=\"cb120-40\"><a href=\"#cb120-40\"></a>        integer, ok := tt.expected.(<span class=\"dt\">int</span>)</span>\n<span id=\"cb120-41\"><a href=\"#cb120-41\"></a>        <span class=\"kw\">if</span> ok {</span>\n<span id=\"cb120-42\"><a href=\"#cb120-42\"></a>            testIntegerObject(t, evaluated, <span class=\"dt\">int64</span>(integer))</span>\n<span id=\"cb120-43\"><a href=\"#cb120-43\"></a>        } <span class=\"kw\">else</span> {</span>\n<span id=\"cb120-44\"><a href=\"#cb120-44\"></a>            testNullObject(t, evaluated)</span>\n<span id=\"cb120-45\"><a href=\"#cb120-45\"></a>        }</span>\n<span id=\"cb120-46\"><a href=\"#cb120-46\"></a>    }</span>\n<span id=\"cb120-47\"><a href=\"#cb120-47\"></a>}</span></code></pre></div>\n<p>Just like in <code>TestArrayIndexExpressions</code> we’re making sure using index operator expressions produces the correct value - only this time with hashes. The different test cases here use string, integer or boolean hash keys when retrieving values out of a hash. So, in essence, what the test really asserts is that the <code>HashKey</code> methods implemented by various data types are called correctly.</p>\n<p>And to make sure that using an object as hash key that does not implement <code>object.Hashable</code> produces an error, we can add another test to our <code>TestErrorHandling</code> test function:</p>\n<div class=\"sourceCode\" id=\"cb121\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb121-1\"><a href=\"#cb121-1\"></a><span class=\"co\">// evaluator/evaluator_test.go</span></span>\n<span id=\"cb121-2\"><a href=\"#cb121-2\"></a></span>\n<span id=\"cb121-3\"><a href=\"#cb121-3\"></a><span class=\"kw\">func</span> TestErrorHandling(t *testing.T) {</span>\n<span id=\"cb121-4\"><a href=\"#cb121-4\"></a>    tests := []<span class=\"kw\">struct</span> {</span>\n<span id=\"cb121-5\"><a href=\"#cb121-5\"></a>        input           <span class=\"dt\">string</span></span>\n<span id=\"cb121-6\"><a href=\"#cb121-6\"></a>        expectedMessage <span class=\"dt\">string</span></span>\n<span id=\"cb121-7\"><a href=\"#cb121-7\"></a>    }{</span>\n<span id=\"cb121-8\"><a href=\"#cb121-8\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb121-9\"><a href=\"#cb121-9\"></a>        {</span>\n<span id=\"cb121-10\"><a href=\"#cb121-10\"></a>            <span class=\"st\">`{&quot;name&quot;: &quot;Monkey&quot;}[fn(x) { x }];`</span>,</span>\n<span id=\"cb121-11\"><a href=\"#cb121-11\"></a>            <span class=\"st\">&quot;unusable as hash key: FUNCTION&quot;</span>,</span>\n<span id=\"cb121-12\"><a href=\"#cb121-12\"></a>        },</span>\n<span id=\"cb121-13\"><a href=\"#cb121-13\"></a>    }</span>\n<span id=\"cb121-14\"><a href=\"#cb121-14\"></a></span>\n<span id=\"cb121-15\"><a href=\"#cb121-15\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb121-16\"><a href=\"#cb121-16\"></a>}</span></code></pre></div>\n<p>Running <code>go test</code> now results in the expected failures:</p>\n<div class=\"sourceCode\" id=\"cb122\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb122-1\"><a href=\"#cb122-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb122-2\"><a href=\"#cb122-2\"></a>--- FAIL: TestErrorHandling (0.00s)</span>\n<span id=\"cb122-3\"><a href=\"#cb122-3\"></a>  evaluator_test.go:237: wrong error message.\\</span>\n<span id=\"cb122-4\"><a href=\"#cb122-4\"></a>    expected=&quot;unusable as hash key: FUNCTION&quot;,\\</span>\n<span id=\"cb122-5\"><a href=\"#cb122-5\"></a>    got=&quot;index operator not supported: HASH&quot;</span>\n<span id=\"cb122-6\"><a href=\"#cb122-6\"></a>--- FAIL: TestHashIndexExpressions (0.00s)</span>\n<span id=\"cb122-7\"><a href=\"#cb122-7\"></a>  evaluator_test.go:597: object is not Integer.\\</span>\n<span id=\"cb122-8\"><a href=\"#cb122-8\"></a>    got=*object.Error (&amp;{Message:index operator not supported: HASH})</span>\n<span id=\"cb122-9\"><a href=\"#cb122-9\"></a>  evaluator_test.go:625: object is not NULL.\\</span>\n<span id=\"cb122-10\"><a href=\"#cb122-10\"></a>    got=*object.Error (&amp;{Message:index operator not supported: HASH})</span>\n<span id=\"cb122-11\"><a href=\"#cb122-11\"></a>  evaluator_test.go:597: object is not Integer.\\</span>\n<span id=\"cb122-12\"><a href=\"#cb122-12\"></a>    got=*object.Error (&amp;{Message:index operator not supported: HASH})</span>\n<span id=\"cb122-13\"><a href=\"#cb122-13\"></a>  evaluator_test.go:625: object is not NULL.\\</span>\n<span id=\"cb122-14\"><a href=\"#cb122-14\"></a>    got=*object.Error (&amp;{Message:index operator not supported: HASH})</span>\n<span id=\"cb122-15\"><a href=\"#cb122-15\"></a>  evaluator_test.go:597: object is not Integer.\\</span>\n<span id=\"cb122-16\"><a href=\"#cb122-16\"></a>    got=*object.Error (&amp;{Message:index operator not supported: HASH})</span>\n<span id=\"cb122-17\"><a href=\"#cb122-17\"></a>  evaluator_test.go:597: object is not Integer.\\</span>\n<span id=\"cb122-18\"><a href=\"#cb122-18\"></a>    got=*object.Error (&amp;{Message:index operator not supported: HASH})</span>\n<span id=\"cb122-19\"><a href=\"#cb122-19\"></a>  evaluator_test.go:597: object is not Integer.\\</span>\n<span id=\"cb122-20\"><a href=\"#cb122-20\"></a>    got=*object.Error (&amp;{Message:index operator not supported: HASH})</span>\n<span id=\"cb122-21\"><a href=\"#cb122-21\"></a>FAIL</span>\n<span id=\"cb122-22\"><a href=\"#cb122-22\"></a>FAIL    monkey/evaluator        0.009s</span></code></pre></div>\n<p>That means we’re ready to add another <code>case</code> branch to the switch statement in <code>evalIndexExpression</code>:</p>\n<div class=\"sourceCode\" id=\"cb123\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb123-1\"><a href=\"#cb123-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb123-2\"><a href=\"#cb123-2\"></a></span>\n<span id=\"cb123-3\"><a href=\"#cb123-3\"></a><span class=\"kw\">func</span> evalIndexExpression(left, index object.Object) object.Object {</span>\n<span id=\"cb123-4\"><a href=\"#cb123-4\"></a>    <span class=\"kw\">switch</span> {</span>\n<span id=\"cb123-5\"><a href=\"#cb123-5\"></a>    <span class=\"kw\">case</span> left.Type() == object.ARRAY_OBJ &amp;&amp; index.Type() == object.INTEGER_OBJ:</span>\n<span id=\"cb123-6\"><a href=\"#cb123-6\"></a>        <span class=\"kw\">return</span> evalArrayIndexExpression(left, index)</span>\n<span id=\"cb123-7\"><a href=\"#cb123-7\"></a>    <span class=\"kw\">case</span> left.Type() == object.HASH_OBJ:</span>\n<span id=\"cb123-8\"><a href=\"#cb123-8\"></a>        <span class=\"kw\">return</span> evalHashIndexExpression(left, index)</span>\n<span id=\"cb123-9\"><a href=\"#cb123-9\"></a>    <span class=\"kw\">default</span>:</span>\n<span id=\"cb123-10\"><a href=\"#cb123-10\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;index operator not supported: %s&quot;</span>, left.Type())</span>\n<span id=\"cb123-11\"><a href=\"#cb123-11\"></a>    }</span>\n<span id=\"cb123-12\"><a href=\"#cb123-12\"></a>}</span></code></pre></div>\n<p>The new <code>case</code> branch calls a new function: <code>evalHashIndexExpression</code>. And we already know how <code>evalHashIndexExpression</code> has to work, since we successfully tested the usage of the <code>object.Hashable</code> interface before - in our tests and when evaluating hash literals. So no surprises here:</p>\n<div class=\"sourceCode\" id=\"cb124\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb124-1\"><a href=\"#cb124-1\"></a><span class=\"co\">// evaluator/evaluator.go</span></span>\n<span id=\"cb124-2\"><a href=\"#cb124-2\"></a></span>\n<span id=\"cb124-3\"><a href=\"#cb124-3\"></a><span class=\"kw\">func</span> evalHashIndexExpression(hash, index object.Object) object.Object {</span>\n<span id=\"cb124-4\"><a href=\"#cb124-4\"></a>    hashObject := hash.(*object.Hash)</span>\n<span id=\"cb124-5\"><a href=\"#cb124-5\"></a></span>\n<span id=\"cb124-6\"><a href=\"#cb124-6\"></a>    key, ok := index.(object.Hashable)</span>\n<span id=\"cb124-7\"><a href=\"#cb124-7\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb124-8\"><a href=\"#cb124-8\"></a>        <span class=\"kw\">return</span> newError(<span class=\"st\">&quot;unusable as hash key: %s&quot;</span>, index.Type())</span>\n<span id=\"cb124-9\"><a href=\"#cb124-9\"></a>    }</span>\n<span id=\"cb124-10\"><a href=\"#cb124-10\"></a></span>\n<span id=\"cb124-11\"><a href=\"#cb124-11\"></a>    pair, ok := hashObject.Pairs[key.HashKey()]</span>\n<span id=\"cb124-12\"><a href=\"#cb124-12\"></a>    <span class=\"kw\">if</span> !ok {</span>\n<span id=\"cb124-13\"><a href=\"#cb124-13\"></a>        <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb124-14\"><a href=\"#cb124-14\"></a>    }</span>\n<span id=\"cb124-15\"><a href=\"#cb124-15\"></a></span>\n<span id=\"cb124-16\"><a href=\"#cb124-16\"></a>    <span class=\"kw\">return</span> pair.Value</span>\n<span id=\"cb124-17\"><a href=\"#cb124-17\"></a>}</span></code></pre></div>\n<p>Adding <code>evalHashIndexExpression</code> to the switch statement makes the tests pass:</p>\n<div class=\"sourceCode\" id=\"cb125\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb125-1\"><a href=\"#cb125-1\"></a>$ go test ./evaluator</span>\n<span id=\"cb125-2\"><a href=\"#cb125-2\"></a>ok      monkey/evaluator        0.007s</span></code></pre></div>\n<p>We can now successfully retrieve values from our hashes! Don’t believe me? Think the tests are lying to us? I faked the test output? It can’t be? The whole book is full of li.. what? No, watch this.</p>\n<div class=\"sourceCode\" id=\"cb126\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb126-1\"><a href=\"#cb126-1\"></a>$ go run main.go</span>\n<span id=\"cb126-2\"><a href=\"#cb126-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb126-3\"><a href=\"#cb126-3\"></a>Feel free to type in commands</span>\n<span id=\"cb126-4\"><a href=\"#cb126-4\"></a>&gt;&gt; let people = [{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 24}, {&quot;name&quot;: &quot;Anna&quot;, &quot;age&quot;: 28}];</span>\n<span id=\"cb126-5\"><a href=\"#cb126-5\"></a>&gt;&gt; people[0][&quot;name&quot;];</span>\n<span id=\"cb126-6\"><a href=\"#cb126-6\"></a>Alice</span>\n<span id=\"cb126-7\"><a href=\"#cb126-7\"></a>&gt;&gt; people[1][&quot;age&quot;];</span>\n<span id=\"cb126-8\"><a href=\"#cb126-8\"></a>28</span>\n<span id=\"cb126-9\"><a href=\"#cb126-9\"></a>&gt;&gt; people[1][&quot;age&quot;] + people[0][&quot;age&quot;];</span>\n<span id=\"cb126-10\"><a href=\"#cb126-10\"></a>52</span>\n<span id=\"cb126-11\"><a href=\"#cb126-11\"></a>&gt;&gt; let getName = fn(person) { person[&quot;name&quot;]; };</span>\n<span id=\"cb126-12\"><a href=\"#cb126-12\"></a>&gt;&gt; getName(people[0]);</span>\n<span id=\"cb126-13\"><a href=\"#cb126-13\"></a>Alice</span>\n<span id=\"cb126-14\"><a href=\"#cb126-14\"></a>&gt;&gt; getName(people[1]);</span>\n<span id=\"cb126-15\"><a href=\"#cb126-15\"></a>Anna</span></code></pre></div>\n</section>\n</section>\n<section id=\"the-grand-finale\" class=\"level2\" data-number=\"4.6\">\n<h2 data-number=\"4.6\">4.6 - The Grand Finale</h2>\n<p>Our Monkey interpreter is now fully functional. It supports mathematical expressions, variable bindings, functions and the application of those functions, conditionals, return statements and even advanced concepts like higher-order functions and closures. And then there are the different data types: integers, booleans, strings, arrays and hashes. We can be proud of ourselves.</p>\n<p>But… and here comes the but… our interpreter still does not pass the most basic of all programming language tests: printing something. Yes, our Monkey interpreter can’t communicate with the outside world. Even programming language scoundrel like Bash and Brainfuck manage to do that. It’s clear what we have to do. We have to add one last built-in function: <code>puts</code>.</p>\n<p><code>puts</code> prints the given arguments on new lines to STDOUT. It calls the <code>Inspect()</code> method on the objects passed in as arguments and prints the return value of these calls. The <code>Inspect()</code> method is part of the <code>Object</code> interface, so every entity in our object system supports it. Using <code>puts</code> should look kinda like this:</p>\n<div class=\"sourceCode\" id=\"cb127\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb127-1\"><a href=\"#cb127-1\"></a>&gt;&gt; puts(&quot;Hello!&quot;)</span>\n<span id=\"cb127-2\"><a href=\"#cb127-2\"></a>Hello!</span>\n<span id=\"cb127-3\"><a href=\"#cb127-3\"></a>&gt;&gt; puts(1234)</span>\n<span id=\"cb127-4\"><a href=\"#cb127-4\"></a>1234</span>\n<span id=\"cb127-5\"><a href=\"#cb127-5\"></a>&gt;&gt; puts(fn(x) { x * x })</span>\n<span id=\"cb127-6\"><a href=\"#cb127-6\"></a>fn(x) {</span>\n<span id=\"cb127-7\"><a href=\"#cb127-7\"></a>(x * x)</span>\n<span id=\"cb127-8\"><a href=\"#cb127-8\"></a>}</span></code></pre></div>\n<p>And <code>puts</code> is a variadic function. It takes an unlimited number of arguments and prints each on a separate line:</p>\n<div class=\"sourceCode\" id=\"cb128\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb128-1\"><a href=\"#cb128-1\"></a>&gt;&gt; puts(&quot;hello&quot;, &quot;world&quot;, &quot;how&quot;, &quot;are&quot;, &quot;you&quot;)</span>\n<span id=\"cb128-2\"><a href=\"#cb128-2\"></a>hello</span>\n<span id=\"cb128-3\"><a href=\"#cb128-3\"></a>world</span>\n<span id=\"cb128-4\"><a href=\"#cb128-4\"></a>how</span>\n<span id=\"cb128-5\"><a href=\"#cb128-5\"></a>are</span>\n<span id=\"cb128-6\"><a href=\"#cb128-6\"></a>you</span></code></pre></div>\n<p>Of course, <code>puts</code> is all about printing things and not producing a value, so we need to make sure that it returns <code>NULL</code>:</p>\n<div class=\"sourceCode\" id=\"cb129\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb129-1\"><a href=\"#cb129-1\"></a>&gt;&gt; let putsReturnValue = puts(&quot;foobar&quot;);</span>\n<span id=\"cb129-2\"><a href=\"#cb129-2\"></a>foobar</span>\n<span id=\"cb129-3\"><a href=\"#cb129-3\"></a>&gt;&gt; putsReturnValue</span>\n<span id=\"cb129-4\"><a href=\"#cb129-4\"></a>null</span></code></pre></div>\n<p>That also means that our REPL will print the <code>null</code> in addition to the output we expect from <code>puts</code>. So it will look like this:</p>\n<div class=\"sourceCode\" id=\"cb130\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb130-1\"><a href=\"#cb130-1\"></a>&gt;&gt; puts(&quot;Hello!&quot;)</span>\n<span id=\"cb130-2\"><a href=\"#cb130-2\"></a>Hello!</span>\n<span id=\"cb130-3\"><a href=\"#cb130-3\"></a>null</span></code></pre></div>\n<p>Now that’s more than enough information and specification to complete this last quest of ours. Are you ready?</p>\n<p>Here it is, here’s what this section has been building up to, here is the complete, working implementation of <code>puts</code>:</p>\n<div class=\"sourceCode\" id=\"cb131\"><pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb131-1\"><a href=\"#cb131-1\"></a><span class=\"co\">// evaluator/builtins.go</span></span>\n<span id=\"cb131-2\"><a href=\"#cb131-2\"></a></span>\n<span id=\"cb131-3\"><a href=\"#cb131-3\"></a><span class=\"kw\">import</span> (</span>\n<span id=\"cb131-4\"><a href=\"#cb131-4\"></a>    <span class=\"st\">&quot;fmt&quot;</span></span>\n<span id=\"cb131-5\"><a href=\"#cb131-5\"></a>    <span class=\"st\">&quot;monkey/object&quot;</span></span>\n<span id=\"cb131-6\"><a href=\"#cb131-6\"></a>)</span>\n<span id=\"cb131-7\"><a href=\"#cb131-7\"></a></span>\n<span id=\"cb131-8\"><a href=\"#cb131-8\"></a><span class=\"kw\">var</span> builtins = <span class=\"kw\">map</span>[<span class=\"dt\">string</span>]*object.Builtin{</span>\n<span id=\"cb131-9\"><a href=\"#cb131-9\"></a><span class=\"co\">// [...]</span></span>\n<span id=\"cb131-10\"><a href=\"#cb131-10\"></a>    <span class=\"st\">&quot;puts&quot;</span>: &amp;object.Builtin{</span>\n<span id=\"cb131-11\"><a href=\"#cb131-11\"></a>        Fn: <span class=\"kw\">func</span>(args ...object.Object) object.Object {</span>\n<span id=\"cb131-12\"><a href=\"#cb131-12\"></a>            <span class=\"kw\">for</span> _, arg := <span class=\"kw\">range</span> args {</span>\n<span id=\"cb131-13\"><a href=\"#cb131-13\"></a>                fmt.Println(arg.Inspect())</span>\n<span id=\"cb131-14\"><a href=\"#cb131-14\"></a>            }</span>\n<span id=\"cb131-15\"><a href=\"#cb131-15\"></a></span>\n<span id=\"cb131-16\"><a href=\"#cb131-16\"></a>            <span class=\"kw\">return</span> NULL</span>\n<span id=\"cb131-17\"><a href=\"#cb131-17\"></a>        },</span>\n<span id=\"cb131-18\"><a href=\"#cb131-18\"></a>    },</span>\n<span id=\"cb131-19\"><a href=\"#cb131-19\"></a>}</span></code></pre></div>\n<p>And with that, we did it. We’re done. Even if you were wary of our little celebrations and shrugged them off before, now’s the time to go looking for a funny party hat and put it on.</p>\n<p>In chapter three we brought the Monkey programming language to life. It started to breathe. With our last change, we made it talk. Now, Monkey is finally a real programming language:</p>\n<div class=\"sourceCode\" id=\"cb132\"><pre class=\"sourceCode changelog\"><code class=\"sourceCode changelog\"><span id=\"cb132-1\"><a href=\"#cb132-1\"></a>$ go run main.go</span>\n<span id=\"cb132-2\"><a href=\"#cb132-2\"></a>Hello mrnugget! This is the Monkey programming language!</span>\n<span id=\"cb132-3\"><a href=\"#cb132-3\"></a>Feel free to type in commands</span>\n<span id=\"cb132-4\"><a href=\"#cb132-4\"></a>&gt;&gt; puts(&quot;Hello World!&quot;)</span>\n<span id=\"cb132-5\"><a href=\"#cb132-5\"></a>Hello World!</span>\n<span id=\"cb132-6\"><a href=\"#cb132-6\"></a>null</span>\n<span id=\"cb132-7\"><a href=\"#cb132-7\"></a>&gt;&gt;</span></code></pre></div>\n</section>\n</section>\n</body>\n</html>\n" }, Chapter { title: "Going Further", sections: [Section { title: "Going Further", start_line: 0, fragment_id: Some("going-further") }, Section { title: "The Lost Chapter", start_line: 2, fragment_id: Some("the-lost-chapter") }, Section { title: "Writing A Compiler In Go", start_line: 12, fragment_id: Some("writing-a-compiler-in-go") }], content_lines: [RenderedLine { text: "Going Further", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The Lost Chapter", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Nearly half a year after publishing the first version of Writing An", style: Normal, search_matches: [], inline_styles: [(57, 67, Italic)], syntax_colors: [] }, RenderedLine { text: "Interpreter In Go, I decided to add another chapter. It’s called The Lost", style: Normal, search_matches: [], inline_styles: [(0, 17, Italic), (67, 75, Italic)], syntax_colors: [] }, RenderedLine { text: "Chapter: A Macro System For Monkey and available for free. You can read or", style: Normal, search_matches: [], inline_styles: [(0, 35, Italic)], syntax_colors: [] }, RenderedLine { text: "download it as an eBook at https://interpreterbook.com/lost.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Writing A Compiler In Go", style: Heading2, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Figure]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "[Image]", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Writing A Compiler In Go is the sequel to Writing An Interpreter In Go and", style: Normal, search_matches: [], inline_styles: [(0, 24, Italic), (42, 70, Italic)], syntax_colors: [] }, RenderedLine { text: "contains the next step in Monkey’s evolution: a bytecode compiler and a", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "virtual machine. It’s the same codebase and the same approach, the books", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "connect seamlessly, except that Monkey ends up being 3 times faster.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "You find out more about it and buy it at https://compilerbook.com.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>ch007.xhtml</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"bodymatter\">\n<section id=\"going-further\" class=\"level1 unnumbered\" data-number=\"\">\n<h1 class=\"unnumbered\" data-number=\"\">Going Further</h1>\n<section id=\"the-lost-chapter\" class=\"level2\" data-number=\"4.7\">\n<h2 data-number=\"4.7\">The Lost Chapter</h2>\n<figure>\n<img src=\"../media/file8.png\" width=\"150\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p>Nearly half a year after publishing the first version of <em>Writing An Interpreter In Go</em>, I decided to add another chapter. It’s called <em>The Lost Chapter: A Macro System For Monkey</em> and available for free. You can read or download it as an eBook at <a href=\"https://interpreterbook.com/lost\">https://interpreterbook.com/lost</a>.</p>\n</section>\n<section id=\"writing-a-compiler-in-go\" class=\"level2\" data-number=\"4.8\">\n<h2 data-number=\"4.8\">Writing A Compiler In Go</h2>\n<figure>\n<img src=\"../media/file9.png\" width=\"150\" alt=\"\" /><figcaption>\u{a0}</figcaption>\n</figure>\n<p><em>Writing A Compiler In Go</em> is the sequel to <em>Writing An Interpreter In Go</em> and contains the next step in Monkey’s evolution: a bytecode compiler and a virtual machine. It’s the same codebase and the same approach, the books connect seamlessly, except that Monkey ends up being 3 times faster.</p>\n<p>You find out more about it and buy it at <a href=\"https://compilerbook.com\">https://compilerbook.com</a>.</p>\n</section>\n</section>\n</body>\n</html>\n" }, Chapter { title: "Resources", sections: [Section { title: "Resources", start_line: 0, fragment_id: Some("resources") }], content_lines: [RenderedLine { text: "Resources", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Books", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Abelson, Harold and Sussman, Gerald Jay with Sussman, Julie. 1996.", style: Normal, search_matches: [], inline_styles: [(69, 70, Bold)], syntax_colors: [] }, RenderedLine { text: "Structure and Interpretation of Computer Programs, Second Edition. MIT", style: Normal, search_matches: [], inline_styles: [(0, 64, Bold)], syntax_colors: [] }, RenderedLine { text: "Press.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Appel, Andrew W.. 2004. Modern Compiler Implementation in C. Cambridge", style: Normal, search_matches: [], inline_styles: [(26, 61, Bold)], syntax_colors: [] }, RenderedLine { text: "University Press.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Cooper, Keith D. and Torczon Linda. 2011. Engineering a Compiler, Second", style: Normal, search_matches: [], inline_styles: [(44, 76, Bold)], syntax_colors: [] }, RenderedLine { text: "Edition. Morgan Kaufmann.", style: Normal, search_matches: [], inline_styles: [(0, 6, Bold)], syntax_colors: [] }, RenderedLine { text: "• Grune, Dick and Jacobs, Ceriel. 1990. Parsing Techniques. A Practical", style: Normal, search_matches: [], inline_styles: [(40, 73, Bold)], syntax_colors: [] }, RenderedLine { text: "Guide.. Ellis Horwood Limited.", style: Normal, search_matches: [], inline_styles: [(0, 5, Bold)], syntax_colors: [] }, RenderedLine { text: "• Grune, Dick and van Reeuwijk, Kees and Bal Henri E. and Jacobs, Ceriel", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "J.H. Jacobs and Langendoen, Koen. 2012. Modern Compiler Design, Second", style: Normal, search_matches: [], inline_styles: [(39, 70, Bold)], syntax_colors: [] }, RenderedLine { text: "Edition. Springer", style: Normal, search_matches: [], inline_styles: [(0, 7, Bold)], syntax_colors: [] }, RenderedLine { text: "• Nisan, Noam and Schocken, Shimon. 2008. The Elements Of Computing", style: Normal, search_matches: [], inline_styles: [(42, 69, Bold)], syntax_colors: [] }, RenderedLine { text: "Systems. MIT Press.", style: Normal, search_matches: [], inline_styles: [(0, 6, Bold)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Papers", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Ayock, John. 2003. A Brief History of Just-In-Time. In ACM Computing", style: Normal, search_matches: [], inline_styles: [(21, 52, Bold), (57, 72, Bold)], syntax_colors: [] }, RenderedLine { text: "Surveys, Vol. 35, No.\u{a0}2, June 2003", style: Normal, search_matches: [], inline_styles: [(0, 34, Bold)], syntax_colors: [] }, RenderedLine { text: "• Ertl, M. Anton and Gregg, David. 2003. The Structure and Performance", style: Normal, search_matches: [], inline_styles: [(41, 72, Bold)], syntax_colors: [] }, RenderedLine { text: "of Efficient Interpreters. In Journal Of Instruction-Level Parallelism", style: Normal, search_matches: [], inline_styles: [(0, 24, Bold), (29, 70, Bold)], syntax_colors: [] }, RenderedLine { text: "5 (2003)", style: Normal, search_matches: [], inline_styles: [(0, 8, Bold)], syntax_colors: [] }, RenderedLine { text: "• Ghuloum, Abdulaziz. 2006. An Incremental Approach To Compiler", style: Normal, search_matches: [], inline_styles: [(28, 65, Bold)], syntax_colors: [] }, RenderedLine { text: "Construction. In Proceedings of the 2006 Scheme and Functional Programming", style: Normal, search_matches: [], inline_styles: [(0, 11, Bold), (16, 74, Bold)], syntax_colors: [] }, RenderedLine { text: "Workshop.", style: Normal, search_matches: [], inline_styles: [(0, 8, Bold)], syntax_colors: [] }, RenderedLine { text: "• Ierusalimschy, Robert and de Figueiredo, Luiz Henrique and Celes", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Waldemar. The Implementation of Lua 5.0. https://www.lua.org/doc/", style: Normal, search_matches: [], inline_styles: [(9, 38, Bold)], syntax_colors: [] }, RenderedLine { text: "jucs05.pdf", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Pratt, Vaughan R. 1973. Top Down Operator Precedence. Massachusetts", style: Normal, search_matches: [], inline_styles: [(26, 54, Bold)], syntax_colors: [] }, RenderedLine { text: "Institute of Technology.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Romer, Theodore H. and Lee, Dennis and Voelker, Geoffrey M. and Wolman,", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Alec and Wong, Wayne A. and Baer, Jean-Loup and Bershad, Brian N. and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Levy, Henry M.. 1996. The Structure and Performance of Interpreters.", style: Normal, search_matches: [], inline_styles: [(22, 67, Bold)], syntax_colors: [] }, RenderedLine { text: "In ASPLOS VII Proceedings of the seventh international conference on", style: Normal, search_matches: [], inline_styles: [(3, 68, Bold)], syntax_colors: [] }, RenderedLine { text: "Architectural support for programming languages and operating systems.", style: Normal, search_matches: [], inline_styles: [(0, 69, Bold)], syntax_colors: [] }, RenderedLine { text: "• Dybvig, R. Kent. 2006. The Development of Chez Scheme. In ACM ICFP ’06", style: Normal, search_matches: [], inline_styles: [(25, 55, Bold), (60, 74, Bold)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Web", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Jack W. Crenshaw - Let’s Build a Compiler! - http://compilers.iecc.com/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "crenshaw/tutorfinal.pdf", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Douglas Crockford - Top Down Operator Precedence - http://", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "javascript.crockford.com/tdop/tdop.html", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Bob Nystrom - Expression Parsing Made Easy - http://", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "made-easy/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Shriram Krishnamurthi and Joe Gibbs Politz - Programming Languages:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Application and Interpretation - http://papl.cs.brown.edu/2015/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• A Python Interpreter Written In Python - http://aosabook.org/en/500L/a-", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "python-interpreter-written-in-python.html", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Dr.\u{a0}Dobbs - Bob: A Tiny Object-Oriented Language - http://", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "www.drdobbs.com/open-source/bob-a-tiny-object-oriented-language/184409401", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Nick Desaulniers - Interpreter, Compiler, JIT - https://", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "nickdesaulniers.github.io/blog/2015/05/25/interpreter-compiler-jit/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Peter Norvig - (How to Write a (Lisp) Interpreter (in Python)) - http://", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "norvig.com/lispy.html", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fredrik Lundh - Simple Town-Down Parsing In Python - http://effbot.org/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "zone/simple-top-down-parsing.htm", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Mihai Bazon - How to implement a programming language in JavaScript -", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "http://lisperator.net/pltut/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Mary Rose Cook - Little Lisp interpreter - https://www.recurse.com/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "blog/21-little-lisp-interpreter", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Peter Michaux - Scheme From Scratch - http://peter.michaux.ca/articles/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "scheme-from-scratch-introduction", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Make a Lisp - https://github.com/kanaka/mal", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Matt Might - Compiling Scheme to C with closure conversion - http://", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "matt.might.net/articles/compiling-scheme-to-c/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Rob Pike - Implementing a bignum calculator - https://www.youtube.com/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "watch?v=PXoG0WX0r_E", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Rob Pike - Lexical Scanning in Go - https://www.youtube.com/watch?", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "v=HxaD_trXwRE", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Source Code", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• The Wren Programming Language - https://github.com/munificent/wren", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Otto - A JavaScript Interpreter In Go - https://github.com/robertkrimen/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "otto", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• The Go Programming Language - https://github.com/golang/go", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• The Lua Programming Language (1.1, 3.1, 5.3.2) - https://www.lua.org/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "versions.html", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• The Ruby Programming Language - https://github.com/ruby/ruby", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• c4 - C in four functions - https://github.com/rswier/c4", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• tcc - Tiny C Compiler - https://github.com/LuaDist/tcc", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• 8cc - A Small C Compiler - https://github.com/rui314/8cc", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fedjmike/mini-c - https://github.com/Fedjmike/mini-c", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• thejameskyle/the-super-tiny-compiler - https://github.com/thejameskyle/", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the-super-tiny-compiler", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• lisp.c - https://gist.github.com/sanxiyn/523967", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>ch008.xhtml</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"bodymatter\">\n<section id=\"resources\" class=\"level1 unnumbered\" data-number=\"\">\n<h1 class=\"unnumbered\" data-number=\"\">Resources</h1>\n<section id=\"books\" class=\"level4\" data-number=\"4.8.0.1\">\n<h4 data-number=\"4.8.0.1\">Books</h4>\n<ul>\n<li>Abelson, Harold and Sussman, Gerald Jay with Sussman, Julie. 1996. <strong>Structure and Interpretation of Computer Programs, Second Edition</strong>. MIT Press.</li>\n<li>Appel, Andrew W.. 2004. <strong>Modern Compiler Implementation in C</strong>. Cambridge University Press.</li>\n<li>Cooper, Keith D. and Torczon Linda. 2011. <strong>Engineering a Compiler, Second Edition</strong>. Morgan Kaufmann.</li>\n<li>Grune, Dick and Jacobs, Ceriel. 1990. <strong>Parsing Techniques. A Practical Guide.</strong>. Ellis Horwood Limited.</li>\n<li>Grune, Dick and van Reeuwijk, Kees and Bal Henri E. and Jacobs, Ceriel J.H. Jacobs and Langendoen, Koen. 2012. <strong>Modern Compiler Design, Second Edition</strong>. Springer</li>\n<li>Nisan, Noam and Schocken, Shimon. 2008. <strong>The Elements Of Computing Systems</strong>. MIT Press.</li>\n</ul>\n</section>\n<section id=\"papers\" class=\"level4\" data-number=\"4.8.0.2\">\n<h4 data-number=\"4.8.0.2\">Papers</h4>\n<ul>\n<li>Ayock, John. 2003. <strong>A Brief History of Just-In-Time</strong>. In <strong>ACM Computing Surveys, Vol. 35, No.\u{a0}2, June 2003</strong></li>\n<li>Ertl, M. Anton and Gregg, David. 2003. <strong>The Structure and Performance of Efficient Interpreters</strong>. In <strong>Journal Of Instruction-Level Parallelism 5 (2003)</strong></li>\n<li>Ghuloum, Abdulaziz. 2006. <strong>An Incremental Approach To Compiler Construction</strong>. In <strong>Proceedings of the 2006 Scheme and Functional Programming Workshop</strong>.</li>\n<li>Ierusalimschy, Robert and de Figueiredo, Luiz Henrique and Celes Waldemar. <strong>The Implementation of Lua 5.0</strong>. <a href=\"https://www.lua.org/doc/jucs05.pdf\">https://www.lua.org/doc/jucs05.pdf</a></li>\n<li>Pratt, Vaughan R. 1973. <strong>Top Down Operator Precedence</strong>. Massachusetts Institute of Technology.</li>\n<li>Romer, Theodore H. and Lee, Dennis and Voelker, Geoffrey M. and Wolman, Alec and Wong, Wayne A. and Baer, Jean-Loup and Bershad, Brian N. and Levy, Henry M.. 1996. <strong>The Structure and Performance of Interpreters</strong>. In <strong>ASPLOS VII Proceedings of the seventh international conference on Architectural support for programming languages and operating systems</strong>.</li>\n<li>Dybvig, R. Kent. 2006. <strong>The Development of Chez Scheme</strong>. In <strong>ACM ICFP ’06</strong></li>\n</ul>\n</section>\n<section id=\"web\" class=\"level4\" data-number=\"4.8.0.3\">\n<h4 data-number=\"4.8.0.3\">Web</h4>\n<ul>\n<li>Jack W. Crenshaw - Let’s Build a Compiler! - <a href=\"http://compilers.iecc.com/crenshaw/tutorfinal.pdf\">http://compilers.iecc.com/crenshaw/tutorfinal.pdf</a></li>\n<li>Douglas Crockford - Top Down Operator Precedence - <a href=\"http://javascript.crockford.com/tdop/tdop.html\">http://javascript.crockford.com/tdop/tdop.html</a></li>\n<li>Bob Nystrom - Expression Parsing Made Easy - <a href=\"http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\">http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/</a></li>\n<li>Shriram Krishnamurthi and Joe Gibbs Politz - Programming Languages: Application and Interpretation - <a href=\"http://papl.cs.brown.edu/2015/\">http://papl.cs.brown.edu/2015/</a></li>\n<li>A Python Interpreter Written In Python - <a href=\"http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html\">http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html</a></li>\n<li>Dr.\u{a0}Dobbs - Bob: A Tiny Object-Oriented Language - <a href=\"http://www.drdobbs.com/open-source/bob-a-tiny-object-oriented-language/184409401\">http://www.drdobbs.com/open-source/bob-a-tiny-object-oriented-language/184409401</a></li>\n<li>Nick Desaulniers - Interpreter, Compiler, JIT - <a href=\"https://nickdesaulniers.github.io/blog/2015/05/25/interpreter-compiler-jit/\">https://nickdesaulniers.github.io/blog/2015/05/25/interpreter-compiler-jit/</a></li>\n<li>Peter Norvig - (How to Write a (Lisp) Interpreter (in Python)) - <a href=\"http://norvig.com/lispy.html\">http://norvig.com/lispy.html</a></li>\n<li>Fredrik Lundh - Simple Town-Down Parsing In Python - <a href=\"http://effbot.org/zone/simple-top-down-parsing.htm\">http://effbot.org/zone/simple-top-down-parsing.htm</a></li>\n<li>Mihai Bazon - How to implement a programming language in JavaScript - <a href=\"http://lisperator.net/pltut/\">http://lisperator.net/pltut/</a></li>\n<li>Mary Rose Cook - Little Lisp interpreter - <a href=\"https://www.recurse.com/blog/21-little-lisp-interpreter\">https://www.recurse.com/blog/21-little-lisp-interpreter</a></li>\n<li>Peter Michaux - Scheme From Scratch - <a href=\"http://peter.michaux.ca/articles/scheme-from-scratch-introduction\">http://peter.michaux.ca/articles/scheme-from-scratch-introduction</a></li>\n<li>Make a Lisp - <a href=\"https://github.com/kanaka/mal\">https://github.com/kanaka/mal</a></li>\n<li>Matt Might - Compiling Scheme to C with closure conversion - <a href=\"http://matt.might.net/articles/compiling-scheme-to-c/\">http://matt.might.net/articles/compiling-scheme-to-c/</a></li>\n<li>Rob Pike - Implementing a bignum calculator - <a href=\"https://www.youtube.com/watch?v=PXoG0WX0r_E\">https://www.youtube.com/watch?v=PXoG0WX0r_E</a></li>\n<li>Rob Pike - Lexical Scanning in Go - <a href=\"https://www.youtube.com/watch?v=HxaD_trXwRE\">https://www.youtube.com/watch?v=HxaD_trXwRE</a></li>\n</ul>\n</section>\n<section id=\"source-code\" class=\"level4\" data-number=\"4.8.0.4\">\n<h4 data-number=\"4.8.0.4\">Source Code</h4>\n<ul>\n<li>The Wren Programming Language - <a href=\"https://github.com/munificent/wren\">https://github.com/munificent/wren</a></li>\n<li>Otto - A JavaScript Interpreter In Go - <a href=\"https://github.com/robertkrimen/otto\">https://github.com/robertkrimen/otto</a></li>\n<li>The Go Programming Language - <a href=\"https://github.com/golang/go\">https://github.com/golang/go</a></li>\n<li>The Lua Programming Language (1.1, 3.1, 5.3.2) - <a href=\"https://www.lua.org/versions.html\">https://www.lua.org/versions.html</a></li>\n<li>The Ruby Programming Language - <a href=\"https://github.com/ruby/ruby\">https://github.com/ruby/ruby</a></li>\n<li>c4 - C in four functions - <a href=\"https://github.com/rswier/c4\">https://github.com/rswier/c4</a></li>\n<li>tcc - Tiny C Compiler - <a href=\"https://github.com/LuaDist/tcc\">https://github.com/LuaDist/tcc</a></li>\n<li>8cc - A Small C Compiler - <a href=\"https://github.com/rui314/8cc\">https://github.com/rui314/8cc</a></li>\n<li>Fedjmike/mini-c - <a href=\"https://github.com/Fedjmike/mini-c\">https://github.com/Fedjmike/mini-c</a></li>\n<li>thejameskyle/the-super-tiny-compiler - <a href=\"https://github.com/thejameskyle/the-super-tiny-compiler\">https://github.com/thejameskyle/the-super-tiny-compiler</a></li>\n<li>lisp.c - <a href=\"https://gist.github.com/sanxiyn/523967\">https://gist.github.com/sanxiyn/523967</a></li>\n</ul>\n</section>\n</section>\n</body>\n</html>\n" }, Chapter { title: "Feedback", sections: [Section { title: "Feedback", start_line: 0, fragment_id: Some("feedback") }], content_lines: [RenderedLine { text: "Feedback", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "If you spot a typo, find something wrong with the code, have a suggestion to", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "make or just a question, feel free to send me an email:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "me@thorstenball.com", style: Normal, search_matches: [], inline_styles: [(0, 19, Bold)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>ch009.xhtml</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"bodymatter\">\n<section id=\"feedback\" class=\"level1 unnumbered\" data-number=\"\">\n<h1 class=\"unnumbered\" data-number=\"\">Feedback</h1>\n<p>If you spot a typo, find something wrong with the code, have a suggestion to make or just a question, feel free to send me an email:</p>\n<p><strong>me@thorstenball.com</strong></p>\n</section>\n</body>\n</html>\n" }, Chapter { title: "Changelog", sections: [Section { title: "Changelog", start_line: 0, fragment_id: Some("changelog") }], content_lines: [RenderedLine { text: "Changelog", style: Heading1, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "7 May 2020 - 1.7", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Code:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Added go.mod files to the code folder so that users with Go >= 1.13 can", style: Normal, search_matches: [], inline_styles: [(6, 12, Code)], syntax_colors: [] }, RenderedLine { text: "easily run it without having to set $GOPATH", style: Normal, search_matches: [], inline_styles: [(36, 43, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Added go.mod files to the code folder so that users with Go >= 1.13 can", style: Normal, search_matches: [], inline_styles: [(8, 14, Code)], syntax_colors: [] }, RenderedLine { text: "easily run it without having to set $GOPATH", style: Normal, search_matches: [], inline_styles: [(35, 42, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 1.5:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Update wrong token types in example Lexer output", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Change from fmt.Printf to fmt.Fprintf to make use of out", style: Normal, search_matches: [], inline_styles: [(13, 23, Code), (27, 38, Code), (54, 56, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Update wrong token types in example Lexer output", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Change from fmt.Printf to fmt.Fprintf to make use of out", style: Normal, search_matches: [], inline_styles: [(14, 24, Code), (28, 39, Code), (55, 58, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 1.3:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix a grammar mistake by removing the additional “the” in “Of the course”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix a grammar mistake by removing the additional “the” in “Of the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "course”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 2.9:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix a typo by changing “intends” to “indents”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix a typo by changing “intends” to “indents”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 3.9:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Change “How to we” to “How do we”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix missing word in “we should bind it too” by rewriting sentence", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Change “How to we” to “How do we”", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix missing word in “we should bind it too” by rewriting sentence", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "20 March 2019 - 1.6", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 2.4:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wrong parseOperatorExpression in pseudo-code example for recursive-", style: Normal, search_matches: [], inline_styles: [(10, 33, Code)], syntax_colors: [] }, RenderedLine { text: "descent parser", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wrong parseOperatorExpression in pseudo-code example for recursive-", style: Normal, search_matches: [], inline_styles: [(12, 35, Code)], syntax_colors: [] }, RenderedLine { text: "descent parser", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 2.5:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Change wrong capitalization in test error message", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Change wrong capitalization in test error message", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 4.5:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Correct explanation of HashKey by clarifying that ObjectType is a string", style: Normal, search_matches: [], inline_styles: [(23, 30, Code), (50, 60, Code), (66, 72, Code)], syntax_colors: [] }, RenderedLine { text: "(as opposed to an integer)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Correct explanation of HashKey by clarifying that ObjectType is a string", style: Normal, search_matches: [], inline_styles: [(25, 32, Code), (52, 62, Code), (68, 74, Code)], syntax_colors: [] }, RenderedLine { text: "(as opposed to an integer)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "31 July 2018 - 1.5", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides fixes for various typos and spelling errors:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Chapter 2:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wrong mention of program.Body in test error messages and change it", style: Normal, search_matches: [], inline_styles: [(21, 33, Code)], syntax_colors: [] }, RenderedLine { text: "to program.Statements", style: Normal, search_matches: [], inline_styles: [(3, 21, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wrong mention of program.Body in test error messages and change it", style: Normal, search_matches: [], inline_styles: [(23, 35, Code)], syntax_colors: [] }, RenderedLine { text: "to program.Statements", style: Normal, search_matches: [], inline_styles: [(2, 20, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 1.3:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Make it clearer where to put import \"monkey/token\" line", style: Normal, search_matches: [], inline_styles: [(29, 50, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Make it clearer where to put import \"monkey/token\" line", style: Normal, search_matches: [], inline_styles: [(31, 52, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 2.4:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wrong error message in testLetStatement helper function", style: Normal, search_matches: [], inline_styles: [(27, 43, Code)], syntax_colors: [] }, RenderedLine { text: "Fix wrong indentation of input in test function", style: Normal, search_matches: [], inline_styles: [(26, 31, Code)], syntax_colors: [] }, RenderedLine { text: "Fix missing imports of fmt package", style: Normal, search_matches: [], inline_styles: [(25, 28, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wrong error message in testLetStatement helper function", style: Normal, search_matches: [], inline_styles: [(29, 45, Code)], syntax_colors: [] }, RenderedLine { text: "• Fix wrong indentation of input in test function", style: Normal, search_matches: [], inline_styles: [(27, 32, Code)], syntax_colors: [] }, RenderedLine { text: "• Fix missing imports of fmt package", style: Normal, search_matches: [], inline_styles: [(25, 28, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 2.5:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wrong mention of ParseProgram instead of the correct parseStatement", style: Normal, search_matches: [], inline_styles: [(21, 33, Code), (57, 71, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wrong mention of ParseProgram instead of the correct parseStatement", style: Normal, search_matches: [], inline_styles: [(23, 35, Code), (59, 73, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 2.6:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wrong explanation of failing test output in prefix operators section", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wrong explanation of the for-loop condition in parseExpression", style: Normal, search_matches: [], inline_styles: [(52, 66, Code)], syntax_colors: [] }, RenderedLine { text: "Rename local variable oe to ie in *ast.InfixExpression methods", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (24, 26, Code), (30, 32, Code), (36, 56, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wrong explanation of failing test output in prefix operators section", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wrong explanation of the for-loop condition in parseExpression", style: Normal, search_matches: [], inline_styles: [(53, 68, Code)], syntax_colors: [] }, RenderedLine { text: "• Rename local variable oe to ie in *ast.InfixExpression methods", style: Normal, search_matches: [], inline_styles: [(24, 26, Code), (30, 32, Code), (36, 56, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 2.8:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Change post-refactoring version of TestParsingInfixExpressions to make", style: Normal, search_matches: [], inline_styles: [(35, 62, Code)], syntax_colors: [] }, RenderedLine { text: "clearer that it has been refactored", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wrong error message in testInfixExpression", style: Normal, search_matches: [], inline_styles: [(28, 46, Code)], syntax_colors: [] }, RenderedLine { text: "Fix wrong output in test error message (“true” to “TRUE”)", style: Normal, search_matches: [], inline_styles: [(0, 1, Code)], syntax_colors: [] }, RenderedLine { text: "Add missing import of strings package", style: Normal, search_matches: [], inline_styles: [(25, 32, Code)], syntax_colors: [] }, RenderedLine { text: "Change wording to make clearer that the section includes changes to the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "existing test suite", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Change post-refactoring version of TestParsingInfixExpressions to make", style: Normal, search_matches: [], inline_styles: [(37, 64, Code)], syntax_colors: [] }, RenderedLine { text: "clearer that it has been refactored", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wrong error message in testInfixExpression", style: Normal, search_matches: [], inline_styles: [(29, 48, Code)], syntax_colors: [] }, RenderedLine { text: "• Fix wrong output in test error message (“true” to “TRUE”)", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Add missing import of strings package", style: Normal, search_matches: [], inline_styles: [(24, 31, Code)], syntax_colors: [] }, RenderedLine { text: "• Change wording to make clearer that the section includes changes to the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "existing test suite", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 2.9:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Add the missing import of monkey/parser to the REPL code", style: Normal, search_matches: [], inline_styles: [(16, 22, Code), (26, 39, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Add the missing import of monkey/parser to the REPL code", style: Normal, search_matches: [], inline_styles: [(18, 24, Code), (28, 41, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 3.5:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wrong error message in failing test output for", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "TestEvalBooleanExpression", style: Normal, search_matches: [], inline_styles: [(0, 25, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wrong error message in failing test output for", style: Normal, search_matches: [], inline_styles: [(53, 54, Code)], syntax_colors: [] }, RenderedLine { text: "TestEvalBooleanExpression", style: Normal, search_matches: [], inline_styles: [(0, 24, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 3.8:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Add missing import of fmt", style: Normal, search_matches: [], inline_styles: [(22, 25, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Add missing import of fmt", style: Normal, search_matches: [], inline_styles: [(24, 27, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 3.10:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Add missing import", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Add missing import", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Chapter 4:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Remove unused import of unicode/utf8 package", style: Normal, search_matches: [], inline_styles: [(24, 36, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Remove unused import of unicode/utf8 package", style: Normal, search_matches: [], inline_styles: [(26, 38, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 4.5:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Add note about hash collisions when explaining the HashKey methods", style: Normal, search_matches: [], inline_styles: [(51, 58, Code)], syntax_colors: [] }, RenderedLine { text: "Fix wrong failing test output after adding a test to TestErrorHandling", style: Normal, search_matches: [], inline_styles: [(54, 70, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Add note about hash collisions when explaining the HashKey methods", style: Normal, search_matches: [], inline_styles: [(53, 60, Code)], syntax_colors: [] }, RenderedLine { text: "• Fix wrong failing test output after adding a test to TestErrorHandling", style: Normal, search_matches: [], inline_styles: [(55, 72, Code)], syntax_colors: [] }, RenderedLine { text: "• Going Further:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Add link to the sequel Writing A Compiler In Go.", style: Normal, search_matches: [], inline_styles: [(23, 47, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Add link to the sequel Writing A Compiler In Go.", style: Normal, search_matches: [], inline_styles: [(25, 49, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "28 June 2017 - 1.4", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 1.4:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Use a local variable to save the literal when creating token.EQ and", style: Normal, search_matches: [], inline_styles: [(33, 40, Code), (55, 63, Code)], syntax_colors: [] }, RenderedLine { text: "token.NOT_EQ", style: Normal, search_matches: [], inline_styles: [(0, 12, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Use a local variable to save the literal when creating token.EQ and", style: Normal, search_matches: [], inline_styles: [(35, 42, Code), (57, 65, Code), (70, 71, Code)], syntax_colors: [] }, RenderedLine { text: "token.NOT_EQ", style: Normal, search_matches: [], inline_styles: [(0, 11, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 2.3:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix a small typo", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix a small typo", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 2.4:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Change incorrect mention of peekPosition in lexer to correct readPosition", style: Normal, search_matches: [], inline_styles: [(28, 40, Code), (61, 73, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Change incorrect mention of peekPosition in lexer to correct", style: Normal, search_matches: [], inline_styles: [(30, 42, Code), (63, 64, Code)], syntax_colors: [] }, RenderedLine { text: "readPosition", style: Normal, search_matches: [], inline_styles: [(0, 11, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 2.6:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix duplicate test input in TestOperatorPrecedenceParsing here and in the", style: Normal, search_matches: [], inline_styles: [(28, 57, Code)], syntax_colors: [] }, RenderedLine { text: "following sections where it’s referenced", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix duplicate test input in TestOperatorPrecedenceParsing here and in", style: Normal, search_matches: [], inline_styles: [(30, 59, Code)], syntax_colors: [] }, RenderedLine { text: "the following sections where it’s referenced", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 3.9:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "In the first example the expression 5 * 5 was used and the text explained", style: Normal, search_matches: [], inline_styles: [(36, 41, Code)], syntax_colors: [] }, RenderedLine { text: "that this should evaluate to 10, which is wrong. It should evaluate to 25,", style: Normal, search_matches: [], inline_styles: [(29, 31, Code), (71, 73, Code)], syntax_colors: [] }, RenderedLine { text: "of course.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• In the first example the expression 5 * 5 was used and the text", style: Normal, search_matches: [], inline_styles: [(38, 43, Code)], syntax_colors: [] }, RenderedLine { text: "explained that this should evaluate to 10, which is wrong. It should", style: Normal, search_matches: [], inline_styles: [(38, 40, Code)], syntax_colors: [] }, RenderedLine { text: "evaluate to 25, of course.", style: Normal, search_matches: [], inline_styles: [(12, 14, Code)], syntax_colors: [] }, RenderedLine { text: "• The Lost Chapter:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Added a new section at the end of the book about The Lost Chapter: A Macro", style: Normal, search_matches: [], inline_styles: [(49, 74, Italic)], syntax_colors: [] }, RenderedLine { text: "System For Monkey and where it can be found.", style: Normal, search_matches: [], inline_styles: [(0, 17, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Added a new section at the end of the book about The Lost Chapter: A", style: Normal, search_matches: [], inline_styles: [(51, 72, Italic)], syntax_colors: [] }, RenderedLine { text: "Macro System For Monkey and where it can be found.", style: Normal, search_matches: [], inline_styles: [(0, 22, Italic)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "26 January 2017 - 1.3", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• License of the code:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The code folder and its content are now licensed under the MIT license.", style: Normal, search_matches: [], inline_styles: [(4, 8, Code)], syntax_colors: [] }, RenderedLine { text: "See the LICENSE file and/or the README.md file.", style: Normal, search_matches: [], inline_styles: [(8, 15, Code), (32, 41, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• The code folder and its content are now licensed under the MIT license.", style: Normal, search_matches: [], inline_styles: [(6, 10, Code)], syntax_colors: [] }, RenderedLine { text: "See the LICENSE file and/or the README.md file.", style: Normal, search_matches: [], inline_styles: [(7, 14, Code), (31, 40, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 1.1:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Make clear that whitespace is only significant in the sense that it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "separates tokens, but not its length.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Make clear that whitespace is only significant in the sense that it", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "separates tokens, but not its length.", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 1.3:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Small wording change", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wrong reference to NextToken when readChar was meant", style: Normal, search_matches: [], inline_styles: [(24, 33, Code), (39, 47, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Small wording change", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wrong reference to NextToken when readChar was meant", style: Normal, search_matches: [], inline_styles: [(25, 34, Code), (40, 48, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 2.8:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix the parseBlockStatement method so it doesn’t run into an endless loop", style: Normal, search_matches: [], inline_styles: [(8, 27, Code)], syntax_colors: [] }, RenderedLine { text: "when parsing incomplete input", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix the parseBlockStatement method so it doesn’t run into an endless", style: Normal, search_matches: [], inline_styles: [(10, 29, Code)], syntax_colors: [] }, RenderedLine { text: "loop when parsing incomplete input", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 4.2:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix the readString method so it doesn’t run into an endless loop when a", style: Normal, search_matches: [], inline_styles: [(8, 18, Code)], syntax_colors: [] }, RenderedLine { text: "string in the input is not terminated with a closing double quote", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix the readString method so it doesn’t run into an endless loop when a", style: Normal, search_matches: [], inline_styles: [(10, 20, Code)], syntax_colors: [] }, RenderedLine { text: "string in the input is not terminated with a closing double quote", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 4.4:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix a typo in the error message of the builtin push function", style: Normal, search_matches: [], inline_styles: [(47, 51, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix a typo in the error message of the builtin push function", style: Normal, search_matches: [], inline_styles: [(49, 53, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "20 December 2016 - 1.2", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 2.8:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Add a missing semicolon to the test input in TestLetStatements", style: Normal, search_matches: [], inline_styles: [(45, 62, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Add a missing semicolon to the test input in TestLetStatements", style: Normal, search_matches: [], inline_styles: [(47, 64, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 4.4:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix the failing test for the builtin push function. Error was introduced", style: Normal, search_matches: [], inline_styles: [(37, 41, Code)], syntax_colors: [] }, RenderedLine { text: "with the last update. This change only occurrs in the code accompanying", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the book and only in subfolder 04.", style: Normal, search_matches: [], inline_styles: [(31, 33, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix the failing test for the builtin push function. Error was introduced", style: Normal, search_matches: [], inline_styles: [(39, 43, Code)], syntax_colors: [] }, RenderedLine { text: "with the last update. This change only occurrs in the code accompanying", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "the book and only in subfolder 04.", style: Normal, search_matches: [], inline_styles: [(31, 33, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "8 December 2016 - 1.1", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Besides fixed typos and spelling errors:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Introduction", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Change the “How To Use This Book” subsection to include a link to the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "downloadable archive of the accompanying code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Change the “How To Use This Book” subsection to include a link to the", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "downloadable archive of the accompanying code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 1.4:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Add hint about accompanying code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Show the last, fully extended version of the test input for TestNextToken", style: Normal, search_matches: [], inline_styles: [(51, 56, Code), (61, 73, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Add hint about accompanying code", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Show the last, fully extended version of the test input for", style: Normal, search_matches: [], inline_styles: [(52, 57, Code), (62, 63, Code)], syntax_colors: [] }, RenderedLine { text: "TestNextToken", style: Normal, search_matches: [], inline_styles: [(0, 12, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 2.6:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "The failing test output for TestParsingPrefixExpressions in the book", style: Normal, search_matches: [], inline_styles: [(28, 56, Code)], syntax_colors: [] }, RenderedLine { text: "text was wrong. It’s corrected to match the actual output one gets when", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "building the parser from scratch", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wording that didn’t match the described test output", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Remove token.LPAREN from the precedences table here. It somehow slipped", style: Normal, search_matches: [], inline_styles: [(10, 22, Code), (32, 43, Code)], syntax_colors: [] }, RenderedLine { text: "in at this point, but should only be added later on in section 2.8, where", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tests are supposed to fail because it’s missing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• The failing test output for TestParsingPrefixExpressions in the book", style: Normal, search_matches: [], inline_styles: [(30, 58, Code)], syntax_colors: [] }, RenderedLine { text: "text was wrong. It’s corrected to match the actual output one gets when", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "building the parser from scratch", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wording that didn’t match the described test output", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Remove token.LPAREN from the precedences table here. It somehow slipped", style: Normal, search_matches: [], inline_styles: [(9, 21, Code), (31, 42, Code)], syntax_colors: [] }, RenderedLine { text: "in at this point, but should only be added later on in section 2.8, where", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "tests are supposed to fail because it’s missing", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 2.8:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Fix wrong test expectation (\"x\" changed to \"y\") in TestLetStatement", style: Normal, search_matches: [], inline_styles: [(28, 31, Code), (43, 46, Code), (51, 67, Code)], syntax_colors: [] }, RenderedLine { text: "Change parser_parser_test.go to parser_test.go", style: Normal, search_matches: [], inline_styles: [(8, 29, Code), (33, 46, Code)], syntax_colors: [] }, RenderedLine { text: "Better show how to use testLiteralExpression in", style: Normal, search_matches: [], inline_styles: [(0, 1, Code), (25, 46, Code)], syntax_colors: [] }, RenderedLine { text: "TestParsingInfixExpressions", style: Normal, search_matches: [], inline_styles: [(3, 27, Code)], syntax_colors: [] }, RenderedLine { text: "Fix outdated test output for failing TestOperatorPrecedenceParsing,", style: Normal, search_matches: [], inline_styles: [(0, 3, Code), (41, 67, Code)], syntax_colors: [] }, RenderedLine { text: "TestIfExpression, TestIfElseExpression, TestFunctionLiteralParsing", style: Normal, search_matches: [], inline_styles: [(0, 3, Code), (5, 21, Code), (23, 43, Code), (45, 66, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Fix wrong test expectation (\"x\" changed to \"y\") in TestLetStatement", style: Normal, search_matches: [], inline_styles: [(30, 33, Code), (45, 48, Code), (53, 69, Code)], syntax_colors: [] }, RenderedLine { text: "• Change parser_parser_test.go to parser_test.go", style: Normal, search_matches: [], inline_styles: [(9, 30, Code), (34, 48, Code)], syntax_colors: [] }, RenderedLine { text: "• Better show how to use testLiteralExpression in", style: Normal, search_matches: [], inline_styles: [(25, 46, Code), (50, 51, Code)], syntax_colors: [] }, RenderedLine { text: "TestParsingInfixExpressions", style: Normal, search_matches: [], inline_styles: [(0, 26, Code)], syntax_colors: [] }, RenderedLine { text: "• Fix outdated test output for failing TestOperatorPrecedenceParsing,", style: Normal, search_matches: [], inline_styles: [(39, 68, Code), (70, 71, Code)], syntax_colors: [] }, RenderedLine { text: "TestIfExpression, TestIfElseExpression, TestFunctionLiteralParsing", style: Normal, search_matches: [], inline_styles: [(0, 15, Code), (17, 37, Code), (39, 65, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 3.10:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Change the Inspect() method of *object.Function to use fn instead of", style: Normal, search_matches: [], inline_styles: [(11, 20, Code), (31, 47, Code), (55, 57, Code)], syntax_colors: [] }, RenderedLine { text: "function and newlines in output", style: Normal, search_matches: [], inline_styles: [(0, 8, Code)], syntax_colors: [] }, RenderedLine { text: "Remove needless semicolons in example", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Change the Inspect() method of *object.Function to use fn instead of", style: Normal, search_matches: [], inline_styles: [(13, 22, Code), (33, 49, Code), (57, 59, Code), (71, 72, Code)], syntax_colors: [] }, RenderedLine { text: "function and newlines in output", style: Normal, search_matches: [], inline_styles: [(0, 7, Code)], syntax_colors: [] }, RenderedLine { text: "• Remove needless semicolons in example", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 3.5:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Change from if/else to “if and return” in nativeBoolToBooleanObject", style: Normal, search_matches: [], inline_styles: [(46, 71, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Change from if/else to “if and return” in nativeBoolToBooleanObject", style: Normal, search_matches: [], inline_styles: [(48, 73, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 3.6:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Update the version of testNullObject to be the one in the accompanying", style: Normal, search_matches: [], inline_styles: [(22, 36, Code)], syntax_colors: [] }, RenderedLine { text: "code, with a correct call to t.Errorf", style: Normal, search_matches: [], inline_styles: [(29, 37, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Update the version of testNullObject to be the one in the accompanying", style: Normal, search_matches: [], inline_styles: [(24, 38, Code)], syntax_colors: [] }, RenderedLine { text: "code, with a correct call to t.Errorf", style: Normal, search_matches: [], inline_styles: [(28, 36, Code)], syntax_colors: [] }, RenderedLine { text: "• Section 4.4:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Name the token.Token field of ast.ArrayLiteral", style: Normal, search_matches: [], inline_styles: [(9, 20, Code), (30, 46, Code)], syntax_colors: [] }, RenderedLine { text: "Fix possible panic through nil error in “first”, “last”, “rest”, and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“push” functions by adding separate check", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Name the token.Token field of ast.ArrayLiteral", style: Normal, search_matches: [], inline_styles: [(11, 22, Code), (32, 48, Code)], syntax_colors: [] }, RenderedLine { text: "• Fix possible panic through nil error in “first”, “last”, “rest”, and", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "“push” functions by adding separate check", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 4.5:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Name the token.Token field of ast.HashLiteral", style: Normal, search_matches: [], inline_styles: [(9, 20, Code), (30, 45, Code)], syntax_colors: [] }, RenderedLine { text: "Replace null in output with missing error message when trying to access", style: Normal, search_matches: [], inline_styles: [(9, 13, Code)], syntax_colors: [] }, RenderedLine { text: "hash via index expression before it’s implemented", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Name the token.Token field of ast.HashLiteral", style: Normal, search_matches: [], inline_styles: [(11, 22, Code), (32, 47, Code)], syntax_colors: [] }, RenderedLine { text: "• Replace null in output with missing error message when trying to access", style: Normal, search_matches: [], inline_styles: [(10, 14, Code)], syntax_colors: [] }, RenderedLine { text: "hash via index expression before it’s implemented", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Section 4.6:", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "Change the expected output using puts with a function literal to match the", style: Normal, search_matches: [], inline_styles: [(33, 37, Code)], syntax_colors: [] }, RenderedLine { text: "updated Inspect() of *object.Function", style: Normal, search_matches: [], inline_styles: [(8, 17, Code), (21, 37, Code)], syntax_colors: [] }, RenderedLine { text: "Explain the nulls in the expected output of put better", style: Normal, search_matches: [], inline_styles: [(13, 17, Code), (45, 48, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Change the expected output using puts with a function literal to match", style: Normal, search_matches: [], inline_styles: [(35, 39, Code)], syntax_colors: [] }, RenderedLine { text: "the updated Inspect() of *object.Function", style: Normal, search_matches: [], inline_styles: [(11, 20, Code), (24, 40, Code)], syntax_colors: [] }, RenderedLine { text: "• Explain the nulls in the expected output of put better", style: Normal, search_matches: [], inline_styles: [(14, 18, Code), (46, 49, Code)], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "23 November 2016 - 1.0", style: Heading3, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "• Initial Release", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }, RenderedLine { text: "", style: Normal, search_matches: [], inline_styles: [], syntax_colors: [] }], file_path: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en-US\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title>ch010.xhtml</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../styles/stylesheet1.css\" />\n</head>\n<body epub:type=\"bodymatter\">\n<section id=\"changelog\" class=\"level1 unnumbered\" data-number=\"\">\n<h1 class=\"unnumbered\" data-number=\"\">Changelog</h1>\n<section id=\"may-2020---1.7\" class=\"level4\" data-number=\"4.8.0.5\">\n<h4 data-number=\"4.8.0.5\">7 May 2020 - 1.7</h4>\n<ul>\n<li>Code:\n<ul>\n<li>Added <code>go.mod</code> files to the code folder so that users with Go &gt;= 1.13 can easily run it without having to set <code>$GOPATH</code></li>\n</ul></li>\n<li>Section 1.5:\n<ul>\n<li>Update wrong token types in example Lexer output</li>\n<li>Change from <code>fmt.Printf</code> to <code>fmt.Fprintf</code> to make use of <code>out</code></li>\n</ul></li>\n<li>Section 1.3:\n<ul>\n<li>Fix a grammar mistake by removing the additional “the” in “Of the course”</li>\n</ul></li>\n<li>Section 2.9:\n<ul>\n<li>Fix a typo by changing “intends” to “indents”</li>\n</ul></li>\n<li>Section 3.9:\n<ul>\n<li>Change “How to we” to “How do we”</li>\n<li>Fix missing word in “we should bind it too” by rewriting sentence</li>\n</ul></li>\n</ul>\n</section>\n<section id=\"march-2019---1.6\" class=\"level4\" data-number=\"4.8.0.6\">\n<h4 data-number=\"4.8.0.6\">20 March 2019 - 1.6</h4>\n<ul>\n<li>Section 2.4:\n<ul>\n<li>Fix wrong <code>parseOperatorExpression</code> in pseudo-code example for recursive-descent parser</li>\n</ul></li>\n<li>Section 2.5:\n<ul>\n<li>Change wrong capitalization in test error message</li>\n</ul></li>\n<li>Section 4.5:\n<ul>\n<li>Correct explanation of <code>HashKey</code> by clarifying that <code>ObjectType</code> is a <code>string</code> (as opposed to an integer)</li>\n</ul></li>\n</ul>\n</section>\n<section id=\"july-2018---1.5\" class=\"level4\" data-number=\"4.8.0.7\">\n<h4 data-number=\"4.8.0.7\">31 July 2018 - 1.5</h4>\n<p>Besides fixes for various typos and spelling errors:</p>\n<ul>\n<li>Chapter 2:\n<ul>\n<li>Fix wrong mention of <code>program.Body</code> in test error messages and change it to <code>program.Statements</code></li>\n</ul></li>\n<li>Section 1.3:\n<ul>\n<li>Make it clearer where to put <code>import \"monkey/token\"</code> line</li>\n</ul></li>\n<li>Section 2.4:\n<ul>\n<li>Fix wrong error message in <code>testLetStatement</code> helper function</li>\n<li>Fix wrong indentation of <code>input</code> in test function</li>\n<li>Fix missing imports of <code>fmt</code> package</li>\n</ul></li>\n<li>Section 2.5:\n<ul>\n<li>Fix wrong mention of <code>ParseProgram</code> instead of the correct <code>parseStatement</code></li>\n</ul></li>\n<li>Section 2.6:\n<ul>\n<li>Fix wrong explanation of failing test output in prefix operators section</li>\n<li>Fix wrong explanation of the for-loop condition in <code>parseExpression</code></li>\n<li>Rename local variable <code>oe</code> to <code>ie</code> in <code>*ast.InfixExpression</code> methods</li>\n</ul></li>\n<li>Section 2.8:\n<ul>\n<li>Change post-refactoring version of <code>TestParsingInfixExpressions</code> to make clearer that it has been refactored</li>\n<li>Fix wrong error message in <code>testInfixExpression</code></li>\n<li>Fix wrong output in test error message (“true” to “TRUE”)</li>\n<li>Add missing import of <code>strings</code> package</li>\n<li>Change wording to make clearer that the section includes changes to the existing test suite</li>\n</ul></li>\n<li>Section 2.9:\n<ul>\n<li>Add the missing <code>import</code> of <code>monkey/parser</code> to the REPL code</li>\n</ul></li>\n<li>Section 3.5:\n<ul>\n<li>Fix wrong error message in failing test output for <code>TestEvalBooleanExpression</code></li>\n</ul></li>\n<li>Section 3.8:\n<ul>\n<li>Add missing import of <code>fmt</code></li>\n</ul></li>\n<li>Section 3.10:\n<ul>\n<li>Add missing import</li>\n</ul></li>\n<li>Chapter 4:\n<ul>\n<li>Remove unused import of <code>unicode/utf8</code> package</li>\n</ul></li>\n<li>Section 4.5:\n<ul>\n<li>Add note about hash collisions when explaining the <code>HashKey</code> methods</li>\n<li>Fix wrong failing test output after adding a test to <code>TestErrorHandling</code></li>\n</ul></li>\n<li>Going Further:\n<ul>\n<li>Add link to the sequel <em>Writing A Compiler In Go</em>.</li>\n</ul></li>\n</ul>\n</section>\n<section id=\"june-2017---1.4\" class=\"level4\" data-number=\"4.8.0.8\">\n<h4 data-number=\"4.8.0.8\">28 June 2017 - 1.4</h4>\n<ul>\n<li>Section 1.4:\n<ul>\n<li>Use a local variable to save the <code>literal</code> when creating <code>token.EQ</code> and <code>token.NOT_EQ</code></li>\n</ul></li>\n<li>Section 2.3:\n<ul>\n<li>Fix a small typo</li>\n</ul></li>\n<li>Section 2.4:\n<ul>\n<li>Change incorrect mention of <code>peekPosition</code> in lexer to correct <code>readPosition</code></li>\n</ul></li>\n<li>Section 2.6:\n<ul>\n<li>Fix duplicate test input in <code>TestOperatorPrecedenceParsing</code> here and in the following sections where it’s referenced</li>\n</ul></li>\n<li>Section 3.9:\n<ul>\n<li>In the first example the expression <code>5 * 5</code> was used and the text explained that this should evaluate to <code>10</code>, which is wrong. It should evaluate to <code>25</code>, of course.</li>\n</ul></li>\n<li>The Lost Chapter:\n<ul>\n<li>Added a new section at the end of the book about <em>The Lost Chapter: A Macro System For Monkey</em> and where it can be found.</li>\n</ul></li>\n</ul>\n</section>\n<section id=\"january-2017---1.3\" class=\"level4\" data-number=\"4.8.0.9\">\n<h4 data-number=\"4.8.0.9\">26 January 2017 - 1.3</h4>\n<ul>\n<li>License of the code:\n<ul>\n<li>The <code>code</code> folder and its content are now licensed under the MIT license. See the <code>LICENSE</code> file and/or the <code>README.md</code> file.</li>\n</ul></li>\n<li>Section 1.1:\n<ul>\n<li>Make clear that whitespace is only significant in the sense that it separates tokens, but not its length.</li>\n</ul></li>\n<li>Section 1.3:\n<ul>\n<li>Small wording change</li>\n<li>Fix wrong reference to <code>NextToken</code> when <code>readChar</code> was meant</li>\n</ul></li>\n<li>Section 2.8:\n<ul>\n<li>Fix the <code>parseBlockStatement</code> method so it doesn’t run into an endless loop when parsing incomplete input</li>\n</ul></li>\n<li>Section 4.2:\n<ul>\n<li>Fix the <code>readString</code> method so it doesn’t run into an endless loop when a string in the input is not terminated with a closing double quote</li>\n</ul></li>\n<li>Section 4.4:\n<ul>\n<li>Fix a typo in the error message of the builtin <code>push</code> function</li>\n</ul></li>\n</ul>\n</section>\n<section id=\"december-2016---1.2\" class=\"level4\" data-number=\"4.8.0.10\">\n<h4 data-number=\"4.8.0.10\">20 December 2016 - 1.2</h4>\n<ul>\n<li>Section 2.8:\n<ul>\n<li>Add a missing semicolon to the test input in <code>TestLetStatements</code></li>\n</ul></li>\n<li>Section 4.4:\n<ul>\n<li>Fix the failing test for the builtin <code>push</code> function. Error was introduced with the last update. This change only occurrs in the code accompanying the book and only in subfolder <code>04</code>.</li>\n</ul></li>\n</ul>\n</section>\n<section id=\"december-2016---1.1\" class=\"level4\" data-number=\"4.8.0.11\">\n<h4 data-number=\"4.8.0.11\">8 December 2016 - 1.1</h4>\n<p>Besides fixed typos and spelling errors:</p>\n<ul>\n<li>Introduction\n<ul>\n<li>Change the “How To Use This Book” subsection to include a link to the downloadable archive of the accompanying code</li>\n</ul></li>\n<li>Section 1.4:\n<ul>\n<li>Add hint about accompanying code</li>\n<li>Show the last, fully extended version of the test <code>input</code> for <code>TestNextToken</code></li>\n</ul></li>\n<li>Section 2.6:\n<ul>\n<li>The failing test output for <code>TestParsingPrefixExpressions</code> in the book text was wrong. It’s corrected to match the actual output one gets when building the parser from scratch</li>\n<li>Fix wording that didn’t match the described test output</li>\n<li>Remove <code>token.LPAREN</code> from the <code>precedences</code> table here. It somehow slipped in at this point, but should only be added later on in section 2.8, where tests are supposed to fail because it’s missing</li>\n</ul></li>\n<li>Section 2.8:\n<ul>\n<li>Fix wrong test expectation (<code>\"x\"</code> changed to <code>\"y\"</code>) in <code>TestLetStatement</code></li>\n<li>Change <code>parser_parser_test.go</code> to <code>parser_test.go</code></li>\n<li>Better show how to use <code>testLiteralExpression</code> in <code>TestParsingInfixExpressions</code></li>\n<li>Fix outdated test output for failing <code>TestOperatorPrecedenceParsing</code>, <code>TestIfExpression</code>, <code>TestIfElseExpression</code>, <code>TestFunctionLiteralParsing</code></li>\n</ul></li>\n<li>Section 3.10:\n<ul>\n<li>Change the <code>Inspect()</code> method of <code>*object.Function</code> to use <code>fn</code> instead of <code>function</code> and newlines in output</li>\n<li>Remove needless semicolons in example</li>\n</ul></li>\n<li>Section 3.5:\n<ul>\n<li>Change from if/else to “if and return” in <code>nativeBoolToBooleanObject</code></li>\n</ul></li>\n<li>Section 3.6:\n<ul>\n<li>Update the version of <code>testNullObject</code> to be the one in the accompanying code, with a correct call to <code>t.Errorf</code></li>\n</ul></li>\n<li>Section 4.4:\n<ul>\n<li>Name the <code>token.Token</code> field of <code>ast.ArrayLiteral</code></li>\n<li>Fix possible panic through nil error in “first”, “last”, “rest”, and “push” functions by adding separate check</li>\n</ul></li>\n<li>Section 4.5:\n<ul>\n<li>Name the <code>token.Token</code> field of <code>ast.HashLiteral</code></li>\n<li>Replace <code>null</code> in output with missing error message when trying to access hash via index expression before it’s implemented</li>\n</ul></li>\n<li>Section 4.6:\n<ul>\n<li>Change the expected output using <code>puts</code> with a function literal to match the updated <code>Inspect()</code> of <code>*object.Function</code></li>\n<li>Explain the <code>null</code>s in the expected output of <code>put</code> better</li>\n</ul></li>\n</ul>\n</section>\n<section id=\"november-2016---1.0\" class=\"level4\" data-number=\"4.8.0.12\">\n<h4 data-number=\"4.8.0.12\">23 November 2016 - 1.0</h4>\n<ul>\n<li>Initial Release</li>\n</ul>\n</section>\n</section>\n</body>\n</html>\n" }] }, file_path: "books/writing_an_interpreter_in_go_1.7.epub" }
2025-12-28 12:12:55 [INFO] Book loading complete: Writing An Interpreter In Go (13 chapters)
2025-12-28 12:12:55 [INFO] Finalizing book load: books/writing_an_interpreter_in_go_1.7.epub
2025-12-28 12:12:55 [DEBUG] Canonical path: \\?\S:\projects\git\reef\books\writing_an_interpreter_in_go_1.7.epub
2025-12-28 12:12:55 [DEBUG] Book already in recent list at position 1, moving to top
2025-12-28 12:12:55 [DEBUG] Loaded 0 bookmarks for this book
2025-12-28 12:12:55 [DEBUG] TOC tree built: 13 items
2025-12-28 12:12:55 [INFO] Restoring reading progress: chapter 5, line 2
